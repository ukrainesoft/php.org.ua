{"pageProps":{"page":{"slug":"filters.encryption.md","content":"## Шифруючі фільтри\n\nФільтри, що шифрують, дуже добре підходять для шифрування файлів і потоків.\n\n## mcrypt.\\*и mdecrypt.\\*\n\n**Увага**\n\nЦя можливість була оголошена *застарілої* починаючи з PHP 7.1.0. Вкрай не рекомендується покладатися на неї в майбутньому.\n\n`mcrypt.*`и`mdecrypt.*` забезпечують симетричне шифрування та дешифрування за допомогою libmcrypt. Обидва набори фільтрів підтримують ті ж алгоритми, що й [модуль mcrypt](ref.mcrypt.md) у вигляді `mcrypt.ciphername`, где`ciphername` - це назва шифру, якби вона передавалася функції [mcrypt\\_module\\_open()](function.mcrypt-module-open.md). Також доступні такі п'ять параметрів:\n\n**Параметри фільтра mcrypt**\n\n| Параметр | Обязателен? | По умолчанию | Приклад значения |\n| --- | --- | --- | --- |\n| mode | Ні | cbc | cbc, cfb, ecb, nofb, ofb, stream |\n| algorithms\\_dir | Ні | ini\\_get('mcrypt.algorithms\\_dir') | Шлях до модулів алгоритмів |\n| modes\\_dir | Ні | ini\\_get('mcrypt.modes\\_dir') | Шлях до модулів режимів |\n| iv | Так | N/A | Зазвичай 8, 16 або 32 байти бінарних даних. Залежить від шифру |\n| key | Так | N/A | Зазвичай 8, 16 або 32 байти бінарних даних. Залежить від шифру |\n\n**Приклад #1 Шифрування/розшифрування за допомогою Blowfish**\n\n```php\n<?php\n// примем, что $key  уже сформирован\n$iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_CBC);\n$iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM);\n$fp = fopen('encrypted-file.enc', 'wb');\nfwrite($fp, $iv);\n$opts = array('mode'=>'cbc','iv'=>$iv, 'key'=>$key);\nstream_filter_append($fp, 'mcrypt.blowfish', STREAM_FILTER_WRITE, $opts);\nfwrite($fp, 'message to encrypt');\nfclose($fp);\n\n//расшифровка...\n$fp = fopen('encrypted-file.enc', 'rb');\n$iv = fread($fp, $iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_CBC));\n$opts = array('mode'=>'cbc','iv'=>$iv, 'key'=>$key)\nstream_filter_append($fp, 'mdecrypt.blowfish', STREAM_FILTER_READ, $opts);\n$data = rtrim(stream_get_contents($fp));//trims off null padding\nfclose($fp);\necho $data;\n?>\n```\n\n**Приклад #2 Шифрування файлу за допомогою AES-128 CBC з SHA256 HMAC**\n\n```php\n<?php\nAES_CBC::encryptFile($password, \"plaintext.txt\", \"encrypted.enc\");\nAES_CBC::decryptFile($password, \"encrypted.enc\", \"decrypted.txt\");\n\nclass AES_CBC\n{\n   protected static $KEY_SIZES = array('AES-128'=>16,'AES-192'=>24,'AES-256'=>32);\n   protected static function key_size() { return self::$KEY_SIZES['AES-128']; } //default AES-128\n   public static function encryptFile($password, $input_stream, $aes_filename){\n      $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);\n      $fin = fopen($input_stream, \"rb\");\n      $fc = fopen($aes_filename, \"wb+\");\n      if (!empty($fin) && !empty($fc)) {\n         fwrite($fc, str_repeat(\"_\", 32) );//placeholder, SHA256 HMAC will go here later\n         fwrite($fc, $hmac_salt = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));\n         fwrite($fc, $esalt = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));\n         fwrite($fc, $iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));\n         $ekey = hash_pbkdf2(\"sha256\", $password, $esalt, $it=1000, self::key_size(), $raw=true);\n         $opts = array('mode'=>'cbc', 'iv'=>$iv, 'key'=>$ekey);\n         stream_filter_append($fc, 'mcrypt.rijndael-128', STREAM_FILTER_WRITE, $opts);\n         $infilesize = 0;\n         while (!feof($fin)) {\n            $block = fread($fin, 8192);\n            $infilesize+=strlen($block);\n            fwrite($fc, $block);\n         }\n         $block_size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);\n         $padding = $block_size - ($infilesize % $block_size);//$padding is a number from 1-16\n         fwrite($fc, str_repeat(chr($padding), $padding) );//perform PKCS7 padding\n         fclose($fin);\n         fclose($fc);\n         $hmac_raw = self::calculate_hmac_after_32bytes($password, $hmac_salt, $aes_filename);\n         $fc = fopen($aes_filename, \"rb+\");\n         fwrite($fc, $hmac_raw);//overwrite placeholder\n         fclose($fc);\n      }\n   }\n   public static function decryptFile($password, $aes_filename, $out_stream) {\n      $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);\n      $hmac_raw = file_get_contents($aes_filename, false, NULL,  0, 32);\n      $hmac_salt = file_get_contents($aes_filename, false, NULL, 32, $iv_size);\n      $hmac_calc = self::calculate_hmac_after_32bytes($password, $hmac_salt, $aes_filename);\n      $fc = fopen($aes_filename, \"rb\");\n      $fout = fopen($out_stream, 'wb');\n      if (!empty($fout) && !empty($fc) && self::hash_equals($hmac_raw,$hmac_calc)) {\n         fread($fc, 32+$iv_size);//skip sha256 hmac and salt\n         $esalt = fread($fc, $iv_size);\n         $iv    = fread($fc, $iv_size);\n         $ekey = hash_pbkdf2(\"sha256\", $password, $esalt, $it=1000, self::key_size(), $raw=true);\n         $opts = array('mode'=>'cbc', 'iv'=>$iv, 'key'=>$ekey);\n         stream_filter_append($fc, 'mdecrypt.rijndael-128', STREAM_FILTER_READ, $opts);\n         while (!feof($fc)) {\n            $block = fread($fc, 8192);\n            if (feof($fc)) {\n               $padding = ord($block[strlen($block) - 1]);//assume PKCS7 padding\n               $block = substr($block, 0, 0-$padding);\n            }\n            fwrite($fout, $block);\n         }\n         fclose($fout);\n         fclose($fc);\n      }\n   }\n   private static function hash_equals($str1, $str2) {\n      if(strlen($str1) == strlen($str2)) {\n         $res = $str1 ^ $str2;\n         for($ret=0,$i = strlen($res) - 1; $i >= 0; $i--) $ret |= ord($res[$i]);\n         return !$ret;\n      }\n      return false;\n   }\n   private static function calculate_hmac_after_32bytes($password, $hsalt, $filename) {\n      static $init=0;\n      $init or $init = stream_filter_register(\"user-filter.skipfirst32bytes\", \"FileSkip32Bytes\");\n      $stream = 'php://filter/read=user-filter.skipfirst32bytes/resource=' . $filename;\n      $hkey = hash_pbkdf2(\"sha256\", $password, $hsalt, $iterations=1000, 24, $raw=true);\n      return hash_hmac_file('sha256', $stream, $hkey, $raw=true);\n   }\n}\nclass FileSkip32Bytes extends php_user_filter\n{\n   private $skipped=0;\n   function filter($in, $out, &$consumed, $closing)  {\n      while ($bucket = stream_bucket_make_writeable($in)) {\n         $outlen = $bucket->datalen;\n         if ($this->skipped<32){\n            $outlen = min($bucket->datalen,32-$this->skipped);\n            $bucket->data = substr($bucket->data, $outlen);\n            $bucket->datalen = $bucket->datalen-$outlen;\n            $this->skipped+=$outlen;\n         }\n         $consumed += $outlen;\n         stream_bucket_append($out, $bucket);\n      }\n      return PSFS_PASS_ON;\n   }\n}\nclass AES_128_CBC extends AES_CBC {\n   protected static function key_size() { return self::$KEY_SIZES['AES-128']; }\n}\nclass AES_192_CBC extends AES_CBC {\n   protected static function key_size() { return self::$KEY_SIZES['AES-192']; }\n}\nclass AES_256_CBC extends AES_CBC {\n   protected static function key_size() { return self::$KEY_SIZES['AES-256']; }\n}\n```\n","title":"Шифруючі фільтри","contentType":2,"navigation":[{"filters.compression.md":"« Компресійні фільтри"},{"transports.md":"Список транспортних протоколів, що підтримуються »"},{"index.md":"PHP Manual"},{"filters.md":"Список доступних фільтрів"}]}},"__N_SSG":true}