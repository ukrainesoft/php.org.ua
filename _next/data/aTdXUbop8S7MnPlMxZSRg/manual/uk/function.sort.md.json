{"pageProps":{"page":{"slug":"function.sort.md","content":"# sort\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nsort — Сортує масив за зростанням\n\n### Опис\n\n```methodsynopsis\nsort(array &$array, int $flags = SORT_REGULAR): true\n```\n\nСортує `array`по значению в порядке возрастания.\n\n> **Зауваження** :\n> \n> Якщо обидва порівнювані значення еквівалентні, вони зберігають свій початковий порядок. До PHP 8.0.0 їх відносний порядок у відсортованому масиві не було визначено.\n\n> **Зауваження**: Ця функція надає нові ключі елементам `array`. Вона видалить усі існуючі ключі, а не просто переупорядкує їх.\n\n> **Зауваження** :\n> \n> Скидає внутрішній покажчик масиву перший елемент.\n\n### Список параметрів\n\n`array`\n\nВхідний масив\n\n`flags`\n\nНеобов'язковий другий параметр `flags` змінює поведінку сортування і може набувати таких значень:\n\nПрапори типів сортування:\n\n-   \\*\\*`SORT_REGULAR`\\*\\*- Звичайне порівняння елементів; подробиці описані в розділі[оператори порівняння](language.operators.comparison.md)\n-   \\*\\*`SORT_NUMERIC`\\*\\*- Чисельне порівняння елементів\n-   \\*\\*`SORT_STRING`\\*\\*- рядкове порівняння елементів\n-   \\*\\*`SORT_LOCALE_STRING`\\*\\*— Порівняти елементи як рядки на основі поточного мовного стандарту. Прапор використовує мовний стандарт, який можна змінити функцією[setlocale()](function.setlocale.md)\n-   **`SORT_NATURAL`** - Порівняння елементів як рядки, використовуючи \"природний порядок\", наприклад [natsort()](function.natsort.md)\n-   \\*\\*`SORT_FLAG_CASE`**\\- можна об'єднувати (побітове АБО) з**`SORT_STRING`** або **`SORT_NATURAL`\\*\\*для сортування рядків без урахування регістру\n\n### Значення, що повертаються\n\nФункція завжди повертає **`true`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.2.0 | Тип значення, що повертається тепер **`true`**; раніше було bool. |\n\n### Приклади\n\n**Приклад #1 Приклад використання** sort()\\*\\*\\*\\*\n\n```php\n<?php\n\n$fruits = array(\"lemon\", \"orange\", \"banana\", \"apple\");\nsort($fruits);\nforeach ($fruits as $key => $val) {\n    echo \"fruits[\" . $key . \"] = \" . $val . \"\\n\";\n}\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nfruits[0] = apple\nfruits[1] = banana\nfruits[2] = lemon\nfruits[3] = orange\n```\n\nФрукти відсортовані за абеткою.\n\n**Приклад #2 Приклад використання** sort()\\*\\* з реєстронезалежним природним упорядкуванням\\*\\*\n\n```php\n<?php\n\n$fruits = array(\n    \"Orange1\", \"orange2\", \"Orange3\", \"orange20\"\n);\nsort($fruits, SORT_NATURAL | SORT_FLAG_CASE);\nforeach ($fruits as $key => $val) {\n    echo \"fruits[\" . $key . \"] = \" . $val . \"\\n\";\n}\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nfruits[0] = Orange1\nfruits[1] = orange2\nfruits[2] = Orange3\nfruits[3] = orange20\n```\n\nФрукти були відсортовані аналогічно до функцій [natcasesort()](function.natcasesort.md)\n\n### Примітки\n\n> **Зауваження**: Як і більшість функцій сортування в PHP, \\*\\*sort()\\*\\*использует реализацию алгоритма[» швидкого сортування](http://en.wikipedia.org/wiki/Quicksort). Основний елемент вибирається із середини сортованої частини, досягаючи таким чином оптимального часу для вже відсортованих масивів. Слід пам'ятати, що це є деталлю реалізації і слід її покладатися.\n\n**Увага**\n\nБудьте обережні при сортуванні масивів, що містять елементи різних типів, тому що в цьому випадку результат роботи функції **sort()** може бути несподіваним, якщо параметр `flags`равен\\*\\*`SORT_REGULAR`\\*\\*\n\n### Дивіться також\n\n-   [rsort()](function.rsort.md) \\- Сортує масив у порядку зменшення\n-   [Порівняння функцій сортування масивів](array.sorting.md)\n","title":"sort","contentType":2,"navigation":[{"function.sizeof.md":"« sizeof"},{"function.uasort.md":"uasort »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}