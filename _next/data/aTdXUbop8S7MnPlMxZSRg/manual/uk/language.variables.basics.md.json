{"pageProps":{"page":{"slug":"language.variables.basics.md","content":"## Основи\n\nЗмінні PHP представлені знаком долара з наступним ім'ям змінної. Ім'я змінної чутливе до регістру.\n\nІмена змінних відповідають тим самим правилам, як і інші назви в PHP. Правильне ім'я змінної повинно починатися з літери або символу підкреслення та складатися з букв, цифр та символів підкреслення у будь-якій кількості. Це можна відобразити регулярним виразом: `^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$`\n\n> **Зауваження**: Під літерами тут маються на увазі символи a-z, A-Z і байти від 128 до 255 (`0x80-0xff`\n\n> **Зауваження** `$this` - це спеціальна змінна, якій не можна нічого присвоювати. До PHP 7.1.0 було можливе опосередковане присвоєння (наприклад, з використанням [змінних змінних](language.variables.variable.md)\n\n**Підказка**\n\nСмотрите также[Посібник з іменування](userlandnaming.md)\n\nДля отримання інформації про функції роботи зі змінними звертайтесь до розділу [функцій роботи зі змінними](ref.var.md)\n\n```php\n<?php\n$var = 'Боб';\n$Var = 'Джо';\necho \"$var, $Var\";      // выведет \"Боб, Джо\"\n\n$4site = 'ещё нет';     // неверно; начинается с цифры\n$_4site = 'ещё нет';    // верно; начинается с символа подчёркивания\n$täyte = 'mansikka';    // верно; 'ä' это (Расширенный) ASCII 228.\n?>\n```\n\nЗа умовчанням змінні завжди надаються за значенням. Тобто, коли ви надаєте вираз змінної, все значення оригінального виразу копіюється в цю змінну. Це означає, наприклад, що як однієї змінної присвоєно значення інший, зміна однієї з них впливає іншу. Додаткову інформацію про цей спосіб присвоєння дивіться у розділі [Вирази](language.expressions.md)\n\nPHP також пропонує інший спосіб присвоєння значень змінним: [присвоєння за посиланням](language.references.md). . Це означає, що нова змінна просто посилається (інакше кажучи, стає псевдонімом або вказує) на оригінальну змінну. Зміни у новій змінній відбиваються на оригіналі, і навпаки.\n\nДля присвоєння за посиланням просто додайте амперсанд (&) до початку імені присвоюваної (вихідної) змінної. Наприклад, наступний фрагмент коду двічі виводить '`Мене звуть Боб`':\n\n```php\n<?php\n$foo = 'Боб';              // Присваивает $foo значение 'Боб'\n$bar = &$foo;              // Ссылка на $foo через $bar.\n$bar = \"Меня зовут $bar\";  // Изменение $bar...\necho $bar;\necho $foo;                 // меняет и $foo.\n?>\n```\n\nЗа посиланням можуть бути присвоєні лише іменовані змінні.\n\n```php\n<?php\n$foo = 25;\n$bar = &$foo;      // Это верное присвоение.\n$bar = &(24 * 7);  // Неверно; ссылка на неименованное выражение.\n\nfunction test()\n{\n   return 25;\n}\n\n$bar = &test();    // Неверно.\n?>\n```\n\nХорошою практикою вважається ініціалізувати змінні, хоча у PHP це і не обов'язкова вимога. Неініціалізовані змінні набувають значення за умовчанням залежно від їх типу, що визначається з контексту їх першого використання: логічні змінні набувають значення **`false`**, цілі числа та числа з плаваючою точкою - нуль, рядки (наприклад, при виклику з конструкцією [echo](function.echo.md)) - Порожній рядок, а масиви стають порожніми масивами.\n\n**Приклад #1 Значення за замовчуванням у неініціалізованих змінних**\n\n```php\n<?php\n// Неустановленная И не имеющая ссылок (то есть без контекста использования) переменная; выведет NULL\nvar_dump($unset_var);\n\n// Использование логической переменной; выведет 'false' (Подробнее по этому синтаксису смотрите раздел о тернарном операторе)\necho $unset_bool ? \"true\\n\" : \"false\\n\";\n\n// Строковое использование; выведет 'string(3) \"abc\"'\n$unset_str .= 'abc';\nvar_dump($unset_str);\n\n// Целочисленное использование; выведет 'int(25)'\n$unset_int += 25; // 0 + 25 => 25\nvar_dump($unset_int);\n\n// Использование в качестве числа с плавающей точкой (float); выведет 'float(1.25)'\n$unset_float += 1.25;\nvar_dump($unset_float);\n\n// Использование в качестве массива; выведет array(1) {  [3]=>  string(3) \"def\" }\n$unset_arr[3] = \"def\"; // array() + array(3 => \"def\") => array(3 => \"def\")\nvar_dump($unset_arr);\n\n// Использование в качестве объекта; создаёт новый объект stdClass (смотрите http://www.php.net/manual/ru/reserved.classes.php)\n// Выведет: object(stdClass)#1 (1) {  [\"foo\"]=>  string(3) \"bar\" }\n$unset_obj->foo = 'bar';\nvar_dump($unset_obj);\n?>\n```\n\nПокладатися на значення за замовчуванням неініціалізованих змінних досить проблематично при включенні файлу до іншого файлу, який використовує змінну з тим самим ім'ям. У разі роботи з неініціалізованою змінною викликається помилка рівня **`E_WARNING`** (до PHP 8.0.0 викидалася помилка рівня **`E_NOTICE`**), за винятком випадку додавання елементів у неініціалізований масив. Для виявлення ініціалізації змінної може бути використана мовна конструкція [isset()](function.isset.md)\n","title":"Основи","contentType":2,"navigation":[{"language.variables.md":"« Змінні"},{"language.variables.predefined.md":"Зумовлені змінні »"},{"index.md":"PHP Manual"},{"language.variables.md":"Змінні"}]}},"__N_SSG":true}