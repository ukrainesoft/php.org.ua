- [« Використання просторів імен: перехід до глобальної
функції/константі](language.namespaces.fallback.md)
- [Часті питання (FAQ): речі, які вам необхідно знати
про простори імен »](language.namespaces.faq.md)

- [PHP Manual](index.md)
- [Простори імен](language.namespaces.md)
- Правила дозволу імен

## Правила дозволу імен

(PHP 5 \>u003d 5.3.0, PHP 7, PHP 8)

Для цих правил тут наведено кілька важливих визначень:

Неповне ім'я
Це ідентифікатор без роздільника просторів імен, наприклад `Foo`

Повне ім'я
Це ідентифікатор з роздільником просторів імен, наприклад `Foo\Bar`

Абсолютне ім'я
Це ідентифікатор з роздільником просторів імен, який починається з
розділювача просторів імен, наприклад, `Foo\Bar`. Простір імен
`Foo` також є абсолютним ім'ям.

Відносне ім'я
Це ідентифікатор, що починається з `namespace`, такий як
`namespace\Foo\Bar`.

Імена дозволяються відповідно до таких правил:

1. Абсолютні імена завжди дозволяються без головного роздільника
простору імен. Наприклад, `\A\B` дозволяється в `A\B`.
2. Відносні імена завжди дозволяються в імена із заміною
namespace на поточний простір імен. Якщо ім'я зустрічається в
глобальному просторі імен, префікс `namespace` просто видаляється.
Наприклад `namespace\A` всередині простору імен `X\Y` дозволяється
`X\Y\A`. Те саме ім'я в глобальному просторі імен дозволяється
в `A`.
3. Для повних імен перший сегмент перетворюється відповідно до
поточною таблицею імпорту класу чи простору імен. Наприклад,
простір імен `A\B\C` імпортований як `C`, тоді ім'я `C\D\E`
перетворюється на `A\B\C\D\E`.
4. Для неповних імен, якщо не застосовується жодного правила імпорту,
поточний простір імен додається до імені. Наприклад, ім'я `C\D\E`
всередині простору імен `A\B`, перетворюється на `A\B\C\D\E`.
5. Для неповних імен імена перетворюються на поточну таблицю імпорту в
залежно від типу елемента. Це означає, що імена класів
перетворюються згідно з таблицею імпорту класів, імена функцій -
згідно таблиці імпорту функцій та константи згідно таблиці
імпорту констант. Наприклад, після `use A\B\C;`, використання
`new C()` дозволяється як `A\B\C()`. Аналогічно, після
`use function A\B n;`, використання `fn()` дозволяється як
'A\B n'.
6. Неповні імена, якщо відсутні обмеження у таблиці імпорту та
якщо вони використовуються як клас, то вони дозволяються з префіксом
поточного простору імен. Наприклад, `new C()` всередині простору
імен `A\B` дозволяються як `A\B\C`.
7. Неповні імена, якщо відсутні обмеження у таблиці імпорту та
якщо вони використовуються як функція або константа, а код знаходиться не
у глобальному просторі імен, імена дозволяються під час
виконання. Наприклад код, у просторі імен `A\B`, що викликає
функцію `foo()`, дозволяється так:
1. Здійснюється пошук функції з поточного простору імен:
'A\B oo()'.
2. PHP намагається знайти та викликати функцію *глобального простору*
`foo()`.

**Приклад #1 Приклади дозволу імен**

`<?phpnamespace A;use B\D, C\E as F;// виклики функційfoo(); // спершу намагається викликати "foo", визначену в просторі імен "A",        | // викликає функцію "foo", визначену в глобальному просторіmy oo(); // викликає функцію "foo", визначену в просторі "A\my"F(); // спочатку намагається викликати "F", визначену в просторі імен "A",             // потім викликає глобальну функцію "F"/ || // створює об'єкт класу "B", визначеного в просторі імен "A". // якщо не найдено, намагається зробити автозавантаження класу "A\B"new D(); // використовуючи правила імпорту, створює об'єкт класу "D", визначеного в просторі імен "B"            // якщо с| // використовуючи правила імпорту, створює об'єкт класу "E", визначеного в просторі імен "C"             // якщо с> | // створює об'єкт класу "B", визначеного в глобальному просторі,             // якщо не знайдено, то намагається робити автозавантаження| // створює об'єкт класу "D", визначеного в глобальному просторі,             // якщо не найдено, то намагається робити автозавантаження| // создаёт объект класса "F", определённого в глобальном пространстве,            // если не найден, то пытается сделать автозагрузку класса "F"// статические методы/функции пространства имён из другого пространства имёнBoo(); // викликає функцію "foo" з простору імен "A\B"B::foo(); // викликає метод "foo" із класу "B", визначеного в просторі імен "A"             // якщо класс "A\B" не | // используя правила импорта, вызывает метод "foo" класса "D", определённого в пространстве имён "B"            // если класс "B\D" не найден, то пытается сделать автозагрузку класса "B\D"\Boo() ; // викликає функцію "foo" з простору імен "B"\B::foo(); // вызывает метод "foo" класса "B" из глобального пространства            // если класс "B" не найден, то пытается сделать автозагрузку класса "B"// статические методы/функции пространства имён из текущего пространства имёнA\B::foo( ); // викликає метод "foo" класу "B" із пространства імен "A\A"               // якщо класс "A\A\B" не  : Foo (); // викликає метод "foo" класу "B" з простору імен "A"               // якщо класс "A\B" не знайдено, |
