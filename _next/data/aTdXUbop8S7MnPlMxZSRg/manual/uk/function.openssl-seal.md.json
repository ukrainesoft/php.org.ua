{"pageProps":{"page":{"slug":"function.openssl-seal.md","content":"# openssl\\_seal\n\n(PHP 4 >= 4.0.4, PHP 5, PHP 7, PHP 8)\n\nopenssl\\_seal — Задрукувати (зашифрувати) дані\n\n### Опис\n\n```methodsynopsis\nopenssl_seal(    string $data,    string &$sealed_data,    array &$encrypted_keys,    array $public_key,    string $cipher_algo,    string &$iv = null): int|false\n```\n\n**openssl\\_seal()** запечатує (шифрує) `data`, используя метод`cipher_algo` із згенерованим випадково секретним ключем. Ключ буде зашифрований кожним відкритим ключем, вказаним у масиві `public_key`, і кожен зашифрований ключ буде поміщений у `encrypted_keys`. Тобто ви можете надіслати запечатані дані відразу кільком одержувачам. Кожен отримувач повинен отримати як запечатані дані, так і зашифрований відповідним відкритим ключем ключ для їхнього відкриття.\n\n### Список параметрів\n\n`data`\n\nДані, що запечатуються.\n\n`sealed_data`\n\nЗапечатані дані.\n\n`encrypted_keys`\n\nМасив зашифрованих ключів.\n\n`public_key`\n\nМасив екземплярів [OpenSSLAsymmetricKey](class.opensslasymmetrickey.md), що містять відкриті ключі.\n\n`cipher_algo`\n\nМетод шифрування.\n\n**Застереження**\n\nЗначення за замовчуванням (`'RC4'`) вважається небезпечним. Настійно рекомендується вказувати метод безпечного шифрування.\n\n`iv`\n\nІніціалізуючий вектор.\n\n### Значення, що повертаються\n\nПовертає довжину запечатаних даних або **`false`**. У разі успішного виконання `sealed_data` містяться запечатані дані, а в `encrypted_keys` зашифровані ключі.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.0.0 | `public_key` тепер приймає масив (array) екземплярів [OpenSSLAsymmetricKey](class.opensslasymmetrickey.md); раніше приймався масив (array) ресурсів ([resource](language.types.resource.md)) типу`OpenSSL key` |\n| 8.0.0 | `cipher_algo` більше не є необов'язковим параметром. |\n| 8.0.0 | `iv` тепер допускає значення null. |\n\n### Приклади\n\n**Приклад #1 Приклад використання** openssl\\_seal()\\*\\*\\*\\*\n\n```php\n<?php\n// $data содержит данные для запечатывания\n\n// извлекаем открытые ключи получателей и подготавливаем их\n$fp = fopen(\"/src/openssl-0.9.6/demos/maurice/cert.pem\", \"r\");\n$cert = fread($fp, 8192);\nfclose($fp);\n$pk1 = openssl_get_publickey($cert);\n// повторяем для второго получателя\n$fp = fopen(\"/src/openssl-0.9.6/demos/sign/cert.pem\", \"r\");\n$cert = fread($fp, 8192);\nfclose($fp);\n$pk2 = openssl_get_publickey($cert);\n\n// задаём метод\n$method = 'AES256';\n\n// генерируем IV\n$ivLength = openssl_cipher_iv_length( $method );\n$iv = openssl_random_pseudo_bytes( $ivLength, $strong );\nif (! $strong) {\n error_log('Инициализирующий вектор может быть не крипографически сильным!');\n}\n\n// запечатываем сообщение, только владельцы $pk1 и $pk2 смогут его распечатать,\n// используя ключи $ekeys[0] и $ekeys[1] соответственно.\nopenssl_seal($data, $sealed, $ekeys, array($pk1, $pk2), $method, $iv);\n\n// освобождаем ресурсы ключей\nopenssl_free_key($pk1);\nopenssl_free_key($pk2);\n?>\n```\n\n### Дивіться також\n\n-   [openssl\\_open()](function.openssl-open.md) \\- Відкрити запечатані дані\n","title":"openssl\\_seal","contentType":2,"navigation":[{"function.openssl-random-pseudo-bytes.md":"« openssl\\_random\\_pseudo\\_bytes"},{"function.openssl-sign.md":"openssl\\_sign »"},{"index.md":"PHP Manual"},{"ref.openssl.md":"Функції OpenSSL"}]}},"__N_SSG":true}