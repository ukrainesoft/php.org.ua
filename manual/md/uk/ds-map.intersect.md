- [« Ds\Map::hasValue](ds-map.hasvalue.md)
- [Ds\Map::isEmpty »](ds-map.isempty.md)

- [PHP Manual](index.md)
- [Колекція пар ключ-значення](class.ds-map.md)
- Створює нову колекцію пар, створену перетином з іншого
колекцією пар

# Ds\Map::intersect

(PECL ds \>u003d 1.0.0)

Ds\Map::intersect — Створює нову колекцію пар, створену перетином
з іншою колекцією пар

### Опис

public **Ds\Map::intersect**([Ds\Map](class.ds-map.md) `$map`):
[Ds\Map](class.ds-map.md)

Створює нову колекцію пар з поточної, що містить елементи, ключі
яких присутні як у поточній колекції, так і в переданій
параметрі `map`. Іншими словами, повертає копію поточної колекції,
якої видалені всі елементи, ключі яких відсутні в колекції
`map`.

`A ∩ B u003d {x : x ∈ A ∧ x ∈ B}`

> **Примітка**:
>
> Значення беруться із поточної колекції пар.

### Список параметрів

`map`
Нова колекція типу Map.

### Значення, що повертаються

Перетин поточної колекції та переданої в `map`.

### Також дивіться

- [» Перетин](https://en.wikipedia.org/wiki/Intersection_(set_theory))
на Вікіпедія

### Приклади

**Приклад #1 Приклад використання **Ds\Map::intersect()****

` <?php$a u003d new \Ds\Map(["a" u003d> 1, "b" u003d> 2, c" u003d> 3]);$b u003d new \Ds\Map(["b" u003d> 4, "c" u003d> 5, "d" u003d> 6]);var_dump($a->intersect($b));?> `

Результатом виконання цього прикладу буде щось подібне:

object(Ds\Map)#3 (2) {
[0]u003d>
object(Ds\Pair)#4 (2) {
["key"]u003d>
string(1) "b"
["value"]u003d>
int(2)
}
[1]u003d>
object(Ds\Pair)#5 (2) {
["key"]u003d>
string(1) "c"
["value"]u003d>
int(3)
}
}
