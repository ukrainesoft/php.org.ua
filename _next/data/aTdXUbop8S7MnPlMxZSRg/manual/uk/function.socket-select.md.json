{"pageProps":{"page":{"slug":"function.socket-select.md","content":"# socket\\_select\n\n(PHP 4 >= 4.1.0, PHP 5, PHP 7, PHP 8)\n\nsocket\\_select — Запускає системний виклик select() для заданих масивів сокетів із зазначеним часом очікування\n\n### Опис\n\n```methodsynopsis\nsocket_select(    ?array &$read,    ?array &$write,    ?array &$except,    ?int $seconds,    int $microseconds = 0): int|false\n```\n\n**socket\\_select()** приймає масиви сокетів та чекає їх зміни статусу. Ті, хто знайомий із сокетами BSD, виявлять, що масиви сокетів насправді є так званими наборами дескрипторів файлів. Спостерігаються три незалежні масиви ресурсів сокетів.\n\n### Список параметрів\n\n`read`\n\nСокети, перелічені у масиві `read` будуть спостерігатися для перегляду, чи є доступні символи для читання (точніше, щоб бачити, чи не буде читання блокуватися, зокрема, сокет вже досяг кінця файлу, і в цьому випадку [socket\\_read()](function.socket-read.md) поверне рядок із нульовою довжиною).\n\n`write`\n\nСокети, перелічені у масиві `write` спостерігатимуться для перегляду, чи запис блокуватиметься.\n\n`except`\n\nСокети, перелічені у масиві `except`будут наблюдаться для исключений.\n\n`seconds`\n\n`seconds`и`microseconds`вместе образуют параметр`timeout`Параметр`timeout` - максимальний проміжок часу до повернення **socket\\_select()**. . `seconds` може бути нулем, змушуючи **socket\\_select()** до негайного повернення. Це корисно для опитування. Якщо `seconds`равен\\*\\*`null`\\*\\*(нет времени ожидания),**socket\\_select()** може блокуватися нескінченно.\n\n`microseconds`\n\n**Увага**\n\nПри завершенні масиви змінюються, щоб визначити, який сокет насправді змінив статус.\n\nНе потрібно передавати кожен масив у **socket\\_select()**. Ви можете пропустити його і використовувати порожній масив або **`null`** замість цього. Також не забувайте, що ці масиви передаються *за посиланням* і будуть змінені після завершення **socket\\_select()**\n\n> **Зауваження** :\n> \n> Через обмеження поточного двигуна Zend неможливо передати модифікатор константи, такий як **`null`**, безпосередньо як параметр у функцію, яка очікує, що цей параметр буде передано за посиланням. Натомість використовуйте тимчасову змінну або вираз, де ліва сторона є тимчасовою змінною:\n> \n> **Приклад #1 Использование**`null`**в**socket\\_select()\\*\\*\\*\\*\n> \n> ```php\n> <?php\n> $e = NULL;\n> socket_select($r, $w, $e, 0);\n> ?>\n> ```\n\n### Значення, що повертаються\n\nУ разі успішного виконання **socket\\_select()** повертає кількість сокетів, що містяться в змінених масивах, яка може дорівнювати нулю, якщо час очікування закінчиться до того, як станеться щось цікаве. У разі виникнення помилки повертається **`false`**. Код помилки може бути отриманий за допомогою [socket\\_last\\_error()](function.socket-last-error.md)\n\n> **Зауваження** :\n> \n> Обов'язково використовуйте оператор `===` під час перевірки на помилку. Оскільки **socket\\_select()** може повертати 0, порівняння з `==` буде оцінюватися як **`true`** :\n> \n> **Приклад #2 Анализ результата**socket\\_select()\\*\\*\\*\\*\n> \n> ```php\n> <?php\n> $ e = NULL;\n> if (false === socket_select($r, $w, $e, 0)) {\n>     echo \"Невдалий виклик socket_select(), причина: \" .\n>         socket_strerror(socket_last_error()) . \"\\n\";\n> }\n> ?>\n> ```\n\n### Приклади\n\n**Приклад #3 Приклад використання** socket\\_select()\\*\\*\\*\\*\n\n```php\n<?php\n/* Подготовить массив сокетов для чтения */\n$read   = array($socket1, $socket2);\n$write  = NULL;\n$except = NULL;\n$num_changed_sockets = socket_select($read, $write, $except, 0);\n\nif ($num_changed_sockets === false) {\n    /* Обработка ошибок */\n} else if ($num_changed_sockets > 0) {\n    /* По крайней мере, в одном из сокетов произошло что-то интересное */\n}\n?>\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Майте на увазі, деякі реалізації сокетів необхідно обробляти дуже обережно. Декілька основних правил:\n> \n> -   Ви завжди повинні спробувати використати\\*\\*socket\\_select()\\*\\*без часу очікування. Ваша програма нічого не повинна робити, якщо немає доступних даних. Код, що залежить від часу очікування, зазвичай не дуже переносимий і важкий для налагодження.\n> -   Сокет не повинен додаватися до будь-якого масиву, якщо ви не збираєтеся перевіряти результат після виклику**socket\\_select()**. Після повернення\\*\\*socket\\_select()\\*\\*всі сокети у всіх масивах мають бути перевірені. Будь-який сокет, доступний для запису чи читання, повинен використовуватися для запису чи читання.\n> -   Якщо ви читаєте або записуєте з сокету, що повертається в масивах, майте на увазі, що він необов'язково зможе прочитати або записати дані, які ви запитуєте. Будьте готові прочитати або записати лише один байт.\n> -   Зазвичай для більшості реалізацій сокетів єдиний виняток, упійманий за допомогою масиву`except`\\- Це дані без прив'язки, отримані в сокеті.\n\n### Дивіться також\n\n-   [socket\\_read()](function.socket-read.md) \\- Читає рядок максимальну довжину байт із сокету\n-   [socket\\_write()](function.socket-write.md) \\- Запис у сокет\n-   [socket\\_last\\_error()](function.socket-last-error.md) \\- Повертає останню помилку на сокеті\n-   [socket\\_strerror()](function.socket-strerror.md) \\- Повертає рядок, що описує помилку сокету\n","title":"socket\\_select","contentType":2,"navigation":[{"function.socket-recvmsg.md":"« socket\\_recvmsg"},{"function.socket-send.md":"socket\\_send »"},{"index.md":"PHP Manual"},{"ref.sockets.md":"Опції сокету"}]}},"__N_SSG":true}