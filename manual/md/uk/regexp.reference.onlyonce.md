- [«Затвердження](regexp.reference.assertions.md)
- [Умовні підмаски »](regexp.reference.conditional.md)

- [PHP Manual](index.md)
- [Опис синтаксису Perl-сумісних регулярних
виразів](reference.pcre.pattern.syntax.md)
- Одноразові підмаски

## Одноразові підмаски

Як для мінімальної, так і максимальної кількості повторень, якщо
Наступна частина шаблону зазнає невдачі у порівнянні, відбувається
повторний аналіз повторюваного висловлювання щодо того, чи можливо
успішне зіставлення всього шаблону при іншій кількості повторень.
Бувають випадки, коли необхідно змінити описану логіку роботи для
реалізації специфічного зіставлення чи оптимізації шаблону (якщо
автор упевнений, що інших варіантів відповідності немає).

Як приклад, розглянемо шаблон \d+foo у застосуванні до рядка
`123456bar`

Після того як \d+ буде зіставлений з першими шістьма цифрами,
зіставлення "foo" зазнає невдачі. Після цього, у відповідність \d+,
буде зіставлено 5 цифр, після чергової невдачі буде зіставлено 4 цифр
цифри тощо. Зрештою, весь шаблон зазнає невдачі.
Одноразові підмаски вказують, що якщо одна частина шаблону була
Порівняно, її не варто аналізувати повторно. Застосовно до
наведеному вище прикладу весь шаблон зазнав би невдачі після першого
ж невдалого зіставлення з "foo". Записуються одноразові шаблони
за допомогою круглих дужок наступним чином: (?\>. Наприклад:
`(?>\d+)bar`

Цей вид підмаски запобігає повторному її аналізу у випадку, якщо
зіставлення наступних елементів зазнають невдачі. Однак це не
заважає повторно аналізувати будь-які інші елементи, зокрема
попередні одноразової підмаски.

Іншими словами, підмаски такого типу відповідають тій частині
підрядки, якою відповідала б одиночна ізольована маска,
заякорена на поточній позиції тексту, що обробляється.

Одноразові підмаски є незахоплюючими. Прості приклади,
подібні до наведеного вище, можна охарактеризувати як безумовний
захоплення максимальної кількості повторень. У той час як \d+ та \d+?
коригуються так, щоб інші частини шаблону так само збіглися,
(?\>\d+) відповідає виключно максимальній за довжиною
послідовності цифр, навіть якщо це призводить до невдачі при
зіставлення інших елементів шаблону.

Одноразові підмаски можуть включати складніші конструкції, а
також можуть бути вкладеними.

Одноразові підмаски можуть використовуватися разом із затвердженнями
щодо попереднього тексту для опису ефективних зіставлень
наприкінці оброблюваного тексту. Розглянемо простий шаблон `abcd$`
застосування до довгого тексту, який відповідає зазначеній масці.
Оскільки пошук відбувається зліва направо, спочатку PCRE шукатиме
букву "a", і лише потім аналізувати наступні записи у шаблоні. В
у випадку, якщо шаблон вказаний у вигляді `^.*abcd$`. У такому разі спочатку .\*
зіставляється з усім рядком, після чого зіставлення зазнає невдачі
(оскільки немає наступного символу 'a'). Після цього .\* зіставляється з
усім рядком, крім останнього символу, потім крім двох останніх
символів і так далі. Зрештою пошук символу 'a' відбувається за
всьому рядку. Однак, якщо шаблон записати у вигляді: `^(?>.*)(?<u003dabcd)`
повторний аналіз для .\* не виконується, і, як наслідок, може
відповідати тільки всьому рядку цілком. Після чого затвердження
перевіряє останні чотири символи на збіг з 'abcd', і у випадку
невдачі все зіставлення зазнає невдачі. Для великих обсягів
оброблюваного тексту цей підхід має значний виграш у часі
виконання.

Якщо шаблон містить необмежену повторення всередині підмаски, яка
у свою чергу також може повторюватися необмежену кількість разів,
використання одноразових підмасок дозволяє уникати багаторазових
невдалих зіставлень, що тривають досить тривале
час. Шаблон `(\D+|<\d+>)*[!?]` відповідає необмеженому
кількості підрядів, які складаються не з цифр, або цифр
ув'язнених у \<\>, за якими слідує ? або!. У випадку, якщо в
оброблюваному тексті містяться відповідності, час роботи регулярного
вирази буде невеликим. Але якщо його застосувати до рядка
`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa це займе
тривалий час. Це пов'язано з тим, що рядок може бути розділений
між двома частинами шаблону багатьма способами, і всі вони будуть
випробувані (у прикладі ми використовували \[?!\], оскільки у випадку
одиночного символу в кінці шаблону PCRE і Perl виконують оптимізацію.
Вони запам'ятовують останній одиночний символ і у разі його відсутності
видають невдачу). Якщо змінити шаблон на `((?>\D+)|<\d+>)*[!?]`, не
цифрові послідовності не можуть бути розірвані, і неможливість
зіставлення виявляється набагато швидше.
