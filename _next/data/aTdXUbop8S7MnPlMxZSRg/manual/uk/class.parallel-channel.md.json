{"pageProps":{"page":{"slug":"class.parallel-channel.md","content":"# Клас parallel\\\\Channel\n\n(0.9.0)\n\n## Небуферизовані канали\n\nНебуферизований канал блокуватиметься під час дзвінків [parallel\\\\Channel::send()](parallel-channel.send.md) до тих пір, поки не з'явиться одержувач, і блокуватись при викликах [parallel\\\\Channel::recv()](parallel-channel.recv.md) доти, доки з'явиться відправник. Це означає, що небуферизований канал - це спосіб обміну даними між завданнями, а й простий метод синхронізації.\n\nНебуферизований канал - це найшвидший спосіб обміну даними між завданнями, що вимагає найменшої кількості копіювання.\n\n## Буферизовані канали\n\nБуферизований канал не блокуватиметься під час дзвінків [parallel\\\\Channel::send()](parallel-channel.send.md) до заповнення буфера, а дзвінки [parallel\\\\Channel::recv()](parallel-channel.recv.md) блокуватимуться до тих пір, поки в буфері є дані.\n\n## Замикання поверх каналів\n\nПотужна особливість паралельних каналів у тому, що дозволяють обмінюватися замиканнями між завданнями (і середовищами виконання).\n\nКоли замикання відправляється по каналу, воно буферизується, не змінює буферизацію каналу, що передає замикання, але воно впливає на статичну область видимості всередині замикання: одне і те ж замикання, відправлене в різні середовища виконання або в те саме середовище виконання, не ділитися своєю статичною областю.\n\nЦе означає, що кожного разу, коли виконується замикання, яке було передане каналом, статичний стан буде таким, яким воно було при буферизації замикання.\n\n## Анонімні канали\n\nКонструктор анонімного каналу дозволяє програмісту уникати присвоєння імен кожному каналу: parallel генерує унікальне ім'я анонімних каналів.\n\n## Огляд класів\n\n```classsynopsis\n\n\n\n    \n     \n      final\n      class parallel\\Channel\n     \n     {\n\n\n    /* Анонимный конструктор */\n    \n   public __construct()\npublic __construct(int $capacity)\n\n\n    /* Доступ */\n    public make(string $name): Channel\npublic make(string $name, int $capacity): Channel\npublic open(string $name): Channel\n\n\n    /* Совместное использование */\n    public recv(): mixed\npublic send(mixed $value): void\n\n\n    /* Закрытие */\n    public close(): void\n\n\n    /* Константа для бесконечной буферизации */\n    \n     const\n      Infinite;\n\n\n   }\n```\n\n## Зміст\n\n-   [parallel\\\\Channel::\\_\\_construct](parallel-channel.construct.md) \\- Конструктор класу Channel\n-   [parallel\\\\Channel::make](parallel-channel.make.md) \\- Доступ\n-   [parallel\\\\Channel::open](parallel-channel.open.md) \\- Доступ\n-   [parallel\\\\Channel::recv](parallel-channel.recv.md) \\- Спільне використання\n-   [parallel\\\\Channel::send](parallel-channel.send.md) \\- Спільне використання\n-   [parallel\\\\Channel::close](parallel-channel.close.md) \\- Закриття\n","title":"Клас parallel\\\\Channel","contentType":2,"navigation":[{"parallel-future.value.md":"« parallel\\\\Future::value"},{"parallel-channel.construct.md":"parallel\\\\Channel::\\_\\_construct »"},{"index.md":"PHP Manual"},{"book.parallel.md":"parallel"}]}},"__N_SSG":true}