{"pageProps":{"page":{"slug":"function.set-error-handler.md","content":"# set\\_error\\_handler\n\n(PHP 4 >= 4.0.1, PHP 5, PHP 7, PHP 8)\n\nset\\_error\\_handler — Задає користувальницький обробник помилок\n\n### Опис\n\n```methodsynopsis\nset_error_handler(?callable $callback, int $error_levels = E_ALL): ?callable\n```\n\nЗадає функцію користувача (`callback`), як обробник помилок у скрипті.\n\nФункція може бути використана для визначення користувальницьких обробників помилок під час виконання, наприклад, у додатках, які повинні виконувати очищення файлів/даних у разі виникнення критичної помилки або при ініціювання помилки у відповідь на певні умови (використовуючи функцію [trigger\\_error()](function.trigger-error.md)\n\nВажливо пам'ятати, що стандартний обробник помилок PHP не оброблятиме жодні типи помилок, визначені в `error_levels`, поки callback-функція не поверне **`false`**. Користувальницький обробник буде викликатись у разі виникнення будь-якої помилки, незалежно від налаштувань, заданих функцією [error\\_reporting](errorfunc.configuration.md#ini.error-reporting)\n\nТакож зверніть увагу, що обробник зобов'язаний при необхідності зупинити виконання скрипту, викликавши функцію [exit()](function.exit.md). Якщо відбувається повернення з оброблювача помилок, керування передається наступному виразу, що стоїть за тим, що викликало помилку.\n\nПомилки таких типів не можуть бути оброблені користувачем: **`E_ERROR`** **`E_PARSE`** **`E_CORE_ERROR`** **`E_CORE_WARNING`** **`E_COMPILE_ERROR`** **`E_COMPILE_WARNING`** незалежно від того, де вони були згенеровані і більшість помилок **`E_STRICT`**, що відбулися у файлі, де викликана функція **set\\_error\\_handler()**\n\nЯкщо помилки виникають до запуску скрипта (наприклад, поки файл завантажується), обробний користувач не буде викликатися, якщо на цей момент він ще не зареєстрований.\n\n### Список параметрів\n\n`callback`\n\nЯкщо передано значення **`null`**, обробник скидається у стан за промовчанням. В іншому випадку обробник являє собою callback-функцію з наступною сигнатурою:\n\n```methodsynopsis\nhandler(    int $errno,    string $errstr,    string $errfile = ?,    int $errline = ?,    array $errcontext = ?): bool\n```\n\n`errno`\n\nУ перший аргумент `errno` буде передано рівень помилки як цілого числа.\n\n`errstr`\n\nУ другому аргументі `errstr` буде передано повідомлення про помилку у вигляді рядка.\n\n`errfile`\n\nЯкщо функція зворотного дзвінка приймає третій параметр `errfile`, то в нього буде передано ім'я файлу, в якому сталася помилка у вигляді рядка.\n\n`errline`\n\nЯкщо функція зворотного дзвінка приймає четвертий параметр `errline`, то в нього буде передано номер рядка, в якому відбулася помилка, у вигляді цілого числа.\n\n`errcontext`\n\nЯкщо функція зворотного дзвінка приймає п'ятий параметр `errcontext`, то нього буде передано масив покажчиків на активну таблицю символів у точці, де сталася помилка. Іншими словами, `errcontext` міститиме масив усіх змінних, що існують в області видимості, де сталася помилка. Користувальницькі обробники помилок не повинні змінювати цей контекст.\n\n**Увага**\n\nЦей параметр оголошено *Застарілим* починаючи з PHP 7.2.0 і був *ВИДАЛЕНО* у PHP 8.0.0. Якщо у вашій функції цей параметр використовується і для нього не встановлено значення за промовчанням, то при виклику функції обробника буде видана помилка \"too few arguments\".\n\nЯкщо функція повертає **`false`**, керування передається вбудованому обробнику помилок.\n\n`error_levels`\n\nМоже використовуватися для завдання маски, відповідно до якої буде викликатись `callback`, за аналогією з ini-настройкою [error\\_reporting](errorfunc.configuration.md#ini.error-reporting), яка відповідає за те, які помилки будуть показані у звіті. Без цієї маски `callback` буде викликатися для обробки всіх помилок, що відбуваються, незалежно від налаштувань в [error\\_reporting](errorfunc.configuration.md#ini.error-reporting)\n\n### Значення, що повертаються\n\nПовертає раніше певний обробник помилок (якщо є) Якщо на даний момент використовується вбудований обробник, функція поверне **`null`**. Якщо попередній певний обробник є методом класу, функція поверне масив, який містить ім'я класу та ім'я методу.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.0.0 | Параметр`errcontext` був видалений і більше не передається в функцію обробки помилок. |\n| 7.2.0 | Параметр`errcontext` оголошено застарілим. Тепер при його використанні викликатиметься помилка рівня **`E_DEPRECATED`** |\n\n### Приклади\n\n**Приклад #1 Обработка ошибок с помощью функций**set\\_error\\_handler()**и[trigger\\_error()](function.trigger-error.md)**\n\nПриклад нижче демонструє обробку внутрішніх виключень шляхом виклику помилок різних типів та їх обробки користувальницькою функцією:\n\n```php\n<?php\n// функция обработки ошибок\nfunction myErrorHandler($errno, $errstr, $errfile, $errline)\n{\n    if (!(error_reporting() & $errno)) {\n        // Этот код ошибки не включён в error_reporting,\n        // так что пусть обрабатываются стандартным обработчиком ошибок PHP\n        return false;\n    }\n\n    // может потребоваться экранирование $errstr:\n    $errstr = htmlspecialchars($errstr);\n\n    switch ($errno) {\n    case E_USER_ERROR:\n        echo \"<b>Пользовательская ОШИБКА</b> [$errno] $errstr<br />\\n\";\n        echo \"  Фатальная ошибка в строке $errline файла $errfile\";\n        echo \", PHP \" . PHP_VERSION . \" (\" . PHP_OS . \")<br />\\n\";\n        echo \"Завершение работы...<br />\\n\";\n        exit(1);\n\n    case E_USER_WARNING:\n        echo \"<b>Пользовательское ПРЕДУПРЕЖДЕНИЕ</b> [$errno] $errstr<br />\\n\";\n        break;\n\n    case E_USER_NOTICE:\n        echo \"<b>Пользовательское УВЕДОМЛЕНИЕ</b> [$errno] $errstr<br />\\n\";\n        break;\n\n    default:\n        echo \"Неизвестная ошибка: [$errno] $errstr<br />\\n\";\n        break;\n    }\n\n    /* Не запускаем внутренний обработчик ошибок PHP */\n    return true;\n}\n\n// функция для тестирования обработчика ошибок\nfunction scale_by_log($vect, $scale)\n{\n    if (!is_numeric($scale) || $scale <= 0) {\n        trigger_error(\"log(x) для x <= 0 не определён, вы используете: scale = $scale\", E_USER_ERROR);\n    }\n\n    if (!is_array($vect)) {\n        trigger_error(\"Некорректный входной вектор, пропущен массив значений\", E_USER_WARNING);\n        return null;\n    }\n\n    $temp = array();\n    foreach($vect as $pos => $value) {\n        if (!is_numeric($value)) {\n            trigger_error(\"Значение на позиции $pos не является числом, будет использован 0 (ноль)\", E_USER_NOTICE);\n            $value = 0;\n        }\n        $temp[$pos] = log($scale) * $value;\n    }\n\n    return $temp;\n}\n\n// переключаемся на пользовательский обработчик\n$old_error_handler = set_error_handler(\"myErrorHandler\");\n\n// вызовем несколько ошибок, во-первых, определим массив с нечисловым элементом\necho \"vector a\\n\";\n$a = array(2, 3, \"foo\", 5.5, 43.3, 21.11);\nprint_r($a);\n\n// теперь создадим ещё один массив\necho \"----\\nvector b - a notice (b = log(PI) * a)\\n\";\n/* Значение на позиции $pos не является числом, будет использован 0 (ноль)*/\n$b = scale_by_log($a, M_PI);\nprint_r($b);\n\n// проблема, мы передаём строку вместо массива\necho \"----\\nvector c - a warning\\n\";\n/* Некорректный входной вектор, пропущен массив значений */\n$c = scale_by_log(\"not array\", 2.3);\nvar_dump($c); // NULL\n\n// критическая ошибка, логарифм от неположительного числа не определён\necho \"----\\nvector d - fatal error\\n\";\n/* log(x) для x <= 0 не определён, вы используете: scale = $scale */\n$d = scale_by_log($a, -2.5);\nvar_dump($d); // До сюда не дойдём никогда\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nvector a\nArray\n(\n    [0] => 2\n    [1] => 3\n    [2] => foo\n    [3] => 5.5\n    [4] => 43.3\n    [5] => 21.11\n)\n----\nvector b - a notice (b = log(PI) * a)\n<b>Пользовательское УВЕДОМЛЕНИЕ</b> [1024]  Значение на позиции 2 не является числом, будет использован 0 (ноль)<br />\nArray\n(\n    [0] => 2.2894597716988\n    [1] => 3.4341896575482\n    [2] => 0\n    [3] => 6.2960143721717\n    [4] => 49.566804057279\n    [5] => 24.165247890281\n)\n----\nvector c - a warning\n<b>Пользовательское ПРЕДУПРЕЖДЕНИЕ</b> [512] Некорректный входной вектор, пропущен массив значений<br />\nNULL\n----\nvector d - fatal error\n<b>Пользовательская ОШИБКА</b> [256] log(x) for x <= 0 is undefined, you used: scale = -2.5<br />\n  Фатальная ошибка в строке 35 файла trigger_error.php, PHP 5.2.1 (FreeBSD)<br />\nЗавершение работы...<br />\n```\n\n### Дивіться також\n\n-   [ErrorException](class.errorexception.md)\n-   [error\\_reporting()](function.error-reporting.md) \\- Встановлює, які помилки PHP потраплять у звіт\n-   [restore\\_error\\_handler()](function.restore-error-handler.md) \\- Відновлює попередній обробник помилок\n-   [trigger\\_error()](function.trigger-error.md) \\- Викликає помилку користувача/попередження/повідомлення\n-   [Константи рівнів помилок](errorfunc.constants.md)\n","title":"set\\_error\\_handler","contentType":2,"navigation":[{"function.restore-exception-handler.md":"« restore\\_exception\\_handler"},{"function.set-exception-handler.md":"set\\_exception\\_handler »"},{"index.md":"PHP Manual"},{"ref.errorfunc.md":"Функції обробки помилок"}]}},"__N_SSG":true}