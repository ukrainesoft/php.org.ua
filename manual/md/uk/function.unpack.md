- [«uniqid](function.uniqid.md)
- [usleep »] (function.usleep.md)

- [PHP Manual](index.md)
- [Різні функції](ref.misc.md)
- Розпакувати дані з бінарного рядка

# unpack

(PHP 4, PHP 5, PHP 7, PHP 8)

unpack — Розпакувати дані з бінарного рядка

### Опис

**unpack**(string `$format`, string `$string`, int `$offset` u003d 0):
array\|false

Розпаковує дані з бінарного рядка в масив відповідно до
заданим у `format` форматі.

Розпаковані дані зберігаються в асоціативному масиві. Для здійснення
цього необхідно позначити різні коди форматів та розділити їх з
допомогою слєша /. Можна також передати заміщувальний аргумент за допомогою
якого кожен ключ масиву буде мати порядковий номер після
заданого імені.

Для підтримки сумісності з Perl зроблено таке:

- Код "a" тепер зберігає завершальні NULL-байти.
- Код "A" тепер видаляє всі завершальні пробіли ASCII
(пробіли, табуляцію, переноси рядків, повернення каретки, та NULL-байти).
- Код "Z" доданий для NULL-доповненими рядками та видаляє
завершальні NULL-байти.

### Список параметрів

`format`
Дивіться функцію [pack()](function.pack.md) для роз'яснення кодів
форматів.

`string`
Запаковані дані.

`offset`
Зміщення, з якого необхідно розпочати розпаковування.

### Значення, що повертаються

Повертає асоціативний масив, що містить розпаковані елементи
бінарного рядка або **`false`** у разі виникнення помилки.

### Список змін

| Версія | Опис |
|--------|---------------------------------------- ----------------------------------------------|
| 7.2.0 | Типи float і double підтримують як зворотний, і прямий порядок передачі байтів. |
| 7.1.0 | Додано необов'язковий параметр `offset`. |

### Приклади

**Приклад #1 Приклад використання **unpack()****

` <?php$binarydata u003d "\x04\x00\xa0\x00";$arrayu003du003dunpack("cchars/nint", $binarydata);print_r($array);?> `

Результат виконання цього прикладу:

Array
(
[chars] u003d> 4
[int] u003d> 160
)

**Приклад #2 Приклад використання **unpack()** із заміщувальним аргументом**

` <?php$binarydata u003d "\x04\x00\xa0\x00";$arrayu003du003dunpack("c2chars/nint", $binarydata);print_r($array);?> `

Результат виконання цього прикладу:

Array
(
[chars1] u003d> 4
[chars2] u003d> 0
[int] u003d> 40960
)

### Примітки

**Застереження**

Слід зазначити, що PHP зберігає цілі значення зі знаком (signed).
Якщо розпакувати значення типу large unsigned long і воно матиме той
ж розмір, як і збережене значення PHP, то результатом буде
негативне число, навіть якщо було зазначено розпаковувати без знаку
(unsigned).

**Застереження**

Якщо не назвати елемент, то будуть використані числові індекси, починаючи
з `1`. Якщо не позначити більше одного елемента, це означає, що
деякі дані будуть перезаписані, оскільки нумерація перезапускається з
`1` для кожного елемента.

**Приклад #3 Приклад використання **unpack()** з безіменними ключами**

` <?php$binarydata u003d "\x32\x42\x00\xa0";$arrayu003du003dunpack("c2/n", $binarydata);var_dump($array);?> `

Результат виконання цього прикладу:

array(2) {
[1]u003d>
int(160)
[2]u003d>
int(66)
}

Зверніть увагу, що перше значення специфікатора `c`
перезаписується першим значенням із специфікатора `n`.

### Дивіться також

- [pack()](function.pack.md) - Упакувати дані в бінарний рядок
