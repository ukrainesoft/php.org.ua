- [«proc_nice](function.proc-nice.md)
- [proc_terminate »](function.proc-terminate.md)

- [PHP Manual](index.md)
- [Функції запуску програм](ref.exec.md)
- Виконати команду та відкрити покажчик на файл для введення/виводу

#proc_open

(PHP 4 \>u003d 4.3.0, PHP 5, PHP 7, PHP 8)

proc_open — Виконати команду та відкрити покажчик на файл для
введення/виводу

### Опис

**proc_open**(
array\|string `$command`,
array `$descriptor_spec`,
array `&$pipes`,
?string `$cwd` u003d **`null`**,
?array `$env_vars` u003d **`null`**,
?array `$options` u003d **`null`**
): resource \ | false

**proc_open()** аналогічна [popen()](function.popen.md), але
надає набагато більше контролю за виконанням програми.

### Список параметрів

`command`
Командна до виконання, зазначена як рядок (string). Спеціальні
символи повинні бути належним чином екрановані, та повинні застосовуватися
правильні лапки.

> **Примітка**: У *Windows*, якщо для `bypass_shell` не встановлено
> значення **`true`** у `options`, `command` передається у **cmd.exe**
> (точніше, `%ComSpec%`) з прапором `/c` як рядки *без лапок* (тобто.
> точно так, як було встановлено в **proc_open()**). Це може призвести до
> тому, що **cmd.exe** видалить тих, хто укладає з `command` (подробиці
> дивіться у документації **cmd.exe**), приводячи до несподіваного та
> потенційно навіть небезпечної поведінки, тому що повідомлення про помилки
> **cmd.exe** можуть містити (частково) переданий параметр `command`
> (дивіться приклад нижче).

Починаючи з PHP 7.4.0, command може передаватися як масив (array)
параметрів команди. У цьому випадку процес буде відкритий безпосередньо (не
проходячи через оболонку) і PHP подбає про екранування будь-якого
необхідного аргументу.

> **Примітка**:
>
> У Windows екранування аргументу масиву (array) елементів
> припускає, що синтаксичний аналіз виконаної команди сумісний
> з синтаксичним аналізом аргументів командного рядка, виконуваних
> середовищем виконання VC.

`descriptor_spec`
Масив, ключі якого є номер дескриптора, а значення
описує, як PHP має передати цей дескриптор дочірньому процесу.
0 - stdin, 1 - stdout і 2 - stderr.

Кожен елемент може бути:

- Масивом, що описує канал (pipe) передачі процесу. Перший
елемент – це дескриптор типу, другий – налаштування для вибраного
типу. Можливі типи: `pipe` (другий елемент або `r` для передачі
процесу сторони каналу для читання, або `w` для передачі сторони
записи) та `file` (другий елемент - ім'я файлу). Зверніть увагу,
що все, крім `w`, обробляється як `r`.
- ресурс потоку, що представляє дескриптор файлу (наприклад, відкритий
файл, сокет, **`STDIN`**).

Номери дескрипторів не обмежені лише 0, 1 та 2 - ви можете призначити
будь-який дійсний номер дескриптора і його буде передано дочірньому
процесу. Це дозволяє скрипту взаємодіяти з іншими скриптами,
працюючими, як паралельні процеси. Зокрема, таким чином можна
передавати дані, що вимагають захисту, у програми на зразок PGP, GPG та
openssl безпечніше. Також це може бути корисним для читання
статусної інформації, що надається цими програмами на
допоміжні файлові дескриптори.

`pipes`
Буде заданий масивом покажчиків на файли, що відповідають створеним
каналів передачі PHP.

`cwd`
Робоча директорія команди. Це має бути *абсолютний* шлях до
директорії або **`null`**, якщо потрібно використовувати директорію з
замовчуванням (робоча директорія поточного процесу PHP).

`env_vars`
Масив змінних оточення для команди, що запускається, або **`null`**, якщо
потрібно використовувати те саме оточення, що й у поточного
PHP-процес.

`options`
Дозволяє встановити додаткові налаштування. На даний момент
підтримуються такі настройки:

- `suppress_errors` (тільки для Windows): при установці в **`true`**
не будуть показуватися помилки, що виникають під час роботи функції
- `bypass_shell` (тільки для Windows): при установці в **`true`**
процес буде запущений в обхід оболонки `cmd.exe`
- `blocking_pipes` (тільки для Windows): примусово блокувати
потік при значенні **`true`**
- `create_process_group` (тільки для Windows): дозволити дочірньому
процесу обробляти `CTRL` події, якщо встановлено значення
**`true`**
- `create_new_console` (тільки для Windows): новий процес використовує
нову консоль, а не успадковує консоль свого батька

### Значення, що повертаються

Повертає ресурс, який представляє процес. Цей ресурс необхідний
звільняти функцією [proc_close()](function.proc-close.md) за
завершення роботи з ним. У разі виникнення помилки повертає
**`false`**.

### Список змін

| Версія | Опис |
|--------|---------------------------------------- ----------------------------|
| 7.4.4 | Додана опція `create_new_console` у параметр `options`. |
| 7.4.0 | **proc_open()** тепер також приймає масив (array) у `command`. |
| 7.4.0 | Додана опція `create_process_group` у параметр `options`. |

### Приклади

**Приклад #1 Приклад використання **proc_open()****

` <?php$descriptorspec u003d array(  0 u003d> array("pipe", "r"), // stdin - канал, з якого дочірній процесс буде читати   1 > > / stdout - канал, в який дочірній процес буде записувати   2 u003d> array("file", "/tmp/error-output.txt", "a") // записи|||| ';$env u003d array('some_option' u003d> 'aeiou');$process u003d proc_open('php', $descriptorspec, $pipes, $cwd, $env);if (is_resource($process))   | $pipes теперь выглядит так:    // 0 u003d> записывающий обработчик, подключённый к дочернему stdin    // 1 u003d> читающий обработчик, подключённый к дочернему stdout    // Вывод сообщений об ошибках будет добавляться в /tmp/error-output.txt    fwrite($ pipes[0], '<?php print_r($_ENV); ?>'); fclose($pipes[0]); echo stream_get_contents($pipes[1]); fclose($pipes[1]); // Важливо закривати всі канали перед| echo "команда вернула $return_value
";}?> `

Результатом виконання цього прикладу буде щось подібне:

Array
(
[some_option] u003d> aeiou
[PWD] u003d> /tmp
[SHLVL] u003d> 1
[_] u003d> /usr/local/bin/php
)
команда повернула 0

**Приклад #2 **proc_open()** примхи в Windows**

Хоча можна очікувати, що наступна програма шукатиме у файлі
`filename.txt` текст `search` і виводити результати, вона веде себе
трохи інакше.

` <?php$descriptorspec u003d [STDIN, STDOUT, STDOUT];$cmd u003d '"findstr" "search" "filename.txt"';$proc u003d proc_open($cmd, $descriptorspec, $pipes); proc);?> `

Результат виконання цього прикладу:

'findstr" "search" "filename.txt' не розпізнається як внутрішня або зовнішня команда,
працююча програма чи пакетний файл.

Щоб обійти цю поведінку, зазвичай достатньо передати `command` у
додаткових лапках:

` $cmd u003d''""findstr" "search" "filename.txt""';`

### Примітки

> **Примітка**:
>
> Сумісність із Windows: Дескриптори далі 2 (stderr) успадковуються
> дочірніми процесами, однак відколи Windows не асоціює
> номери файлових дескрипторів із низькорівневими обробниками, дочірні
> процеси немає (поки) до них доступу. Це не відноситься до stdin,
> stdout та stderr.

> **Примітка**:
>
> Якщо потрібний однонаправлений канал процесу, використовуйте функцію
> [popen()](function.popen.md), так як вона значно простіше в
> використання.

### Дивіться також

- [popen()](function.popen.md) - Відкриває файловий покажчик
процесу
- [exec()](function.exec.md) - Виконати зовнішню програму
- [system()](function.system.md) - Виконати зовнішню програму та
відобразити висновок
- [passthru()](function.passthru.md) - Виконати зовнішню програму та
відобразити необроблений висновок
- [stream_select()](function.stream-select.md) - Запускає
еквівалент системного виклику select() на заданих масивах потоків
з часом очікування, вказаним параметрами seconds та microseconds
- [Оператор зворотний апостроф](language.operators.execution.md)
