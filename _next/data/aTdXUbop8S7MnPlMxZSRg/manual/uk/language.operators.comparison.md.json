{"pageProps":{"page":{"slug":"language.operators.comparison.md","content":"## Оператори порівняння\n\nОператори порівняння, як це видно з їхньої назви, дозволяють порівнювати між собою два значення. Можуть також виявитися цікавими для знайомства [таблиці порівняння типів](types.comparisons.md), оскільки в них показані приклади порівнянь, пов'язаних із різними типами.\n\n**Оператори порівняння**\n\n| Приклад | Название | Результат |\n| --- | --- | --- |\n| $a == $b | Рівно | Повертається **`true`**, якщо значення змінної $a після перетворення типів дорівнює значенням змінної $b. |\n| $a === $b | Тотожно | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a дорівнює значенню змінної $b і має той самий тип. |\n| $a != $b | Не дорівнює | Повертається **`true`**, якщо значення змінної $a після перетворення типів не дорівнює значенню змінної $b. |\n| $a <> $b | Не дорівнює | Повертається **`true`**, якщо значення змінної $a після перетворення типів не дорівнює значенню змінної $b. |\n| $a !== $b | Тотожно не одно | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a не дорівнює значенню змінної $b або вони різних типів. |\n| $a < $b | Менше | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a строго менше значення змінної $b. |\n| $a > $b | Більше | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a строго більше значення змінної $b. |\n| $a <= $b | Менше або дорівнює | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a менше або дорівнює значенням змінної $b. |\n| $a >= $b | Більше або дорівнює | Повертається \\*\\*`true`\\*\\*якщо значення змінної $a більше або дорівнює значенням змінної $b. |\n| $a <=> $b | Космічний корабель (spaceship) | Ціле число (int) менше, більше або дорівнює нулю, коли значення змінної $a менше, більше або дорівнює значенню змінної $b. |\n\nЕсли оба операнда —[рядки, що містять числа](language.types.numeric-strings.md), або один операнд - число, а інший - [рядок, що містить числа](language.types.numeric-strings.md), то порівняння виконується чисельно. Ці правила також справедливі для оператора [switch](control-structures.switch.md). Тип не перетворюється при порівняннях виду `===`или`!==`оскільки це включає порівняння типу, а також значення.\n\n**Увага**\n\nДо PHP 8.0.0, якщо рядок (string) порівнювався з числом або рядком, що містить число, то рядок (string) перетворювався на число перед виконанням порівняння. Це могло призвести до несподіваних результатів, які можна побачити на наступному прикладі:\n\n```php\n<?php\n\nvar_dump(0 == \"a\");\nvar_dump(\"1\" == \"01\");\nvar_dump(\"10\" == \"1e1\");\nvar_dump(100 == \"1e2\");\n\nswitch (\"a\") {\ncase 0:\n    echo \"0\";\n    break;\ncase \"a\":\n    echo \"a\";\n    break;\n}\n```\n\nРезультат виконання наведеного прикладу в PHP 7:\n\n```\nbool(true)\nbool(true)\nbool(true)\nbool(true)\n0\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nbool(false)\nbool(true)\nbool(true)\nbool(true)\na\n```\n\n```php\n<?php\n// Целые числа\necho 1 <=> 1; // 0\necho 1 <=> 2; // -1\necho 2 <=> 1; // 1\n\n// Числа с плавающей точкой\necho 1.5 <=> 1.5; // 0\necho 1.5 <=> 2.5; // -1\necho 2.5 <=> 1.5; // 1\n\n// Строки\necho \"a\" <=> \"a\"; // 0\necho \"a\" <=> \"b\"; // -1\necho \"b\" <=> \"a\"; // 1\necho \"a\" <=> \"aa\"; // -1\necho \"zz\" <=> \"aa\"; // 1\n\n// Массивы\necho [] <=> []; // 0\necho [1, 2, 3] <=> [1, 2, 3]; // 0\necho [1, 2, 3] <=> []; // 1\necho [1, 2, 3] <=> [1, 2, 1]; // 1\necho [1, 2, 3] <=> [1, 2, 4]; // -1\n\n// Объекты\n$a = (object) [\"a\" => \"b\"];\n$b = (object) [\"a\" => \"b\"];\necho $a <=> $b; // 0\n$a = (object) [\"a\" => \"b\"];\n$b = (object) [\"a\" => \"c\"];\necho $a <=> $b; // -1\n$a = (object) [\"a\" => \"c\"];\n$b = (object) [\"a\" => \"b\"];\necho $a <=> $b; // 1\n\n// сравниваются не только значения; ключи также должны совпадать\n$a = (object) [\"a\" => \"b\"];\n$b = (object) [\"b\" => \"b\"];\necho $a <=> $b; // 1\n?>\n```\n\nДля різних типів порівняння відбувається відповідно до наступної таблиці (по порядку).\n\n**Порівняння типів**\n\n| Тип операнда 1 | Тип операнда 2 | Результат |\n| --- | --- | --- |\n| null або string | string | **`null`** перетворюється на порожній рядок (\"\"), числове чи лексичне порівняння |\n| bool або null | що завгодно | Перетворюється на bool, **`false`** < **`true`** |\n| object | object | Вбудовані класи можуть визначати свої правила порівняння, об'єкти різних класів не порівнюються, порівняння об'єктів одного класу розказано в розділі «[Порівняння об'єкта](language.oop5.object-comparison.md)» |\n| string, resource, int або float | string, resource, int або float | Рядки та ресурси переводяться в числа, звичайна математика |\n| array | array | Масив з меншим числом елементів менший, якщо ключ з першого масиву не знайдено у другому масиві — масиви не можуть порівнюватися, інакше йде порівняння значень (див. приклад нижче) |\n| array | що завгодно | Тип array завжди більший |\n| object | що завгодно | Тип object завжди більший |\n\n**Приклад #1 Порівняння boolean/null**\n\n```php\n<?php\n\n// Логические значения и null всегда сравниваются как логические\nvar_dump(1 == TRUE); // TRUE  — то же, что и (bool)1 == TRUE\nvar_dump(0 == FALSE); // TRUE  — то же, что и (bool)0 == FALSE\nvar_dump(100 < TRUE); // FALSE  — то же, что и (bool)100 < TRUE\nvar_dump(-10 < FALSE); // FALSE  — то же, что и (bool)-10 < FALSE\nvar_dump(min(-100, -10, NULL, 10, 100)); // NULL  — (bool)NULL < (bool)-100 это FALSE < TRUE\n```\n\n**Приклад #2 Алгоритм порівняння звичайних масивів**\n\n```php\n<?php\n\n// Массивы сравниваются как в этом Прикладе — со стандартными операторами сравнения, а также оператором «космический корабль» (spaceship).\nfunction standard_array_compare($op1, $op2)\n{\n    if (count($op1) < count($op2)) {\n        return -1; // $op1 < $op2\n    } elseif (count($op1) > count($op2)) {\n        return 1; // $op1 > $op2\n    }\n\n    foreach ($op1 as $key => $val) {\n        if (!array_key_exists($key, $op2)) {\n            return 1;\n        } elseif ($val < $op2[$key]) {\n            return -1;\n        } elseif ($val > $op2[$key]) {\n            return 1;\n        }\n    }\n\n    return 0; // $op1 == $op2\n}\n```\n\n**Увага**\n\n# Порівняння чисел з плаваючою точкою\n\nЗ причин, пов'язаних зі способом внутрішнього представлення чисел з плаваючою точкою (float), не потрібно перевіряти два числа з плаваючою точкою (float) на рівність.\n\nДокладніше про це можна дізнатися в документації типу float.\n\n> **Зауваження**: Коли пишуть код, пам'ятають, що жонглювання типами PHP не завжди дає передбачуваний результат при порівнянні значень різних типів, особливо при порівнянні цілих чисел (int) з логічними значеннями (bool) або цілих чисел (int) з рядками (string). Тому краще користуватись операторами `===`и`!==`, а не`==`и`!=`\n\n### Незрівнянне значення\n\nХоча тотожні порівняння (`===`и`!==`) можна застосовувати до довільних значень, інші оператори порівняння краще застосовувати лише до порівнянних значень. Результат порівняння незрівнянних значень не визначено і не потрібно покладатися.\n\n### Дивіться також\n\n-   [strcasecmp()](function.strcasecmp.md)\n-   [strcmp()](function.strcmp.md)\n-   [Оператори, що працюють із масивами](language.operators.array.md)\n-   [Типи](language.types.md)\n\n### Тернарний оператор\n\nЩе один умовний оператор – тернарний оператор «?:».\n\n**Приклад #3 Призначення за промовчанням**\n\n```php\n<?php\n\n// Приклад выражения с тернарным оператором\n$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];\n\n// Код выше аналогичен блоку с конструкциями if/else\nif (empty($_POST['action'])) {\n    $action = 'default';\n} else {\n    $action = $_POST['action'];\n}\n```\n\nВираз `(expr1) ? (expr2) : (expr3)` інтерпретується як expr2, якщо expr1 дорівнює **`true`**, або як expr3, якщо expr1 дорівнює **`false`**\n\nМожна не писати середню частину тернарного оператора. Вираз `expr1 ?: expr3` оцінюється як результат виразу expr1, якщо воно оцінюється як **`true`**, інакше як результат виразу expr3. Вираз expr1 оцінюється лише один раз.\n\n> **Зауваження**: Зверніть увагу, що тернарний оператор - це вираз, і він оцінюється не як змінна, а як результат виразу Це важливо, якщо потрібно повернути змінну за посиланням. Вираз `return $var == 42 ? $a : $b;` не працюватиме у функції, що повертає значення за посиланням, а в пізніших версіях PHP також буде видано попередження.\n\n> **Зауваження** :\n> \n> Рекомендовано уникати «нагромадження» тернарних виразів. Поведінка PHP при вказівці більш ніж одного тернарного оператора без дужок в одному виразі не очевидна порівняно з іншими мовами. Справді, до PHP 8.0.0 троїчні висловлювання оцінювалися як лівоасоціативні, а чи не правоасоціативні, як у більшості інших мов програмування. Опора на ліву асоціативність застаріла з PHP 7.4.0. Починаючи з PHP 8.0.0, тернарний оператор неасоціативний.\n> \n> **Приклад #4 Неочевидна поведінка тернарного оператора**\n> \n> ```php\n> <?php\n> \n> // здається, що наступний код виведе «true»\n> echo (true ? 'true' : false ? 't' : 'f');\n> \n> // проте він виводить \"t\" до PHP 8.0.0\n> // Це тому, що тернарні вирази лівоасоціативні\n> \n> // наступний запис — більш очевидна версія того ж коду, який показаний вище\n> echo ((true ? 'true' : false) ? 't' : 'f');\n> \n> // Тут видно, що перший вираз оцінюється як рядкове \"true\", яке\n> // оцінюється як логічне (bool) true, тому повертає справжню гілку\n> / / Другого тернарного виразу.\n> ```\n\n> **Зауваження** :\n> \n> Ланцюжок коротких тернарних операторів (`?:`), однак, стабільна і поводиться обґрунтовано. Вона оцінюватиме перший аргумент, який оцінюється як помилкове значення. Зверніть увагу, що невизначені значення однаково викликатимуть попередження.\n> \n> **Приклад #5 Ланцюжок коротких тернарних операторів**\n> \n> ```php\n> <?php\n> echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; // 1\n> echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; // 2\n> echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; // 3\n> ?>\n> ```\n\n### Оператор об'єднання з null\n\nІнший корисний скорочений оператор – це оператор об'єднання з NULL – «??» (Null coalescing).\n\n**Приклад #6 Призначення за промовчанням**\n\n```php\n<?php\n\n// Приклад работы с оператором нулевого слияния\n$action = $_POST['action'] ?? 'default';\n\n// Приклад выше аналогичен этому выражению с if/else\nif (isset($_POST['action'])) {\n    $action = $_POST['action'];\n} else {\n    $action = 'default';\n}\n```\n\nВираз `(expr1) ?? (expr2)` обчислюється так: expr2, якщо expr1 дорівнює \\*\\*`null`\\*\\*інакше expr1.\n\nЦей оператор не викликає попередження або помилки, якщо лівий операнд не існує, як мовна конструкція [isset()](function.isset.md). Це дуже корисно для ключів масиву.\n\n> **Зауваження**: Зверніть увагу, оператор об'єднання з NULL - це вираз, і він оцінюється не як змінна, а як результат обчислення виразу. Це важливо, якщо потрібно повернути значення за посиланням. Вираз `return $foo ?? $bar;` у функції, що повертає посилання, не працюватиме, а виводитиме попередження.\n\n> **Зауваження** :\n> \n> Оператор об'єднання з NULL має низький пріоритет. Тобто при змішуванні його з іншими операторами (наприклад, з операторами конкатенації рядків або арифметичними операторами), швидше за все, будуть потрібні круглі дужки.\n> \n> ```php\n> <?php\n> \n> // Викликає попередження, що $name не визначено.\n> print 'Mr. '. $name ?? 'Anonymous';\n> \n> // Виведе \"Mr. Anonymous\"\n> print 'Mr. '. ($name ?? 'Anonymous');\n> ```\n\n> **Зауваження** :\n> \n> Зверніть увагу, оператор об'єднання з NULL дозволяє просту вкладеність:\n> \n> **Приклад #7 Вкладений оператор null coalescing**\n> \n> ```php\n> <?php\n> \n> $ foo = null;\n> $bar = null;\n> $ Baz = 1;\n> $ Qux = 2;\n> \n> echo $foo ?? $bar ?? $baz ?? $qux; // виведе 1\n> ```\n","title":"Оператори порівняння","contentType":2,"navigation":[{"language.operators.bitwise.md":"« Побітові оператори"},{"language.operators.errorcontrol.md":"Управління помилками »"},{"index.md":"PHP Manual"},{"language.operators.md":"Оператори"}]}},"__N_SSG":true}