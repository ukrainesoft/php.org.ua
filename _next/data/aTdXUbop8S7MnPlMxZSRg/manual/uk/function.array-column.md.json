{"pageProps":{"page":{"slug":"function.array-column.md","content":"# array\\_column\n\n(PHP 5 >= 5.5.0, PHP 7, PHP 8)\n\narray\\_column — Повертає масив із значень одного стовпця вхідного масиву\n\n### Опис\n\n```methodsynopsis\narray_column(array $array, int|string|null $column_key, int|string|null $index_key = null): array\n```\n\nФункция**array\\_column()** повертає значення одного стовпця масиву (`array`), обозначенного ключом`column_key`. Щоб проіндексувати значення масиву, що повертається, значеннями стовпця `index_key` вхідного масиву, задають необов'язковий параметр `index_key`\n\n### Список параметрів\n\n`array`\n\nБагатомірний масив або масив об'єктів, з якого витягуватиметься стовпець значень. Якщо заданий масив об'єктів, то можна вибирати будь-які його загальнодоступні характеристики. Щоб отримати закриті або захищені властивості, у класі потрібно реалізувати два магічні методи. **\\_\\_get()** і **\\_\\_isset()**\n\n`column_key`\n\nКлюч шпальти, значення якого потрібно повернути. Дозволено передавати як цілий ключ стовпця, так і рядкову назву ключа асоціативного масиву або властивості об'єкта, значення якого потрібно отримати. У параметр також дозволено передавати значення **`null`** для повернення повних масивів або об'єктів (це буде корисно за умови одночасної передачі параметра `index_key`, щоб переіндексувати масив).\n\n`index_key`\n\nСтовпець, значення якого будуть ключами або індексами масива, що повертається. Дозволено вказувати як цілий ключ стовпця, так і рядкову назву ключа. Значення [наводиться](language.types.array.md#language.types.array.key-casts) як завжди для ключів масиву (проте, до PHP 8.0.0 об'єкти, що підтримують перетворення до рядка, були також дозволені).\n\n### Значення, що повертаються\n\nПовертає масив із значень одного стовпця чи властивості об'єкта вхідного масиву.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.0.0 | Об'єкти в стовпцях, позначені параметром `index_key`, більше не будуть перетворені на рядок і замість цього викидатимуть виняток [TypeError](class.typeerror.md) |\n\n### Приклади\n\n**Приклад #1 Отримаємо стовпець із іменами з набору записів**\n\n```php\n<?php\n\n// Массив, представляющий набор записей, возвращённых из базы данных\n$records = array(\n    array(\n        'id' => 2135,\n        'first_name' => 'John',\n        'last_name' => 'Doe',\n    ),\n    array(\n        'id' => 3245,\n        'first_name' => 'Sally',\n        'last_name' => 'Smith',\n    ),\n    array(\n        'id' => 5342,\n        'first_name' => 'Jane',\n        'last_name' => 'Jones',\n    ),\n    array(\n        'id' => 5623,\n        'first_name' => 'Peter',\n        'last_name' => 'Doe',\n    )\n);\n\n$first_names = array_column($records, 'first_name');\nprint_r($first_names);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => John\n    [1] => Sally\n    [2] => Jane\n    [3] => Peter\n)\n```\n\n**Приклад #2 Отримаємо стовпець прізвищ з набору записів, проіндексувавши їх значення стовпця «id»**\n\n```php\n<?php\n\n// Используем массив $records из первого Приклада\n$last_names = array_column($records, 'last_name', 'id');\nprint_r($last_names);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [2135] => Doe\n    [3245] => Smith\n    [5342] => Jones\n    [5623] => Doe\n)\n```\n\n**Приклад #3 Отримаємо стовпець імен користувачів із загальнодоступної властивості «username» об'єкта**\n\n```php\n<?php\n\nclass User\n{\n    public $username;\n\n    public function __construct(string $username)\n    {\n        $this->username = $username;\n    }\n}\n\n$users = [\n    new User('user 1'),\n    new User('user 2'),\n    new User('user 3'),\n];\n\nprint_r(array_column($users, 'username'));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => user 1\n    [1] => user 2\n    [2] => user 3\n)\n```\n\n**Приклад #4 Отримаємо стовпець імен користувачів з приватної властивості об'єкта «name», визначивши магічний метод **\\_\\_get()****\n\n```php\n<?php\n\nclass Person\n{\n    private $name;\n\n    public function __construct(string $name)\n    {\n        $this->name = $name;\n    }\n\n    public function __get($prop)\n    {\n        return $this->$prop;\n    }\n\n    public function __isset($prop) : bool\n    {\n        return isset($this->$prop);\n    }\n}\n\n$people = [\n    new Person('Fred'),\n    new Person('Jane'),\n    new Person('John'),\n];\n\nprint_r(array_column($people, 'name'));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => Fred\n    [1] => Jane\n    [2] => John\n)\n```\n\nЯкщо в об'єкті не буде методу **\\_\\_isset()**, то повернеться порожній масив.\n","title":"array\\_column","contentType":2,"navigation":[{"function.array-chunk.md":"« array\\_chunk"},{"function.array-combine.md":"array\\_combine »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}