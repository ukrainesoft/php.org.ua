{"pageProps":{"page":{"slug":"pdo.prepare.md","content":"# PDO::prepare\n\n(PHP 5 >= 5.1.0, PHP 7, PHP 8, PHP 8,PECL pdo >= 0.1.0)\n\nPDO::prepare — Готує запит до виконання та повертає пов'язаний із цим запитом об'єкт\n\n### Опис\n\n```methodsynopsis\npublic PDO::prepare(string $query, array $options = []): PDOStatement|false\n```\n\nПідготовка SQL-запиту до бази даних до запуску за допомогою методу [PDOStatement::execute()](pdostatement.execute.md). Запит може містити іменовані (:name) або неіменовані (?) псевдозмінні, які будуть замінені на реальні значення під час запуску запиту на виконання. Використовувати одночасно і іменовані, і неіменовані псевдозмінні в одному запиті не можна, необхідно вибрати щось одне. Використовуйте псевдозмінні, щоб прив'язати до запиту введення користувача, не включайте дані, введені користувачем, безпосередньо в запит.\n\nВи повинні підбирати унікальні імена псевдозмінних для кожного значення, яке необхідно надсилати в запит під час виклику [PDOStatement::execute()](pdostatement.execute.md). Не можна використовувати одну псевдозмінну в запиті більше одного разу, крім варіанта, коли активовано режим емуляції.\n\n> **Зауваження** :\n> \n> Псевдозмінні повинні представляти лише одиничний обсяг даних. Ні частина значення, ні службове слово, ні ім'я поля, ні будь-яку довільну частину запиту. Наприклад, ви не можете зв'язати псевдозмінну з кількома значеннями для вставки в конструкцію IN().\n\nВиклик \\*\\*PDO::prepare()\\*\\*и[PDOStatement::execute()](pdostatement.execute.md) для запитів, які будуть запускатися багаторазово з різними параметрами, підвищує продуктивність програми, дозволяючи драйверу кешувати на клієнті та/або сервері план виконання запиту та метадані, а також допомагає уникнути SQL-ін'єкцій, оскільки немає необхідності екранувати параметри, що передаються.\n\nЯкщо драйвер не підтримує запити, що підготовляються, PDO вміє їх емулювати, а також може замінювати псевдозмінні на те, що більше підходить, якщо, наприклад, драйвер підтримує тільки іменовані або, навпаки, тільки неіменовані псевдозмінні.\n\n> **Зауваження**: Синтаксичний аналізатор, що використовується для підготовлених емульованих операторів і для перезапису іменованих параметрів або параметрів стилю знака питання, підтримує нестандартні зворотні сліші для одинарних і подвійних лапок. Це означає, що завершальні лапки, що безпосередньо передують зворотній косій межі, не розпізнаються як такі, що може призвести до неправильного виявлення параметрів, що призведе до збою підготовленого оператора при його виконанні. Обхідний шлях – не використовувати емульовану підготовку до таких SQL-запитів та уникати перезапису параметрів, використовуючи стиль параметрів, який спочатку підтримується драйвером.\n\nПочинаючи з PHP 7.4.0, можна уникнути екранування знаків питання, подвоївши їх. Це означає, що рядок `??`будет преобразована в`?` при надсиланні запиту до бази даних.\n\n### Список параметрів\n\n`query`\n\nЦе має бути коректний SQL-запит з погляду цільової СУБД.\n\n`options`\n\nЦей масив містить одну або більше пар ключ => значення для встановлення значень атрибутів об'єкта PDOStatement, який буде повернутий з цього методу. В основному, ви використовуватимете цей масив для присвоєння значення `PDO::ATTR_CURSOR`атрибуту`PDO::CURSOR_SCROLL`, щоб отримати курсор, що прокручується. Деякі драйвери можуть мати свої специфічні налаштування, які можна встановити під час підготовки запиту.\n\n### Значення, що повертаються\n\nЯкщо СУБД успішно підготувала запит, **PDO::prepare()** повертає об'єкт [PDOStatement](class.pdostatement.md). Якщо підготувати запит не вдалося, **PDO::prepare()** повертає **`false`** або викидає виняток [PDOException](class.pdoexception.md)(зависит от текущего режима[обробки помилок](pdo.error-handling.md)\n\n> **Зауваження** :\n> \n> Емульовані підготовлені запити не створюються на сервері баз даних, тому **PDO::prepare()** неспроможна перевірити правильність побудованого запиту.\n\n### Помилки\n\nВидає помилку рівня **`E_WARNING`**, якщо атрибуту **`PDO::ATTR_ERRMODE`**установлено значение**`PDO::ERRMODE_WARNING`**\n\nВикидає виняток [PDOException](class.pdoexception.md), якщо атрибуту **`PDO::ATTR_ERRMODE`**установлено значение**`PDO::ERRMODE_EXCEPTION`**\n\n### Приклади\n\n**Приклад #1 Підготовка SQL-запиту з іменованими параметрами**\n\n```php\n<?php\n/* Выполнение запроса с передачей ему массива параметров */\n$sql = 'SELECT name, colour, calories\n    FROM fruit\n    WHERE calories < :calories AND colour = :colour';\n$sth = $dbh->prepare($sql, [PDO::ATTR_CURSOR => PDO::CURSOR_FWDONLY]);\n$sth->execute(['calories' => 150, 'colour' => 'red']);\n$red = $sth->fetchAll();\n/* Ключи массива также могут начинаться с двоеточия \":\" (необязательно) */\n$sth->execute([':calories' => 175, ':colour' => 'yellow']);\n$yellow = $sth->fetchAll();\n?>\n```\n\n**Приклад #2 Підготовка SQL-запиту з неназваними параметрами (символ '?')**\n\n```php\n<?php\n/* Выполнение запроса с передачей ему массива параметров */\n$sth = $dbh->prepare('SELECT name, colour, calories\n    FROM fruit\n    WHERE calories < ? AND colour = ?');\n$sth->execute([150, 'red']);\n$red = $sth->fetchAll();\n$sth->execute([175, 'yellow']);\n$yellow = $sth->fetchAll();\n?>\n```\n\n**Приклад #3 Підготовка SQL-запиту з екранованим знаком питання**\n\n```php\n<?php\n/* замечание: работает только с базами данных PostgreSQL */\n$sth = $dbh->prepare('SELECT * FROM issues WHERE tag::jsonb ?? ?');\n$sth->execute(['feature']);\n$featureIssues = $sth->fetchAll();\n$sth->execute(['performance']);\n$performanceIssues = $sth->fetchAll();\n?>\n```\n\n### Дивіться також\n\n-   [PDO::exec()](pdo.exec.md) \\- Виконує SQL-запит та повертає кількість порушених рядків\n-   [PDO::query()](pdo.query.md) \\- готує та виконує вираз SQL без заповнювачів\n-   [PDOStatement::execute()](pdostatement.execute.md) \\- Запускає підготовлений запит на виконання\n","title":"PDO::prepare","contentType":2,"navigation":[{"pdo.lastinsertid.md":"« PDO::lastInsertId"},{"pdo.query.md":"PDO::query »"},{"index.md":"PHP Manual"},{"class.pdo.md":"PDO"}]}},"__N_SSG":true}