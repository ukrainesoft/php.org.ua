{"pageProps":{"page":{"slug":"function.extract.md","content":"# extract\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nextract — Імпортує змінні масиву до поточної таблиці символів\n\n### Опис\n\n```methodsynopsis\nextract(array &$array, int $flags = EXTR_OVERWRITE, string $prefix = \"\"): int\n```\n\nІмпортує змінні масиву до поточної таблиці символів.\n\nФункція перевіряє кожен ключ масиву, щоб побачити, чи він містить допустиме ім'я змінної. Буде також перевірено збіги (колізії) з існуючими змінними у таблиці символів.\n\n**Увага**\n\nНе викликайте функції **extract()** з ненадійними даними на кшталт введення користувача (наприклад, з суперглобальними змінними [$\\_GET](reserved.variables.get.md) [$\\_FILES](reserved.variables.files.md)\n\n### Список параметрів\n\n`array`\n\nАсоціативний масив. Функція трактує ключі масиву як імена змінних, а значення як значення змінних. Для кожної пари ключ/значення буде створено змінну в поточній таблиці символів з урахуванням прапорів (`flags`) та параметрів префікса (`prefix`\n\nБез прапорів **`EXTR_PREFIX_ALL`** або **`EXTR_PREFIX_INVALID`** функція працює лише з асоціативними масивами; індексний масив не дасть результатів.\n\n`flags`\n\nПараметр`flags` визначає спосіб трактування неправильних/числових ключів та колізій. Дозволено вказувати одне з наступних значень:\n\n**`EXTR_OVERWRITE`**\n\nЯкщо змінна з такою назвою існує, вона буде перезаписана.\n\n**`EXTR_SKIP`**\n\nЯкщо змінна з такою назвою існує, її поточне значення не буде перезаписано.\n\n**`EXTR_PREFIX_SAME`**\n\nЯкщо змінна з таким ім'ям існує, до її імені буде додано префікс, визначений параметром `prefix`\n\n**`EXTR_PREFIX_ALL`**\n\nДобавить префикс`prefix` до всіх імен змінних.\n\n**`EXTR_PREFIX_INVALID`**\n\nДобавить префикс`prefix` тільки до некоректних/числових імен змінних.\n\n**`EXTR_IF_EXISTS`**\n\nПерезаписати лише ті змінні, які містяться в поточній таблиці символів, інакше нічого не робити. Це корисно для визначення списку допустимих змінних і вилучення тільки тих, які розробник вже визначив, наприклад, з масиву на кшталт [$\\_REQUEST](reserved.variables.request.md)\n\n**`EXTR_PREFIX_IF_EXISTS`**\n\nСтворити лише префікс-версії змінних, якщо версія змінної без префікса вже міститься у поточній таблиці символів.\n\n**`EXTR_REFS`**\n\nВитягти змінні як посилання. Це фактично означає, що значення імпортованих змінних все ще посилатимуться на значення масиву `array`. Дозволено вказувати цей прапор окремо або комбінувати його з іншими значеннями параметра `flags`через побитовое «ИЛИ».\n\nЯкщо параметр `flags` не заданий, він трактується як прапор **`EXTR_OVERWRITE`**\n\n`prefix`\n\nЗверніть увагу, що префікс (`prefix`) потрібен, тільки якщо параметру `flags`установлено значение\\*\\*`EXTR_PREFIX_SAME`\\*\\* **`EXTR_PREFIX_ALL`** \\*\\*`EXTR_PREFIX_INVALID`** або **`EXTR_PREFIX_IF_EXISTS`\\*\\*Если в результате добавления префикса не будет получено допустимое имя переменной, она не будет импортирована в текущую таблицу символов.\n\n### Значення, що повертаються\n\nПовертає кількість змінних, успішно імпортованих до таблиці символів.\n\n### Приклади\n\n**Приклад #1 Приклад використання функції** extract()\\*\\*\\*\\*\n\nФункцию**extract()** також викликають для імпорту в таблицю символів змінних, що містяться в асоціативному масиві, що повертається функцією [wddx\\_deserialize()](function.wddx-deserialize.md)\n\n```php\n<?php\n\n/* Предположим, что переменная $var_array — это массив, который вернула\n   функция wddx_deserialize */\n\n$size = \"large\";\n$var_array = array(\n     \"color\" => \"blue\",\n     \"size\"  => \"medium\",\n     \"shape\" => \"sphere\"\n);\nextract($var_array, EXTR_PREFIX_SAME, \"wddx\");\n\necho \"$color, $size, $shape, $wddx_size\\n\";\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nblue, large, sphere, medium\n```\n\nЗмінна $size не була перезаписана, тому що було встановлено прапор \\*\\*`EXTR_PREFIX_SAME`\\*\\*тому була створена змінна $wddx\\_size. Якби був визначений прапор \\*\\*`EXTR_SKIP`\\*\\*тоді змінна $wddx\\_size не було б створено. Прапор **`EXTR_OVERWRITE`** привів би до того, що змінною $size було б надано значення «medium», а прапор **`EXTR_PREFIX_ALL`** був би причиною того, що були б створені змінні $wddx\\_color, $wddx\\_size та $wddx\\_shape.\n\n### Примітки\n\n**Увага**\n\nНе варто викликати функцію **extract()** з ненадійними даними на кшталт введення користувача (наприклад, з суперглобальними змінними [$\\_GET](reserved.variables.get.md) [$\\_FILES](reserved.variables.files.md)). Коли це таки роблять, перевіряють, що значення параметра `flags` задано неперезаписуючим прапором на кшталт **`EXTR_SKIP`**, і пам'ятають, що змінні потрібно витягувати в тому самому порядку, який визначений у директиві [variables\\_order](ini.core.md#ini.variables-order)файла[php.ini](ini.md)\n\n### Дивіться також\n\n-   [compact()](function.compact.md) \\- Створює масив, що містить назви змінних та їх значення\n-   [list()](function.list.md) \\- надає змінним значення схожим на масиви синтаксисом\n","title":"extract","contentType":2,"navigation":[{"function.end.md":"« end"},{"function.in-array.md":"in\\_array »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}