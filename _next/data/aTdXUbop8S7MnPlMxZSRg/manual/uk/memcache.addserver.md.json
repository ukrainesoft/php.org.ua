{"pageProps":{"page":{"slug":"memcache.addserver.md","content":"# Memcache::addServer\n\n(PECL memcache >= 2.0.0)\n\nMemcache::addServer — Додає сервер memcached у пул з'єднань\n\n### Опис\n\n```methodsynopsis\nMemcache::addServer(    string $host,    int $port = 11211,    bool $persistent = ?,    int $weight = ?,    int $timeout = ?,    int $retry_interval = ?,    bool $status = ?,    callable $failure_callback = ?,    int $timeoutms = ?): bool\n```\n\n**Memcache::addServer()** додає сервер до пулу з'єднань. Ви також можете використати функцію **memcache\\_add\\_server()**\n\nПри використанні цього методу (на відміну від [Memcache::connect()](memcache.connect.md) і [Memcache::pconnect()](memcache.pconnect.md)) мережне з'єднання не буде встановлено, поки в ньому не виникне потреба. У зв'язку з цим можна не побоюватися зниження продуктивності при додаванні великої кількості серверів до пулу, оскільки, можливо, вони ніколи не будуть використані.\n\nПотреба у забезпеченні стійкості до відмови може виникнути на будь-якому етапі в будь-якому методі і якщо при цьому будуть доступні хоча б один сервер з пулу - користувач не отримає будь-якого оповіщення. Будь-який тип помилки сокету або сервера Memcached (за винятком помилки переповнення пам'яті) може увімкнути протокол забезпечення відмовостійкості. Звичайні клієнтські помилки, такі як додавання існуючого ключа, не викликають такої поведінки.\n\n> **Зауваження** :\n> \n> Ця функція була додана до Memcache версії 2.0.0.\n\n### Список параметрів\n\n`host`\n\nВказує на хост із запущеним сервісом memcached. Цей параметр можна встановити як `unix:///path/to/memcached.sock`для использования сокетов Unix, но в таком случае будет необходимо установить параметр`port`, рівним\n\n`port`\n\nВказує порт, яким доступний сервіс memcached. Необхідно встановити рівним якщо використовуються сокети Unix.\n\nПожалуйста обратите внимание:`port`по умолчанию равен[memcache.default\\_port](memcache.ini.md#ini.memcache.default-port). Тому рекомендується завжди вказувати номер порту під час використання цього методу.\n\n`persistent`\n\nЧи використовувати постійне з'єднання. За замовчуванням **`true`**\n\n`weight`\n\nНеобхідна кількість створених пакетів даних для цього сервера, що, своєю чергою, визначає можливість його вибору. Імовірність розраховується щодо загальної ваги всіх серверів.\n\n`timeout`\n\nЧас очікування в секундах для встановлення з'єднання із сервером. Двічі подумайте, перш ніж встановлювати це значення більше ніж 1. Це може нівелювати всю користь від використання memcached.\n\n`retry_interval`\n\nКерує частотою перевірки доступності сервера, що відмовив, за замовчуванням 15 секунд. Якщо встановити значення \"-1\", то спроб перевірити доступність сервера робитися не буде. Ні цей параметр, ні параметр `persistent` не впливають, якщо модуль завантажений динамічно через функцію [dl()](function.dl.md)\n\nКожна структура з'єднання, що провалилася, має власне значення часу очікування і, поки воно не перевищено, структура буде пропущена, після чого спробує вибрати інший сервер для обслуговування запиту. Після того як час з'єднання закінчився, воно або вдало переєднається, або буде позначено проваленим і чекатиме ще `retry_interval` секунд. Зазвичай ефект полягає в тому, що кожен процес веб-сервера буде очікувати `retry_interval`секунд при обслуживании запроса.\n\n`status`\n\nВизначає, чи сервер позначений прапором як \"онлайн\". Встановлення цього параметра \\*\\*`false`**и`retry_interval` -1 дозволить зберегти сервер в пулі, але не використовувати його в алгоритмі розподілу ключів. Запит до цього сервера або запустить механізм забезпечення стійкості до відмов, або відразу ж перерветься з помилкою, залежно від налаштування `memcache.allow_failover`По умолчанию равно**`true`\\*\\*що означає, що сервер активний і готовий приймати запити.\n\n`failure_callback`\n\nДозволяє користувачеві встановити функцію зворотного дзвінка, яка запуститься у разі будь-якої помилки. Ця функція буде викликана раніше, ніж буде запущено механізм забезпечення стійкості до відмови. Функція приймає два параметри - ім'я хоста і порт сервера, що відмовив.\n\n`timeoutms`\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** Memcache::addServer()\\*\\*\\*\\*\n\n```php\n<?php\n\n/* объектно-ориентированное API */\n\n$memcache = new Memcache;\n$memcache->addServer('memcache_host', 11211);\n$memcache->addServer('memcache_host2', 11211);\n\n/* процедурное API */\n\n$memcache_obj = memcache_connect('memcache_host', 11211);\nmemcache_add_server($memcache_obj, 'memcache_host2', 11211);\n\n?>\n```\n\n### Примітки\n\n**Увага**\n\nКогда значение`port` не вказано, цей метод використовує значення, вказане в ini-директиві PHP [memcache.default\\_port](memcache.ini.md#ini.memcache.default-port). Якщо це значення було змінено десь у вашому додатку, це може дати непередбачувані результати. Тому краще завжди явно вказувати порт при виклику методу.\n\n### Дивіться також\n\n-   [Memcache::connect()](memcache.connect.md) \\- Відкриває з'єднання з сервером memcached\n-   [Memcache::pconnect()](memcache.pconnect.md) \\- Відкриває постійне з'єднання з сервером memcached\n-   [Memcache::close()](memcache.close.md) \\- Закрити з'єднання з сервером memcached\n-   [Memcache::setServerParams()](memcache.setserverparams.md) \\- Змінює параметри сервера та статус під час виконання\n-   [Memcache::getServerStatus()](memcache.getserverstatus.md) \\- Повертає статус сервера\n","title":"Memcache::addServer","contentType":2,"navigation":[{"memcache.add.md":"« Memcache::add"},{"memcache.close.md":"Memcache::close »"},{"index.md":"PHP Manual"},{"class.memcache.md":"Memcache"}]}},"__N_SSG":true}