{"pageProps":{"page":{"slug":"migration56.openssl.md","content":"## Зміни OpenSSL у PHP 5.6.x\n\n### Обгортки потоків тепер за промовчанням перевіряють сертифікати вузлів та імена хостів під час використання SSL/TLS\n\nВсі клієнтські потоки, що шифруються, тепер за замовчуванням включають перевірку бенкетів. За замовчуванням сертифікат бенкету перевіряється пакетом OpenSSL CA. Зазвичай нічого не потрібно робити для з'єднання з серверами з правильним SSL-сертифікатом, оскільки OpenSSL налаштований так, що вже працює з хорошими CA-пакетами.\n\nСтандартний CA пакет може бути перевизначений глобально за допомогою установки або openssl.cafile або openssl.capath рядків конфігурації, або ж на рівні кожного запиту, використовуючи опції контексту [`cafile`](context.ssl.md#context.ssl.cafile) або [`capath`](context.ssl.md#context.ssl.capath)\n\nХоча це і не рекомендується, але можна вимкнути перевірку сертифіката бенкету для запиту, встановивши [`verify_peer`](context.ssl.md#context.ssl.verify-peer)опцию контекста в\\*\\*`false`**, і можна вимкнути перевірку імені бенкету, встановивши [`verify_peer_name`](context.ssl.md#context.ssl.verify-peer-name)в**`false`\\*\\*\n\n### Сигнатура сертифіката\n\nБуло додано підтримку вилучення та перевірки сигнатури сертифіката. Для отримання сигнатур сертифікатів X.509 додано функцію [openssl\\_x509\\_fingerprint()](function.openssl-x509-fingerprint.md). Також було додано дві опції [контексту потоку SSL](context.ssl.md) `capture_peer_cert`для захвата узлового сертификата X.509, и`peer_fingerprint`для проверки сертификата на соответствие заданной сигнатуре.\n\n### Оновлено шифри за замовчуванням\n\nСписок стандартних шифрів, що використовуються PHP, був оновлений на більш безпечний відповідно до [»  рекомендаціями щодо шифрів від Mozilla](https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_Ciphersuite), з двома додатковими винятками: анонімні шифри Діффі-Хеллмана та RC4.\n\nЦей список доступний через нову константу **`OPENSSL_DEFAULT_STREAM_CIPHERS`**, і може бути перевизначений (як і в попередніх версіях PHP) установкою опцією контексту [`ciphers`](context.ssl.md#context.ssl.ciphers)\n\n### Стиснення заборонено за умовчанням\n\nСтиснення SSL/TLS було заборонено за замовчуванням для зменшення зменшення ймовірності атаки типу CRIME. У PHP 5.4.13 було додано опцію контексту [`disable_compression`](context.ssl.md#context.ssl.disable-compression) для можливості заборонити компресію і тепер вона за умовчанням встановлена ​​як **`true`** (тобто компресію заборонено).\n\n### Дозвіл серверу визначати свій власний порядок шифрів\n\nДодано опцію контексту `honor_cipher_order`, яка дозволяє серверу, що обслуговує зашифрований потік, самому визначати шифри, якими буде користуватися клієнт. Це дозволить знизити ризик атаки типу BEAST.\n\n### Доступ до узгодженого протоколу та шифру\n\nПротокол та шифр, узгоджені для шифрованого потоку, доступні за допомогою функцій [stream\\_get\\_meta\\_data()](function.stream-get-meta-data.md) або [stream\\_context\\_get\\_options()](function.stream-context-get-options.md), если опция контекста SSL`capture_session_meta`установлена как\\*\\*`true`\\*\\*\n\n```php\n<?php\n$ctx = stream_context_create(['ssl' => [\n    'capture_session_meta' => TRUE\n]]);\n\n$html = file_get_contents('https://google.com/', FALSE, $ctx);\n$meta = stream_context_get_options($ctx)['ssl']['session_meta'];\nvar_dump($meta);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(4) {\n  [\"protocol\"]=>\n  string(5) \"TLSv1\"\n  [\"cipher_name\"]=>\n  string(20) \"ECDHE-RSA-AES128-SHA\"\n  [\"cipher_bits\"]=>\n  int(128)\n  [\"cipher_version\"]=>\n  string(11) \"TLSv1/SSLv3\"\n}\n```\n\n### Нові можливості для досконалої прямої секретності (PFS) для серверів, які обслуговують шифровані потоки\n\nШифровані потоки клієнта вже підтримують пряму таємність, оскільки вона, як правило, контролюється сервером. Сервери PHP, що обслуговують шифровані потоки, використовують сертифікати підтримують досконалу пряму секретність не потребують будь-яких додаткових дій для включення PFS; однак, було додано кілька нових опцій контексту SSL для більш точного контролю над PFS та для вирішення можливих проблем.\n\n`ecdh_curve`\n\nЦя опція дозволяє вибрати криву для використання у шифрах ECDH. Якщо не задано, то використовуватиметься `prime256v1`\n\n`dh_param`\n\nШлях до файлу, що містить параметри для обміну ключами Діффі-Хеллмана, створеного, наприклад, за допомогою такої команди:\n\nopenssl dhparam -out /path/to/my/certs/dh-2048.pem 2048\n\n`single_dh_use`\n\nЕсли установлено как\\*\\*`true`\\*\\*, нова пара ключів буде створена, використовуючи параметри Діффі-Хеллмана, тим самим покращуючи пряму таємність.\n\n`single_ecdh_use`\n\nЕсли установлено как\\*\\*`true`\\*\\*, нова пара ключів буде генеруватися завжди, за узгодженням шифру ECDH. Це покращує пряму таємність.\n\n### Вибір версії SSL/TLS\n\nТепер можна вибирати конкретну версію SSL та TLS за допомогою опції контексту `crypto_method` або вказуючи конкретний транспорт під час створення обгортки потоку (наприклад, за допомогою виклику [stream\\_socket\\_client()](function.stream-socket-client.md) або [stream\\_socket\\_server()](function.stream-socket-server.md)\n\nОпция контекста SSL`crypto_method` приймає бітову маску, що перераховує допустимі протоколи, як і задається в параметрі `crypto_type` функції [stream\\_socket\\_enable\\_crypto()](function.stream-socket-enable-crypto.md)\n\n**Вибрана версія протоколу та відповідні опції**\n\n| Протокол | Флаг клиента | Флаг сервера | Транспорт |\n| --- | --- | --- | --- |\n| Будь-які версії TLS або SSL | **`STREAM_CRYPTO_METHOD_ANY_CLIENT`** | **`STREAM_CRYPTO_METHOD_ANY_SERVER`** | `ssl://` |\n| Будь-яка версія TLS | **`STREAM_CRYPTO_METHOD_TLS_CLIENT`** | **`STREAM_CRYPTO_METHOD_TLS_SERVER`** | `tls://` |\n| TLS 1.0 | **`STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT`** | **`STREAM_CRYPTO_METHOD_TLSv1_0_SERVER`** | `tlsv1.0://` |\n| TLS 1.1 | **`STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT`** | **`STREAM_CRYPTO_METHOD_TLSv1_1_SERVER`** | `tlsv1.1://` |\n| TLS 1.2 | **`STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT`** | **`STREAM_CRYPTO_METHOD_TLSv1_2_SERVER`** | `tlsv1.2://` |\n| SSL 3 | **`STREAM_CRYPTO_METHOD_SSLv3_CLIENT`** | **`STREAM_CRYPTO_METHOD_SSLv3_SERVER`** | `sslv3://` |\n\n```php\n<?php\n\n// Требуется TLS 1.0 или выше для использования file_get_contents():\n$ctx = stream_context_create([\n    'ssl' => [\n        'crypto_method' => STREAM_CRYPTO_METHOD_TLS_CLIENT,\n    ],\n]);\n$html = file_get_contents('https://google.com/', false, $ctx);\n\n// Требуется TLS 1.1 или 1.2:\n$ctx = stream_context_create([\n    'ssl' => [\n        'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT |\n                           STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,\n    ],\n]);\n$html = file_get_contents('https://google.com/', false, $ctx);\n\n// Соединяемся с использованием транспорта потокового сокета tlsv1.2://\n$sock = stream_socket_client('tlsv1.2://google.com:443/');\n\n?>\n```\n\n### Добавлена функция[openssl\\_get\\_cert\\_locations()](function.openssl-get-cert-locations.md)\n\nБула додана функція [openssl\\_get\\_cert\\_locations()](function.openssl-get-cert-locations.md): вона повертає розташування, в яких PHP шукатиме пакети CA за замовчуванням.\n\n```php\n<?php\nvar_dump(openssl_get_cert_locations());\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(8) {\n  [\"default_cert_file\"]=>\n  string(21) \"/etc/pki/tls/cert.pem\"\n  [\"default_cert_file_env\"]=>\n  string(13) \"SSL_CERT_FILE\"\n  [\"default_cert_dir\"]=>\n  string(18) \"/etc/pki/tls/certs\"\n  [\"default_cert_dir_env\"]=>\n  string(12) \"SSL_CERT_DIR\"\n  [\"default_private_dir\"]=>\n  string(20) \"/etc/pki/tls/private\"\n  [\"default_default_cert_area\"]=>\n  string(12) \"/etc/pki/tls\"\n  [\"ini_cafile\"]=>\n  string(0) \"\"\n  [\"ini_capath\"]=>\n  string(0) \"\"\n}\n```\n\n### Підтримка SPKI\n\nБуло додано підтримку для створення, вилучення та перевірки підписаних публічних ключів та розпізнавальних рядків (SPKAC). Були додані функції [openssl\\_spki\\_new()](function.openssl-spki-new.md) [openssl\\_spki\\_verify()](function.openssl-spki-verify.md) [openssl\\_spki\\_export\\_challenge()](function.openssl-spki-export-challenge.md) і [openssl\\_spki\\_export()](function.openssl-spki-export.md) для створення, перевірки експорту PEM публічних ключів та відповідних розпізнавальних рядків із SPKAC, створених з елементів HTML5 `KeyGen`\n\n`openssl_spki_new`\n\nГенерація нового SPKAC з використанням приватного ключа, розпізнавального рядка та алгоритму хешування.\n\n```php\n<?php\n$pkey = openssl_pkey_new();\nopenssl_pkey_export($pkey, 'secret passphrase');\n\n$spkac = openssl_spki_new($pkey, 'challenge string');\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nSPKAC=MIIBXjCByDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA3L0IfUijj7+A8CPC8EmhcdNoe5fUAog7OrBdhn7EkxFButUp40P7+LiYiygYG1TmoI/a5EgsLU3s9twEz3hmgY9mYIqb/rb+SF8qlD/K6KVyUORC7Wlz1Df4L8O3DuRGzx6/+3jIW6cPBpfgH1sVuYS1vDBsP/gMMIxwTsKJ4P0CAwEAARYkYjViMzYxMTktNjY5YS00ZDljLWEyYzctMGZjNGFhMjVlMmE2MA0GCSqGSIb3DQEBAwUAA4GBAF7hu0ifzmjonhAak2FhhBRsKFDzXdKIkrWxVNe8e0bZzMrWOxFM/rqBgeH3/gtOUDRS5Fnzyq425UsTYbjfiKzxGeCYCQJb1KJ2V5Ij/mIJHZr53WYEXHQTNMGR8RPm7IxwVXVSHIgAfXsXZ9IXNbFbcaLRiSTr9/N4U+MXUWL7\n```\n\n`openssl_spki_verify`\n\nПеревірка наданого SPKAC.\n\n```php\n<?php\n$pkey = openssl_pkey_new();\nopenssl_pkey_export($pkey, 'secret passphrase');\n\n$spkac = openssl_spki_new($pkey, 'challenge string');\nvar_dump(openssl_spki_verify($spkac));\n?>\n```\n\n`openssl_spki_export_challenge`\n\nЕкспорт пов'язаного розпізнавального рядка із наданого SPKAC.\n\n```php\n<?php\n$pkey = openssl_pkey_new();\nopenssl_pkey_export($pkey, 'secret passphrase');\n\n$spkac = openssl_spki_new($pkey, 'challenge string');\n$challenge = openssl_spki_export_challenge($spkac);\necho $challenge;\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nchallenge string\n```\n\n`openssl_spki_export`\n\nЕкспорт публічного ключа (PEM) RSA у форматі SPKAC.\n\n```php\n<?php\n$pkey = openssl_pkey_new();\nopenssl_pkey_export($pkey, 'secret passphrase');\n\n$spkac = openssl_spki_new($pkey, 'challenge string');\necho openssl_spki_export($spkac);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcvQh9SKOPv4DwI8LwSaFx02h7\nl9QCiDs6sF2GfsSTEUG61SnjQ/v4uJiLKBgbVOagj9rkSCwtTez23ATPeGaBj2Zg\nipv+tv5IXyqUP8ropXJQ5ELtbXPUN/gvw7cO5EbPHr/7eMhbpw8Gl+AfWxW5hLW8\nMGw/+AwwjHBOwong/QIDAQAB\n-----END PUBLIC KEY-----\n```\n","title":"Зміни OpenSSL у PHP 5.6.x","contentType":2,"navigation":[{"migration56.new-functions.md":"« Нові функції"},{"migration56.extensions.md":"Інші зміни у модулях »"},{"index.md":"PHP Manual"},{"migration56.md":"Міграція з PHP 5.5.x на PHP 5.6.x"}]}},"__N_SSG":true}