{"pageProps":{"page":{"slug":"ev.periodic-modes.md","content":"# Режими роботи періодичних спостерігачів\n\nСпостерігачі [EvPeriodic](class.evperiodic.md) працюють у різних режимах залежно від значення параметрів `offset` `interval`и`reschedule_cb`\n\n1.  *Абсолютний таймер*. У цьому режимі`interval` `reschedule_cb` **`null`**. Таймер просто спрацює один раз у задане в`offset`час. Він не компенсує стрибки часу і якщо вказано спрацювати в*1 Січня 2014*, то він спрацює коли системний час дорівнюватиме або більше цього значення.\n    \n2.  *Таймер із фіксованим інтервалом*. У цьому режимі`interval` > , а`reschedule_cb` **`null`**. Кожне подальше спрацювання буде рівно через`offset` **`N`** \\* `interval`(де\\*\\*`N`\\*\\*- ціле число), незважаючи на стрибки часу.\n    \n    Це можна використовувати для створення таймерів, які не розходяться із системним часом:\n    \n    ```php\n    <?php\n    $hourly = EvPeriodic(0, 3600, NULL, function () {\n      echo \"один раз на годину\\n\";\n    });\n    ?>\n    ```\n    \n    Це не означає, що між спрацюваннями завжди буде рівно\\*\\*`3600`\\*\\*секунд. Це означає, що callback-функція буде викликана тільки коли системний годинник покаже повну годину (*UTC*\n    \n    У цьому режимі,[EvPeriodic](class.evperiodic.md)буде намагатися запустити callback-функцію в наступний доступний час, коли time =`offset` `mod` `interval`), незалежно від стрибків часу.\n    \n3.  *Режим ручного перевизначення часу спрацьовування*. У цьому режимі`reschedule_cb`є коректним параметром типу[callable](language.types.callable.md)\n    \n    `interval`и`offset`ігноруються. Натомість, при кожному спрацьовуванні, спостерігач запускає callback-функцію (`reschedule_cb`) з двома аргументами, посиланням на спостерігача та часом.\n    \n    Ця callback-функція ніколи*не повинна*зупиняти або знищувати цей або будь-який інший періодичний спостерігач і*не повинна*викликати функції та методи подієвого циклу. Для зупинки можна повернути дуже велику кількість, наприклад,\\*\\*`1e30`\\*\\*і зупинити спостерігач за межами цієї функції. Для цього можна використати спостерігачів[EvPrepare](class.evprepare.md)\n    \n    Ця функція повинна повернути наступний час спрацьовування, ґрунтуючись на переданому значенні часу (тобто найменше значення часу більше або дорівнює другому аргументу). Зазвичай вона викликається перед тим, як буде викликана основна callback-функція спостерігача, але може пізніше.\n    \n    **Приклад #1 Використання спостерігача з ручним перевизначенням часу спрацьовування**\n    \n    ```php\n    <?php\n    // Спрацьовувати кожні 10.5 секунд\n    \n    function reschedule_cb ($watcher, $now) {\n       return $now + (10.5. - fmod($now, 10.5));\n    }\n    \n    $w = new EvPeriodic(0., 0., \"reschedule_cb\", function ($w, $revents) {\n       echo time(), PHP_EOL;\n    });\n    \n    Ev:: run ();\n    ?>\n    ```\n","title":"Режими роботи періодичних спостерігачів","contentType":2,"navigation":[{"ev.watcher-callbacks.md":"« Watcher callbacks"},{"class.ev.md":"Ev »"},{"index.md":"PHP Manual"},{"book.ev.md":"Ev"}]}},"__N_SSG":true}