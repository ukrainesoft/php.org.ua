{"pageProps":{"page":{"slug":"class.recursivecallbackfilteriterator.md","content":"# Клас RecursiveCallbackFilterIterator\n\n(PHP 5 >= 5.4.0, PHP 7, PHP 8)\n\n## Вступ\n\n## Огляд класів\n\n```classsynopsis\n\n    \n     class RecursiveCallbackFilterIterator\n    \n\n    \n     extends\n      CallbackFilterIterator\n    \n\n    \n     implements\n      RecursiveIterator {\n\n    /* Методы */\n    \n   public __construct(RecursiveIterator $iterator, callable $callback)\n\n    public getChildren(): RecursiveCallbackFilterIterator\npublic hasChildren(): bool\n\n\n    /* Наследуемые методы */\n    public CallbackFilterIterator::accept(): bool\n\n    public FilterIterator::accept(): bool\npublic FilterIterator::current(): mixed\npublic FilterIterator::key(): mixed\npublic FilterIterator::next(): void\npublic FilterIterator::rewind(): void\npublic FilterIterator::valid(): bool\n\n    public IteratorIterator::current(): mixed\npublic IteratorIterator::getInnerIterator(): ?Iterator\npublic IteratorIterator::key(): mixed\npublic IteratorIterator::next(): void\npublic IteratorIterator::rewind(): void\npublic IteratorIterator::valid(): bool\n\n   }\n```\n\n## Приклади\n\nCallback-функція може приймати до трьох аргументів: поточний елемент, поточний ключ та ітератор відповідно.\n\n**Приклад #1 Доступні аргументи callback-функції**\n\n```php\n<?php\n\n/**\n * Callback-функция для RecursiveCallbackFilterIterator\n *\n * @param $current   Значение текущего элемента\n * @param $key       Ключ текущего элемента\n * @param $iterator  Итератор, который фильтруется\n * @return boolean   TRUE для приёма текущего элемента или FALSE - в ином случае.\n */\nfunction my_callback($current, $key, $iterator) {\n    // Здесь ваш код фильтрации\n}\n\n?>\n```\n\nФільтрація рекурсивного ітератора зазвичай включає дві умови. Перше у тому, щоб дозволити рекурсію. Callback-функція має повертати \\*\\*`true`\\*\\*якщо поточний елемент ітератора має нащадків. Друге - це нормальна умова фільтра, наприклад, перевірка розміру файлу чи розширення, як у наведеному нижче прикладі.\n\n**Приклад #2 Простий приклад рекурсивного зворотного виклику**\n\n```php\n<?php\n\n$dir = new RecursiveDirectoryIterator(__DIR__);\n\n// Фильтр больших файлов ( > 100MB)\n$files = new RecursiveCallbackFilterIterator($dir, function ($current, $key, $iterator) {\n    // Разрешить рекурсию\n    if ($iterator->hasChildren()) {\n        return TRUE;\n    }\n    // Проверка больших файлов\n    if ($current->isFile() && $current->getSize() > 104857600) {\n        return TRUE;\n    }\n    return FALSE;\n});\n\nforeach (new RecursiveIteratorIterator($files) as $file) {\n    echo $file->getPathname() . PHP_EOL;\n}\n\n?>\n```\n\n## Зміст\n\n-   [RecursiveCallbackFilterIterator::\\_\\_construct](recursivecallbackfilteriterator.construct.md)— Створює об'єкт класу RecursiveCallbackFilterIterator на основі об'єкта RecursiveIterator\n-   [RecursiveCallbackFilterIterator::getChildren](recursivecallbackfilteriterator.getchildren.md)— Повертає дочірні елементи ітератора, що зберігається всередині RecursiveCallbackFilterIterator\n-   [RecursiveCallbackFilterIterator::hasChildren](recursivecallbackfilteriterator.haschildren.md)— Перевіряє, чи поточний елемент внутрішнього ітератора містить дочірні елементи.\n","title":"Клас RecursiveCallbackFilterIterator","contentType":2,"navigation":[{"recursivecachingiterator.haschildren.md":"« RecursiveCachingIterator::hasChildren"},{"recursivecallbackfilteriterator.construct.md":"RecursiveCallbackFilterIterator::\\_\\_construct »"},{"index.md":"PHP Manual"},{"spl.iterators.md":"Ітератори"}]}},"__N_SSG":true}