{"pageProps":{"page":{"slug":"mysqlnd.plugin.architecture.md","content":"## Архитектура плагинов MySQL Native Driver\n\nУ цій секції розглянуто архітектуру плагінів.`mysqlnd`\n\n**Поверхневий огляд MySQL Native Driver**\n\nПеред початком розробки плагінів`mysqlnd`, корисно ознайомитись, як сам по собі організований`mysqlnd`. . `Mysqlnd`складається з наступних модулів:\n\n**Організаційна схема mysqlnd, помодульно**\n\n| Модули статистики | mysqlnd\\_statistics.c |\n| --- | --- |\n| З'єднання | mysqlnd.c |\n| Результуючий набір | mysqlnd\\_result.c |\n| Метадані результуючого набору | mysqlnd\\_result\\_meta.c |\n| Оператор | mysqlnd\\_ps.c |\n| Мережа | mysqlnd\\_net.c |\n| Протокол обміну | mysqlnd\\_wireprotocol.c |\n\n**Об'єктно-орієнтована парадигма C**\n\nНа рівні коду,`mysqlnd`використовує патерн для реалізації об'єктно-орієнтованого підходу.\n\nУ C об'єкти описують використовуючи`struct`. Члени структури є властивостями об'єкта. Члени структури, що вказують на функції, є способами.\n\nНа відміну від мов як C++ чи Java, в C немає фіксованих правил успадкування. Однак існують деякі домовленості, які слід слідувати, але це ми обговоримо пізніше.\n\n**Життєвий цикл PHP**\n\nПри розгляді життєвого циклу PHP існує два основні цикли:\n\n-   Цикл старту та зупинки двигуна PHP\n    \n-   Цикл обробки запиту\n    \n\nПри старті двигуна PHP, перш за все викликається функція ініціалізації модулів (MINIT) для кожного зареєстрованого модуля. Це дозволяє кожному модулю встановити змінні та виділити ресурси, які будуть задіяні весь час життя процесу движка PHP. Коли PHP вимикається, він викликає функцію зупинки модулів (MSHUTDOWN) для кожного модуля.\n\nПротягом життєвого циклу двигуна PHP, він приймає кілька запитів. Кожен запит породжує новий цикл життя. На кожен запит, PHP двигун викликає функцію ініціалізації для кожного модуля. Модуль може зробити виставлення змінних та виділення ресурсів, необхідних обслуговування запиту. Після закінчення життя запиту, двигун викликає функцію зупинки запиту (RSHUTDOWN) для кожного модуля, що дозволяє зробити необхідні чистки.\n\n**Як працює плагін**\n\nПлагин`mysqlnd`працює перехоплюючи виклики модулів, які використовують`mysqlnd`, до`mysqlnd`. Це досягається заміною таблиці функцій`mysqlnd`на створену плагіном.\n\nНаступний код показує заміну таблиці функцій`mysqlnd` :\n\n```\n/* хранилище оригинальной таблицы */\nstruct st_mysqlnd_conn_methods org_methods;\n\nvoid minit_register_hooks(TSRMLS_D) {\n  /* активная таблица функций */\n  struct st_mysqlnd_conn_methods * current_methods\n    = mysqlnd_conn_get_methods();\n\n  /* бэкап оригинальной таблицы */\n  memcpy(&org_methods, current_methods,\n    sizeof(struct st_mysqlnd_conn_methods);\n\n  /* установка новых методов */\n  current_methods->query = MYSQLND_METHOD(my_conn_class, query);\n}\n```\n\nМаніпуляцією з таблицею функцій з'єднання необхідно проводити етапі ініціалізації модуля (MINIT). Таблиця функцій - це глобальний ресурс, що розділяється. У багатопотоковому оточенні, зі складанням TSRM, маніпуляція глобальним ресурсом, що розділяється, на етапі обробки запиту призведе до конфліктів.\n\n> **Зауваження** :\n> \n> Не використовуйте будь-яку логіку, пов'язану з фіксованим розміром при маніпуляції з таблицею функцій`mysqlnd`. Завжди додавайте нові методи до кінця таблиці, оскільки сама таблиця може у майбутньому будь-якої миті змінитися.\n\n**Виклик батьківських методів**\n\nЯкщо записи оригінальної таблиці функцій були збережені, завжди залишається можливість викликати оригінальний метод - батьківський.\n\nУ деяких випадках, наприклад, для`Connection::stmt_init()`, життєво важливо спочатку викликати батьківський метод, і лише потім робити щось у новому методі.\n\n```\nMYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,\n  const char *query, unsigned int query_len TSRMLS_DC) {\n\n  php_printf(\"my_conn_class::query(query = %s)\\n\", query);\n\n  query = \"SELECT 'query rewritten' FROM DUAL\";\n  query_len = strlen(query);\n\n  return org_methods.query(conn, query, query_len); /* возврат с вызовом родителя */\n}\n```\n\n**Розширення властивостей**\n\nОб'єкти `mysqlnd`представлені як C struct. Неможливо додати члена до C struct під час виконання. Користувачі об'єктів`mysqlnd`не можуть просто додати властивості об'єкту.\n\nДовільні дані (властивості) можуть бути додані до об'єкту`mysqlnd`з використанням відповідної функції із сімейства`mysqlnd_plugin_get_plugin_<object>_data()`. При розміщенні об'єкту`mysqlnd`резервується місце наприкінці об'єкта для утримання`void *` указателя на произвольные данные . `mysqlnd`резервує місце для одного`void *`вказівник на плагін.\n\nУ наступній таблиці показано, як визначити положення покажчика для конкретного плагіна:\n\n**Розрахунок покажчика для mysqlnd**\n\n| Адрес памяти | Содержимое |\n| --- | --- |\n|  | Початок об'єкту mysqlnd (C struct) |\n| n | Кінець об'єкта mysqlnd (C struct) |\n| n + (m x sizeof(void\\*)) | void\\* для даних об'єкта плагіна номер m |\n\nЯкщо ви плануєте робити підклас від одного з конструкторів об'єкту`mysqlnd`, які дозволені, майте це на увазі!\n\nНаступний код демонструє розширення властивостей:\n\n```\n/* Любые данные, которые мы хотим добавить */\ntypedef struct my_conn_properties {\n  unsigned long query_counter;\n} MY_CONN_PROPERTIES;\n\n/* идентификатор плагина */\nunsigned int my_plugin_id;\n\nvoid minit_register_hooks(TSRMLS_D) {\n  /* получаем уникальный идентификатор плагина */\n  my_plugin_id = mysqlnd_plugin_register();\n  /* snip - see Extending Connection: methods */\n}\n\nstatic MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {\n  MY_CONN_PROPERTIES** props;\n  props = (MY_CONN_PROPERTIES**)mysqlnd_plugin_get_plugin_connection_data(\n    conn, my_plugin_id);\n  if (!props || !(*props)) {\n    *props = mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);\n    (*props)->query_counter = 0;\n  }\n  return props;\n}\n```\n\nРозробник плагіна відповідає за керування пам'яттю даних плагіна.\n\nРекомендується використовувати керування пам'яттю`mysqlnd`для даних плагіна. Ці функції називаються використовуючи такі угоди:`mnd_*loc()`. Управління пам'яттю`mysqlnd`має ряд корисних властивостей, таких як використання налагоджувального модуля управління пам'яттю в неналагоджувальних зборках.\n\n**Коли і як створювати підклас**\n\n|  | Когда создавать подкласс? | Каждый экземпляр имеет свою собственную таблицу функций? | Как создавать подкласс? |\n| --- | --- | --- | --- |\n| З'єднання (MYSQLND) | MINIT | Ні | mysqlnd\\_conn\\_get\\_methods() |\n| Результуючий набір (MYSQLND\\_RES) | MINIT or later | Так | mysqlnd\\_result\\_get\\_methods() або методом об'єкта, що маніпулює таблицею функцій |\n| Результуючий набір (MYSQLND\\_RES\\_METADATA) | MINIT | Ні | mysqlnd\\_result\\_metadata\\_get\\_methods() |\n| Оператор (MYSQLND\\_STMT) | MINIT | Ні | mysqlnd\\_stmt\\_get\\_methods() |\n| Мережа (MYSQLND\\_NET) | MINIT чи пізніше | Так | mysqlnd\\_net\\_get\\_methods() або методом об'єкта, що маніпулює таблицею функцій |\n| Протокол обміну (MYSQLND\\_PROTOCOL) | MINIT чи пізніше | Так | mysqlnd\\_protocol\\_get\\_methods() або методом об'єкта, що маніпулює таблицею функцій |\n\nВи не повинні маніпулювати таблицею функцій після MINIT, якщо це не дозволено в таблиці вище.\n\nДеякі класи містять покажчик таблицю функцій методів. Всі екземпляри подібних класів повинні ділити одну й ту саму таблицю функцій. Щоб уникнути хаосу, особливо у багатопотоковому оточенні, керувати такими таблицями функцій варто лише під час MINIT.\n\nІнші класи використовують копії глобально поділених таблиць функцій. Таблиця функцій створюється одночасно з об'єктом. Кожен об'єкт використовує таблицю. Це дає вам дві можливості: ви можете керувати таблицею функцій за промовчанням для об'єкта під час MINIT, а також ви можете змінювати методи об'єкта, не торкаючись інших екземплярів цього ж класу.\n\nПеревага таблиці функцій, що розділяється, у продуктивності, оскільки немає потреби копіювати таблицю функцій окремо для кожного об'єкта.\n\n**Статус конструктора**\n\n| Тип | Размещение, создание, сброс | Может быть изменено? | Вызывающий |\n| --- | --- | --- | --- |\n| Connection (MYSQLND) | mysqlnd\\_init() | Ні | mysqlnd\\_connect() |\n| Результуючий набір (MYSQLND\\_RES) |  |  |  |\n| Розміщення: |  |  |  |\n\n-   Connection::result\\_init()\n\nСкидання та повторна ініціалізація під час:\n\n-   Result::use\\_result()\n    \n-   Result::store\\_result\n    \n\n| Так, але викличте батька! |\n\n-   Connection::list\\_fields()\n    \n-   Statement::get\\_result()\n    \n-   Statement::prepare() (Тільки метадані)\n    \n-   Statement::resultMetaData()\n    \n\n| | Методи результуючого набору (MYSQLND\\_RES\\_METADATA) | Connection::result\\_meta\\_init() | Так, але викличте батька! | Result::read\\_result\\_metadata() | | Оператор (MYSQLND\\_STMT) | Connection::stmt\\_init() | Так, але викличте батька! | Connection::stmt\\_init() | | Мережа (MYSQLND\\_NET) | mysqlnd\\_net\\_init() | Ні | Connection::init() | | Протокол обміну (MYSQLND\\_PROTOCOL) | mysqlnd\\_protocol\\_init() | Ні | Connection::init() |\n\nНастійно рекомендується не замінювати конструктор цілком. Конструктори виробляють виділення пам'яті. Виділення пам'яті життєво необхідне для API плагінів`mysqlnd`та для логіки об'єкта`mysqlnd`. Якщо вам не страшні попередження і хочете сильно поміняти конструктор, то хоча б викличте батьківський конструктор перш ніж щось робити.\n\nНезважаючи на всі попередження, це може бути корисним для конструктора підкласу. Конструктори - відмінне місце зміни таблиці функцій для об'єктів, не використовують розділену таблицю, як-от результуючий набір, мережу, протокол обміну.\n\n**Статус знищення**\n\n|  | Производный метод должен вызвать родительский? | Деструктор |\n| --- | --- | --- |\n| З'єднання | так, після виконання методу | free\\_contents(), end\\_psession() |\n| Результуючий набір | так, після виконання методу | free\\_result() |\n| Метадані результуючого набору | так, після виконання методу | free() |\n| Оператор | так, після виконання методу | dtor(), free\\_stmt\\_content() |\n| Мережа | так, після виконання методу | free() |\n| Протокол обміну | так, після виконання методу | free() |\n\nДеструктори є відповідним місцем, щоб звільнити ресурси, які займають властивості.`mysqlnd_plugin_get_plugin_<object>_data()`\n\nПерелічені деструктори можуть не збігатися з актуальними методами`mysqlnd`для очищення самого об'єкта. Однак вони є найкращим місцем, куди ви можете вклинитися для очищення даних свого плагіна. Так само, як і з конструкторами, ви можете повністю перевизначити ці методи, але робити це не рекомендується. Якщо вам необхідно вставити в кожен із перерахованих методів очищення даних свого плагіна, необхідно забезпечити запуск батьківських методів`mysqlnd`\n\nРекомендований метод для плагінів - виконати код очищення даних плагіна і відразу після цього викликати батьківський метод.\n","title":"Архитектура плагинов MySQL Native Driver","contentType":2,"navigation":[{"mysqlnd.plugin.obtaining.md":"« Отримання API плагінів mysqlnd"},{"mysqlnd.plugin.api.md":"API плагінів mysqlnd »"},{"index.md":"PHP Manual"},{"mysqlnd.plugin.md":"API для плагінів до вбудованого драйвера MySQL"}]}},"__N_SSG":true}