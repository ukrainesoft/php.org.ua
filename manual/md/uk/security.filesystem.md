- [«Безпека сесій](security.sessions.md)
- [Проблеми безпеки, пов'язані з нульовим байтом
»](security.filesystem.nullbytes.md)

- [PHP Manual](index.md)
- [Безпека](security.md)
- Безпека файлової системи

# Безпека файлової системи

## Зміст

- [Проблеми безпеки, пов'язані з нульовим
байтом](security.filesystem.nullbytes.md)

PHP є одним з важливих моментів у питанні безпеки сервера,
оскільки PHP-скрипти можуть маніпулювати файлами та каталогами на
диск. У зв'язку з цим існують конфігураційні налаштування,
які вказують, які файли можуть бути доступні та які операції з ними
можна виконувати. Необхідно виявляти обережність, оскільки будь-який
файлів, з повними правами читання ("world readable") може бути прочитаний
кожним, хто має доступ до файлової системи.

Оскільки в PHP спочатку передбачався повноправний
доступ до файлової системи, можна написати PHP-скрипт, який дозволить
читати системні файли, такі як /etc/passwd, керувати мережевими
з'єднаннями, надсилати завдання принтеру, і так далі. Як наслідок,
ви завжди повинні бути впевнені в тому, що файли, які ви читаєте або
модифікуєте, є саме тими, що ви мали на увазі.

Розглянемо наступний приклад, у якому користувач створив скрипт,
видаляє файл із його домашньої директорії. Передбачається ситуація,
коли веб-інтерфейс, написаний на PHP, регулярно використовується для
роботи з файлами, та налаштування безпеки дозволяють видаляти файли в
домашньому каталозі.

**Приклад #1 Недостатня перевірка зовнішніх даних веде до...**

` <?php// Видалення файла з домашньої директорії користувача$username u003d $_POST['user_submitted_name'];$userfile u003d $_POST['user_submitted_filename'];$homedir u003du003d""/home/$$ /$userfile");echo "Файл був віддалений!";?> `

Оскільки змінні вводяться в формі користувача, існує
можливість видалити файли, що належать комусь іншому, ввівши
відповідні значення. І тут може знадобитися авторизація.
Подивимося, що станеться, якщо буде відправлено значення "../etc/" і
"passwd". Скрипт виконає такі дії:

**Приклад #2 ... атаці на файлову систему**

` <?php// Видалення любого файла, доступного з PHP-скрипта. // "../etc"$userfile u003d $_POST['user_submitted_filename']; //"passwd"$homedir u003du003d"/home/$username"; // "/home/../etc"unlink("$homedir/$userfile"); // "/home/../etc/passwd"echo "Файл був віддалений!";?> `

Існують два важливі заходи, які можна вжити для запобігання
описаної проблеми.

- Обмежити доступ користувача, з правами якого працює
веб-сервер із PHP.
- Перевірити всі дані, що вводяться користувачем.

Ось покращений варіант коду:

**Приклад #3 Більш безпечна перевірка імені файлу**

` <?php// Видалення любого файла, до которого має доступ користувач,// під яким запущений PHP.$username u003d $_SERVER['REMOTE_USER']; // використання авторизації$userfile u003d basename($_POST['user_submitted_filename']);$homedir u003d "/home/$username";$filepath u003d "$homedir/$userfile";if (file_exists($filepath) && $filepath)) {   $logstring u003d "$filepath віддалений
";} else {    $logstring u003d "Не удалося видалити $filepath
";}$fp u003dfopen("/home/logging/filedelete.log", "a");fwrite($fp, $logstring);fclose($fp);echo htmlentities($logstring, ENT_QUOTES);?> `

Однак і така перевірка не враховує всіх можливих ситуацій. Якщо
система авторизації дозволяє користувачам вибирати довільні
логіни, зломщик може створити обліковий запис виду "../etc/" та система
знову виявиться вразливою. Виходячи з цього, вам може знадобитися більше
сувора перевірка:

**Приклад #4 Суворіша перевірка імені файлу**

` <?php$username     u003d $_SERVER['REMOTE_USER']; // використання авторизації$userfile     u003d $_POST['user_submitted_filename'];$homedir     u003d "/home/$username";$filepath     u003du003d "$homedir/$userfile"|| '/^(?:[a-z0-9_-]|\.(?!\.))+$/iD', $userfile)) {   die("Неправильне ім'я користувача або файл");}//etc ...?> `

Залежно від операційної системи, що використовується вами, необхідно
передбачати можливість атаки на різноманітні файли, включаючи
системні файли пристроїв (/dev/ або COM1), конфігураційні файли
(наприклад /etc/ або файли з розширенням .ini), добре відомі області
зберігання даних (/home/, My Documents), тощо. Виходячи з цього,
як правило, легше реалізувати таку безпекову політику, в якій
заборонено все, крім того, що явно дозволено.
