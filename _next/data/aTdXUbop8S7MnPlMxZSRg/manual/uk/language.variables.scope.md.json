{"pageProps":{"page":{"slug":"language.variables.scope.md","content":"## Область видимості змінної\n\nОбласть видимості змінної – це контекст, у якому ця змінна визначена. У більшості випадків всі змінні PHP мають лише одну область видимості. Ця єдина область видимості охоплює також файли, що включаються (include) і необхідні (require). Наприклад:\n\n```php\n<?php\n$a = 1;\ninclude 'b.inc';\n?>\n```\n\nТут змінна $a буде доступна всередині скрипта b.inc. Однак визначення (тіло) функції користувача задає локальну область видимості даної функції. Будь-яка змінна за умовчанням обмежена локальною областю видимості функції. Наприклад:\n\n```php\n<?php\n$a = 1; /* глобальная область видимости */\n\nfunction test()\n{\n    echo $a; /* ссылка на переменную в локальной области видимости */\n}\n\ntest();\n?>\n```\n\nЦей скрипт видасть діагностику невизначеної змінної **`E_WARNING`**(или\\*\\*`E_NOTICE`\\*\\* до версії PHP 8.0.0. Однак якщо в налаштуваннях INI [display\\_errors](errorfunc.configuration.md#ini.display-errors) встановлено приховування такої діагностики, нічого виводитися нічого очікувати. Це з тим, що оператор echo вказує на локальну версію змінної $a, а межах цієї області видимості їй було присвоєно значення. Можливо ви помітили, що це трохи відрізняється від мови C у тому, що глобальні змінні C автоматично доступні функціям, якщо тільки вони не були перезаписані локальним визначенням. Це може викликати деякі проблеми, оскільки люди можуть ненароком змінити глобальну змінну. У PHP, якщо глобальна змінна буде використовуватися всередині функції, вона повинна бути оголошена глобальною всередині визначення функції.\n\n### Ключевое слово`global`\n\nСначала Приклад использования`global` :\n\n**Приклад #1 Использование`global`**\n\n```php\n<?php\n$a = 1;\n$b = 2;\n\nfunction Sum()\n{\n    global $a, $b;\n\n    $b = $a + $b;\n}\n\nSum();\necho $b;\n?>\n```\n\nНаведений вище скрипт виведе `3`. Після визначення $a і $b всередині функції як global всі посилання будь-яку з цих змінних будуть вказувати їх глобальну версію. Немає жодних обмежень на кількість глобальних змінних, які можуть оброблятися функцією.\n\nДругий спосіб доступу до змінних глобальної області видимості - використання спеціального, що визначається PHP масиву [$GLOBALS](reserved.variables.globals.md). Попередній приклад може бути переписаний так:\n\n**Приклад #2 Использование[$GLOBALS](reserved.variables.globals.md) замість global**\n\n```php\n<?php\n$a = 1;\n$b = 2;\n\nfunction Sum()\n{\n    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];\n}\n\nSum();\necho $b;\n?>\n```\n\n[$GLOBALS](reserved.variables.globals.md) - це асоціативний масив, ключем якого є ім'я, а значенням – вміст глобальної змінної. Зверніть увагу, що [$GLOBALS](reserved.variables.globals.md) існує в будь-якій області видимості, це пояснюється тим, що [$GLOBALS](reserved.variables.globals.md)является[суперглобальним](language.variables.superglobals.md). Нижче наведено приклад, що демонструє можливості суперглобальних змінних:\n\n**Приклад #3 Суперглобальні змінні та область видимості**\n\n```php\n<?php\nfunction test_superglobal()\n{\n    echo $_POST['name'];\n}\n?>\n```\n\n> **Зауваження** :\n> \n> Використання ключового слова `global` поза функцією не є помилкою. Він може бути використаний у файлі, який включається всередині функції.\n\n### Використання статичних (`static`) змінних\n\nІнший важливою особливістю області видимості змінної є *статична* змінна. Статична змінна існує тільки в локальній області видимості функції, але не втрачає свого значення, коли виконання програми виходить із цієї області видимості. Розглянемо наступний приклад:\n\n**Приклад #4 Демонстрація необхідності статичних змінних**\n\n```php\n<?php\nfunction test()\n{\n    $a = 0;\n    echo $a;\n    $a++;\n}\n?>\n```\n\nЦя функція досить марна, оскільки при кожному виклику вона встановлює $a в і виводить . Інкремент змінної $a++ тут ​​не відіграє ролі, тому що при виході з функції змінна $a зникає. Щоб написати корисну функцію підрахунку, яка не втрачатиме поточного значення лічильника, змінна $a оголошується як static:\n\n**Приклад #5 Приклад використання статичних змінних**\n\n```php\n<?php\nfunction test()\n{\n    static $a = 0;\n    echo $a;\n    $a++;\n}\n?>\n```\n\nТепер $a буде проініціалізована тільки при першому виклику функції, а кожен виклик функції `test()` буде виводити значення $a та інкрементувати його.\n\nСтатичні змінні також дозволяють працювати з рекурсивними функціями. Рекурсивною є функція, що викликає саму себе. При написанні рекурсивної функції слід бути уважним, оскільки є можливість зробити рекурсію нескінченною. Ви повинні переконатися, що є адекватний спосіб завершення рекурсії. Наступна проста функція рекурсивно рахує до 10, використовуючи для визначення моменту зупинки статичну змінну $count:\n\n**Приклад #6 Статичні змінні та рекурсивні функції**\n\n```php\n<?php\nfunction test()\n{\n    static $count = 0;\n\n    $count++;\n    echo $count;\n    if ($count < 10) {\n        test();\n    }\n    $count--;\n}\n?>\n```\n\nСтатичним змінним можна присвоїти значення, що є результатом виразу, але не можна використовувати для цього функцію, так це викликає помилку аналізу.\n\n**Приклад #7 Оголошення статичних змінних**\n\n```php\n<?php\nfunction foo() {\n    static $int = 0;          // верно\n    static $int = 1+2;        // верно\n    static $int = sqrt(121);  // неверно (поскольку это функция)\n\n    $int++;\n    echo $int;\n}\n?>\n```\n\nПочинаючи з PHP 8.1.0, коли метод, що використовує статичні змінні, успадковується (але не перевизначається), успадкований метод тепер використовуватиме статичні змінні спільно з батьківським методом. Це означає, що статичні змінні в методах тепер поводяться так само, як і статичні властивості.\n\n**Приклад #8 Використання статичних змінних у успадкованих методах**\n\n```php\n<?php\nclass Foo {\n    public static function counter() {\n        static $counter = 0;\n        $counter++;\n        return $counter;\n    }\n}\nclass Bar extends Foo {}\nvar_dump(Foo::counter()); // int(1)\nvar_dump(Foo::counter()); // int(2)\nvar_dump(Bar::counter()); // int(3), до PHP 8.1.0 int(1)\nvar_dump(Bar::counter()); // int(4), до PHP 8.1.0 int(2)\n?>\n```\n\n> **Зауваження** :\n> \n> Статичні оголошення обчислюються під час компіляції скрипту.\n\n### Посилання з глобальними (`global`) та статичними (`static`) змінними\n\nPHP використовує модифікатори змінних [static](language.variables.scope.md#language.variables.scope.static) і [global](language.variables.scope.md#language.variables.scope.global) як [посилання](language.references.md). Наприклад, реальна глобальна змінна, впроваджена область видимості функції вказівкою ключового слова `global`, Насправді створює посилання на глобальну змінну. Це може призвести до несподіваної поведінки, як це показано в наступному прикладі:\n\n```php\n<?php\nfunction test_global_ref() {\n    global $obj;\n    $new = new stdClass;\n    $obj = &$new;\n}\n\nfunction test_global_noref() {\n    global $obj;\n    $new = new stdClass;\n    $obj = $new;\n}\n\ntest_global_ref();\nvar_dump($obj);\ntest_global_noref();\nvar_dump($obj);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNULL\nobject(stdClass)#1 (0) {\n}\n```\n\nАналогічно поводиться і вираз `static`. Посилання не зберігаються статично:\n\n```php\n<?php\nfunction &get_instance_ref() {\n    static $obj;\n\n    echo 'Статический объект: ';\n    var_dump($obj);\n    if (!isset($obj)) {\n        $new = new stdClass;\n        // Присвоить ссылку статической переменной\n        $obj = &$new;\n    }\n    if (!isset($obj->property)) {\n        $obj->property = 1;\n    } else {\n        $obj->property++;\n    }\n    return $obj;\n}\n\nfunction &get_instance_noref() {\n    static $obj;\n\n    echo 'Статический объект: ';\n    var_dump($obj);\n    if (!isset($obj)) {\n        $new = new stdClass;\n        // Присвоить объект статической переменной\n        $obj = $new;\n    }\n    if (!isset($obj->property)) {\n        $obj->property = 1;\n    } else {\n        $obj->property++;\n    }\n    return $obj;\n}\n\n$obj1 = get_instance_ref();\n$still_obj1 = get_instance_ref();\necho \"\\n\";\n$obj2 = get_instance_noref();\n$still_obj2 = get_instance_noref();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nСтатический объект: NULL\nСтатический объект: NULL\n\nСтатический объект: NULL\nСтатический объект: object(stdClass)#3 (1) {\n  [\"property\"]=>\n  int(1)\n}\n```\n\nЦей приклад демонструє, що при привласненні посилання статичної змінної вона не *запам'ятовується*, коли ви викликаєте функцію `&get_instance_ref()` вдруге.\n","title":"Область видимості змінної","contentType":2,"navigation":[{"language.variables.predefined.md":"«Зумовлені змінні"},{"language.variables.variable.md":"Змінні змінні »"},{"index.md":"PHP Manual"},{"language.variables.md":"Змінні"}]}},"__N_SSG":true}