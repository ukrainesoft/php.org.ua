{"pageProps":{"page":{"slug":"function.preg-match.md","content":"# preg\\_match\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\npreg\\_match — Виконує перевірку на відповідність регулярному виразу\n\n### Опис\n\n```methodsynopsis\npreg_match(    string $pattern,    string $subject,    array &$matches = null,    int $flags = 0,    int $offset = 0): int|false\n```\n\nШукає у заданому тексті `subject` збіги з шаблоном `pattern`\n\n### Список параметрів\n\n`pattern`\n\nШуканий шаблон у вигляді рядка.\n\n`subject`\n\nВхідний рядок.\n\n`matches`\n\nЯкщо вказано додатковий параметр `matches`, він буде заповнений результатами пошуку. Елемент $matches\\[ \\] міститиме частину рядка, що відповідає входу всього шаблону, $matches\\[ \\] - частина рядка, що відповідає першій підмасці тощо.\n\n`flags`\n\n`flags` може бути комбінацією наступних прапорів:\n\n**`PREG_OFFSET_CAPTURE`**\n\nУ випадку, якщо цей прапор вказано, для кожного знайденого підрядка буде вказано її позицію (в байтах) у вихідному рядку. Необхідно пам'ятати, що цей прапор змінює формат масиву, що повертається. `matches` масив, кожен елемент якого містить масив, що містить в індексі з номером знайдений підрядок, а зміщення цього підрядка у параметрі `subject`\\- в индексе\n\n```php\n<?php\npreg_match('/(foo)(bar)(baz)/', 'foobarbaz', $matches, PREG_OFFSET_CAPTURE);\nprint_r($matches);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => Array\n        (\n            [0] => foobarbaz\n            [1] => 0\n        )\n\n    [1] => Array\n        (\n            [0] => foo\n            [1] => 0\n        )\n\n    [2] => Array\n        (\n            [0] => bar\n            [1] => 3\n        )\n\n    [3] => Array\n        (\n            [0] => baz\n            [1] => 6\n        )\n\n)\n```\n\n**`PREG_UNMATCHED_AS_NULL`**\n\nЯкщо цей прапор передано, несупадні підмаски будуть представлені значеннями **`null`**; інакше вони відображаються як порожніх рядків (string).\n\n```php\n<?php\npreg_match('/(a)(b)*(c)/', 'ac', $matches);\nvar_dump($matches);\npreg_match('/(a)(b)*(c)/', 'ac', $matches, PREG_UNMATCHED_AS_NULL);\nvar_dump($matches);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(4) {\n  [0]=>\n  string(2) \"ac\"\n  [1]=>\n  string(1) \"a\"\n  [2]=>\n  string(0) \"\"\n  [3]=>\n  string(1) \"c\"\n}\narray(4) {\n  [0]=>\n  string(2) \"ac\"\n  [1]=>\n  string(1) \"a\"\n  [2]=>\n  NULL\n  [3]=>\n  string(1) \"c\"\n}\n```\n\n`offset`\n\nЗазвичай пошук здійснюється зліва направо, з початку рядка. Можна використовувати додатковий параметр `offset` для вказівки альтернативної початкової позиції пошуку (в байтах).\n\n> **Зауваження** :\n> \n> Использование параметра`offset` не еквівалентно заміні зіставного рядка виразом `substr($subject, $offset)` при виклику функції **preg\\_match()**, оскільки шаблон `pattern` може містити такі умови як *^* \\*$*или*(?<=x)\\*Сравните:\n> \n> ```php\n> <?php\n> $subject = \"abcdef\";\n> $pattern = '/^def/';\n> preg_match($pattern, $subject, $matches, PREG_OFFSET_CAPTURE, 3);\n> print_r($matches);\n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> Array\n> (\n> )\n> ```\n> \n> У той час як цей приклад\n> \n> ```php\n> <?php\n> $subject = \"abcdef\";\n> $pattern = '/^def/';\n> preg_match($pattern, substr($subject,3), $matches, PREG_OFFSET_CAPTURE);\n> print_r($matches);\n> ?>\n> ```\n> \n> виведе наступне:\n> \n> ```\n> Array\n> (\n>     [0] => Array\n>         (\n>             [0] => def\n>             [1] => 0\n>         )\n> \n> )\n> ```\n> \n> Як альтернатива **substr()()**, используйте утверждение`\\G` замість якоря `^` або модифікатор `A`Оба они работают с параметром`offset`\n\n### Значення, що повертаються\n\n**preg\\_match()** повертає 1, якщо параметр `pattern`соответствует переданному параметру`subject`, 0 якщо ні \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n**Увага**\n\nЦя функція може повертати як логічне значення \\*\\*`false`\\*\\*так і значення не типу boolean, яке наводиться до **`false`**. За більш детальною інформацією зверніться до розділу [Логічний тип](language.types.boolean.md)Используйте[оператор ===](language.operators.comparison.md) для перевірки значення, яке повертається цією функцією.\n\n### Помилки\n\nЯкщо переданий шаблон регулярного виразу не компілюється в допустимий регулярний вираз, видається помилка рівня **`E_WARNING`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.2.0 | Тепер константа **`PREG_UNMATCHED_AS_NULL`** підтримується для параметра `$flags` |\n\n### Приклади\n\n**Приклад #1 Пошук підрядки \"php\" у тексті**\n\n```php\n<?php\n// Символ \"i\" после закрывающего ограничителя шаблона означает\n// регистронезависимый поиск.\nif (preg_match(\"/php/i\", \"PHP is the web scripting language of choice.\")) {\n    echo \"Вхождение найдено.\";\n} else {\n    echo \"Вхождение не найдено.\";\n}\n?>\n```\n\n**Приклад #2 Пошук слова \"web\" у тексті**\n\n```php\n<?php\n/* Специальная последовательность \\b в шаблоне означает границу слова,\n   следовательно, только изолированное вхождение слова 'web' будет\n   соответствовать маске, в отличие от \"webbing\" или \"cobweb\" */\nif (preg_match(\"/\\bweb\\b/i\", \"PHP is the web scripting language of choice.\")) {\n    echo \"Вхождение найдено.\";\n} else {\n    echo \"Вхождение не найдено.\";\n}\n\nif (preg_match(\"/\\bweb\\b/i\", \"PHP is the website scripting language of choice.\")) {\n    echo \"Вхождение найдено.\";\n} else {\n    echo \"Вхождение не найдено.\";\n}\n?>\n```\n\n**Приклад #3 Вилучення домену з URL**\n\n```php\n<?php\n// Извлекаем имя хоста из URL\npreg_match('@^(?:http://)?([^/]+)@i',\n    \"http://www.php.net/index.md\", $matches);\n$host = $matches[1];\n\n// извлекаем две последние части имени хоста\npreg_match('/[^.]+\\.[^.]+$/', $host, $matches);\necho \"доменное имя: {$matches[0]}\\n\";\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nдоменное имя: php.net\n```\n\n**Приклад #4 Використання іменованих підмасок**\n\n```php\n<?php\n\n$str = 'foobar: 2008';\n\npreg_match('/(?P<name>\\w+): (?P<digit>\\d+)/', $str, $matches);\n\n/* Альтернативный вариант */\n// preg_match('/(?<name>\\w+): (?<digit>\\d+)/', $str, $matches);\n\nprint_r($matches);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => foobar: 2008\n    [name] => foobar\n    [1] => foobar\n    [digit] => 2008\n    [2] => 2008\n)\n```\n\n### Примітки\n\n**Підказка**\n\nНе используйте функцию**preg\\_match()**, якщо необхідно перевірити наявність підрядка у заданому рядку. Використовуйте для цього [strpos()](function.strpos.md) оскільки вона виконає це завдання набагато швидше.\n\n### Дивіться також\n\n-   \" [Регулярні вирази PCRE](pcre.pattern.md) \"\n-   [preg\\_quote()](function.preg-quote.md) \\- Екранує символи у регулярних виразах\n-   [preg\\_match\\_all()](function.preg-match-all.md) \\- Виконує глобальний пошук шаблону у рядку\n-   [preg\\_replace()](function.preg-replace.md) \\- Виконує пошук та заміну за регулярним виразом\n-   [preg\\_split()](function.preg-split.md) \\- Розбиває рядок за регулярним виразом\n-   [preg\\_last\\_error()](function.preg-last-error.md) \\- Повертає код помилки виконання останнього регулярного вираження PCRE\n-   [preg\\_last\\_error\\_msg()](function.preg-last-error-msg.md) \\- Повертає повідомлення про помилку останньої запущеної функції PCRE\n","title":"preg\\_match","contentType":2,"navigation":[{"function.preg-match-all.md":"« preg\\_match\\_all"},{"function.preg-quote.md":"preg\\_quote »"},{"index.md":"PHP Manual"},{"ref.pcre.md":"Функції PCRE"}]}},"__N_SSG":true}