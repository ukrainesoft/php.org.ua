{"pageProps":{"page":{"slug":"mysqlnd.stats.md","content":"# Статистика\n\n**Використання статистичних даних**\n\nMySQL Native Driver підтримує збір статистики щодо взаємодії клієнта із сервером. Статистика збирається з двох основних точок:\n\n-   Клієнтська статистика\n    \n-   Статистика з'єднання\n    \n\nЯкщо ви використовуєте модуль `mysqli`, ця статистика доступна за допомогою двох функцій, що звертаються до API:\n\n-   [mysqli\\_get\\_client\\_stats()](function.mysqli-get-client-stats.md)\n    \n-   [mysqli\\_get\\_connection\\_stats()](mysqli.get-connection-stats.md)\n    \n\n> **Зауваження** :\n> \n> Статистика агрегується з усіх модулів, які використовують MySQL Native Driver. Наприклад, якщо підключити та `ext/mysql`и`ext/mysqli` через MySQL Native Driver, як виклики функцій `ext/mysql`так и`ext/mysqli` буде внесено до загальної статистики. Можливість поділу статистики в залежності від використаного модуля відсутня. Ви можете налаштувати драйвера PDO MySQL, `ext/mysql`и`ext/mysqli` для опціонального використання MySQL Native Driver При цьому всі три модулі змінюватимуть статистику.\n\n**Доступ до клієнтської статистики**\n\nДля отримання клієнтської статистики потрібно виконати функцію [mysqli\\_get\\_client\\_stats()](function.mysqli-get-client-stats.md). Функція викликається без установок.\n\nФункція повертає асоціативний масив, що використовує як ключі назви метрик статистики і як значення цих метрик, власне, значення.\n\nТакож клієнтська статистика доступна за допомогою функції [phpinfo()](function.phpinfo.md)\n\n**Доступ до статистики з'єднання**\n\nЩоб отримати статистику з'єднання, виконайте функцію [mysqli\\_get\\_connection\\_stats()](mysqli.get-connection-stats.md), передавши як параметр ресурс з'єднання.\n\nФункція повертає асоціативний масив, що використовує як ключі назви метрик статистики і як значення цих метрик, власне, значення.\n\n**Буферизовані та небуферизовані результуючі набори**\n\nРезультуючі набори можуть бути буферизовані та небуферизовані. При використанні стандартних налаштувань, `ext/mysql`и`ext/mysqli` працюють із буферизованими результуючими наборами під час використання нормальних (не підготовлених) запитів. Буферизовані результуючі набори кешуються на стороні клієнта. Після виконання запиту всі результати передаються на клієнта, де зберігаються в кеші. Перевага буферизованих запитів у тому, що відразу вивільняються серверні ресурси, пов'язані зі зберіганням результуючого набору.\n\nНебуферизовані результуючі набори, з іншого боку, зберігаються на сервері набагато довше. Якщо ви хочете скоротити споживання пам'яті на клієнті, але при цьому навантажити сервер, використовуйте небуферизовані результуючі набори. Якщо вузьким місцем у вашій системі є сервер баз даних, то варто задуматися про якнайшвидше переміщення результатів на клієнта. Зазвичай клієнти масштабуються набагато легше, ніж сервер БД. Навантаження лягає не тільки на пам'ять, але й на інші ресурси, які повинна підтримувати база даних для обслуговування з'єднання, такі як відкриті файлові дескриптори та нитки виконання.\n\nПідготовлені запити за замовчуванням використовують небуферизовані результуючі набори. У будь-якому випадку ви можете використовувати функцію [mysqli\\_stmt\\_store\\_result()](mysqli-stmt.store-result.md)для буферизации результатов.\n\n**Статистика MySQL Native Driver, що повертається**\n\nНаступна таблиця демонструє список функцій, що повертаються. [mysqli\\_get\\_client\\_stats()](function.mysqli-get-client-stats.md) і [mysqli\\_get\\_connection\\_stats()](mysqli.get-connection-stats.md)статистики.\n\n**Статистика mysqlnd: Мережа**\n\n| Метрика | Область применения | Опис | Замечания |\n| --- | --- | --- | --- |\n| `bytes_sent` | З'єднання | Кількість байт, переданих від PHP на сервер MySQL | Може використовуватись для перевірки ефективності протоколу стиснення |\n| `bytes_received` | З'єднання | Кількість байт, отриманих від сервера MySQL | Може використовуватись для перевірки ефективності протоколу стиснення |\n| `packets_sent` | З'єднання | Кількість пакетів надісланих від клієнта серверу MySQL | Використовується для налагодження реалізації клієнт-серверного протоколу |\n| `packets_received` | З'єднання | Кількість пакетів, прийнятих клієнтом від сервера MySQL | Використовується для налагодження реалізації клієнт-серверного протоколу |\n| `protocol_overhead_in` | З'єднання | накладні витрати клієнт-серверного протоколу MySQL у байтах для вхідного трафіку. на даний момент тільки заголовок пакета (4 байти) вважається накладними витратами. protocol\\_overhead\\_in = packets\\_received \\* 4 | Використовується для налагодження реалізації клієнт-серверного протоколу |\n| `protocol_overhead_out` | З'єднання | MySQL Client Server protocol overhead in bytes for outgoing traffic. Currently only the Packet Header (4 bytes) is considered as overhead. protocol\\_overhead\\_out = packets\\_sent \\* 4 | Використовується для налагодження реалізації клієнт-серверного протоколу |\n| `bytes_received_ok_packet` | З'єднання | Загальна кількість байт прийнятих ОК пакетів клієнт-серверного протоколу MySQL. OK-пакети можуть містити статусні повідомлення. Довжина статусних повідомлень може змінюватися, отже, розмір ОК-пакетів не фіксована. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_ok` | З'єднання | Кількість прийнятих OK-пакетів | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_eof_packet` | З'єднання | Загальна кількість байт прийнятих пакетів EOF. Розмір пакета EOF може змінюватись в залежності від версії сервера. Також EOF-пакети можуть використовуватися як транспорт для повідомлень про помилки. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_eof` | З'єднання | Кількість прийнятих пакетів EOF. Як і для іншої статистики пакетів, це число може збільшуватися кожного разу, коли PHP не отримує очікуваний пакет, а, наприклад, отримує повідомлення про помилку. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_rset_header_packet` | З'єднання | Загальна кількість байт прийнятих заголовних пакетів результуючих наборів. Розмір пакетів залежить від корисного навантаження (`LOAD LOCAL INFILE` `INSERT` `UPDATE` `SELECT`, повідомлення про помилку). | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_rset_header` | З'єднання | Кількість пакетів заголовків результуючих наборів. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_rset_field_meta_packet` | З'єднання | Загальний розмір у байтах отриманих пакетів із метаданими результуючих наборів (інформації про стовпці). Звичайно розмір кожного пакета індивідуальний. Ці пакети можуть бути транспортом для помилок і EOF-пакетів у разі COM\\_LIST\\_FIELDS. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_rset_field_meta` | З'єднання | Загальна кількість отриманих пакетів із метаданими результуючих наборів (інформації про стовпці). | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_rset_row_packet` | З'єднання | Загальний розмір у байтах одержаних пакетів з даними результуючого набору. Ці пакети можуть бути транспортом для помилок і як EOF-пакетів. Ви можете обчислити кількість помилок і EOF-пакетів забравши `rows_fetched_from_server_normal`и`rows_fetched_from_server_ps`от`bytes_received_rset_row_packet` | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_rset_row` | З'єднання | Кількість пакетів із даними результуючих наборів та їх сумарний обсяг у байтах. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_prepare_response_packet` | З'єднання | Загальний розмір байтів ОК-пакетів ініціалізації підготовлених запитів. (Ініціалізують пакети підготовлених запитів). Ці пакети можуть бути транспортом для помилок. Розмір пакета залежить від версії Mysql: 9 байт для MySQL4.1 та 12 байт починаючи з 5.0. Немає надійного способу дізнатися про кількість помилок. Ви можете визначити, що трапилася помилка, якщо, наприклад, ви працюєте з MySQL 5.0 або новіше, а `bytes_received_prepare_response_packet` != `packets_received_prepare_response` \\* 12. Також дивіться `ps_prepared_never_executed` `ps_prepared_once_executed` | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_prepare_response` | З'єднання | Кількість одержаних ОК-пакетів для ініціалізації підготовлених запитів. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `bytes_received_change_user_packet` | З'єднання | Загальний розмір у байтах отриманих пакетів COM\\_CHANGE\\_USER. Пакети можуть бути транспортом для помилок і EOF-пакетів. | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_received_change_user` | З'єднання | Кількість прийнятих пакетів COM\\_CHANGE\\_USER | Використовується для налагодження реалізації клієнт-серверного протоколу. Зверніть увагу, що загальний розмір включає заголовний пакет, розміром 4 байти. |\n| `packets_sent_command` | З'єднання | Кількість команд надісланих від PHP серверу MySQL. Можливість дізнатися, які конкретно та в яких кількостях надсилалися команди відсутня. Найкраще, для чого ви можете використовувати цю метрику, це перевіряти, що посилає команди серверу MySQL та підтримка MySQL у PHP не заборонена. Також немає можливості визначити кількість помилок, що виникли під час відправлення цих команд. Єдина впізнавана помилка – це command\\_buffer\\_too\\_small (дивіться нижче). | Використовується для налагодження реалізації клієнт-серверного протоколу |\n| `bytes_received_real_data_normal` | З'єднання | Кількість байт корисного навантаження витягнутого клієнтом PHP з `mysqlnd` із використанням текстового протоколу. | Це актуальний розмір даних, що містяться в результуючому наборі, які клієнт PHP вже завантажив. Зверніть увагу, що хоч можливо `mysqlnd` забрав і повний результуючий набір з сервера MySQL, але в цій метриці враховуються лише дані, вже отримані клієнтом PHP від `mysqlnd`. . Наприклад, наступний код збільшить значення метрики: |\n\n```\n$mysqli = new mysqli();\n$res = $mysqli->query(\"SELECT 'abc'\");\n$res->fetch_assoc();\n$res->close();\n```\n\nКожна операція вилучення збільшує це число.\n\nСтатистика не зміниться, якщо результуючий набір був буферизований, але не витягнутий, як у цьому прикладі:\n\n```\n$mysqli = new mysqli();\n$res = $mysqli->query(\"SELECT 'abc'\");\n$res->close();\n```\n\n`bytes_received_real_data_ps` | Поєднання | Кількість байт корисного навантаження, витягнутого клієнтом PHP з `mysqlnd` використовуючи підготовлені запити. | Це розмір лише тих даних, які витягнули клієнт PHP. Значення метрики не збільшуватиметься якщо клієнт PHP не буде запитувати ці дані. Зверніть увагу, що хоч можливо `mysqlnd` забрав і повний результуючий набір з сервера MySQL, але в цій метриці враховуються лише дані, вже отримані клієнтом PHP від `mysqlnd`Также смотрите`bytes_received_real_data_normal`.\n\n**Результуючий набір**\n\n**Статистика mysqlnd: результуючий набір**\n\n| Метрика | Область применения | Опис | Замечания |\n| --- | --- | --- | --- |\n| `result_set_queries` | З'єднання | Кількість запитів, за якими було створено результуючий набір. Приклад запитів, що створюють результуючий набір: `SELECT` `SHOW`. . Статистика не збільшуватиметься у разі виникнення помилки читання заголовного пакета результуючого набору. | Ви можете використовувати цю метрику як опосередкований лічильник виконаних запитів, наприклад, для виявлення клієнта, що створює велике навантаження на БД. |\n| `non_result_set_queries` | З'єднання | Кількість запитів, за якими не створено результуючий набір. Приклад запитів, що не створюють результуючого набору: `INSERT` `UPDATE` `LOAD DATA`. . Статистика не збільшуватиметься у разі виникнення помилки читання заголовного пакета результуючого набору. | Ви можете використовувати цю метрику як опосередкований лічильник виконаних запитів, наприклад, для виявлення клієнта, що створює велике навантаження на БД. |\n| `no_index_used` | З'єднання | Кількість запитів, що створюють результуючий набір, але не використовували індекси (також дивіться опцію запуску mysqld-log-queries-not-using-indexes). Якщо ви бажаєте отримувати звіти про подібні запити, ви можете використовувати mysqli\\_report(MYSQLI\\_REPORT\\_INDEX) для того, щоб ext/mysqli викидав виняток. Якщо ви віддаєте перевагу просто попередження, використовуйте mysqli\\_report(MYSQLI\\_REPORT\\_INDEX ^ MYSQLI\\_REPORT\\_STRICT). |  |\n| `bad_index_used` | З'єднання | Кількість запитів, що створюють результуючий набір, але не використовували хороші індекси (дивіться також опцію запуску mysqld –log-slow-queries). | Якщо ви бажаєте отримувати звіти про подібні запити, ви можете використовувати mysqli\\_report(MYSQLI\\_REPORT\\_INDEX)для того, щоб ext/mysqli викидав виняток. Якщо ви віддаєте перевагу просто попередження, використовуйте mysqli\\_report(MYSQLI\\_REPORT\\_INDEX ^ MYSQLI\\_REPORT\\_STRICT) |\n| `slow_queries` | З'єднання | SQL-запити, що виконувались довше `long_query_time` секунд і перебору, що зажадали, більш ніж `min_examined_row_limit` рядків. | Не вилучається за допомогою [mysqli\\_report()](function.mysqli-report.md) |\n| `buffered_sets` | З'єднання | Кількість буферизованих результуючих наборів, повернутих нормальними запитами. Нормальні, тут і далі не підготовлені. | Приклади викликів API, які буферизують результуючий набір на клієнта: [mysql\\_query()](function.mysql-query.md) [mysqli\\_query()](mysqli.query.md) [mysqli\\_store\\_result()](mysqli.store-result.md) [mysqli\\_stmt\\_get\\_result()](mysqli-stmt.get-result.md). . Буферизація результуючого набору на клієнті гарантує, що серверні ресурси будуть звільнені так швидко, як можливо, і робить позиціонування простішим. Погана новина в тому, що це буде варто додаткової витрати пам'яті клієнта. Зауважте, що mysqlnd (на відміну від клієнтської бібліотеки MySQL) залежить від обмежень PHP на згадку, оскільки використовує внутрішній менеджер пам'яті PHP. Це є однією з причин, чому [memory\\_get\\_usage()](function.memory-get-usage.md) при використанні mysqlnd показує більше значення, ніж при використанні клієнтської бібліотеки MySQL. . [memory\\_get\\_usage()](function.memory-get-usage.md) не заміряє споживання пам'яті клієнтською бібліотекою MySQL, оскільки не використовує внутрішній менеджер пам'яті PHP. |\n| `unbuffered_sets` | З'єднання | Кількість небуферизованих результуючих наборів, повернутих нормальними (не підготовленими) запитами. | Приклади викликів API, які не буферизують результуючий набір на клієнта: [mysqli\\_use\\_result()](mysqli.use-result.md) |\n| `ps_buffered_sets` | З'єднання | Кількість буферизованих результуючих наборів, повернутих підготовленими запитами. За замовчуванням підготовлені запити не буферизуються. | Приклади викликів API, які буферизують результуючий набір на клієнта: `mysqli_stmt_store_result` |\n| `ps_unbuffered_sets` | З'єднання | Кількість небуферизованих результуючих наборів, повернутих підготовленими запитами. | За замовчуванням підготовлені запити не буферизуються. |\n| `flushed_normal_sets` | З'єднання | Кількість результуючих наборів, повернутих нормальними (не підготовленими) запитами з непрочитаними даними, які були обнулені прозоро для вас. Подібне відбувається лише з небуферизованими результуючими наборами. | Небуферизовані результуючі набори повинні бути повністю вилучені, перш ніж буде можливо запустити новий запит у тому ж з'єднанні з MySQL, інакше буде помилка. Якщо програма не витягла всі рядки небуферизованого результуючого набору, mysqlnd примусово витягне його, щоб звільнити ресурси сервера. Також дивіться `rows_skipped_normal`и`rows_skipped_ps`. Можливі причини, що ведуть до примусового обнулення: |\n\n-   Помилка клієнтської програми\n    \n-   Клієнт перестав отримувати записи, оскільки знайшов, що шукав, але результуючий набір не був витягнутий остаточно\n    \n-   Аварійне завершення клієнтської програми\n    \n\n`flushed_ps_sets` | Поєднання | Кількість результуючих наборів, повернутих підготовленими запитами з непрочитаними даними, які були обнулені прозоро для вас. Подібне відбувається лише з небуферизованими результуючими наборами. | Небуферизовані результуючі набори повинні бути повністю вилучені, перш ніж буде можливо запустити новий запит у тому ж з'єднанні з MySQL, інакше буде помилка. Якщо програма не витягла всі рядки небуферизованого результуючого набору, mysqlnd примусово витягне його, щоб звільнити ресурси сервера. Також дивіться `rows_skipped_normal`и`rows_skipped_ps`. Можливі причини, що ведуть до примусового обнулення:\n\n-   Помилка клієнтської програми\n    \n-   Клієнт перестав отримувати записи, оскільки знайшов, що шукав, але результуючий набір не був витягнутий остаточно\n    \n-   Аварійне завершення клієнтської програми\n    \n\n`ps_prepared_never_executed` | Поєднання | Кількість підготовлених, але з запущених запитів. | Підготовлені запити споживають серверні ресурси. Ви не повинні готувати запити, якщо не запускатимете їх. | | `ps_prepared_once_executed` | Поєднання | Кількість підготовлених запитів, запущених лише один раз. | Головна ідея підготовлених запитів у тому, що той самий запит буде запускатися кілька разів, але, можливо, з іншими параметрами. Це дозволяє заощадити на підготовці запитів, дозволяючи зробити розбір запиту лише один раз, а потім просто підставляти параметри і запускати. При підготовці запиту відбувається кешування результату, наприклад, можна багаторазово використовувати дерево розбору, створене один раз на етапі підготовки. Якщо ж ви запускаєте підготовлений запит лише один раз, то жодного виграшу порівняно з нормальними запитами не буде, навіть навпаки, будуть додаткові витрати на кешування підготовленого запиту. Таким чином, підготовлені запити, які використовуються лише один раз, ведуть до погіршення продуктивності. | | `rows_fetched_from_server_normal` `rows_fetched_from_server_ps` | Поєднання | Загальна кількість успішно вилучених рядків з бази MySQL незалежно від того, використані вони були додатком чи ні. Частина рядків можуть не вилучатись додатком, але при цьому примусово обнулятися. | Також дивіться `packets_received_rset_row` `rows_buffered_from_client_normal` `rows_buffered_from_client_ps` | Поєднання | Загальна кількість успішно буферизованих рядків, отриманих під час виконання \"нормальних\" запитів. Це кількість рядків, витягнутих з MySQL та буферизованих на клієнті. Зверніть увагу, що існує дві незалежні метрики для буферизованих рядків і (переданих від MySQL до буферу mysqlnd) і рядків, прочитаних додатком (переданих з буфера mysqlnd клієнтської програми). Якщо кількість буферизованих рядків більше, ніж кількість витягнутих клієнтом, варто звернути увагу до клієнтські запити, оскільки вони отримують більше даних, ніж їм насправді потрібно. | Приклад запитів, що буферизують результуючі набори: [mysqli\\_query()](mysqli.query.md) [mysqli\\_store\\_result()](mysqli.store-result.md) `rows_fetched_from_client_normal_buffered` `rows_fetched_from_client_ps_buffered` | Поєднання | Загальна кількість витягнутих клієнтів рядків із буферизованих результуючих наборів для будь-якого типу запитів. | | | `rows_fetched_from_client_normal_unbuffered` `rows_fetched_from_client_ps_unbuffered` | Поєднання | Total number of rows fetched by the client from unbuffered result set created by \"normal\" query or prepared statement. | | | `rows_fetched_from_client_ps_cursor` | Поєднання | Загальна кількість витягнутих клієнтів рядків із небуферизованих результуючих наборів для будь-якого типу запитів. | | | `rows_skipped_normal` `rows_skipped_ps` | Поєднання | Зарезервовано для використання у майбутньому і на даний момент не підтримується | | | `copy_on_write_saved` `copy_on_write_performed` | Процес | Якщо використовується mysqlnd: змінні, повернуті модулем, вказують на внутрішній мережевий буфер результатів mysqlnd. Якщо ви не змінювали змінні, вилучені дані будуть збережені в пам'яті один раз. Якщо ви змінювали змінні, mysqlnd виконає копіювання під час запису для захисту внутрішніх мережних буферів результату від зміни. Якщо використовується клієнтська бібліотека MySQL: Ви завжди тримаєте дані в пам'яті в двох примірниках. Один раз у внутрішніх буферах клієнтської бібліотеки MySQL, і ще один раз у змінних, повернутих модулем. Теоретично, mysqlnd може до 40% скоротити споживання пам'яті. У будь-якому випадку пам'ятайте, що цю економію не вдасться заміряти за допомогою [memory\\_get\\_usage()](function.memory-get-usage.md). `explicit_free_result` `implicit_free_result` | З'єднання, процес (тільки на стадії очищення підготовлених запитів) Загальна кількість звільнених результуючих наборів. | Очищення завжди проводиться явно, але для результуючих наборів, створених командами, що ініціалізують, наприклад `mysqli_options(MYSQLI_INIT_COMMAND , ...)` `proto_text_fetched_null` `proto_text_fetched_bit` `proto_text_fetched_tinyint` `proto_text_fetched_short` `proto_text_fetched_int24` `proto_text_fetched_int` `proto_text_fetched_bigint` `proto_text_fetched_decimal` `proto_text_fetched_float` `proto_text_fetched_double` `proto_text_fetched_date` `proto_text_fetched_year` `proto_text_fetched_time` `proto_text_fetched_datetime` `proto_text_fetched_timestamp` `proto_text_fetched_string` `proto_text_fetched_blob` `proto_text_fetched_enum` `proto_text_fetched_set` `proto_text_fetched_geometry` `proto_text_fetched_other` | Поєднання | Загальна кількість стовпців певного типу, витягнутих нормальними запитами (текстовий протокол MySQL). | Зв'язування метаданих C API / MySQL з іменами метрик статистики:\n\n-   `MYSQL_TYPE_NULL`\\- proto\\_text\\_fetched\\_null\n    \n-   `MYSQL_TYPE_BIT`\\- proto\\_text\\_fetched\\_bit\n    \n-   `MYSQL_TYPE_TINY`\\- proto\\_text\\_fetched\\_tinyint\n    \n-   `MYSQL_TYPE_SHORT`\\- proto\\_text\\_fetched\\_short\n    \n-   `MYSQL_TYPE_INT24`\\- proto\\_text\\_fetched\\_int24\n    \n-   `MYSQL_TYPE_LONG`\\- proto\\_text\\_fetched\\_int\n    \n-   `MYSQL_TYPE_LONGLONG`\\- proto\\_text\\_fetched\\_bigint\n    \n-   `MYSQL_TYPE_DECIMAL` `MYSQL_TYPE_NEWDECIMAL`\\- proto\\_text\\_fetched\\_decimal\n    \n-   `MYSQL_TYPE_FLOAT`\\- proto\\_text\\_fetched\\_float\n    \n-   `MYSQL_TYPE_DOUBLE`\\- proto\\_text\\_fetched\\_double\n    \n-   `MYSQL_TYPE_DATE` `MYSQL_TYPE_NEWDATE`\\- proto\\_text\\_fetched\\_date\n    \n-   `MYSQL_TYPE_YEAR`\\- proto\\_text\\_fetched\\_year\n    \n-   `MYSQL_TYPE_TIME`\\- proto\\_text\\_fetched\\_time\n    \n-   `MYSQL_TYPE_DATETIME`\\- proto\\_text\\_fetched\\_datetime\n    \n-   `MYSQL_TYPE_TIMESTAMP`\\- proto\\_text\\_fetched\\_timestamp\n    \n-   `MYSQL_TYPE_STRING` `MYSQL_TYPE_VARSTRING` `MYSQL_TYPE_VARCHAR`\\- proto\\_text\\_fetched\\_string\n    \n-   `MYSQL_TYPE_TINY_BLOB` `MYSQL_TYPE_MEDIUM_BLOB` `MYSQL_TYPE_LONG_BLOB` `MYSQL_TYPE_BLOB`\\- proto\\_text\\_fetched\\_blob\n    \n-   `MYSQL_TYPE_ENUM`\\- proto\\_text\\_fetched\\_enum\n    \n-   `MYSQL_TYPE_SET`\\- proto\\_text\\_fetched\\_set\n    \n-   `MYSQL_TYPE_GEOMETRY`\\- proto\\_text\\_fetched\\_geometry\n    \n-   Будь-які не перелічені`MYSQL_TYPE_*`\\- proto\\_text\\_fetched\\_other\n    \n\nЗверніть увагу, що константи типів MYSQL\\_\\* можуть не асоціюватися з однаковими шпальтами SQL для різних версій MySQL.\n\n`proto_binary_fetched_null` `proto_binary_fetched_bit` `proto_binary_fetched_tinyint` `proto_binary_fetched_short` `proto_binary_fetched_int24` `proto_binary_fetched_int` `proto_binary_fetched_bigint` `proto_binary_fetched_decimal` `proto_binary_fetched_float` `proto_binary_fetched_double` `proto_binary_fetched_date` `proto_binary_fetched_year` `proto_binary_fetched_time` `proto_binary_fetched_datetime` `proto_binary_fetched_timestamp` `proto_binary_fetched_string` `proto_binary_fetched_blob` `proto_binary_fetched_enum` `proto_binary_fetched_set` `proto_binary_fetched_geometry` `proto_binary_fetched_other` | Поєднання | Загальна кількість стовпців певного типу, які витягли підготовлені запити (бінарний протокол MySQL). | Зв'язок типів з `proto_text_*` дивіться у попередньому пункті. |\n\n**Статистика mysqlnd: З'єднання**\n\n| Метрика | Область применения | Опис | Замечания |\n| --- | --- | --- | --- |\n| `connect_success` `connect_failure` | З'єднання | Загальна кількість вдалих/невдалих спроб з'єднання. | Перевикористані та інші типи з'єднань включаються. |\n| `reconnect` | Процес | Загальна кількість спроб виконати real\\_connect на вже відкритому з'єднанні. | Наступний код `$link = new mysqli(...); $link->real_connect(...)` призведе до переєднання. Але `$link = new mysqli(...); $link->connect(...)` не приведе, оскільки `$link->connect(...)` примусово закриє існуюче з'єднання перед створенням нового. |\n| `pconnect_success` | З'єднання | Загальна кількість успішних спроб відкрити постійне з'єднання | Обратите внимание, что`connect_success` містить сумарну кількість звичайних та постійних з'єднань. Отже кількість звичайних сполук можна обчислити так: `connect_success` `pconnect_success` |\n| `active_connections` | З'єднання | Загальна кількість активних сполук, як звичайних, і постійних. |  |\n| `active_persistent_connections` | З'єднання | Загальна кількість активних постійних з'єднань. | Загальна кількість активних непостійних з'єднань дорівнює: `active_connections` `active_persistent_connections` |\n| `explicit_close` | З'єднання | Загальна кількість закритих з'єднань (тільки ext/mysqli). | Приклад коду, в якому явно закривається з'єднання: |\n\n```\n$link = new mysqli(...); $link->close(...)\n$link = new mysqli(...); $link->connect(...)\n```\n\n`implicit_close` | Поєднання | Загальна кількість неявно закритих з'єднань (тільки ext/mysqli). | Приклад коду, в якому з'єднання закривається не явно:\n\n-   `$link = new mysqli(...); $link->real_connect(...)`\n    \n-   `unset($link)`\n    \n-   Постійне з'єднання: з'єднання було створено за допомогою real\\_connect і, можливо, з невідомим набором опцій - закривається неявно для запобігання перевикористання з'єднання з невідомим набором опцій\n    \n-   Постійне з'єднання: ping/change\\_user завершуються з помилкою та ext/mysqli закриває з'єднання\n    \n-   Закінчення роботи скрипта: закриваються з'єднання, які не закриті користувачем явно\n    \n\n`disconnect_close` | Поєднання | Помилки з'єднання, що повертаються під час виклику C API **mysql\\_real\\_connect()** під час встановлення з'єднання. | Викликається `disconnect_close`тому, що ідентифікатор з'єднання, переданий у виклик C API, повинен бути закритий. | | `in_middle_of_command_close` | Процес | З'єднання закрито під час виконання команди (результуючий набір не вилучений, після запуску запиту та до отримання відповіді, під час отримання даних, під час завантаження даних за допомогою LOAD DATA). | Якщо ви не використовуєте асинхронні запити, подібне може статися лише в тому випадку, якщо робота скрипту несподівано перервалася і PHP автоматично закрив з'єднання. | | `init_command_executed_count` | Поєднання | Загальна кількість запусків команд, що ініціалізують, наприклад `mysqli_options(MYSQLI_INIT_COMMAND , ...)`. | Кількість успішно запущених команд дорівнює `init_command_executed_count` `init_command_failed_count`. `init_command_failed_count` | Поєднання | Загальна кількість невдалих команд, що ініціалізують. | |\n\n**Статистика mysqlnd: Команди COM\\_\\***\n\n| Метрика | Область применения | Опис | Замечания |\n| --- | --- | --- | --- |\n| `com_quit` `com_init_db` `com_query` `com_field_list` `com_create_db` `com_drop_db` `com_refresh` `com_shutdown` `com_statistics` `com_process_info` `com_connect` `com_process_kill` `com_debug` `com_ping` `com_time` `com_delayed_insert` `com_change_user` `com_binlog_dump` `com_table_dump` `com_connect_out` `com_register_slave` `com_stmt_prepare` `com_stmt_execute` `com_stmt_send_long_data` `com_stmt_close` `com_stmt_reset` `com_stmt_set_option` `com_stmt_fetch` `com_daemon` | З'єднання | Загальна кількість спроб надіслати одну з COM\\_\\* команд із PHP серверу MySQL. |  |\n| Метрика збільшується після перевірки синтаксису команди і перед відсиланням відповідного пакета серверу MySQL. Якщо mysqlnd не вдалося надіслати пакет, метрика не буде зменшена. У разі невдалої посилки mysqlnd поверне попередження Error while sending %s packet. PID=%d. |  |  |  |\n\nПриклади використання:\n\n-   Відстежити, що PHP посилає певні команди серверу, наприклад, що клієнт надсилає`COM_PROCESS_KILL`\n    \n-   Порахувати середню кількість запусків підготовлених запитів, порівнявши`COM_EXECUTE`с`COM_PREPARE`\n    \n-   Перевірити, що PHP виконує непідготовлені запити, переконавшись, що`COM_QUERY`одно нулю\n    \n-   Визначити скрипт PHP, який виконує безліч запитів, перевіривши`COM_QUERY`и`COM_EXECUTE`\n    \n\n**Інше**\n\n**Статистика mysqlnd: Інше**\n\n| Метрика | Область применения | Опис | Замечания |\n| --- | --- | --- | --- |\n| `explicit_stmt_close` `implicit_stmt_close` | Процес | Загальна кількість закритих запитів. | Закриття завжди відбувається явно, крім помилок під час підготовки. |\n| `mem_emalloc_count` `mem_emalloc_ammount` `mem_ecalloc_count` `mem_ecalloc_ammount` `mem_erealloc_count` `mem_erealloc_ammount` `mem_efree_count` `mem_malloc_count` `mem_malloc_ammount` `mem_calloc_count` `mem_calloc_ammount` `mem_realloc_count` `mem_realloc_ammount` `mem_free_count` | Процес | Дзвінки менеджера пам'яті. | Лише для розробників. |\n| `command_buffer_too_small` | З'єднання | Кількість модулів мережного командного буфера під час відправки команди від PHP серверу MySQL. |  |\n| mysqlnd виділяє внутрішній командний/мережевий буфер розміру `mysqlnd.net_cmd_buffer_size` (php.ini) байт для кожного з'єднання. Якщо команда клієнт-серверного протоколу MySQL, наприклад `COM_QUERY` (звичайний запит), що не міститься в ньому, mysqlnd збільшує розмір буфера до необхідного розміру. Щоразу, коли розмір буфера збільшується для з'єднання, `command_buffer_too_small` збільшується на одиницю. |  |  |  |\n\nЯкщо mysqlnd збільшує розмір буфера більше за його початковий розмір `mysqlnd.net_cmd_buffer_size` (php.ini) практично для кожного з'єднання вам варто задуматися про зміну цього значення.\n\nРозмір за замовчуванням буфера становить 4096 байт, що є найменшим можливим значенням. Це значення можна змінити в php.ini, змінивши значення ключа `mysqlnd.net_cmd_buffer_size`или используя`mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int size)`\n\n`connection_reused`\n","title":"Статистика","contentType":2,"navigation":[{"mysqlnd.persist.md":"« Постійне з'єднання"},{"mysqlnd.notes.md":"Зауваження »"},{"index.md":"PHP Manual"},{"book.mysqlnd.md":"Mysqlnd"}]}},"__N_SSG":true}