{"pageProps":{"page":{"slug":"datetimeimmutable.createfromformat.md","content":"# DateTimeImmutable::createFromFormat\n\n# date\\_create\\_immutable\\_from\\_format\n\n(PHP 5 >= 5.5.0, PHP 7, PHP 8)\n\nDateTimeImmutable::createFromFormat -- date\\_create\\_immutable\\_from\\_format — Розбирає рядок з датою згідно з вказаним форматом\n\n### Опис\n\nОб'єктно-орієнтований стиль\n\n```methodsynopsis\npublic static DateTimeImmutable::createFromFormat(string $format, string $datetime, ?DateTimeZone $timezone = null): DateTimeImmutable|false\n```\n\nПроцедурний стиль\n\n```methodsynopsis\ndate_create_immutable_from_format(string $format, string $datetime, ?DateTimeZone $timezone = null): DateTimeImmutable|false\n```\n\nПовертає новий об'єкт DateTimeImmutable, що представляє дату та час, вказані рядком у параметрі `datetime`, які були відформатовані у заданому форматі `format`\n\n### Список параметрів\n\n`format`\n\nФормат дати та часу у вигляді рядка (string), якому відповідає значення другого аргументу функції. Список варіантів форматування наведено нижче. Найчастіше, при форматуванні використовуються самі символи, як і функції [date()](function.date.md)\n\nУсі поля ініціалізуються з поточною датою/часом. У більшості випадків необхідно їх \"обнулити\" (епоха Unix, `1970-01-01 00:00:00 UTC`). Для цього потрібно додати символ `!` як перший символ параметра `format`или в качестве последнего. Для получения дополнительной информации смотрите документацию по каждому символу ниже.\n\nФормат розбирається ліворуч, це означає, що в деяких ситуаціях порядок присутності символів формату впливає на результат. В разі `z` (День року) потрібно, щоб рік уже був розібраний, наприклад, за допомогою символів `Y`или`y`\n\nСимволи для аналізу чисел допускають широкий діапазон значень, що виходить за межі логічного діапазону. Наприклад, `d`(день месяца) принимает значения в диапазоне от`00`до`99`. Єдиним обмеженням є кількість цифр. Коли задаються значення, що виходять за межі діапазону, спрацьовує механізм переповнення аналізатора дати/часу. Нижче показано кілька прикладів такої поведінки.\n\nЦе означає, що розібрані дані для літери формату є жадібними і зчитуватимуться до кількості цифр, що допускається форматом. Також це означає, що у рядку `datetime` не вистачає символів для наступних символів формату. Приклад на цій сторінці також ілюструє проблему.\n\n**Список можливих символів для складання рядка `format`**\n\n| Символ в строке `format` | Опис | Возможные значения |\n| --- | --- | --- |\n| *День* | \\--- | \\--- |\n| `d`и`j` | День місяця, 2 цифри з нулем на початку чи без нього | Від `01`до`31` або від до`31`. . (допускається використання двозначних чисел, що перевищують кількість днів на місяці, у цьому випадку різниця переноситься на наступний місяць. Наприклад, використання числа 33 із січнем означає 2 лютого) |\n| `D`и`l` | Текстова вистава дня тижня | Від `Mon`до`Sun` або від `Sunday`до`Saturday`. . Якщо задане ім'я дня відрізняється від імені дня, що належить розібраній даті (або за замовчуванням), то відбувається переповнення до *наступною* дати із заданим ім'ям дня. Дивіться нижче приклади для пояснення. |\n| `S` | Суфікс для числа в англійській нумерації, 2 літери. Ці літери будуть пропущені при розборі рядка. | `st` `nd` `rd`или`th` |\n| `z` | Номер з початку року (починаючи з 0); має передувати `Y`или`y` | C по`365`. . (Допускаються тризначні числа, що перевищують числа на рік, у цьому випадку різниця переноситься на наступний рік. Наприклад, використання числа 366 з 2022 роком означає 2 січня 2023 року) |\n| *Місяць* | \\--- | \\--- |\n| `F`и`M` | Текстова вистава місяця, наприклад January або Sept | С`January`по`December` або з `Jan`по`Dec` |\n| `m`и`n` | Числове уявлення місяця з першим нулем або без нього | С`01`по`12` або з по`12`. . (Допускаються двоцифрові числа більше 12, у цьому випадку різниця переноситься на наступний рік. Наприклад, використання числа 13 означає січень наступного року) |\n| *Рік* | \\--- | \\--- |\n| `X`и`x` | Повне числове подання року, до 19 цифр, з префіксом `+` или`-` | Приклади: `0055` `787` `1999` `-2003` `+10191` |\n| `Y` | Повне числове уявлення року, до 4 цифр. | Приклади: `0055` `787` `1999` `2003` |\n| `y` | 2 цифри у поданні року (в діапазоні 1970-2069 включно) | Приклади: `99`или`03` (буде розшифровано як `1999`и`2003` відповідно) |\n| *Час* | \\--- | \\--- |\n| `a`и`A` | До полудня та Після полудня | `am`или`pm` |\n| `g`и`h` | 12-ти годинний формат часу з першим нулем або без нього | С по`12` або з `01`по`12`. . (Допускається використання двозначних чисел більше 12, у цьому випадку різниця переноситься на наступний день. Наприклад, використання числа `14` означає `02` у наступному періоді AM/PM) |\n| `G`и`H` | 24-х годинний формат часу з нулем на початку або без нього | С по`23` або з `00`по`23` (Допускаються двоцифрові числа більше 24, у цьому випадку різниця переноситься на наступний день. Наприклад, використання `26` означає `02:00` наступного дня) |\n| `i` | Хвилини з нулем на початку | С`00`по`59`. . (допускається використання двозначних чисел більше 59, у цьому випадку різниця переноситься на наступну годину. Наприклад, використання числа `66` означає `:06` наступної години) |\n| `s` | Секунди з нулем на початку | Від `00`до`59`. . (Допускаються двоцифрові числа більше 59, у цьому випадку різниця переноситься на наступну хвилину. Наприклад, використання числа `90` означає `:30` наступної хвилини) |\n| `v` | Дріб у мілісекундах (до 3 цифр) | Приклади: `12` `0.12` секунд), `345` `0.345` секунд) |\n| `u` | Дріб у мікросекундах (до 6 цифр) | Приклади: `45` `0.45` секунд), `654321` `0.654321` секунд) |\n| *Часовий пояс* | \\--- | \\--- |\n| `e` `O` `P`и`T` | Ідентифікатор часового поясу, або різниця в годиннику щодо UTC, або різниця щодо UTC з двокрапкою між годинником і хвилинами, або абревіатура часового поясу | Приклади: `UTC` `GMT` `Atlantic/Azores`или`+0200`или`+02:00`или`EST` `MDT` |\n| *Дата/Час повністю* | \\--- | \\--- |\n| `U` | Кількість секунд від початку Епохи Unix (January 1 1970 00:00:00 GMT) | Приклад: `1292177455` |\n| *Пробіл та Розділювачі* | \\--- | \\--- |\n| (пробіл) | Нуль або кілька символів пробілу, табуляції, нерозривної пробілу NBSP (U+A0) або вузької нерозривної пробілу NNBSP (U+202F) | Приклад: `\"\\t\"` `\" \"` |\n| `#` | Один із наступних символів: `:` `,` `-` или`) .` | Приклад: |\n| `:` `,` `-` или`) .` | Розділювач символ. | Приклад: `-` |\n| `?` | Один випадковий (будь-який) символ | Приклад: `^` (Будьте уважні: у UTF-8 кодуванні вам може знадобитися більше одного `?` тому що там один символ може займати більше одного байта. У таких випадках може допомогти використання `*` |\n| `*` | Будь-яка кількість будь-яких символів до наступного роздільника | Приклад: `*`в`Y-*-d` для рядка `2009-aWord-08` буде відповідати `aWord` |\n| `!` | Скидає всі поля (рік, місяць, день, година, хвилина, секунда та часовий пояс) до нульових значень ( для години, хвилини, секунди, для місяця та дня, `1970` для року та `UTC` для інформації про часовий пояс). | Без `!` всі поля відповідатимуть поточному часу. |\n| \\` | \\` | Скидає значення незаданих полів (рік, місяць, день, година, хвилина, секунда, часовий пояс) до нульових значень. |\n| `+` | Якщо заданий цей специфікатор, дані, що завершують рядок (нуль байт наприклад) не викликатимуть помилку, тільки попередження | Используйте[DateTime::getLastErrors()](datetime.getlasterrors.md) для визначення, чи були у рядку завершальні символи. |\n\nНаявність у рядку формату символів, що не розпізнаються, відсутніх у списку вище, призведе до помилки розбору рядка. У цьому випадку повідомлення про помилку буде додано до структури, що повертається. Отримати це повідомлення можна за допомогою функції [DateTime::getLastErrors()](datetime.getlasterrors.md)\n\nДля вставки в`format` літерний символ, ви повинні екранувати його за допомогою зворотного слєша(`\\`\n\nЯкщо `format` не містить символ `!`, то значення полів, не заданих у рядку формату, будуть встановлені відповідно до поточного часу.\n\nЯкщо `format` містить символ `!`, то значення полів, не заданих у рядку формату (як і значення полів зліва від `!`) будуть встановлені відповідно до значень полів початку Епохи Unix.\n\nЯкщо будь-який символ часу розібраний, всі інші поля, пов'язані з часом, встановлюються в \"0\", якщо вони також не розібрані.\n\nПочаток епохи Unix 1970-01-01 00:00:00 UTC.\n\n`datetime`\n\nРядок, що представляє час.\n\n`timezone`\n\nОб'єкт класу [DateTimeZone](class.datetimezone.md), що представляє очікуваний часовий пояс.\n\nЯкщо `timezone`не указан или\\*\\*`null`\\*\\*и`datetime` не містить часовий пояс, то буде використано поточний часовий пояс.\n\n> **Зауваження** :\n> \n> Параметр`timezone` і поточний часовий пояс буде проігноровано, якщо параметр `datetime` також містить мітку часу UNIX (тобто timestamp виду `946684800`) або зазначений часовий пояс (тобто `2010-01-28T15:00:00+02:00`\n\n### Значення, що повертаються\n\nПовертає новий екземпляр DateTimeImmutable або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Помилки\n\nФункція викидає [ValueError](class.valueerror.md), якщо параметр `datetime` містить нульові байти.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.2.9 | Специфікатор (пробіл) також підтримує символи нерозривної пробілу NBSP (U+A0) і вузької нерозривної пробілу NNBSP (U+202F). |\n| 8.2.0 | Додані специфікатори `X`и`x`параметру`format` |\n| 8.0.21, 8.1.8, 8.2.0 | Тепер, коли у параметр `datetime` передаються нульові байти, викидається виняток [ValueError](class.valueerror.md), Раніше така ситуація ігнорувалась. |\n| 7.3.0 | Доданий специфікатор `v`параметру`format` |\n\n### Приклади\n\n**Приклад #1 Приклад використання** DateTimeImmutable::createFromFormat()\\*\\*\\*\\*\n\nОб'єктно-орієнтований стиль\n\n```php\n<?php\n$date = DateTimeImmutable::createFromFormat('j-M-Y', '15-Feb-2009');\necho $date->format('Y-m-d');\n?>\n```\n\n**Приклад #2 Використання певних констант формату за допомогою **DateTimeImmutable::createFromFormat()****\n\nОб'єктно-орієнтований стиль\n\n```php\n<?php\n$date = DateTimeImmutable::createFromFormat(DateTimeInterface::ISO8601, '2004-02-12T15:19:21+00:00');\n$date = DateTimeImmutable::createFromFormat(DateTimeInterface::RFC3339_EXTENDED, '2013-10-14T09:00:00.000+02:00');\n?>\n```\n\n[Константи форматування](class.datetimeinterface.md#datetimeinterface.constants.types), що використовуються в даному прикладі, складаються з рядка символів для [форматування](datetime.format.md) об'єкта [DateTimeImmutable](class.datetimeimmutable.md). У більшості випадків ці літери збігаються з тими самими елементами інформації про дату/час, які визначені в параметрах вище, але вони, як правило, більш м'які.\n\n**Приклад #3 Тонкощі **DateTimeImmutable::createFromFormat()****\n\n```php\n<?php\necho 'Текущее время: ' . date('Y-m-d H:i:s') . \"\\n\";\n\n$format = 'Y-m-d';\n$date = DateTimeImmutable::createFromFormat($format, '2009-02-15');\necho \"Формат: $format; \" . $date->format('Y-m-d H:i:s') . \"\\n\";\n\n$format = 'Y-m-d H:i:s';\n$date = DateTimeImmutable::createFromFormat($format, '2009-02-15 15:16:17');\necho \"Формат: $format; \" . $date->format('Y-m-d H:i:s') . \"\\n\";\n\n$format = 'Y-m-!d H:i:s';\n$date = DateTimeImmutable::createFromFormat($format, '2009-02-15 15:16:17');\necho \"Формат: $format; \" . $date->format('Y-m-d H:i:s') . \"\\n\";\n\n$format = '!d';\n$date = DateTimeImmutable::createFromFormat($format, '15');\necho \"Формат: $format; \" . $date->format('Y-m-d H:i:s') . \"\\n\";\n\n$format = 'i';\n$date = DateTimeImmutable::createFromFormat($format, '15');\necho \"Формат: $format; \" . $date->format('Y-m-d H:i:s') . \"\\n\";\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nТекущее время: 2022-06-02 15:50:46\nФормат: Y-m-d; 2009-02-15 15:50:46\nФормат: Y-m-d H:i:s; 2009-02-15 15:16:17\nФормат: Y-m-!d H:i:s; 1970-01-15 15:16:17\nФормат: !d; 1970-01-15 00:00:00\nФормат: i; 2022-06-02 00:15:00\n```\n\n**Приклад #4 Форматування рядка за допомогою літеральних символів**\n\n```php\n<?php\necho DateTimeImmutable::createFromFormat('H\\h i\\m s\\s','23h 15m 03s')->format('H:i:s');\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n23:15:03\n```\n\n**Приклад #5 Поведінка при переповненні**\n\n```php\n<?php\necho DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2021-17-35 16:60:97')->format(DateTimeImmutable::RFC2822);\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nSat, 04 Jun 2022 17:01:37 +0000\n```\n\nХоча результат виглядає дивно, він правильний, тому що трапляються такі переповнення:\n\n1.  `97`секунд перевалюють за хвилину, залишаючи`37`секунд.\n2.  `61`хвилин перевалює за годину, залишаючи хвилину.\n3.  `35`днів перевалюють за місяць, залишаючи `4`дня. Кількість днів залежить від місяця, тому що не в кожному місяці однакова кількість днів.\n4.  `18`місяців перевалюють за рік, залишаючи`6`місяців.\n\n**Приклад #6 Поведінка імені переповненого дня**\n\n```php\n<?php\n$d = DateTime::createFromFormat(DateTimeInterface::RFC1123, 'Mon, 3 Aug 2020 25:00:00 +0000');\necho $d->format(DateTime::RFC1123), \"\\n\";\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nMon, 10 Aug 2020 01:00:00 +0000\n```\n\nХоча результат виглядає дивно, він правильний, тому що трапляються такі переповнення:\n\n1.  `3 Aug 2020 25:00:00`перевалює за`(Tue) 4 Aug 2020 01:00`\n2.  Застосовується`Mon`, що перекладає дату на`Mon, 10 Aug 2020 01:00:00`. Пояснення щодо ключових слів, таких як`Mon`, описано у розділі відносні формати.\n\nДля виявлення переповнень у датах можна використовувати метод [DateTimeImmutable::getLastErrors()](datetimeimmutable.getlasterrors.md), який включатиме попередження, якщо відбулося переповнення.\n\n**Приклад #7 Виявлення переповнення дат**\n\n```php\n<?php\n$d = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2021-17-35 16:60:97');\necho $d->format(DateTimeImmutable::RFC2822), \"\\n\\n\";\n\nvar_dump(DateTimeImmutable::GetLastErrors());\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nSat, 04 Jun 2022 17:01:37 +0000\n\narray(4) {\n  'warning_count' =>\n  int(2)\n  'warnings' =>\n  array(1) {\n    [19] =>\n    string(27) \"The parsed date was invalid\"\n  }\n  'error_count' =>\n  int(0)\n  'errors' =>\n  array(0) {\n  }\n}\n```\n\n**Приклад #8 Жадібна поведінка при розборі**\n\n```php\n<?php\nprint_r(date_parse_from_format('Gis', '60101'));\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nArray\n(\n    [year] =>\n    [month] =>\n    [day] =>\n    [hour] => 60\n    [minute] => 10\n    [second] => 0\n    [fraction] => 0\n    [warning_count] => 1\n    [warnings] => Array\n        (\n            [5] => The parsed time was invalid\n        )\n\n    [error_count] => 1\n    [errors] => Array\n        (\n            [4] => A two digit second could not be found\n        )\n\n    [is_localtime] =>\n)\n```\n\nФормат`G` призначений для розбору 24-годинного годинника з провідним нулем або без нього. Для цього необхідно розібрати 1 чи 2 цифри. Так як є дві наступні цифри, він жадібно зчитує це як `60`\n\nНаступні символи формату `i`и`s` вимагають двох цифр. Це означає, що `10` передається як хвилина (`i`) і що потім залишається недостатньо цифр для розбору секунд (`s`\n\nНа цю проблему вказує масив `errors`\n\nКрім того, година `60`находится вне диапазона -`24`, что добавляет предупреждение в массив`warnings` про те, що час є недійсним.\n\n### Дивіться також\n\n-   [DateTimeImmutable::\\_\\_construct()](datetimeimmutable.construct.md) \\- Повертає новий об'єкт DateTimeImmutable\n-   [DateTimeImmutable::getLastErrors()](datetimeimmutable.getlasterrors.md) \\- Повертає попередження та помилки\n-   [checkdate()](function.checkdate.md) \\- Перевіряє коректність дати за григоріанським календарем\n-   [strptime()](function.strptime.md) \\- Розбирає рядок дати/часу, згенерований функцією strftime\n","title":"DateTimeImmutable::createFromFormat","contentType":2,"navigation":[{"datetimeimmutable.construct.md":"« DateTimeImmutable::\\_\\_construct"},{"datetimeimmutable.createfrominterface.md":"DateTimeImmutable::createFromInterface »"},{"index.md":"PHP Manual"},{"class.datetimeimmutable.md":"DateTimeImmutable"}]}},"__N_SSG":true}