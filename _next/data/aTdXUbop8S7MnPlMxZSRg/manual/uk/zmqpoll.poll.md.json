{"pageProps":{"page":{"slug":"zmqpoll.poll.md","content":"# ZMQPoll::poll\n\n(PECL zmq >= 0.5.0)\n\nZMQPoll::poll — Опитати всі елементи пулу\n\n### Опис\n\n```methodsynopsis\npublic ZMQPoll::poll(array &$readable, array &$writable, int $timeout = -1): int\n```\n\nОпитує всі елементи пулу. Читані та записувані елементи містяться у параметрах `readable`и`writable` відповідно. Для перевірки помилок використовуйте метод [ZMQPoll::getLastErrors()](zmqpoll.getlasterrors.md)\n\n### Список параметрів\n\n`readable`\n\nМасив, в який будуть повернуті об'єкти, що читаються ZMQSockets/потоки PHP. Перед початком роботи масив буде очищений.\n\n`writable`\n\nМасив, в який будуть повернуті записані об'єкти ZMQSockets/потоки PHP. Перед початком роботи масив буде очищений.\n\n`timeout`\n\nЧас очікування операції. -1 означає, що опитування чекатиме до останнього. Зверніть увагу, що з версії 1.0.0 час очікування задається в мілісекундах, а не в мікросекундах, як раніше.\n\n### Значення, що повертаються\n\nПовертає кількість елементів, котрим відбувалася якась активність.\n\n### Помилки\n\nВикидає **ZMQPollException**в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** ZMQPoll()\\*\\*\\*\\*\n\nСтворимо простий сервер опитування\n\n```php\n<?php\n\n/* Создаём сокет, паттерн request-reply (отвечающий сокет) */\n$context = new ZMQContext();\n$server  = $context->getSocket(ZMQ::SOCKET_REP);\n\n/* Привязываем к порту 5555 на адрес 127.0.0.1 */\n$server->bind(\"tcp://127.0.0.1:5555\");\n\n/* Создаём новый пул опроса для входящих/исходящих сообщений */\n$poll = new ZMQPoll();\n\n/* Добавляем объект и слушаем на предмет опроса входящих/исходящих */\n$id = $poll->add($server, ZMQ::POLL_IN | ZMQ::POLL_OUT);\necho \"Added object with id \" . $id . \"\\n\";\n\n/* Инициализируем массив читаемых и записываемых элементов */\n$readable = array();\n$writable = array();\n\nwhile (true) {\n   /* Количество извлечённых событий */\n   $events = 0;\n\n   try {\n       /* Опрашиваем, пока есть что делать */\n       $events = $poll->poll($readable, $writable, -1);\n       $errors = $poll->getLastErrors();\n\n       if (count($errors) > 0) {\n           foreach ($errors as $error) {\n               echo \"Ошибка опроса объекта \" . $error . \"\\n\";\n           }\n       }\n   } catch (ZMQPollException $e) {\n       echo \"Опрос не удался: \" . $e->getMessage() . \"\\n\";\n   }\n\n   if ($events > 0) {\n       /* Перебираем читаемые объекты и получаем сообщения */\n       foreach ($readable as $r) {\n           try {\n               echo \"Получено сообщение: \" . $r->recv() . \"\\n\";\n           } catch (ZMQException $e) {\n               echo \"Ошибка получения: \" . $e->getMessage() . \"\\n\";\n           }\n       }\n\n       /* Перебираем записываемые объекты и отправляем ответы */\n       foreach ($writable as $w) {\n           try {\n               $w->send(\"Получил!\");\n           } catch (ZMQException $e) {\n               echo \"Ошибка отправки: \" . $e->getMessage() . \"\\n\";\n           }\n       }\n   }\n}\n?>\n```\n","title":"ZMQPoll::poll","contentType":2,"navigation":[{"zmqpoll.getlasterrors.md":"« ZMQPoll::getLastErrors"},{"zmqpoll.remove.md":"ZMQPoll::remove »"},{"index.md":"PHP Manual"},{"class.zmqpoll.md":"ZMQPoll"}]}},"__N_SSG":true}