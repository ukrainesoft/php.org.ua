{"pageProps":{"page":{"slug":"function.json-encode.md","content":"# json\\_encode\n\n(PHP 5 >= 5.2.0, PHP 7, PHP 8, PECL json >= 1.2.0)\n\njson\\_encode — Повертає JSON-подання даних\n\n### Опис\n\n```methodsynopsis\njson_encode(mixed $value, int $flags = 0, int $depth = 512): string|false\n```\n\nПовертає рядок, що містить JSON-подання для зазначеного `value`. Якщо параметр масивом (array) або об'єктом (object), він буде рекурсивно серіалізований.\n\nЯкщо значення, що серіалізується, є об'єктом, то за замовчуванням будуть включені тільки публічно видимі властивості. Як альтернатива клас може реалізувати інтерфейс [JsonSerializable](class.jsonserializable.md) для керування тим, як його значення серіалізуються в JSON.\n\nНа кодирование влияет параметр`flags`и, кроме того, кодирование значений типа float зависит от значения[serialize\\_precision](ini.core.md#ini.serialize-precision)\n\n### Список параметрів\n\n`value`\n\n`value` - значення, яке буде закодовано. Можливо будь-якого типу, крім [resource](language.types.resource.md)\n\nФункція працює лише з кодуванням UTF-8.\n\n> **Зауваження** :\n> \n> PHP реалізує надмножина JSON, який описаний у початковому [» RFC 7159](http://www.faqs.org/rfcs/rfc7159)\n\n`flags`\n\nБітова маска, що складається із значень **`JSON_FORCE_OBJECT`** **`JSON_HEX_QUOT`** **`JSON_HEX_TAG`** **`JSON_HEX_AMP`** **`JSON_HEX_APOS`** **`JSON_INVALID_UTF8_IGNORE`** **`JSON_INVALID_UTF8_SUBSTITUTE`** **`JSON_NUMERIC_CHECK`** **`JSON_PARTIAL_OUTPUT_ON_ERROR`** **`JSON_PRESERVE_ZERO_FRACTION`** **`JSON_PRETTY_PRINT`** **`JSON_UNESCAPED_LINE_TERMINATORS`** **`JSON_UNESCAPED_SLASHES`** **`JSON_UNESCAPED_UNICODE`** **`JSON_THROW_ON_ERROR`**. Сенс цих констант пояснюється на [сторінці JSON-констант](json.constants.md)\n\n`depth`\n\nВстановлює максимальну глибину. Має бути більше нуля.\n\n### Значення, що повертаються\n\nПовертає рядок (string), закодований JSON або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.3.0 | Добавлена константа\\*\\*`JSON_THROW_ON_ERROR`\\*\\*для параметра`flags` |\n| 7.2.0 | Додані константи \\*\\*`JSON_INVALID_UTF8_IGNORE`** і **`JSON_INVALID_UTF8_SUBSTITUTE`\\*\\*для параметра`flags` |\n| 7.1.0 | Добавлена константа\\*\\*`JSON_UNESCAPED_LINE_TERMINATORS`\\*\\*для параметра`flags` |\n| 7.1.0 | При кодуванні чисел із плаваючою точкою (float) використовується [serialize\\_precision](ini.core.md#ini.serialize-precision) замість [precision](ini.core.md#ini.precision) |\n\n### Приклади\n\n**Приклад #1 Приклад використання** json\\_encode()\\*\\*\\*\\*\n\n```php\n<?php\n$arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);\n\necho json_encode($arr);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n{\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5}\n```\n\n**Приклад #2 Приклад використання** json\\_encode()\\*\\* з опціями\\*\\*\n\n```php\n<?php\n$a = array('<foo>',\"'bar'\",'\"baz\"','&blong&', \"\\xc3\\xa9\");\n\necho \"Обычно: \",     json_encode($a), \"\\n\";\necho \"Теги: \",       json_encode($a, JSON_HEX_TAG), \"\\n\";\necho \"Апострофы: \",  json_encode($a, JSON_HEX_APOS), \"\\n\";\necho \"Кавычки: \",    json_encode($a, JSON_HEX_QUOT), \"\\n\";\necho \"Амперсанды: \", json_encode($a, JSON_HEX_AMP), \"\\n\";\necho \"Юникод: \",     json_encode($a, JSON_UNESCAPED_UNICODE), \"\\n\";\necho \"Все: \",        json_encode($a, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE), \"\\n\\n\";\n\n$b = array();\n\necho \"Отображение пустого массива как массива: \", json_encode($b), \"\\n\";\necho \"Отображение неассоциативного массива как объекта: \", json_encode($b, JSON_FORCE_OBJECT), \"\\n\\n\";\n\n$c = array(array(1,2,3));\n\necho \"Отображение неассоциативного массива как массива: \", json_encode($c), \"\\n\";\necho \"Отображение неассоциативного массива как объекта: \", json_encode($c, JSON_FORCE_OBJECT), \"\\n\\n\";\n\n$d = array('foo' => 'bar', 'baz' => 'long');\n\necho \"Ассоциативный массив всегда отображается как объект: \", json_encode($d), \"\\n\";\necho \"Ассоциативный массив всегда отображается как объект: \", json_encode($d, JSON_FORCE_OBJECT), \"\\n\\n\";\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nОбычно: [\"<foo>\",\"'bar'\",\"\\\"baz\\\"\",\"&blong&\",\"\\u00e9\"]\nТеги: [\"\\u003Cfoo\\u003E\",\"'bar'\",\"\\\"baz\\\"\",\"&blong&\",\"\\u00e9\"]\nАпострофы: [\"<foo>\",\"\\u0027bar\\u0027\",\"\\\"baz\\\"\",\"&blong&\",\"\\u00e9\"]\nКавычки: [\"<foo>\",\"'bar'\",\"\\u0022baz\\u0022\",\"&blong&\",\"\\u00e9\"]\nАмперсанды: [\"<foo>\",\"'bar'\",\"\\\"baz\\\"\",\"\\u0026blong\\u0026\",\"\\u00e9\"]\nЮникод: [\"<foo>\",\"'bar'\",\"\\\"baz\\\"\",\"&blong&\",\"é\"]\nВсе: [\"\\u003Cfoo\\u003E\",\"\\u0027bar\\u0027\",\"\\u0022baz\\u0022\",\"\\u0026blong\\u0026\",\"é\"]\n\nОтображение пустого массива как массива: []\nОтображение неассоциативного массива как объекта: {}\n\nОтображение неассоциативного массива как массива: [[1,2,3]]\nОтображение неассоциативного массива как объекта: {\"0\":{\"0\":1,\"1\":2,\"2\":3}}\n\nАссоциативный массив всегда отображается как объект: {\"foo\":\"bar\",\"baz\":\"long\"}\nАссоциативный массив всегда отображается как объект: {\"foo\":\"bar\",\"baz\":\"long\"}\n```\n\n**Приклад #3 Приклад використання опції JSON\\_NUMERIC\\_CHECK**\n\n```php\n<?php\necho \"Строки, содержащие числа преобразуются в числа\".PHP_EOL;\n$numbers = array('+123123', '-123123', '1.2e3', '0.00001');\nvar_dump(\n $numbers,\n json_encode($numbers, JSON_NUMERIC_CHECK)\n);\necho \"Строки, содержащие некорректно заданные числа\".PHP_EOL;\n$strings = array('+a33123456789', 'a123');\nvar_dump(\n $strings,\n json_encode($strings, JSON_NUMERIC_CHECK)\n);\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nСтроки, содержащие числа преобразуются в числа\narray(4) {\n  [0]=>\n  string(7) \"+123123\"\n  [1]=>\n  string(7) \"-123123\"\n  [2]=>\n  string(5) \"1.2e3\"\n  [3]=>\n  string(7) \"0.00001\"\n}\nstring(28) \"[123123,-123123,1200,1.0e-5]\"\nСтроки, содержащие некорректно заданные числа\narray(2) {\n  [0]=>\n  string(13) \"+a33123456789\"\n  [1]=>\n  string(4) \"a123\"\n}\nstring(24) \"[\"+a33123456789\",\"a123\"]\"\n```\n\n**Приклад #4 Приклад з послідовними індексами, що починаються з нуля, та непослідовними індексами масивів**\n\n```php\n<?php\necho \"Последовательный массив\".PHP_EOL;\n$sequential = array(\"foo\", \"bar\", \"baz\", \"blong\");\nvar_dump(\n $sequential,\n json_encode($sequential)\n);\n\necho PHP_EOL.\"Непоследовательный массив\".PHP_EOL;\n$nonsequential = array(1=>\"foo\", 2=>\"bar\", 3=>\"baz\", 4=>\"blong\");\nvar_dump(\n $nonsequential,\n json_encode($nonsequential)\n);\n\necho PHP_EOL.\"Последовательный массив с одним удалённым индексом\".PHP_EOL;\nunset($sequential[1]);\nvar_dump(\n $sequential,\n json_encode($sequential)\n);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nПоследовательный массив\narray(4) {\n  [0]=>\n  string(3) \"foo\"\n  [1]=>\n  string(3) \"bar\"\n  [2]=>\n  string(3) \"baz\"\n  [3]=>\n  string(5) \"blong\"\n}\nstring(27) \"[\"foo\",\"bar\",\"baz\",\"blong\"]\"\n\nНепоследовательный массив\narray(4) {\n  [1]=>\n  string(3) \"foo\"\n  [2]=>\n  string(3) \"bar\"\n  [3]=>\n  string(3) \"baz\"\n  [4]=>\n  string(5) \"blong\"\n}\nstring(43) \"{\"1\":\"foo\",\"2\":\"bar\",\"3\":\"baz\",\"4\":\"blong\"}\"\n\nПоследовательный массив с одним удалённым индексом\narray(3) {\n  [0]=>\n  string(3) \"foo\"\n  [2]=>\n  string(3) \"baz\"\n  [3]=>\n  string(5) \"blong\"\n}\nstring(33) \"{\"0\":\"foo\",\"2\":\"baz\",\"3\":\"blong\"}\"\n```\n\n**Приклад #5 Приклад использования опции**`JSON_PRESERVE_ZERO_FRACTION`\\*\\*\\*\\*\n\n```php\n<?php\nvar_dump(json_encode(12.0, JSON_PRESERVE_ZERO_FRACTION));\nvar_dump(json_encode(12.0));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(4) \"12.0\"\nstring(2) \"12\"\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> у разі виникнення помилки кодування можна використовувати [json\\_last\\_error()](function.json-last-error.md) визначення точної помилки.\n\n> **Зауваження** :\n> \n> При кодуванні масиву у разі, якщо його індекси не є послідовними числами від нуля, всі індекси кодуються в рядкові ключі для кожної пари індекс-значення.\n\n> **Зауваження** :\n> \n> Як і еталонний кодувальник JSON, **json\\_encode()** буде створювати JSON у вигляді простого значення (тобто не об'єкт і не масив), якщо йому передані типи string, int, float або bool як вхідне значення `value`. Більшість декодерів сприймають ці значення як правильний JSON, але деякі ні, тому що специфікація неоднозначна щодо цього.\n> \n> Завжди перевіряйте, що ваш декодер JSON може правильно обробляти дані, які ви створюєте за допомогою **json\\_encode()**\n\n### Дивіться також\n\n-   [JsonSerializable](class.jsonserializable.md)\n-   [json\\_decode()](function.json-decode.md) \\- Декодує рядок JSON\n-   [json\\_last\\_error()](function.json-last-error.md) \\- Повертає останню помилку\n-   [serialize()](function.serialize.md) \\- Генерує придатне для зберігання уявлення змінної\n","title":"json\\_encode","contentType":2,"navigation":[{"function.json-decode.md":"« json\\_decode"},{"function.json-last-error-msg.md":"json\\_last\\_error\\_msg »"},{"index.md":"PHP Manual"},{"ref.json.md":"Функції JSON"}]}},"__N_SSG":true}