{"pageProps":{"page":{"slug":"language.oop5.serialization.md","content":"## Серіалізація об'єктів\n\n## Серіалізація об'єктів - збереження об'єктів між сесіями\n\nФункция[serialize()](function.serialize.md) повертає рядкове подання будь-якого значення, яке може бути збережене у PHP. Функція [unserialize()](function.unserialize.md) може використовувати цей рядок для відновлення вихідного значення змінної. Використання серіалізації для збереження об'єкта збереже всі його змінні. Методи в об'єкті не будуть збережені лише ім'я класу.\n\nЩоб десеріалізувати об'єкт функцією [unserialize()](function.unserialize.md)необхідно заздалегідь визначити клас цього об'єкта. Тобто, якщо є екземпляр класу А, і він буде серіалізований, буде отримано його рядкове уявлення, яке містить значення всіх змінних, що містяться в ньому. Щоб відновити об'єкт із рядка в іншому PHP-файлі, клас A повинен бути визначений у цьому файлі заздалегідь. Це можна зробити, наприклад, шляхом збереження визначення класу A в окремому файлі та підключення цього файлу або викликом функції [spl\\_autoload\\_register()](function.spl-autoload-register.md) для автоматичного з'єднання.\n\n```php\n<?php\n// A.php:\n\n  class A {\n      public $one = 1;\n\n      public function show_one() {\n          echo $this->one;\n      }\n  }\n\n// page1.php:\n\n  include \"A.php\";\n\n  $a = new A;\n  $s = serialize($a);\n  // сохраняем $s где-нибудь, откуда page2.php сможет его получить.\n  file_put_contents('store', $s);\n\n// page2.php:\n\n  // это нужно для того, чтобы функция unserialize работала правильно.\n  include \"A.php\";\n\n  $s = file_get_contents('store');\n  $a = unserialize($s);\n\n  // теперь можно использовать метод show_one() объекта $a.\n  $a->show_one();\n?>\n```\n\nЯкщо в додатку серіалізуються об'єкти, які будуть використані в додатку пізніше, слідують суворій рекомендації — підключати визначення класу для цього об'єкта у всьому додатку. При невиконанні цієї вимоги десеріалізація об'єкта пройде без визначення класу, але PHP призначить цьому об'єкту клас **\\_\\_PHP\\_Incomplete\\_Class\\_Name**, що не має методів, і зробить об'єкт марним.\n\nТому, як у прикладі вище, якщо змінна $a стала частиною сесії шляхом додавання нового ключа до суперглобального масиву [$\\_SESSION](reserved.variables.session.md)потрібно підключати файл `A.php` на всіх сторінках, а не лише на сторінках page1.php та page2.php.\n\nЗверніть увагу, що, окрім уже наведеної поради, можна підключитися до подій серіалізації та десеріалізації об'єкта через методи [\\_\\_sleep()](language.oop5.magic.md#object.sleep) і [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup)В методе[\\_\\_sleep()](language.oop5.magic.md#object.sleep) можна керувати тим, які якості об'єкта будуть серіалізовані.\n","title":"Серіалізація об'єктів","contentType":2,"navigation":[{"language.oop5.references.md":"« Об'єкти та посилання"},{"language.oop5.variance.md":"Коваріантність та контраваріантність »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}