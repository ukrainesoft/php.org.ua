{"pageProps":{"page":{"slug":"8.1.md","content":"# PHP 8.1 – велике оновлення PHP. \nВоно містить безліч нових можливостей, включаючи перерахування, readonly-властивості, callback-функції як об'єкти першого класу, файбери, перетин типів, поліпшення продуктивності та багато іншого.\n\n [Переходьте на PHP 8.1!](https://php.net/downloads) \n\n## Перечислення [RFC](https://wiki.php.net/rfc/enumerations) [Документація](/manual/uk/language.enumerations.php) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nclass Status\n{\n    const DRAFT = 'draft';\n    const PUBLISHED = 'published';\n    const ARCHIVED = 'archived';\n}\nfunction acceptStatus(string $status) {...}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nenum Status\n{\n    case Draft;\n    case Published;\n    case Archived;\n}\nfunction acceptStatus(Status $status) {...}\n```\n\nВикористовуйте переліки замість набору констант, щоб валідувати їх автоматично під час виконання коду.\n\n## Readonly-свойства [RFC](https://wiki.php.net/rfc/readonly_properties_v2) [Документація](/manual/uk/language.oop5.properties.php#language.oop5.properties.readonly-properties) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nclass BlogData\n{\n    private Status $status;\n   \n    public function __construct(Status $status) \n    {\n        $this->status = $status;\n    }\n    \n    public function getStatus() : Status \n    {\n        return $this->status;    \n    }\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nclass BlogData\n{\n    public readonly Status $status;\n   \n    public function __construct(Status $status) \n    {\n        $this->status = $status;\n    }\n}\n```\n\nReadonly-властивості не можна змінити після ініціалізації (тобто коли їм було надано значення). \nВони будуть дуже корисні при реалізації об'єктів типу Value Object та Data Transfer Object.\n\n## Callback-функції як об'єкти першого класу [RFC](https://wiki.php.net/rfc/first_class_callable_syntax) [Документація](/manual/uk/functions.first_class_callable_syntax.php) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\n$foo = [$this, 'foo'];\n\n$fn = Closure::fromCallable('strlen') ;\n```\n\nPHP 8.1\n\n```php\n<?php\n\n$foo = $this->foo(...) ;\n\n$fn = strlen(...) ;\n```\n\nЗа допомогою нового синтаксису будь-яка функція може бути об'єктом першого класу. Тим самим вона розглядатиметься як звичайне значення, яке можна, наприклад, зберегти в змінну.\n\n## Розширена ініціалізація об'єктів [RFC](https://wiki.php.net/rfc/new_in_initializers) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nclass Service \n{\n    private Logger $logger;\n \n    public function __construct(\n        ?Logger $logger = null,\n    ) {\n        $this->logger = $logger ?? new NullLogger() ;\n    }\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nclass Service \n{\n    private Logger $logger;\n    \n    public function __construct(\n        Logger $logger = new NullLogger() ,\n    ) {\n        $this->logger = $logger;\n    }\n}\n```\n\nОб'єкти тепер можна використовувати як значення параметрів за умовчанням, статичних змінних і глобальних констант, а також в аргументах атрибутів.\n\nУ такий спосіб з'явилася можливість використання **вкладених атрибутів**\n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nclass User \n{\n    /**\n     * @Assert\\All({\n     *     @Assert\\NotNull,\n     *     @Assert\\Length(min=5) \n     * }) \n     */\n    public string $name = '';\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nclass User \n{\n    # [\\Assert\\All(\n        new \\Assert\\NotNull,\n        new \\Assert\\Length(min: 5) ) \n    ]\n    public string $name = '';\n}\n```\n\n## Перетин типов [RFC](https://wiki.php.net/rfc/pure-intersection-types) [Документація](/manual/uk/language.types.declarations.php#language.types.declarations.composite.intersection) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nfunction count_and_iterate(Iterator $value) {\n    if (!($value instanceof Countable) ) {\n        throw new TypeError('value must be Countable') ;\n    }\n\n    foreach ($value as $val) {\n        echo $val;\n    }\n\n    count($value) ;\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nfunction count_and_iterate(Iterator&Countable $value) {\n    foreach ($value as $val) {\n        echo $val;\n    }\n\n    count($value) ;\n}\n```\n\nТепер в оголошенні типів параметрів можна вказати, що значення має стосуватися кількох типів одночасно.\n\nВ даний момент перетину типів не можна використовувати разом з об'єднаними типами, наприклад, `A&B|C`\n\n## Тип значення, що повертається never [RFC](https://wiki.php.net/rfc/noreturn_type) [Документація](/manual/uk/language.types.declarations.php#language.types.declarations.never) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nfunction redirect(string $uri) {\n    header('Location: ' . $uri) ;\n    exit() ;\n}\n \nfunction redirectToLoginPage() {\n    redirect('/login') ;\n    echo 'Hello'; // <- dead code\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nfunction redirect(string $uri) : never {\n    header('Location: ' . $uri) ;\n    exit() ;\n}\n \nfunction redirectToLoginPage() : never {\n    redirect('/login') ;\n    echo 'Hello'; // <- dead code detected by static analysis \n}\n```\n\nФункція чи метод, оголошені з типом `never`, вказують на те, що вони не повернуть значення або викинуть виняток, або завершать виконання скрипту за допомогою виклику функції `die() ` `exit() ` `trigger_error() ` або чимось подібним.\n\n## Остаточні константи класу [RFC](https://wiki.php.net/rfc/final_class_const) [Документація](/manual/uk/language.oop5.final.php#language.oop5.final.example.php81) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\nclass Foo\n{\n    public const XX = \"foo\";\n}\n\nclass Bar extends Foo\n{\n    public const XX = \"bar\"; // No error\n}\n```\n\nPHP 8.1\n\n```php\n<?php\n\nclass Foo\n{\n    final public const XX = \"foo\";\n}\n\nclass Bar extends Foo\n{\n    public const XX = \"bar\"; // Fatal error\n}\n```\n\nТепер константи класу можна оголосити як остаточні, щоб їх не можна було перевизначити в дочірніх класах.\n\n## Явне вісімкове числове позначення [RFC](https://wiki.php.net/rfc/explicit_octal_notation) [Документація](/manual/uk/migration81.new-features.php#migration81.new-features.core.octal-literal-prefix) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\n016 === 16; // false because `016` is octal for `14` and it's confusing\n016 === 14; // true \n```\n\nPHP 8.1\n\n```php\n<?php\n\n0o16 === 16; // false — not confusing with explicit notation\n0o16 === 14; // true \n```\n\nТепер можна записувати восьмеричні числа з явним префіксом `0o`\n\n## Файбери [RFC](https://wiki.php.net/rfc/fibers) [Документація](/manual/uk/language.fibers.php) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\n$httpClient->request('https://example.com/') \n        ->then(function (Response $response) {\n            return $response->getBody() ->buffer() ;\n        }) \n        ->then(function (string $responseBody) {\n            print json_decode($responseBody)['code'];\n        }) ;\n```\n\nPHP 8.1\n\n```php\n<?php\n\n$response = $httpClient->request('https://example.com/') ;\nprint json_decode($response->getBody() ->buffer() )['code'];\n```\n\nФайбери — це примітиви реалізації полегшеної невитіснюючої конкурентності. Вони є засобом створення блоків коду, які можна призупиняти та відновлювати, як генератори, але з будь-якої точки стека. Файбери власними силами не надають можливостей асинхронного виконання завдань, все одно має бути цикл обробки подій. Однак вони дозволяють блокуючим і неблокуючим реалізаціям використовувати один і той же API.\n\nФайбери дозволяють позбавитися шаблонного коду, який раніше використовувався за допомогою `Promise::then() ` чи корутин на основі генератора. Бібліотеки зазвичай створюють додаткові абстракції навколо файберів, тому немає потреби взаємодіяти безпосередньо з ними.\n\n## Підтримка розпакування масивів з рядковими ключами [RFC](https://wiki.php.net/rfc/array_unpacking_string_keys) [Документація](/manual/uk/language.types.array.php#language.types.array.unpacking) \n\nPHP < 8.1\n\n```php_no_run\n<?php\n\n$arrayA = ['a' => 1];\n$arrayB = ['b' => 2];\n\n$result = array_merge( ['a' => 0], $arrayA, $arrayB) ;\n\n// ['a' => 1, 'b' => 2]\n```\n\nPHP 8.1\n\n```php\n<?php\n\n$arrayA = ['a' => 1];\n$arrayB = ['b' => 2];\n\n$result = ['a' => 0, ...$arrayA, ...$arrayB];\n\n// ['a' => 1, 'b' => 2]\n```\n\nPHP раніше підтримував розпакування масивів за допомогою оператора `...`, але тільки якщо масиви були з цілими ключами. Тепер можна розпаковувати масиви з рядковими ключами.\n\n## Поліпшення продуктивності\n\n**Час запросу демо Symfony** \n25 послідовних запусків за 250 запитами (сек) \n(Менше - краще) \n\n![](https://php.net/images/php8/php81_performance.svg)\n\n### Результат (относительно PHP 8.0) :\n\n- Прискорення демо Symfony на 23,0%\n- Прискорення WordPress на 3,5%\n\n### Функціональність з покращеною продуктивністю в PHP 8.1:\n\n- Бекенд JIT для ARM64 (AArch64).\n- Кеш успадкування (не потрібно зв'язувати класи кожного запиту).\n- Прискорено дозвіл імені класу (виключено перетворення регістру імені та пошук по хешу).\n- Поліпшення продуктивності `timelib` і `ext/date`\n- Поліпшення ітераторів файлової системи SPL.\n- Оптимизация функций`serialize() ``unserialize() `\n- Оптимізація деяких внутрішніх функцій (`get_declared_classes() ` `explode() ` `strtr() ` `strnatcmp() ` `dechex() `\n- Покращення й виправлення JIT.\n\n## Нові класи, інтерфейси та функції\n\n- Доданий новий атрибут `# [ReturnTypeWillChange]`\n- Додані функції `fsync` і `fdatasync`\n- Добавлена новая функция `array_is_list`\n- Нові функції Sodium XChaCha20.\n\n## Застаріла функціональність та зміни у зворотній сумісності\n\n- Передача значення `NULL` параметрам вбудованих функцій, що не допускають значення `NULL`, оголошено застарілою.\n- Попередні типи значень, що повертаються у вбудованих методах класів PHP\n- Інтерфейс `Serializable` оголошено застарілим.\n- Функції кодування/декодування HTML-сутностей за умовчанням перетворюють одинарні лапки і замінюють неприпустимі символи на символ заміни Юнікоду.\n- Обмежено способи використання змінної `$GLOBALS`\n- Модуль MySQLi: режим помилок за замовчуванням встановлено на викидання виключення.\n- Неявне перетворення числа з плаваючою точкою до всього із втратою ненульової дробової частини оголошено застарілим.\n- Модуль finfo: ресурси `file_info` замінені на об'єкти `finfo`\n- Модуль IMAP: ресурси `imap` замінені на об'єкти `IMAP\\Connection`\n- Модуль FTP: ресурси `Connection` замінені на об'єкти `FTP\\Connection`\n- Модуль GD:`Font identifiers` замінені на об'єкти `GdFont`\n- Модуль LDAP: ресурси замінені на об'єкти `LDAP\\Connection` `LDAP\\Result` і `LDAP\\ResultEntry`\n- Модуль PostgreSQL: ресурси замінені на об'єкти `PgSql\\Connection` `PgSql\\Result` і `PgSql\\Lob`\n- Модуль Pspell: ресурси `pspell` `pspell config` замінені на об'єкти `PSpell\\Dictionary` `PSpell\\Config`\n\n## Вище продуктивність, краще синтаксис, надійніша система типів.\n\n [Переходьте на PHP 8.1!](https://php.net/downloads) \n\nЩоб завантажити вихідний код PHP 8.1, відвідайте сторінку [Downloads](https://www.php.net/downloads). Бінарні файли Windows знаходяться на сайті [PHP for Windows](https://windows.php.net/download). Список змін - на сторінці [ChangeLog](https://www.php.net/ChangeLog-8.php#PHP_8_1) \n\n [Руководство по міграции](/manual/uk/migration81.php) у розділі документації. Ознайомтеся з ним, щоб дізнатися про всі нові можливості та зміни, що стосуються зворотної сумісності.\n","title":"8.1","contentType":2}},"__N_SSG":true}