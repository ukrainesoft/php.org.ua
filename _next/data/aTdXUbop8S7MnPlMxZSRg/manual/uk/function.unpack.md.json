{"pageProps":{"page":{"slug":"function.unpack.md","content":"# unpack\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nunpack — Розпакувати дані з бінарного рядка\n\n### Опис\n\n```methodsynopsis\nunpack(string $format, string $string, int $offset = 0): array|false\n```\n\nРозпаковує дані з бінарного рядка в масив відповідно до заданого в `format`формате.\n\nРозпаковані дані зберігаються в асоціативному масиві. Для цього необхідно позначити різні коди форматів і розділити їх за допомогою слеша /. Можна також передати заміщаючий аргумент, за допомогою якого кожен ключ масиву матиме порядковий номер після заданого імені.\n\nДля підтримки сумісності з Perl зроблено таке:\n\n-   Код \"a\" тепер зберігає завершальні NULL-байти.\n-   Код \"A\" тепер видаляє всі завершальні пробіли ASCII (пробіли, табуляцію, переноси рядків, повернення каретки, і NULL-байти).\n-   Код \"Z\" доданий для NULL-доповнених рядків і видаляє завершальні NULL-байти.\n\n### Список параметрів\n\n`format`\n\nСмотрите функцию[pack()](function.pack.md) для роз'яснення форматів кодів.\n\n`string`\n\nЗапаковані дані.\n\n`offset`\n\nЗміщення, з якого необхідно розпочати розпакування.\n\n### Значення, що повертаються\n\nПовертає асоціативний масив, що містить розпаковані елементи бінарного рядка або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.2.0 | Типи float і double підтримують як зворотний, і прямий порядок передачі байтів. |\n| 7.1.0 | Додано необов'язковий параметр `offset` |\n\n### Приклади\n\n**Приклад #1 Приклад використання** unpack()\\*\\*\\*\\*\n\n```php\n<?php\n$binarydata = \"\\x04\\x00\\xa0\\x00\";\n$array = unpack(\"cchars/nint\", $binarydata);\nprint_r($array);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [chars] => 4\n    [int] => 160\n)\n```\n\n**Приклад #2 Приклад використання** unpack()\\*\\* із заміщувальним аргументом\\*\\*\n\n```php\n<?php\n$binarydata = \"\\x04\\x00\\xa0\\x00\";\n$array = unpack(\"c2chars/nint\", $binarydata);\nprint_r($array);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [chars1] => 4\n    [chars2] => 0\n    [int] => 40960\n)\n```\n\n### Примітки\n\n**Застереження**\n\nPHP зберігає цілі значення зі знаком (signed). Якщо розпакувати значення типу large unsigned long і воно матиме той самий розмір, що і PHP, то результатом буде негативне число, навіть якщо було вказано розпаковувати без знака (unsigned).\n\n**Застереження**\n\nЯкщо не назвати елемент, то будуть використані числові індекси, починаючи з . Якщо не позначити більше одного елемента, це означає, що деякі дані будуть перезаписані, так як нумерація перезапускається з для кожного елемента.\n\n**Приклад #3 Приклад використання** unpack()\\*\\* з безіменними ключами\\*\\*\n\n```php\n<?php\n$binarydata = \"\\x32\\x42\\x00\\xa0\";\n$array = unpack(\"c2/n\", $binarydata);\nvar_dump($array);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(2) {\n  [1]=>\n  int(160)\n  [2]=>\n  int(66)\n}\n```\n\nОбратите внимание, что первое значение из спецификатора`c` перезаписується першим значенням із специфікатора `n`\n\n### Дивіться також\n\n-   [pack()](function.pack.md) \\- Упакувати дані у бінарний рядок\n","title":"unpack","contentType":2,"navigation":[{"function.uniqid.md":"« uniqid"},{"function.usleep.md":"usleep »"},{"index.md":"PHP Manual"},{"ref.misc.md":"Різні функції"}]}},"__N_SSG":true}