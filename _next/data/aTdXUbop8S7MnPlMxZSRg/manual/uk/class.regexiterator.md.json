{"pageProps":{"page":{"slug":"class.regexiterator.md","content":"# Клас RegexIterator\n\n(PHP 5 >= 5.2.0, PHP 7, PHP 8)\n\n## Вступ\n\nЦей ітератор можна використовувати для фільтрації іншого ітератора на основі регулярних виразів.\n\n## Огляд класів\n\n```classsynopsis\n\n    \n     class RegexIterator\n    \n\n    \n     extends\n      FilterIterator\n     {\n\n    /* Константы */\n    \n     public\n     const\n     int\n      USE_KEY;\n\n    public\n     const\n     int\n      INVERT_MATCH;\n\n    public\n     const\n     int\n      MATCH;\n\n    public\n     const\n     int\n      GET_MATCH;\n\n    public\n     const\n     int\n      ALL_MATCHES;\n\n    public\n     const\n     int\n      SPLIT;\n\n    public\n     const\n     int\n      REPLACE;\n\n\n    /* Свойства */\n    public\n     ?string\n      $replacement = null;\n\n\n    /* Методы */\n    \n   public __construct(    Iterator $iterator,    string $pattern,    int $mode = RegexIterator::MATCH,    int $flags = 0,    int $pregFlags = 0)\n\n    public accept(): bool\npublic getFlags(): int\npublic getMode(): int\npublic getPregFlags(): int\npublic getRegex(): string\npublic setFlags(int $flags): void\npublic setMode(int $mode): void\npublic setPregFlags(int $pregFlags): void\n\n\n    /* Наследуемые методы */\n    public FilterIterator::accept(): bool\npublic FilterIterator::current(): mixed\npublic FilterIterator::key(): mixed\npublic FilterIterator::next(): void\npublic FilterIterator::rewind(): void\npublic FilterIterator::valid(): bool\n\n    public IteratorIterator::current(): mixed\npublic IteratorIterator::getInnerIterator(): ?Iterator\npublic IteratorIterator::key(): mixed\npublic IteratorIterator::next(): void\npublic IteratorIterator::rewind(): void\npublic IteratorIterator::valid(): bool\n\n   }\n```\n\n## Обумовлені константи\n\n## Режими роботи RegexIterator\n\n**`RegexIterator::ALL_MATCHES`**\n\nПовертати всі збіги для поточного запису (дивіться [preg\\_match\\_all()](function.preg-match-all.md)\n\n**`RegexIterator::GET_MATCH`**\n\nПовертати перший збіг для поточного запису (дивіться [preg\\_match()](function.preg-match.md)\n\n**`RegexIterator::MATCH`**\n\nТільки виконання порівняння (фільтра) для поточного запису (дивіться [preg\\_match()](function.preg-match.md)\n\n**`RegexIterator::REPLACE`**\n\nЗаменить текущую запись (смотрите[preg\\_replace()](function.preg-replace.md); Повністю поки що не реалізовано)\n\n**`RegexIterator::SPLIT`**\n\nПовертати розділені значення для поточного запису (див. [preg\\_split()](function.preg-split.md)\n\n## Прапори RegexIterator\n\n**`RegexIterator::USE_KEY`**\n\nСпеціальний прапорець: Порівняти ключ запису замість значення запису.\n\n**`RegexIterator::INVERT_MATCH`**\n\nІнвертує значення, що повертається [RegexIterator::accept()](regexiterator.accept.md)\n\n## Властивості\n\nreplacement\n\n## Зміст\n\n-   [RegexIterator::accept](regexiterator.accept.md) \\- Перевірка відповідності регулярному виразу\n-   [RegexIterator::\\_\\_construct](regexiterator.construct.md) \\- Конструктор класу RegexIterator\n-   [RegexIterator::getFlags](regexiterator.getflags.md)— Отримання прапорів налаштування\n-   [RegexIterator::getMode](regexiterator.getmode.md)— Повертає режим роботи\n-   [RegexIterator::getPregFlags](regexiterator.getpregflags.md)— Повертає прапори регулярного вираження\n-   [RegexIterator::getRegex](regexiterator.getregex.md)— Повертає рядок поточного регулярного виразу\n-   [RegexIterator::setFlags](regexiterator.setflags.md) \\- Установка прапорів\n-   [RegexIterator::setMode](regexiterator.setmode.md)— Встановлення режиму роботи\n-   [RegexIterator::setPregFlags](regexiterator.setpregflags.md) \\- Завдання прапорів регулярного вираження\n","title":"Клас RegexIterator","contentType":2,"navigation":[{"recursivetreeiterator.valid.md":"« RecursiveTreeIterator::valid"},{"regexiterator.accept.md":"RegexIterator::accept »"},{"index.md":"PHP Manual"},{"spl.iterators.md":"Ітератори"}]}},"__N_SSG":true}