{"pageProps":{"page":{"slug":"class.eventbufferevent.md","content":"# Клас EventBufferEvent\n\n(PECL event >= 1.2.6-beta)\n\n## Вступ\n\nПредставляє буферизовану подію Libevent.\n\nЗазвичай додатку потрібно зробити буферизацію певної кількості даних на додаток до того, щоб легко реагувати на події. Коли ми, наприклад, хочемо записувати дані, звичайний алгоритм має такий вигляд:\n\n1.  Вирішуємо, що нам треба записати дані у з'єднання; складаємо дані у буфер\n    \n2.  Очікуємо, коли з'єднання стане доступним для запису\n    \n3.  Записуємо стільки даних, скільки можемо\n    \n4.  Запам'ятовуємо, скільки даних записали і якщо залишилися недозаписані дані, чекаємо, коли з'єднання знову стане доступним для запису.\n    \n\nЦе шаблон буферизованого вводу/виводу настільки поширений, що Libevent надає вбудований механізм для нього. Буферизована подія складається з транспорту (наприклад сокета), буфера читання та буфера запису. На відміну від стандартних подій, які використовують функцію зворотного виклику, коли транспорт стає доступним для читання або запису, буферизована подія викликає функцію зворотного виклику тоді, коли прочитає або запише достатню кількість даних.\n\n## Огляд класів\n\n```classsynopsis\n\n     \n    \n    \n    \n     \n      final\n      class EventBufferEvent\n     \n     {\n    \n    /* Константы */\n    \n     const\n     int\n      READING = 1;\n\n    const\n     int\n      WRITING = 2;\n\n    const\n     int\n      EOF = 16;\n\n    const\n     int\n      ERROR = 32;\n\n    const\n     int\n      TIMEOUT = 64;\n\n    const\n     int\n      CONNECTED = 128;\n\n    const\n     int\n      OPT_CLOSE_ON_FREE = 1;\n\n    const\n     int\n      OPT_THREADSAFE = 2;\n\n    const\n     int\n      OPT_DEFER_CALLBACKS = 4;\n\n    const\n     int\n      OPT_UNLOCK_CALLBACKS = 8;\n\n    const\n     int\n      SSL_OPEN = 0;\n\n    const\n     int\n      SSL_CONNECTING = 1;\n\n    const\n     int\n      SSL_ACCEPTING = 2;\n\n    /* Свойства */\n    public\n     int\n      $fd;\n\n    public\n     int\n      $priority;\n\n    public\n     readonly\n     EventBuffer\n      $input;\n\n    public\n     readonly\n     EventBuffer\n      $output;\n\n    /* Методы */\n    \n   public\n   close(): void\npublic\n   connect(\n    string\n     $addr\n   ): bool\npublic\n   connectHost(    \n    EventDnsBase\n     $dns_base\n   ,    \n    string\n     $hostname\n   ,    \n    int\n     $port\n   ,    \n    int\n     $family\n     = EventUtil::AF_UNSPEC\n   ): bool\npublic\n   __construct(    \n    EventBase\n     $base\n   ,    \n    mixed\n     $socket\n     = null\n   ,    \n    int\n     $options\n     = 0\n   ,    \n    callable\n     $readcb\n     = null\n   ,    \n    callable\n     $writecb\n     = null\n   ,    \n    callable\n     $eventcb\n     = null\n   ,    \n    mixed\n     $arg\n     = null\n   )\npublic\n   static\n   createPair(\n    EventBase\n     $base\n   , \n    int\n     $options\n     = 0\n   ): array\npublic\n   disable(\n    int\n     $events\n   ): bool\npublic\n   enable(\n    int\n     $events\n   ): bool\npublic\n   free(): void\npublic\n   getDnsErrorString(): string\npublic\n   getEnabled(): int\npublic\n   getInput(): EventBuffer\npublic\n   getOutput(): EventBuffer\npublic\n   read(\n    int\n     $size\n   ): string\npublic\n   readBuffer(\n    EventBuffer\n     $buf\n   ): bool\npublic\n   setCallbacks(    \n    callable\n     $readcb\n   ,    \n    callable\n     $writecb\n   ,    \n    callable\n     $eventcb\n   ,    \n    mixed\n     $arg\n    = ?): void\npublic\n   setPriority(\n    int\n     $priority\n   ): bool\npublic\n   setTimeouts(\n    float\n     $timeout_read\n   , \n    float\n     $timeout_write\n   ): bool\npublic\n   setWatermark(\n    int\n     $events\n   , \n    int\n     $lowmark\n   , \n    int\n     $highmark\n   ): void\npublic\n   sslError(): string\npublic\n   static\n   sslFilter(    \n    EventBase\n     $base\n   ,    \n    EventBufferEvent\n     $underlying\n   ,    \n    EventSslContext\n     $ctx\n   ,    \n    int\n     $state\n   ,    \n    int\n     $options\n     = 0\n   ): EventBufferEvent\npublic\n   sslGetCipherInfo(): string\npublic\n   sslGetCipherName(): string\npublic\n   sslGetCipherVersion(): string\npublic\n   sslGetProtocol(): string\npublic\n   sslRenegotiate(): void\npublic\n   static\n   sslSocket(    \n    EventBase\n     $base\n   ,    \n    mixed\n     $socket\n   ,    \n    EventSslContext\n     $ctx\n   ,    \n    int\n     $state\n   ,    \n    int\n     $options\n    = ?): EventBufferEvent\npublic\n   write(\n    string\n     $data\n   ): bool\npublic\n   writeBuffer(\n    EventBuffer\n     $buf\n   ): bool\n\n   }\n```\n\n## Властивості\n\nfd\n\nЧисловий файловий дескриптор пов'язаний із буферизованим сокетом. Зазвичай є пов'язаним сокетом. Рівний \\*\\*`null`\\*\\*якщо відсутній файловий дескриптор (сокет) пов'язаний з буферизованим подією.\n\npriority\n\nПріоритет подій, які використовуються для буферизованих подій.\n\ninput\n\nНижчележачий об'єкт вхідного буфера ( [EventBuffer](class.eventbuffer.md)\n\noutput\n\nНижчележачий об'єкт вихідного буфера ( [EventBuffer](class.eventbuffer.md)\n\n## Обумовлені константи\n\n**`EventBufferEvent::READING`**\n\nПодія сталася в момент операції читання з буферевенти. Перевірте інші прапори цієї події.\n\n**`EventBufferEvent::WRITING`**\n\nПодія сталася в момент операції запису в буферевенті. Перевірте інші прапори цієї події.\n\n**`EventBufferEvent::EOF`**\n\nОтримано ознаку кінця файлу для буферизованого події.\n\n**`EventBufferEvent::ERROR`**\n\nВідбулася помилка під час операції з буфером. Детальну інформацію про помилку можна отримати за допомогою методів [EventUtil::getLastSocketErrno()](eventutil.getlastsocketerrno.md)и/или[EventUtil::getLastSocketError()](eventutil.getlastsocketerror.md)\n\n**`EventBufferEvent::TIMEOUT`**\n\n**`EventBufferEvent::CONNECTED`**\n\nЗапитане з'єднання з bufferevent встановлено.\n\n**`EventBufferEvent::OPT_CLOSE_ON_FREE`**\n\nЗакрити транспорт, що знаходиться нижче, коли об'єкт буферизованої події знищено. Буде закрито сокет, знищено буфер тощо.\n\n**`EventBufferEvent::OPT_THREADSAFE`**\n\nАвтоматично розміщувати блокування для bufferevent, що дозволяє безпечно використовувати багатопоточність.\n\n**`EventBufferEvent::OPT_DEFER_CALLBACKS`**\n\nКоли прапор встановлено, bufferevent відкладає всі функції зворотного виклику. Дивіться [» Швидке, переносне, неблокуюче мережне програмування з Libevent та відкладеними функціями зворотного виклику (Deferred callbacks)](http://www.wangafu.net/~nickm/libevent-book/Ref6_bufferevent.md#_deferred_callbacks)\n\n**`EventBufferEvent::OPT_UNLOCK_CALLBACKS`**\n\nЗа замовчуванням, коли bufferevent налаштований як потокобезпечний, для буферизованого події будуть зберігатися блокування при запуску будь-яких функцій користувача зворотного виклику. Установка цього прапора каже Libevent прибирати блокування під час виклику цих callback-функцій.\n\n**`EventBufferEvent::SSL_OPEN`**\n\nПідтвердження SSL завершено\n\n**`EventBufferEvent::SSL_CONNECTING`**\n\nВ даний момент SSL бере участь у встановленні з'єднання як клієнт\n\n**`EventBufferEvent::SSL_ACCEPTING`**\n\nВ даний момент SSL бере участь у встановленні з'єднання як сервер\n\n## Зміст\n\n-   [EventBufferEvent::close](eventbufferevent.close.md)— Закриває дескриптор файлу, пов'язаний із поточною подією буфера\n-   [EventBufferEvent::connect](eventbufferevent.connect.md)— Підключає файловий дескриптор події буфера до вказаної адреси або сокету UNIX\n-   [EventBufferEvent::connectHost](eventbufferevent.connecthost.md)— Підключається на ім'я хоста з можливістю асинхронного дозволу DNS\n-   [EventBufferEvent::\\_\\_construct](eventbufferevent.construct.md)— Створює об'єкт EventBufferEvent\n-   [EventBufferEvent::createPair](eventbufferevent.createpair.md)— Створює дві буферні події, пов'язані одна з одною\n-   [EventBufferEvent::disable](eventbufferevent.disable.md)— Вимикає читання, запис або те й інше у події буфера\n-   [EventBufferEvent::enable](eventbufferevent.enable.md)— Включає читання, запис або те й інше у події буфера\n-   [EventBufferEvent::free](eventbufferevent.free.md) \\- Звільняє подію буфера\n-   [EventBufferEvent::getDnsErrorString](eventbufferevent.getdnserrorstring.md)— Повертає рядок, який описує останню невдалу спробу пошуку DNS\n-   [EventBufferEvent::getEnabled](eventbufferevent.getenabled.md)— Повертає бітову маску подій, які активовані для буферної події.\n-   [EventBufferEvent::getInput](eventbufferevent.getinput.md)— Повертає базовий вхідний буфер, пов'язаний із поточною буферною подією\n-   [EventBufferEvent::getOutput](eventbufferevent.getoutput.md)— Повертає базовий вихідний буфер, пов'язаний із поточною буферною подією\n-   [EventBufferEvent::read](eventbufferevent.read.md) \\- Читає дані буфера\n-   [EventBufferEvent::readBuffer](eventbufferevent.readbuffer.md)— Зливає весь вміст буфера введення та поміщає його у буфер.\n-   [EventBufferEvent::setCallbacks](eventbufferevent.setcallbacks.md)— Призначає callback-функції для читання, запису та події (стану)\n-   [EventBufferEvent::setPriority](eventbufferevent.setpriority.md) \\- Надає пріоритет bufferevent\n-   [EventBufferEvent::setTimeouts](eventbufferevent.settimeouts.md)— Встановлює час очікування читання та запису для події буфера\n-   [EventBufferEvent::setWatermark](eventbufferevent.setwatermark.md)— Регулює водяні знаки читання та/або запису\n-   [EventBufferEvent::sslError](eventbufferevent.sslerror.md)— Повертає останню помилку OpenSSL, повідомлену буферною подією\n-   [EventBufferEvent::sslFilter](eventbufferevent.sslfilter.md)— Створює нову подію буфера SSL для надсилання своїх даних через іншу подію буфера\n-   [EventBufferEvent::sslGetCipherInfo](eventbufferevent.sslgetcipherinfo.md)— Повертає текстовий опис шифру\n-   [EventBufferEvent::sslGetCipherName](eventbufferevent.sslgetciphername.md)— Повертає поточне ім'я шифру з'єднання SSL\n-   [EventBufferEvent::sslGetCipherVersion](eventbufferevent.sslgetcipherversion.md)— Повертає версію шифру, який використовується поточним SSL-з'єднанням.\n-   [EventBufferEvent::sslGetProtocol](eventbufferevent.sslgetprotocol.md)— Повертає ім'я протоколу, який використовується для поточного з'єднання SSL.\n-   [EventBufferEvent::sslRenegotiate](eventbufferevent.sslrenegotiate.md)— Повідомляє буферну подію розпочати перегляд SSL\n-   [EventBufferEvent::sslSocket](eventbufferevent.sslsocket.md)— Створює нову буферну подію SSL для надсилання своїх даних через SSL у сокет\n-   [EventBufferEvent::write](eventbufferevent.write.md)— Додає дані до буфера виводу буферної події\n-   [EventBufferEvent::writeBuffer](eventbufferevent.writebuffer.md)— Додає вміст буфера в буфер виводу буферної події\n","title":"Клас EventBufferEvent","contentType":2,"navigation":[{"eventbuffer.write.md":"« EventBuffer::write"},{"eventbufferevent.close.md":"EventBufferEvent::close »"},{"index.md":"PHP Manual"},{"book.event.md":"Event"}]}},"__N_SSG":true}