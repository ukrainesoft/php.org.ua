- [« Значення перерахування у постійних
виразах](language.enumerations.expressions.md)
- [Список значень»] (language.enumerations.listing.md)

- [PHP Manual](index.md)
- [Перерахування](language.enumerations.md)
- Відмінності від об'єктів

## Відмінності від об'єктів

Хоча перерахування побудовані на класах та об'єктах, вони не підтримують
всі функціональні можливості пов'язані з об'єктами. Зокрема,
варіантів перерахувань заборонено мати стан.

- Конструктори та деструктори заборонені.
- Спадкування не підтримується. Переліки не можуть успадковувати
або успадковуватися.
- Статичні властивості чи властивості об'єкта не допускаються.
- Клонування варіанта перерахування не підтримується, оскільки
варіанти мають бути одноелементними екземплярами.
- [Магічні методи](language.oop5.magic.md), крім перерахованих
нижче, заборонено.

Доступні такі функціональні можливості об'єкта, що ведуть
себе так само, як і для будь-якого іншого об'єкта:

- методи public, private і protected.
- Статичні методи public, private та protected.
- Константи public, private і protected.
- Переліки можуть здійснювати будь-яку кількість інтерфейсів.
- До перерахунків та варіантів можуть бути додані
[атрибути](language.attributes.md). Цільовий фільтр
**`TARGET_CLASS`** включає самі перерахування. Цільовий фільтр
**`TARGET_CLASS_CONST`** включає варіанти перерахувань.
- Магічні методи
[\_\_call](language.oop5.overloading.md#object.call),
[\_\_callStatic](language.oop5.overloading.md#object.callstatic),
та [\_\_invoke](language.oop5.magic.md#object.invoke).
- Константи **`__CLASS__`** та **`__FUNCTION__`** поводяться як
зазвичай.

Магічна константа `::class` для типу перерахунку оцінює ім'я типу,
включаючи будь-який простір імен, так само, як об'єкт. Магічна
константа `::class` в екземплярі варіанта також оцінюється як тип
перерахування, оскільки є екземпляром цього типу.

Крім того, варіанти перерахування не можуть бути створені безпосередньо з
допомогою `new` або за допомогою
[ReflectionClass::newInstanceWithoutConstructor()](reflectionclass.newinstancewithoutconstructor.md).
Обидва способи призведуть до помилки.

` <?php$clovers u003d new Suit();// Error: Cannot instantiate enum Suit$horseshoes u003d (new ReflectionClass(Suit::class))->newInstanceWithoutConstructor()// u
