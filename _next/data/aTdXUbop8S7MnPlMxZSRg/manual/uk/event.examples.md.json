{"pageProps":{"page":{"slug":"event.examples.md","content":"# Приклади\n\n**Приклад #1 Простий клієнт HTTP**\n\n```php\n<?php\n// Функция обратного вызова обработки чтения\nfunction readcb($bev, $base) {\n    //$input = $bev->input; //$bev->getInput();\n\n    //$pos = $input->search(\"TTP\");\n    $pos = $bev->input->search(\"TTP\");\n\n    while (($n = $bev->input->remove($buf, 1024)) > 0) {\n        echo $buf;\n    }\n}\n\n// Функция обратного вызова обработки события\nfunction eventcb($bev, $events, $base) {\n    if ($events & EventBufferEvent::CONNECTED) {\n        echo \"Соединение установлено.\\n\";\n    } elseif ($events & (EventBufferEvent::ERROR | EventBufferEvent::EOF)) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"Ошибка DNS: \", $bev->getDnsErrorString(), PHP_EOL;\n        }\n\n        echo \"Закрываем соединение\\n\";\n        $base->exit();\n        exit(\"Готово\\n\");\n    }\n}\n\nif ($argc != 3) {\n    echo <<<EOS\nTrivial HTTP 0.x client\nSyntax: php {$argv[0]} [hostname] [resource]\nExample: php {$argv[0]} www.google.com /\n\nEOS;\n    exit();\n}\n\n$base = new EventBase();\n\n$dns_base = new EventDnsBase($base, TRUE); // Используем асинхронный запрос к DNS\nif (!$dns_base) {\n    exit(\"Failed to init DNS Base\\n\");\n}\n\n$bev = new EventBufferEvent($base, /* используем внутренний сокет */ NULL,\n    EventBufferEvent::OPT_CLOSE_ON_FREE | EventBufferEvent::OPT_DEFER_CALLBACKS,\n    \"readcb\", /* writecb */ NULL, \"eventcb\"\n);\nif (!$bev) {\n    exit(\"Ошибка создания сокета bufferevent\\n\");\n}\n\n//$bev->setCallbacks(\"readcb\", /* writecb */ NULL, \"eventcb\", $base);\n$bev->enable(Event::READ | Event::WRITE);\n\n$output = $bev->output; //$bev->getOutput();\nif (!$output->add(\n    \"GET {$argv[2]} HTTP/1.0\\r\\n\".\n    \"Host: {$argv[1]}\\r\\n\".\n    \"Connection: Close\\r\\n\\r\\n\"\n)) {\n    exit(\"Ошибка добавления запроса в буфер вывода\\n\");\n}\n\nif (!$bev->connectHost($dns_base, $argv[1], 80, EventUtil::AF_UNSPEC)) {\n    exit(\"Невозможно установить соединение с {$argv[1]}\\n\");\n}\n\n$base->dispatch();\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nСоединение установлено.\nHTTP/1.1 301 Moved Permanently\nDate: Fri, 01 Mar 2013 18:47:48 GMT\nLocation: http://www.google.co.uk/\nContent-Type: text/html; charset=UTF-8\nCache-Control: public, max-age=2592000\nServer: gws\nContent-Length: 221\nX-XSS-Protection: 1; mode=block\nX-Frame-Options: SAMEORIGIN\nAge: 133438\nExpires: Sat, 30 Mar 2013 05:39:28 GMT\nConnection: close\n\n<HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<TITLE>301 Moved</TITLE></HEAD><BODY>\n<H1>301 Moved</H1>\nThe document has moved\n<A HREF=\"http://www.google.co.uk/\">here</A>.\n</BODY></HTML>\nЗакрываем соединение\nГотово\n```\n\n**Приклад #2 HTTP клієнт із асинхронним запитом до DNS**\n\n```php\n<?php\n/*\n * 1. Соединяемся с 127.0.0.1 на порту 80\n * посредством EventBufferEvent::connect().\n *\n * 2. Запрашиваем /index.cphp по протоколу HTTP/1.0\n * используя буфер вывода.\n *\n * 3. Асинхорнно читаем ответ и выводим его в stdout.\n */\n\n// Функция обратного вызова обработки чтения\nfunction readcb($bev, $base) {\n    $input = $bev->getInput();\n\n    while (($n = $input->remove($buf, 1024)) > 0) {\n        echo $buf;\n    }\n}\n\n// Функция обратного вызова обработки события\nfunction eventcb($bev, $events, $base) {\n    if ($events & EventBufferEvent::CONNECTED) {\n        echo \"Соединение установлено.\\n\";\n    } elseif ($events & (EventBufferEvent::ERROR | EventBufferEvent::EOF)) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"Ошибка DNS: \", $bev->getDnsErrorString(), PHP_EOL;\n        }\n\n        echo \"Закрываем соединение\\n\";\n        $base->exit();\n        exit(\"Готово\\n\");\n    }\n}\n\n$base = new EventBase();\n\necho \"step 1\\n\";\n$bev = new EventBufferEvent($base, /* используем внутренний сокет*/ NULL,\n    EventBufferEvent::OPT_CLOSE_ON_FREE | EventBufferEvent::OPT_DEFER_CALLBACKS);\nif (!$bev) {\n    exit(\"Ошибка создания сокета bufferevent\\n\");\n}\n\necho \"step 2\\n\";\n$bev->setCallbacks(\"readcb\", /* writecb */ NULL, \"eventcb\", $base);\n$bev->enable(Event::READ | Event::WRITE);\n\necho \"step 3\\n\";\n// Посылаем запрос\n$output = $bev->getOutput();\nif (!$output->add(\n    \"GET /index.cphp HTTP/1.0\\r\\n\".\n    \"Connection: Close\\r\\n\\r\\n\"\n)) {\n    exit(\"Ошибка добавления запроса в буфер вывода\\n\");\n}\n\n/* Синхронно соединяемся с хостом.\nМы знаем IP и не нуждаемся в запросе к DNS. */\nif (!$bev->connect(\"127.0.0.1:80\")) {\n    exit(\"Не удалось установить соединение\\n\");\n}\n\n// Обрабатываем ожидающие события\n$base->dispatch();\n?>\n```\n\n**Приклад #3 Ехо-сервер**\n\n```php\n<?php\n/*\n * Простой эхо-сервер на базе слушателя соединений libevent\n *\n * Использование:\n * 1) В первом терминальном окне запускаем:\n *\n * $ php listener.php 9881\n *\n * 2) Во втором терминальном окне открываем соединение:\n *\n * $ nc 127.0.0.1 9881\n *\n * 3) Начинаем печатать. Сервер должен повторять наш ввод.\n */\n\nclass MyListenerConnection {\n    private $bev, $base;\n\n    public function __destruct() {\n        $this->bev->free();\n    }\n\n    public function __construct($base, $fd) {\n        $this->base = $base;\n\n        $this->bev = new EventBufferEvent($base, $fd, EventBufferEvent::OPT_CLOSE_ON_FREE);\n\n        $this->bev->setCallbacks(array($this, \"echoReadCallback\"), NULL,\n            array($this, \"echoEventCallback\"), NULL);\n\n        if (!$this->bev->enable(Event::READ)) {\n            echo \"Не удалось разрешить чтение (READ)\\n\";\n            return;\n        }\n    }\n\n    public function echoReadCallback($bev, $ctx) {\n        // Копируем все данные из буфера ввода в буфер вывода\n\n        // Вариант #1\n        $bev->output->addBuffer($bev->input);\n\n        /* Вариант #2 */\n        /*\n        $input    = $bev->getInput();\n        $output = $bev->getOutput();\n        $output->addBuffer($input);\n        */\n    }\n\n    public function echoEventCallback($bev, $events, $ctx) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"Ошибка bufferevent\\n\";\n        }\n\n        if ($events & (EventBufferEvent::EOF | EventBufferEvent::ERROR)) {\n            //$bev->free();\n            $this->__destruct();\n        }\n    }\n}\n\nclass MyListener {\n    public $base,\n        $listener,\n        $socket;\n    private $conn = array();\n\n    public function __destruct() {\n        foreach ($this->conn as &$c) $c = NULL;\n    }\n\n    public function __construct($port) {\n        $this->base = new EventBase();\n        if (!$this->base) {\n            echo \"Не удаётся создать EventBase\";\n            exit(1);\n        }\n\n        // Вариант #1\n        /*\n        $this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        if (!socket_bind($this->socket, '0.0.0.0', $port)) {\n            echo \"Невозможно назначить сокет\\n\";\n            exit(1);\n        }\n        $this->listener = new EventListener($this->base,\n            array($this, \"acceptConnCallback\"), $this->base,\n            EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE,\n            -1, $this->socket);\n         */\n\n        // Вариант #2\n         $this->listener = new EventListener($this->base,\n             array($this, \"acceptConnCallback\"), $this->base,\n             EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE, -1,\n             \"0.0.0.0:$port\");\n\n        if (!$this->listener) {\n            echo \"Невозможно создать слушателя\";\n            exit(1);\n        }\n\n        $this->listener->setErrorCallback(array($this, \"accept_error_cb\"));\n    }\n\n    public function dispatch() {\n        $this->base->dispatch();\n    }\n\n    // Эта функция обратного вызова будет вызвана, если в $bev есть данные для чтения\n    public function acceptConnCallback($listener, $fd, $address, $ctx) {\n        // У нас новое соединение! Настроим bufferevent для него. */\n        $base = $this->base;\n        $this->conn[] = new MyListenerConnection($base, $fd);\n    }\n\n    public function accept_error_cb($listener, $ctx) {\n        $base = $this->base;\n\n        fprintf(STDERR, \"Ошибка слушателя: %d (%s). \"\n            .\"Аварийная остановка.\\n\",\n            EventUtil::getLastSocketErrno(),\n            EventUtil::getLastSocketError());\n\n        $base->exit(NULL);\n    }\n}\n\n$port = 9808;\n\nif ($argc > 1) {\n    $port = (int) $argv[1];\n}\nif ($port <= 0 || $port > 65535) {\n    exit(\"Некорректный порт\");\n}\n\n$l = new MyListener($port);\n$l->dispatch();\n?>\n```\n\n**Приклад #4 SSL луна-сервер**\n\n```php\n<?php\n/*\n * SSL эхо-сервер\n *\n * Для тестирования:\n * 1) Запустите:\n * $ php examples/ssl-echo-server/server.php 9998\n *\n * 2) В другом окне:\n * $ socat - SSL:127.0.0.1:9998,verify=1,cafile=examples/ssl-echo-server/cert.pem\n */\n\nclass MySslEchoServer {\n    public $port,\n        $base,\n        $bev,\n        $listener,\n        $ctx;\n\n    function __construct ($port, $host = \"127.0.0.1\") {\n        $this->port = $port;\n        $this->ctx = $this->init_ssl();\n        if (!$this->ctx) {\n            exit(\"Невозможно создать контекст SSL\\n\");\n        }\n\n        $this->base = new EventBase();\n        if (!$this->base) {\n            exit(\"Невозможно создать EventBase\\n\");\n        }\n\n        $this->listener = new EventListener($this->base,\n            array($this, \"ssl_accept_cb\"), $this->ctx,\n            EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE,\n            -1, \"$host:$port\");\n        if (!$this->listener) {\n            exit(\"невозможно создать слушателя\\n\");\n        }\n\n        $this->listener->setErrorCallback(array($this, \"accept_error_cb\"));\n    }\n    function dispatch() {\n        $this->base->dispatch();\n    }\n\n    // Эта функция обратного вызова будет вызвана, если в $bev есть данные для чтения\n    function ssl_read_cb($bev, $ctx) {\n        $in = $bev->input; //$bev->getInput();\n\n        printf(\"Received %zu bytes\\n\", $in->length);\n        printf(\"----- data ----\\n\");\n        printf(\"%ld:\\t%s\\n\", (int) $in->length, $in->pullup(-1));\n\n        $bev->writeBuffer($in);\n    }\n\n    // Эта функция обратного вызова будет вызвана, если на слушателя придёт событие,\n    // наПриклад если закроется соединение или произойдёт ошибка\n    function ssl_event_cb($bev, $events, $ctx) {\n        if ($events & EventBufferEvent::ERROR) {\n            // Извлекаем ошибку из стека ошибок SSL\n            while ($err = $bev->sslError()) {\n                fprintf(STDERR, \"Ошибка bufferevent: %s.\\n\", $err);\n            }\n        }\n\n        if ($events & (EventBufferEvent::EOF | EventBufferEvent::ERROR)) {\n            $bev->free();\n        }\n    }\n\n    // Эта функция обратного вызова будет вызвана, когда клиент примет новое соединение\n    function ssl_accept_cb($listener, $fd, $address, $ctx) {\n        // У нас новое соединение! Настроим bufferevent для него.\n        $this->bev = EventBufferEvent::sslSocket($this->base, $fd, $this->ctx,\n            EventBufferEvent::SSL_ACCEPTING, EventBufferEvent::OPT_CLOSE_ON_FREE);\n\n        if (!$this->bev) {\n            echo \"Failed creating ssl buffer\\n\";\n            $this->base->exit(NULL);\n            exit(1);\n        }\n\n        $this->bev->enable(Event::READ);\n        $this->bev->setCallbacks(array($this, \"ssl_read_cb\"), NULL,\n            array($this, \"ssl_event_cb\"), NULL);\n    }\n\n    // Эта функция обратного вызова будет вызвана, если не удастся создать новое соединение\n    function accept_error_cb($listener, $ctx) {\n        fprintf(STDERR, \"Ошибка слушателя: %d (%s). \"\n            .\"Shutting down.\\n\",\n            EventUtil::getLastSocketErrno(),\n            EventUtil::getLastSocketError());\n\n        $this->base->exit(NULL);\n    }\n\n    // Инициализируем структуры SSL, создаём EventSslContext\n    // Опционально создаём самоподписанный сертификат\n    function init_ssl() {\n        // Нам *необходима* энтропия. Иначе в криптографии нет смысла.\n        if (!EventUtil::sslRandPoll()) {\n            exit(\"EventUtil::sslRandPoll failed\\n\");\n        }\n\n        $local_cert = __DIR__.\"/cert.pem\";\n        $local_pk   = __DIR__.\"/privkey.pem\";\n\n        if (!file_exists($local_cert) || !file_exists($local_pk)) {\n            echo \"Невозможно прочитать $local_cert или $local_pk file.  Для генерации ключа\\n\",\n                \"и самоподписанного сертификата, запустите:\\n\",\n                \"  openssl genrsa -out $local_pk 2048\\n\",\n                \"  openssl req -new -key $local_pk -out cert.req\\n\",\n                \"  openssl x509 -req -days 365 -in cert.req -signkey $local_pk -out $local_cert\\n\";\n\n            return FALSE;\n        }\n\n        $ctx = new EventSslContext(EventSslContext::SSLv3_SERVER_METHOD, array (\n             EventSslContext::OPT_LOCAL_CERT  => $local_cert,\n             EventSslContext::OPT_LOCAL_PK    => $local_pk,\n             //EventSslContext::OPT_PASSPHRASE  => \"echo server\",\n             EventSslContext::OPT_VERIFY_PEER => true,\n             EventSslContext::OPT_ALLOW_SELF_SIGNED => false,\n        ));\n\n        return $ctx;\n    }\n}\n\n// Разрешаем переопределение порта\n$port = 9999;\nif ($argc > 1) {\n    $port = (int) $argv[1];\n}\nif ($port <= 0 || $port > 65535) {\n    exit(\"Некорректный порт\\n\");\n}\n\n\n$l = new MySslEchoServer($port);\n$l->dispatch();\n?>\n```\n\n**Приклад #5 Обробник сигналів**\n\n```php\n<?php\n/*\nЗапустите в терминальном окне:\n\n$ php examples/signal.php\n\nВ другом терминальном окне найдите pid этого процесса и пошлите ему сигнал SIGTERM:\n\n$ ps aux | grep examp\nruslan    3976  0.2  0.0 139896 11256 pts/1    S+   10:25   0:00 php examples/signal.php\nruslan    3978  0.0  0.0   9572   864 pts/2    S+   10:26   0:00 grep --color=auto examp\n$ kill -TERM 3976\n\nВ первом окне вы должны увидить следующее::\n\nПойман сигнал 15\n*/\n\nclass MyEventSignal {\n    private $base;\n\n    function __construct($base) {\n        $this->base = $base;\n    }\n\n    function eventSighandler($no, $c) {\n        echo \"Пойман сигнал $no\\n\";\n        event_base_loopexit($c->base);\n    }\n}\n\n$base = event_base_new();\n$c    = new MyEventSignal($base);\n$no   = SIGTERM;\n$ev   = evsignal_new($base, $no, array($c,'eventSighandler'), $c);\n\nevsignal_add($ev);\n\nevent_base_loop($base);\n?>\n```\n\n**Приклад #6 Использование цикла libevent для обработки запросов модуля\\`eio'**\n\n```php\n<?php\n// Функция обратного вызова для eio_nop()\nfunction my_nop_cb($d, $r) {\n    echo \"step 6\\n\";\n}\n\n$dir = \"/tmp/abc-eio-temp\";\nif (file_exists($dir)) {\n    rmdir($dir);\n}\n\necho \"step 1\\n\";\n\n$base = new EventBase();\n\necho \"step 2\\n\";\n\neio_init();\n\neio_mkdir($dir, 0750, EIO_PRI_DEFAULT, \"my_nop_cb\");\n\n$event = new Event($base, eio_get_event_stream(),\n    Event::READ | Event::PERSIST, function ($fd, $events, $base) {\n    echo \"step 5\\n\";\n\n    while (eio_nreqs()) {\n        eio_poll();\n    }\n\n    $base->stop();\n}, $base);\n\necho \"step 3\\n\";\n\n$event->add();\n\necho \"step 4\\n\";\n\n$base->dispatch();\n\necho \"Готово\\n\";\n?>\n```\n\n**Приклад #7 Різне**\n\n```php\n<?php\n/* {{{ Конфигурация и поддерживаемые методы */\necho \"Поддерживаемые методы:\\n\";\nforeach (Event::getSupportedMethods() as $m) {\n    echo $m, PHP_EOL;\n}\n\n// Избегаем метода \"select\"\n$cfg = new EventConfig();\nif ($cfg->avoidMethod(\"select\")) {\n    echo \"Метод 'select' будет игнорироваться\\n\";\n}\n\n// Создаём event_base связанный с конфигурацией\n$base = new EventBase($cfg);\necho \"Используется событийный метод: \", $base->getMethod(), PHP_EOL;\n\necho \"Способы:\\n\";\n$features = $base->getFeatures();\n($features & EventConfig::FEATURE_ET) and print \"ET — одноразовое срабатывание при пересечении порога (edge-triggered IO)\\n\";\n($features & EventConfig::FEATURE_O1) and print \"O1 — операции добавления/удаления событий со сложностью O(1)\\n\";\n($features & EventConfig::FEATURE_FDS) and print \"FDS — обычные дескрипторы файлов, а не только сокеты\\n\";\n\n// Запрашиваем способ FDS\nif ($cfg->requireFeatures(EventConfig::FEATURE_FDS)) {\n    echo \"Запрошен способ FDS\\n\";\n\n    $base = new EventBase($cfg);\n    ($base->getFeatures() & EventConfig::FEATURE_FDS)\n        and print \"FDS — обычные дескрипторы файлов, а не только сокеты\\n\";\n}\n/* }}} */\n\n/* {{{ Base */\n$base = new EventBase();\n$event = new Event($base, STDIN, Event::READ | Event::PERSIST, function ($fd, $events, $arg) {\n    static $max_iterations = 0;\n\n    if (++$max_iterations >= 5) {\n        /* выход после 5 итераций с паузами в 2.33 секунды */\n        echo \"Останавливаемся...\\n\";\n        $arg[0]->exit(2.33);\n    }\n\n    echo fgets($fd);\n}, array (&$base));\n\n$event->add();\n$base->loop();\n/* Base }}} */\n?>\n```\n\n**Приклад #8 Простий HTTP-сервер**\n\n```php\n<?php\n/*\n * Простой HTTP-сервер.\n *\n * Для проверки:\n * 1) Запускаете на любом порту, наПриклад:\n * $ php examples/http.php 8010\n * 2) В другом терминальном окне устанавливаете к нему соединение\n * и делаете GET или POST запрос(другие запросы не реализованы):\n * $ nc -t 127.0.0.1 8010\n * POST /about HTTP/1.0\n * Content-Type: text/plain\n * Content-Length: 4\n * Connection: close\n * (нажимаете Enter)\n *\n * Должно вывести:\n * a=12\n * HTTP/1.0 200 OK\n * Content-Type: text/html; charset=ISO-8859-1\n * Connection: close\n *\n * $ nc -t 127.0.0.1 8010\n * GET /dump HTTP/1.0\n * Content-Type: text/plain\n * Content-Encoding: UTF-8\n * Connection: close\n * (нажимаете Enter)\n *\n * IДолжно вывести:\n * HTTP/1.0 200 OK\n * Content-Type: text/html; charset=ISO-8859-1\n * Connection: close\n * (нажимаете Enter)\n *\n * $ nc -t 127.0.0.1 8010\n * GET /unknown HTTP/1.0\n * Connection: close\n *\n * Должно вывести:\n * HTTP/1.0 200 OK\n * Content-Type: text/html; charset=ISO-8859-1\n * Connection: close\n *\n * 3) Смотрите, что выводится в окне, в котором вы запустили сервер.\n */\n\nfunction _http_dump($req, $data) {\n    static $counter      = 0;\n    static $max_requests = 2;\n\n    if (++$counter >= $max_requests)  {\n        echo \"Счётчик запросов достиг максимума $max_requests. Выходим\\n\";\n        exit();\n    }\n\n    echo __METHOD__, \" метод\\n\";\n    echo \"запрос:\"; var_dump($req);\n    echo \"данные:\"; var_dump($data);\n\n    echo \"\\n===== DUMP =====\\n\";\n    echo \"Команда:\", $req->getCommand(), PHP_EOL;\n    echo \"URI:\", $req->getUri(), PHP_EOL;\n    echo \"Входящие заголовки:\"; var_dump($req->getInputHeaders());\n    echo \"Исходящие заголовки:\"; var_dump($req->getOutputHeaders());\n\n    echo \"\\n >> Посылаем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n\n    echo \"\\n >> Читаем входной буфер ...\\n\";\n    $buf = $req->getInputBuffer();\n    while ($s = $buf->readLine(EventBuffer::EOL_ANY)) {\n        echo $s, PHP_EOL;\n    }\n    echo \"В буфере больше нет данных\\n\";\n}\n\nfunction _http_about($req) {\n    echo __METHOD__, PHP_EOL;\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    echo \"\\n >> Посылаем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n}\n\nfunction _http_default($req, $data) {\n    echo __METHOD__, PHP_EOL;\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    echo \"\\n >> Посылаем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n}\n\n$port = 8010;\nif ($argc > 1) {\n    $port = (int) $argv[1];\n}\nif ($port <= 0 || $port > 65535) {\n    exit(\"Некорректный порт\");\n}\n\n$base = new EventBase();\n$http = new EventHttp($base);\n$http->setAllowedMethods(EventHttpRequest::CMD_GET | EventHttpRequest::CMD_POST);\n\n$http->setCallback(\"/dump\", \"_http_dump\", array(4, 8));\n$http->setCallback(\"/about\", \"_http_about\");\n$http->setDefaultCallback(\"_http_default\", \"custom data value\");\n\n$http->bind(\"0.0.0.0\", 8010);\n$base->loop();\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\na=12\nHTTP/1.0 200 OK\nContent-Type: text/html; charset=ISO-8859-1\nConnection: close\n\nHTTP/1.0 200 OK\nContent-Type: text/html; charset=ISO-8859-1\nConnection: close\n(жмём Enter)\n\nHTTP/1.0 200 OK\nContent-Type: text/html; charset=ISO-8859-1\nConnection: close\n```\n\n**Приклад #9 Простий сервер HTTPS**\n\n```php\n<?php\n/*\n * Простой HTTPS-сервер.\n *\n * 1) Запустите сервер: `php examples/https.php 9999`\n * 2) Протестируйте его: `php examples/ssl-connection.php 9999`\n */\n\nfunction _http_dump($req, $data) {\n    static $counter      = 0;\n    static $max_requests = 200;\n\n    if (++$counter >= $max_requests)  {\n        echo \"Счётчик запросов достиг максимума $max_requests. Выходим\\n\";\n        exit();\n    }\n\n    echo __METHOD__, \" called\\n\";\n    echo \"запрос:\"; var_dump($req);\n    echo \"данные:\"; var_dump($data);\n\n    echo \"\\n===== DUMP =====\\n\";\n    echo \"Команда:\", $req->getCommand(), PHP_EOL;\n    echo \"URI:\", $req->getUri(), PHP_EOL;\n    echo \"Входящие заголовки:\"; var_dump($req->getInputHeaders());\n    echo \"Исходящие заголовки:\"; var_dump($req->getOutputHeaders());\n\n    echo \"\\n >> Отправляем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n\n    $buf = $req->getInputBuffer();\n    echo \"\\n >> Читаем входящий буфер (\", $buf->length, \") ...\\n\";\n    while ($s = $buf->read(1024)) {\n        echo $s;\n    }\n    echo \"\\nВ буфере больше нет данных\\n\";\n}\n\nfunction _http_about($req) {\n    echo __METHOD__, PHP_EOL;\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    echo \"\\n >> Отправляем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n}\n\nfunction _http_default($req, $data) {\n    echo __METHOD__, PHP_EOL;\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    echo \"\\n >> Отправляем ответ ...\";\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n}\n\nfunction _http_400($req) {\n    $req->sendError(400);\n}\n\nfunction _init_ssl() {\n    $local_cert = __DIR__.\"/ssl-echo-server/cert.pem\";\n    $local_pk   = __DIR__.\"/ssl-echo-server/privkey.pem\";\n\n    $ctx = new EventSslContext(EventSslContext::SSLv3_SERVER_METHOD, array (\n        EventSslContext::OPT_LOCAL_CERT  => $local_cert,\n        EventSslContext::OPT_LOCAL_PK    => $local_pk,\n        //EventSslContext::OPT_PASSPHRASE  => \"test\",\n        EventSslContext::OPT_ALLOW_SELF_SIGNED => true,\n    ));\n\n    return $ctx;\n}\n\n$port = 9999;\nif ($argc > 1) {\n    $port = (int) $argv[1];\n}\nif ($port <= 0 || $port > 65535) {\n    exit(\"Некорректный порт\");\n}\n$ip = '0.0.0.0';\n\n$base = new EventBase();\n$ctx  = _init_ssl();\n$http = new EventHttp($base, $ctx);\n$http->setAllowedMethods(EventHttpRequest::CMD_GET | EventHttpRequest::CMD_POST);\n\n$http->setCallback(\"/dump\", \"_http_dump\", array(4, 8));\n$http->setCallback(\"/about\", \"_http_about\");\n$http->setCallback(\"/err400\", \"_http_400\");\n$http->setDefaultCallback(\"_http_default\", \"custom data value\");\n\n$http->bind($ip, $port);\n$base->dispatch();\n```\n\n**Приклад #10 OpenSSL з'єднання**\n\n```php\n<?php\n/*\n * Простой OpenSSL клиент.\n *\n * Использование:\n * 1) Запускаем сервер, наПриклад так:\n * $ php examples/https.php 9999\n *\n * 2) Запускаем клиента в другом окне:\n * $ php examples/ssl-connection.php 9999\n */\n\nfunction _request_handler($req, $base) {\n    echo __FUNCTION__, PHP_EOL;\n\n    if (is_null($req)) {\n        echo \"Превышен интервал ожидания\\n\";\n    } else {\n        $response_code = $req->getResponseCode();\n\n        if ($response_code == 0) {\n            echo \"В соединении отказано\\n\";\n        } elseif ($response_code != 200) {\n            echo \"Неожиданный ответ: $response_code\\n\";\n        } else {\n            echo \"Соединение успешно: $response_code\\n\";\n            $buf = $req->getInputBuffer();\n            echo \"Body:\\n\";\n            while ($s = $buf->readLine(EventBuffer::EOL_ANY)) {\n                echo $s, PHP_EOL;\n            }\n        }\n    }\n\n    $base->exit(NULL);\n}\n\nfunction _init_ssl() {\n    $ctx = new EventSslContext(EventSslContext::SSLv3_CLIENT_METHOD, array ());\n\n    return $ctx;\n}\n\n\n// Разрешаем переопределять порт\n$port = 9999;\nif ($argc > 1) {\n    $port = (int) $argv[1];\n}\nif ($port <= 0 || $port > 65535) {\n    exit(\"Некорректный порт\\n\");\n}\n$host = '127.0.0.1';\n\n$ctx = _init_ssl();\nif (!$ctx) {\n    trigger_error(\"Не удалось создать контекст SSL\", E_USER_ERROR);\n}\n\n$base = new EventBase();\nif (!$base) {\n    trigger_error(\"Не удалось инициализировать обработчик событий\", E_USER_ERROR);\n}\n\n$conn = new EventHttpConnection($base, NULL, $host, $port, $ctx);\n$conn->setTimeout(50);\n\n$req = new EventHttpRequest(\"_request_handler\", $base);\n$req->addHeader(\"Host\", $host, EventHttpRequest::OUTPUT_HEADER);\n$buf = $req->getOutputBuffer();\n$buf->add(\"<html>HTML TEST</html>\");\n//$req->addHeader(\"Content-Length\", $buf->length, EventHttpRequest::OUTPUT_HEADER);\n//$req->addHeader(\"Connection\", \"close\", EventHttpRequest::OUTPUT_HEADER);\n$conn->makeRequest($req, EventHttpRequest::CMD_POST, \"/dump\");\n\n$base->dispatch();\necho \"END\\n\";\n?>\n```\n\n**Приклад #11 Приклад использования[EventHttpConnection::makeRequest()](eventhttpconnection.makerequest.md)**\n\n```php\n<?php\nfunction _request_handler($req, $base) {\n    echo __FUNCTION__, PHP_EOL;\n\n    if (is_null($req)) {\n        echo \"Timed out\\n\";\n    } else {\n        $response_code = $req->getResponseCode();\n\n        if ($response_code == 0) {\n            echo \"В соединении отказано\\n\";\n        } elseif ($response_code != 200) {\n            echo \"Неожиданный ответ: $response_code\\n\";\n        } else {\n            echo \"Успешное соединение: $response_code\\n\";\n            $buf = $req->getInputBuffer();\n            echo \"Данные:\\n\";\n            while ($s = $buf->readLine(EventBuffer::EOL_ANY)) {\n                echo $s, PHP_EOL;\n            }\n        }\n    }\n\n    $base->exit(NULL);\n}\n\n$address = \"127.0.0.1\";\n$port = 80;\n\n$base = new EventBase();\n$conn = new EventHttpConnection($base, NULL, $address, $port);\n$conn->setTimeout(5);\n$req = new EventHttpRequest(\"_request_handler\", $base);\n\n$req->addHeader(\"Host\", $address, EventHttpRequest::OUTPUT_HEADER);\n$req->addHeader(\"Content-Length\", \"0\", EventHttpRequest::OUTPUT_HEADER);\n$conn->makeRequest($req, EventHttpRequest::CMD_GET, \"/index.cphp\");\n\n$base->loop();\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n_request_handler\nSuccess: 200\nBody:\nPHP, date:\n2013-03-13T20:27:52+05:00\n```\n\n**Приклад #12 Слухач з'єднань на базі сокетів UNIX**\n\n```php\n<?php\n/*\n * Простой echo-сервер на базе слушателя соединений libevent.\n *\n * Использование:\n * 1) В первом окне запустите слушатель:\n *\n * $ php unix-domain-listener.php [путь к сокету]\n *\n * 2) Во втором окне откройте соединение к сокету:\n *\n * $ socat - GOPEN:/tmp/1.sock\n *\n * 3) Начните печататью Сервер должен повторять ввод.\n */\n\nclass MyListenerConnection {\n    private $bev, $base;\n\n    public function __destruct() {\n        if ($this->bev) {\n            $this->bev->free();\n        }\n    }\n\n    public function __construct($base, $fd) {\n        $this->base = $base;\n\n        $this->bev = new EventBufferEvent($base, $fd, EventBufferEvent::OPT_CLOSE_ON_FREE);\n\n        $this->bev->setCallbacks(array($this, \"echoReadCallback\"), NULL,\n            array($this, \"echoEventCallback\"), NULL);\n\n        if (!$this->bev->enable(Event::READ)) {\n            echo \"Не удалось разрешить чтение (READ)\\n\";\n            return;\n        }\n    }\n\n    public function echoReadCallback($bev, $ctx) {\n        // Копируем все данные из входящего буфера в исходящий буфер\n        $bev->output->addBuffer($bev->input);\n    }\n\n    public function echoEventCallback($bev, $events, $ctx) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"Ошибка в bufferevent\\n\";\n        }\n\n        if ($events & (EventBufferEvent::EOF | EventBufferEvent::ERROR)) {\n            $bev->free();\n            $bev = NULL;\n        }\n    }\n}\n\nclass MyListener {\n    public $base,\n        $listener,\n        $socket;\n    private $conn = array();\n\n    public function __destruct() {\n        foreach ($this->conn as &$c) $c = NULL;\n    }\n\n    public function __construct($sock_path) {\n        $this->base = new EventBase();\n        if (!$this->base) {\n            echo \"Не удаётся открыть обработчик ошибок\";\n            exit(1);\n        }\n\n        if (file_exists($sock_path)) {\n            unlink($sock_path);\n        }\n\n         $this->listener = new EventListener($this->base,\n             array($this, \"acceptConnCallback\"), $this->base,\n             EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE, -1,\n             \"unix:$sock_path\");\n\n        if (!$this->listener) {\n            trigger_error(\"Невозможно создать слушатель\", E_USER_ERROR);\n        }\n\n        $this->listener->setErrorCallback(array($this, \"accept_error_cb\"));\n    }\n\n    public function dispatch() {\n        $this->base->dispatch();\n    }\n\n    // Эта callback-функция будет запущена, когда в $bev появятся данные для чтения\n    public function acceptConnCallback($listener, $fd, $address, $ctx) {\n        // Появилось новое соединение! Настроем для него bufferevent. */\n        $base = $this->base;\n        $this->conn[] = new MyListenerConnection($base, $fd);\n    }\n\n    public function accept_error_cb($listener, $ctx) {\n        $base = $this->base;\n\n        fprintf(STDERR, \"Ошибка слушателя: %d (%s). \"\n            .\"Shutting down.\\n\",\n            EventUtil::getLastSocketErrno(),\n            EventUtil::getLastSocketError());\n\n        $base->exit(NULL);\n    }\n}\n\nif ($argc <= 1) {\n    exit(\"Не указан сокет\\n\");\n}\n$sock_path = $argv[1];\n\n$l = new MyListener($sock_path);\n$l->dispatch();\n?>\n```\n\n**Приклад #13 Простий SMTP-сервер**\n\n```php\n<?php\n /*\n * Автор: Andrew Rose <hello at andrewrose dot co dot uk>\n *\n * Usage:\n * 1) Подготовим файлы сертификата cert.pem и приватного ключа privkey.pem.\n * 2) Запустим скрипт сервера\n * 3) Откроем TLS-соединение, наПриклад:\n *      $ openssl s_client -connect localhost:25 -starttls smtp -crlf\n * 4) Протестируем команды, описанные в метода `cmd`.\n */\n\nclass Handler {\n    public $domainName = FALSE;\n    public $connections = [];\n    public $buffers = [];\n    public $maxRead = 256000;\n\n    public function __construct() {\n        $this->ctx = new EventSslContext(EventSslContext::SSLv3_SERVER_METHOD, [\n            EventSslContext::OPT_LOCAL_CERT  => 'cert.pem',\n            EventSslContext::OPT_LOCAL_PK    => 'privkey.pem',\n            //EventSslContext::OPT_PASSPHRASE  => '',\n            EventSslContext::OPT_VERIFY_PEER => false, // для корректного сертификата укажите true\n            EventSslContext::OPT_ALLOW_SELF_SIGNED => true // для корректного сертификата укажите false\n        ]);\n\n        $this->base = new EventBase();\n        if (!$this->base) {\n            exit(\"Не удалось открыть обработчик событий\\n\");\n        }\n\n        if (!$this->listener = new EventListener($this->base,\n            [$this, 'ev_accept'],\n            $this->ctx,\n            EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE,\n            -1,\n            '0.0.0.0:25'))\n        {\n            exit(\"Невозможно создать слушателя\\n\");\n        }\n\n        $this->listener->setErrorCallback([$this, 'ev_error']);\n        $this->base->dispatch();\n    }\n\n    public function ev_accept($listener, $fd, $address, $ctx) {\n        static $id = 0;\n        $id += 1;\n\n        $this->connections[$id]['clientData'] = '';\n        $this->connections[$id]['cnx'] = new EventBufferEvent($this->base, $fd,\n            EventBufferEvent::OPT_CLOSE_ON_FREE);\n\n        if (!$this->connections[$id]['cnx']) {\n            echo \"Failed creating buffer\\n\";\n            $this->base->exit(NULL);\n            exit(1);\n        }\n\n        $this->connections[$id]['cnx']->setCallbacks([$this, \"ev_read\"], NULL,\n            [$this, 'ev_error'], $id);\n        $this->connections[$id]['cnx']->enable(Event::READ | Event::WRITE);\n\n        $this->ev_write($id, '220 '.$this->domainName.\" wazzzap?\\r\\n\");\n    }\n\n    function ev_error($listener, $ctx) {\n        $errno = EventUtil::getLastSocketErrno();\n\n        fprintf(STDERR, \"Ошибка слушателя: %d (%s). Аварийное завершение работы.\\n\",\n            $errno, EventUtil::getLastSocketError());\n\n        if ($errno != 0) {\n            $this->base->exit(NULL);\n            exit();\n        }\n    }\n\n    public function ev_close($id) {\n        $this->connections[$id]['cnx']->disable(Event::READ | Event::WRITE);\n        unset($this->connections[$id]);\n    }\n\n    protected function ev_write($id, $string) {\n        echo 'S('.$id.'): '.$string;\n        $this->connections[$id]['cnx']->write($string);\n    }\n\n    public function ev_read($buffer, $id) {\n        while($buffer->input->length > 0) {\n            $this->connections[$id]['clientData'] .= $buffer->input->read($this->maxRead);\n            $clientDataLen = strlen($this->connections[$id]['clientData']);\n\n            if($this->connections[$id]['clientData'][$clientDataLen-1] == \"\\n\"\n                && $this->connections[$id]['clientData'][$clientDataLen-2] == \"\\r\")\n            {\n                // удаляем все завершающие \\r\\n\n                $line = substr($this->connections[$id]['clientData'], 0,\n                    strlen($this->connections[$id]['clientData']) - 2);\n\n                $this->connections[$id]['clientData'] = '';\n                $this->cmd($buffer, $id, $line);\n            }\n        }\n    }\n\n    protected function cmd($buffer, $id, $line) {\n        switch ($line) {\n            case strncmp('EHLO ', $line, 4):\n                $this->ev_write($id, \"250-STARTTLS\\r\\n\");\n                $this->ev_write($id, \"250 OK ehlo\\r\\n\");\n                break;\n\n            case strncmp('HELO ', $line, 4):\n                $this->ev_write($id, \"250-STARTTLS\\r\\n\");\n                $this->ev_write($id, \"250 OK helo\\r\\n\");\n                break;\n\n            case strncmp('QUIT', $line, 3):\n                $this->ev_write($id, \"250 OK quit\\r\\n\");\n                $this->ev_close($id);\n                break;\n\n            case strncmp('STARTTLS', $line, 3):\n                $this->ev_write($id, \"220 Ready to start TLS\\r\\n\");\n                $this->connections[$id]['cnx'] = EventBufferEvent::sslFilter($this->base,\n                    $this->connections[$id]['cnx'], $this->ctx,\n                    EventBufferEvent::SSL_ACCEPTING,\n                    EventBufferEvent::OPT_CLOSE_ON_FREE);\n                $this->connections[$id]['cnx']->setCallbacks([$this, \"ev_read\"], NULL, [$this, 'ev_error'], $id);\n                $this->connections[$id]['cnx']->enable(Event::READ | Event::WRITE);\n                break;\n\n            default:\n                echo 'неизвестная команда: '.$line.\"\\n\";\n                break;\n        }\n    }\n}\n\nnew Handler();\n```\n","title":"Приклади","contentType":2,"navigation":[{"event.resources.md":"« Типи ресурсів"},{"event.flags.md":"Прапори подій »"},{"index.md":"PHP Manual"},{"book.event.md":"Event"}]}},"__N_SSG":true}