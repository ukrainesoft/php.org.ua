{"pageProps":{"page":{"slug":"mysqli.quickstart.stored-procedures.md","content":"## Збережені процедури\n\nСУБД MySQL підтримує процедури, що зберігаються. Під цим терміном розуміється послідовність операцій, що зберігається як єдине ціле в каталозі бази даних на сервері. Програми можуть викликати та запускати збережені процедури. Для запуску процедури, що зберігається, використовується SQL вираз `CALL`\n\n**Параметри**\n\nЗбережені процедури можуть мати параметри `IN` `INOUT`и`OUT` Залежно від версії MySQL. Інтерфейс mysqli не робить різниці між цими типами параметрів.\n\n**Параметр IN**\n\nВхідні параметри вказуються усередині пропозиції `CALL`. При передачі вхідних параметрів важливо переконатись, що їх значення коректно екрановані.\n\n**Приклад #1 Виклик збереженої процедури**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n\n$mysqli->query(\"DROP PROCEDURE IF EXISTS p\");\n$mysqli->query(\"CREATE PROCEDURE p(IN id_val INT) BEGIN INSERT INTO test(id) VALUES(id_val); END;\");\n\n$mysqli->query(\"CALL p(1)\");\n\n$result = $mysqli->query(\"SELECT id FROM test\");\n\nvar_dump($result->fetch_assoc());\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(1) {\n  [\"id\"]=>\n  string(1) \"1\"\n}\n```\n\n**Параметр INOUT/OUT**\n\nЗначения параметров`INOUT` `OUT` доступні через змінні сесії.\n\n**Приклад #2 Використання змінних сесії**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP PROCEDURE IF EXISTS p\");\n$mysqli->query('CREATE PROCEDURE p(OUT msg VARCHAR(50)) BEGIN SELECT \"Hi!\" INTO msg; END;');\n\n$mysqli->query(\"SET @msg = ''\");\n$mysqli->query(\"CALL p(@msg)\");\n\n$result = $mysqli->query(\"SELECT @msg as _p_out\");\n\n$row = $result->fetch_assoc();\necho $row['_p_out'];\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHi!\n```\n\nРозробники додатків та фреймворків можуть надати більш зручний API, в якому поряд із сесійними змінними використовується перегляд каталогів бази даних безпосередньо. Проте варто враховувати, що такий підхід знижує швидкодію.\n\n**Обробка результуючих наборів**\n\nЗбережені процедури можуть повертати результуючі набори рядків. Таблиці результатів роботи процедури, що зберігається, не можна коректно витягти засобами [mysqli::query()](mysqli.query.md)Функция[mysqli::query()](mysqli.query.md) виконує дві операції: запускає запит і отримує перший результуючий набір, поміщаючи його в буфер. Збережені процедури можуть повертати більше одного результуючого набору, але при використанні [mysqli::query()](mysqli.query.md) всі вони, крім першого, стануть недоступними для користувача.\n\nРезультуючі таблиці процедур, що зберігаються, витягуються функціями [mysqli::real\\_query()](mysqli.real-query.md) або [mysqli::multi\\_query()](mysqli.multi-query.md). Обидві функції дозволяють отримати будь-яку кількість результуючих наборів, повернутих SQL-запитами, таких як `CALL`. Якщо в процесі роботи не вдається отримати всі доступні результати виклику процедури, що зберігається, буде викликатися помилка.\n\n**Приклад #3 Вилучення результатів роботи процедури, що зберігається.**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n$mysqli->query(\"INSERT INTO test(id) VALUES (1), (2), (3)\");\n\n$mysqli->query(\"DROP PROCEDURE IF EXISTS p\");\n$mysqli->query('CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id FROM test; SELECT id + 1 FROM test; END;');\n\n$mysqli->multi_query(\"CALL p()\");\n\ndo {\n    if ($result = $mysqli->store_result()) {\n        printf(\"---\\n\");\n        var_dump($result->fetch_all());\n        $result->free();\n    }\n} while ($mysqli->next_result());\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n---\narray(3) {\n  [0]=>\n  array(1) {\n    [0]=>\n    string(1) \"1\"\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    string(1) \"2\"\n  }\n  [2]=>\n  array(1) {\n    [0]=>\n    string(1) \"3\"\n  }\n}\n---\narray(3) {\n  [0]=>\n  array(1) {\n    [0]=>\n    string(1) \"2\"\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    string(1) \"3\"\n  }\n  [2]=>\n  array(1) {\n    [0]=>\n    string(1) \"4\"\n  }\n}\n```\n\n**Використання запитів, що готуються.**\n\nСпеціальних засобів для вилучення даних при використанні запитів, що готуються, не потрібно. Інтерфейси підготовлюваних та звичайних запитів однакові. Однак, потрібно враховувати, що не всі версії MySQL підтримують підготовку в запиті SQL-виразу `CALL`\n\n**Приклад #4 Збережені процедури та запити, що готуються.**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n$mysqli->query(\"INSERT INTO test(id) VALUES (1), (2), (3)\");\n\n$mysqli->query(\"DROP PROCEDURE IF EXISTS p\");\n$mysqli->query('CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id FROM test; SELECT id + 1 FROM test; END;');\n\n$stmt = $mysqli->prepare(\"CALL p()\");\n\n$stmt->execute();\n\ndo {\n    if ($result = $stmt->get_result()) {\n        printf(\"---\\n\");\n        var_dump($result->fetch_all());\n        $result->free();\n    }\n} while ($stmt->next_result());\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n---\narray(3) {\n  [0]=>\n  array(1) {\n    [0]=>\n    int(1)\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    int(2)\n  }\n  [2]=>\n  array(1) {\n    [0]=>\n    int(3)\n  }\n}\n---\narray(3) {\n  [0]=>\n  array(1) {\n    [0]=>\n    int(2)\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    int(3)\n  }\n  [2]=>\n  array(1) {\n    [0]=>\n    int(4)\n  }\n}\n```\n\nЗрозуміло, підтримується прив'язка результатів до об'єкта запиту.\n\n**Приклад #5 Збережені процедури та запити, що готуються, з використанням прив'язки результатів**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n$mysqli->query(\"INSERT INTO test(id) VALUES (1), (2), (3)\");\n\n$mysqli->query(\"DROP PROCEDURE IF EXISTS p\");\n$mysqli->query('CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id FROM test; SELECT id + 1 FROM test; END;');\n\n$stmt = $mysqli->prepare(\"CALL p()\");\n\n$stmt->execute();\n\ndo {\n    if ($stmt->store_result()) {\n        $stmt->bind_result($id_out);\n        while ($stmt->fetch()) {\n            echo \"id = $id_out\\n\";\n        }\n    }\n} while ($stmt->next_result());\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid = 1\nid = 2\nid = 3\nid = 2\nid = 3\nid = 4\n```\n\n**Дивіться також**\n\n-   [mysqli::query()](mysqli.query.md)\n-   [mysqli::multi\\_query()](mysqli.multi-query.md)\n-   [mysqli::next\\_result()](mysqli.next-result.md)\n-   [mysqli::more\\_results()](mysqli.more-results.md)\n","title":"Збережені процедури","contentType":2,"navigation":[{"mysqli.quickstart.prepared-statements.md":"« Підготовка запитів"},{"mysqli.quickstart.multiple-statement.md":"Множинні запити »"},{"index.md":"PHP Manual"},{"mysqli.quickstart.md":"Короткий посібник"}]}},"__N_SSG":true}