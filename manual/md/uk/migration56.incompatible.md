- [« Міграція з PHP 5.5.x на PHP 5.6.x](migration56.md)
- [Нові можливості »](migration56.new-features.md)

- [PHP Manual](index.md)
- [Міграція з PHP 5.5.x на PHP 5.6.x](migration56.md)
- Зміни, що ламають зворотну сумісність

## Зміни, що ламають зворотну сумісність

Незважаючи на те, що більша частина існуючого коду PHP 5 повинна
працювати без змін, все ж таки ознайомтеся з деякими змінами,
які можуть позначитися на зворотній сумісності:

### Ключі масиву не будуть перезаписані при визначенні масиву як властивості класу через літерал масиву

Раніше в масивах, задані як властивості класу зі змішаними явними та
неявними ключами, елементи з явно заданими ключами могли мовчки
перезаписуватись, якщо явний ключ перетинався з послідовним неявним
ключем. Наприклад:

`<?phpclass C {    const ONE u003d 1; public $array u003d [        self::ONE u003d> 'foo',        'bar',        'quux',    |

Результат виконання цього прикладу в PHP 5.5:

array(2) {
[0]u003d>
string(3) "bar"
[1]u003d>
string(4) "quux"
}

Результат виконання цього прикладу в PHP 5.6:

array(3) {
[1]u003d>
string(3) "foo"
[2]u003d>
string(3) "bar"
[3]u003d>
string(4) "quux"
}

### Суворість [json_decode()](function.json-decode.md)

Тепер [json_decode()](function.json-decode.md) відповідно до
специфікацією JSON відхиляє JSON літерали `true`, `false` та `null`,
задані не строго в нижньому регістрі, і відповідно встановлює
[json_last_error()](function.json-last-error.md). Раніше дані,
передані в [json_decode()](function.json-decode.md) та містять
виключно одне з цих значень у верхньому або змішаному регістрі,
приймалися.

Ця зміна вплине тільки у разі передачі в
[json_decode()](function.json-decode.md) некоректного JSON. В разі
коректно сформованого JSON, жодного ефекту не буде.

### Тепер потокові обгортки за замовчуванням перевіряють сертифікати точок під час використання SSL/TLS

Всі клієнтські потоки, що шифруються, тепер за замовчуванням включають перевірку
бенкетів. За замовчуванням використовується OpenSSL CA пакет для перевірки
сертифіката бенкету. У більшості випадків не потрібно нічого робити для
з'єднання з серверами з правильним SSL сертифікатом, оскільки зазвичай
OpenSSL вже налаштований для використання хороших пакетів CA.

Стандартний CA пакет може бути перевизначений глобально за допомогою
установки або openssl.cafile або openssl.capath рядків конфігурації, або
ж на рівні кожного запиту використовуючи опції контексту
[`cafile`](context.ssl.md#context.ssl.cafile) або
[`capath`](context.ssl.md#context.ssl.capath).

Хоча це й не рекомендується, але можна вимкнути перевірку сертифіката
бенкету для запиту, встановивши
[`verify_peer`](context.ssl.md#context.ssl.verify-peer) опцію
контексту в **`false`**, і можна відключити перевірку імені бенкету,
встановивши
[`verify_peer_name`](context.ssl.md#context.ssl.verify-peer-name) в
**`false`**.

### Тепер ресурси [GMP](book.gmp.md) є об'єктами

Наразі ресурси [GMP](book.gmp.md) є об'єктами. Функціональне
API, реалізований у модулі GMP, залишився без змін. Існуючий
код повинен запрацювати без змін, тільки якщо в ньому явно не
використовувалися перевірки на ресурс
[is_resource()](function.is-resource.md) або щось подібне.

### Тепер функція [Mcrypt](book.mcrypt.md) вимагає коректні ключі та IV

[mcrypt_encrypt()](function.mcrypt-encrypt.md),
[mcrypt_decrypt()](function.mcrypt-decrypt.md), **mcrypt_cbc()**,
**mcrypt_cfb()**, **mcrypt_ecb()**,
[mcrypt_generic()](function.mcrypt-generic.md) та **mcrypt_ofb()**
більше не приймають ключі та IV з некоректною довжиною, а режими блокового
шифра, що вимагають IV, будуть завершуватися помилково, якщо його не передати.

### Завантаження файлів за допомогою [cURL](book.curl.md)

Тепер завантаження з використанням синтаксису @file потребує встановлення
CURLOPT_SAFE_UPLOAD на значення **`false`**. Натомість слід
використовувати [CURLFile](class.curlfile.md).
