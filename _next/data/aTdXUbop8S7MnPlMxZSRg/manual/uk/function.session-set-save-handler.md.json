{"pageProps":{"page":{"slug":"function.session-set-save-handler.md","content":"# session\\_set\\_save\\_handler\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nsession\\_set\\_save\\_handler - Встановлює користувальницькі обробники зберігання сесії\n\n### Опис\n\n```methodsynopsis\nsession_set_save_handler(    callable $open,    callable $close,    callable $read,    callable $write,    callable $destroy,    callable $gc,    callable $create_sid = ?,    callable $validate_sid = ?,    callable $update_timestamp = ?): bool\n```\n\nТакож можна зареєструвати наступний прототип:\n\n```methodsynopsis\nsession_set_save_handler(object $sessionhandler, bool $register_shutdown = true): bool\n```\n\n**session\\_set\\_save\\_handler()** встановлює користувальницькі обробники зберігання сесії, які використовуються для збереження та отримання даних, пов'язаних із сесією. Це особливо корисно, коли доцільним є метод зберігання, відмінний від тих, які надаються сесіями PHP, наприклад, зберігання даних сесії в локальній базі даних.\n\n### Список параметрів\n\nЦя функція має два визначення (прототипу).\n\n`sessionhandler`\n\nПримірник класу, що реалізує інтерфейс [SessionHandlerInterface](class.sessionhandlerinterface.md) та необов'язкові [SessionIdInterface](class.sessionidinterface.md)и/или[SessionUpdateTimestampHandlerInterface](class.sessionupdatetimestamphandlerinterface.md), такий як [SessionHandler](class.sessionhandler.md), Для реєстрації як оброблювач сесії.\n\n`register_shutdown`\n\nЗареєструвати [session\\_write\\_close()](function.session-write-close.md) як функцію [register\\_shutdown\\_function()](function.register-shutdown-function.md)\n\nабо\n\n`open`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nopen(string $savePath, string $sessionName): bool\n```\n\nCallback-функция`open` працює як конструктор у класах та виконується при відкритті сесії. Це перша callback-функція, яка виконується, коли сесія стартує автоматично або вручну через [session\\_start()](function.session-start.md)Возвращаемое значение\\*\\*`true`\\*\\* у разі успішного виконання, \\*\\*`false`\\*\\*в случае неудачи.\n\n`close`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nclose(): bool\n```\n\nCallback-функция`close` працює як деструктор у класах і виконується після того, як була викликана callback-функція `write`. Вона також викликається під час виклику [session\\_write\\_close()](function.session-write-close.md). Значення, що повертається, має бути **`true`** у разі успішного виконання, \\*\\*`false`\\*\\*в случае неудачи.\n\n`read`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nread(string $sessionId): string\n```\n\nCallback-функция`read` повинна завжди повертати кодований (серіалізований) рядок сесії або порожній рядок, якщо немає даних для читання.\n\nЦя callback-функція викликається внутрішнім механізмом PHP при старті сесії або виклику [session\\_start()](function.session-start.md). Перед тим, як буде викликана ця callback-функція, PHP викличе callback-функцію `open`\n\nЗначення, що повертається даної callback-функції повинно бути в такому ж серіалізованому форматі, який спочатку передавався для зберігання в callback-функцію `write`. Значення, що повертається, буде автоматично десеріалізовано PHP і використано для заповнення суперглобальної змінної [$\\_SESSION](reserved.variables.session.md). Навіть якщо дані схожі на результат [serialize()](function.serialize.md), варто пам'ятати, що це інший формат серіалізації, який визначений ini-директивою [session.serialize\\_handler](session.configuration.md#ini.session.serialize-handler)\n\n`write`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nwrite(string $sessionId, string $data): bool\n```\n\nCallback-функция`write` викликається, коли сесія має бути збережена та закрита. Ця callback-функція приймає ідентифікатор поточної сесії та серіалізовану версію суперглобальної змінної [$\\_SESSION](reserved.variables.session.md). Метод серіалізації, що використовується всередині PHP, визначений ini-директивою. [session.serialize\\_handler](session.configuration.md#ini.session.serialize-handler)\n\nПередані у цю callback-функцію серіалізовані дані сесії мають бути збережені у зв'язку з переданим ідентифікатором сесії. При отриманні цих даних, callback-функція `read` повинна повернути те саме значення, що було передано в callback-функцію `write`\n\nЦя callback-функція викликається, коли PHP завершує роботу або явно під час виклику [session\\_write\\_close()](function.session-write-close.md). Слід пам'ятати, що після виконання цієї callback-функції PHP виконає callback-функцію `close`\n\n> **Зауваження** :\n> \n> Обробник \"write\" не виконається доти, доки вихідний потік не буде закрито. Таким чином, виведення налагоджувальних операторів в обробнику \"write\" ніколи не відобразиться у браузері. Якщо потрібно вивести налагоджувальну інформацію, рекомендується записувати налагоджувальні дані у файл.\n\n`destroy`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\ndestroy(string $sessionId): bool\n```\n\nЦя callback-функція викликається, коли сесія знищується за допомогою [session\\_destroy()](function.session-destroy.md) або під час виклику [session\\_regenerate\\_id()](function.session-regenerate-id.md) з параметром destroy, встановленим у **`true`**. Значення, що повертається, має бути **`true`** у разі успішного виконання, \\*\\*`false`\\*\\*в случае неудачи.\n\n`gc`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\ngc(int $lifetime): bool\n```\n\nCallback-функція збирача сміття періодично викликається PHP для очищення даних старих сесій. Частота контролюється директивами [session.gc\\_probability](session.configuration.md#ini.session.gc-probability) і [session.gc\\_divisor](session.configuration.md#ini.session.gc-divisor). Значення lifetime, яке передається в дану callback-функцію, може бути встановлено в [session.gc\\_maxlifetime](session.configuration.md#ini.session.gc-maxlifetime). Значення, що повертається, має бути **`true`** у разі успішного виконання, \\*\\*`false`\\*\\*в случае неудачи.\n\n`create_sid`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\ncreate_sid(): string\n```\n\nЦя callback-функція виконується, коли потрібний новий ідентифікатор сесії. Не передбачає параметрів, а значення, що повертається, має бути рядком, який є допустимим ідентифікатором сесії для вашого оброблювача.\n\n`validate_sid`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nvalidate_sid(string $key): bool\n```\n\nCallback-функція виконується, коли має бути запущена сесія, надається ідентифікатор сесії та вмикається [session.use\\_strict\\_mode](session.configuration.md#ini.session.use-strict-mode). . `key` – це ідентифікатор сесії для перевірки. Ідентифікатор сесії є дійсним, якщо сесія з таким ідентифікатором вже існує. Значення, що повертається, має бути **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n`update_timestamp`\n\nCallback-функція з наступною сигнатурою:\n\n```methodsynopsis\nupdate_timestamp(string $key, string $val): bool\n```\n\nCallback-функція виконується під час сесії . `key` - це ідентифікатор сесії, `val` - Це дані сесії. Значення, що повертається, має бути **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Користувальницький обробник сесії: повний код дивіться в описі [SessionHandlerInterface](class.sessionhandlerinterface.md)**\n\nТут лише продемонстровано виклик session\\_set\\_save\\_handler, повний приклад можна подивитися в описі [SessionHandlerInterface](class.sessionhandlerinterface.md)\n\nЗауважте, що з **session\\_set\\_save\\_handler()** ми використовуємо ООП-прототип і реєструємо функцію завершення, використовуючи прапорець параметра функції. Це зазвичай рекомендується під час реєстрації об'єктів як оброблювачів зберігання сесії.\n\n```php\n<?php\nclass MySessionHandler implements SessionHandlerInterface\n{\n    // здесь реализация интерфейса\n}\n\n$handler = new MySessionHandler();\nsession_set_save_handler($handler, true);\nsession_start();\n\n// устанавливаем и получаем значения по ключу из $_SESSION\n```\n\n### Примітки\n\n**Увага**\n\nОбработчики`write`и`close` викликаються після деструктора об'єкта і тому неможливо використовувати його контекст чи кидати винятки. Винятки не можуть бути оброблені, тому що не будуть спіймані, не буде відображено трасування стека виключення і виконання просто припиниться несподівано. Однак при цьому деструктори об'єкта можуть використовувати сесії.\n\nМожна викликати [session\\_write\\_close()](function.session-write-close.md) з деструктора, щоб вирішити цю проблему \"курки та яйця\", але найнадійніший спосіб - це реєструвати функцію завершення, як описано вище.\n\n**Увага**\n\nПоточний робочий каталог змінюється деякими SAPI, якщо сесія закривається після завершення скрипта. Завершити сесію можна раніше за допомогою [session\\_write\\_close()](function.session-write-close.md)\n\n### Дивіться також\n\n-   Директива[session.save\\_handler](session.configuration.md#ini.session.save-handler)\n-   Директива[session.serialize\\_handler](session.configuration.md#ini.session.serialize-handler)\n-   [register\\_shutdown\\_function()](function.register-shutdown-function.md) \\- Реєструє функцію, яка виконається після завершення роботи скрипту\n-   [session\\_register\\_shutdown()](function.session-register-shutdown.md) \\- функція завершення сесії\n-   Обратитесь к[» save\\_handler.inc](https://github.com/php/php-src/blob/master/ext/session/tests/save_handler.inc)для повного набору рекомендацій щодо реалізації\n","title":"session\\_set\\_save\\_handler","contentType":2,"navigation":[{"function.session-set-cookie-params.md":"« session\\_set\\_cookie\\_params"},{"function.session-start.md":"session\\_start »"},{"index.md":"PHP Manual"},{"ref.session.md":"Функції для роботи із сесіями"}]}},"__N_SSG":true}