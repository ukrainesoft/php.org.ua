{"pageProps":{"page":{"slug":"class.sessionhandler.md","content":"# Клас SessionHandler\n\n(PHP 5 >= 5.4.0, PHP 7, PHP 8)\n\n## Вступ\n\n**SessionHandler** це спеціальний клас, який може використовуватись для доповнення внутрішнього оброблювача сесій PHP шляхом створення дочірніх класів від цього. Існує сім методів, які є обгортками над сімома внутрішніми обробниками зберігання даних сесії (`open` `close` `read` `write` `destroy` `gc`и`create_sid`). За умовчанням цей клас обертає всі внутрішні обробники сесії, визначені в опції конфігурації [session.save\\_handler](session.configuration.md#ini.session.save-handler). За замовчуванням ця опція має значення `files`Другие внутренние обработчики сессий предоставляются PHP-модулями, такими как SQLite (`sqlite`), Memcache (`memcache`) та Memcached (`memcached`\n\nЕкземпляр класу **SessionHandler** може встановлюватися як обробник сесії за допомогою виклику функції [session\\_set\\_save\\_handler()](function.session-set-save-handler.md). У цьому випадку він стане обгорткою існуючого внутрішнього оброблювача. Класи, що розширюють **SessionHandler** дозволять перевизначити методи оброблювача сесії або перехопити/відфільтрувати їх шляхом виклику батьківських методів-оберток внутрішнього оброблювача сесій PHP.\n\nЦе дозволить вам, наприклад, перехопити методи `read`и`write` для шифрування/дешифрування даних сесії та передачі результату батьківському класу та від нього. Або, наприклад, ви можете повністю перевизначити такий метод як callback-функція збирача сміття (`gc`\n\nТак как**SessionHandler** є обгорткою над стандартним внутрішнім обробником сесії, то приклад, наведений вище про шифрування даних може бути застосований до будь-якого внутрішнього оброблювача сесії навіть без розуміння внутрішнього пристрою процесу сесії.\n\nДля використання цього класу, по-перше, встановіть обробник, який ви хочете доповнити, використовуючи [session.save\\_handler](session.configuration.md#ini.session.save-handler). Далі передайте екземпляр класу **SessionHandler** або одного з класів, що розширюють його функції [session\\_set\\_save\\_handler()](function.session-set-save-handler.md)\n\nЗверніть увагу, що callback-методи цього класу призначені для внутрішнього виклику PHP і не призначені для виклику з коду простору користувача. Значення, що повертаються однаково обробляються всередині PHP. Додаткову інформацію про роботу із сесією можна дізнатися з опису функції [session\\_set\\_save\\_handler()](function.session-set-save-handler.md)\n\n## Огляд класів\n\n```classsynopsis\n\n    \n     class SessionHandler\n    \n\n    \n     implements\n      SessionHandlerInterface,\n\n     SessionIdInterface {\n\n    /* Методы */\n    \n   public close(): bool\npublic create_sid(): string\npublic destroy(string $id): bool\npublic gc(int $max_lifetime): int|false\npublic open(string $path, string $name): bool\npublic read(string $id): string|false\npublic write(string $id, string $data): bool\n\n   }\n```\n\n**Увага**\n\nЦей клас призначений для розширення поточного внутрішнього оброблювача сесії PHP. При цьому, якщо вам потрібно написати власний обробник, необхідно написати власну реалізацію інтерфейсу [SessionHandlerInterface](class.sessionhandlerinterface.md)вместо расширения класса**SessionHandler**\n\n**Приклад #1 Использование**SessionHandler\\*\\* для того, щоб додати шифрування даних до внутрішнього оброблювача сесій PHP.\\*\\*\n\n```php\n<?php\n\n /**\n  * расшифровать данные, используя алгоритм AES 256\n  *\n  * @param data $edata\n  * @param string $password\n  * @return расшифрованные данные\n  */\nfunction decrypt($edata, $password) {\n    $data = base64_decode($edata);\n    $salt = substr($data, 0, 16);\n    $ct = substr($data, 16);\n\n    $rounds = 3; // зависит от длины ключа\n    $data00 = $password.$salt;\n    $hash = array();\n    $hash[0] = hash('sha256', $data00, true);\n    $result = $hash[0];\n    for ($i = 1; $i < $rounds; $i++) {\n        $hash[$i] = hash('sha256', $hash[$i - 1].$data00, true);\n        $result .= $hash[$i];\n    }\n    $key = substr($result, 0, 32);\n    $iv  = substr($result, 32,16);\n\n    return openssl_decrypt($ct, 'AES-256-CBC', $key, true, $iv);\n  }\n\n/**\n * зашифровать данные алгоритмом AES 256\n *\n * @param data $data\n * @param string $password\n * @return base64 зашифрованные данные\n */\nfunction encrypt($data, $password) {\n    // Генерация криптографически безопасной случайной соли с помощью функции random_bytes()\n    $salt = random_bytes(16);\n\n    $salted = '';\n    $dx = '';\n    // Ключ соли (32) и вектор инициализации (16) = 48\n    while (strlen($salted) < 48) {\n      $dx = hash('sha256', $dx.$password.$salt, true);\n      $salted .= $dx;\n    }\n\n    $key = substr($salted, 0, 32);\n    $iv  = substr($salted, 32,16);\n\n    $encrypted_data = openssl_encrypt($data, 'AES-256-CBC', $key, true, $iv);\n    return base64_encode($salt . $encrypted_data);\n}\n\nclass EncryptedSessionHandler extends SessionHandler\n{\n    private $key;\n\n    public function __construct($key)\n    {\n        $this->key = $key;\n    }\n\n    public function read($id)\n    {\n        $data = parent::read($id);\n\n        if (!$data) {\n            return \"\";\n        } else {\n            return decrypt($data, $this->key);\n        }\n    }\n\n    public function write($id, $data)\n    {\n        $data = encrypt($data, $this->key);\n\n        return parent::write($id, $data);\n    }\n}\n\n// Здесь мы перехватываем встроенный обработчик 'files', но можно использовать любой другой\n// обработчик, наПриклад 'sqlite', 'memcache' или 'memcached',\n// которые предоставлены модулями PHP.\nini_set('session.save_handler', 'files');\n\n$key = 'secret_string';\n$handler = new EncryptedSessionHandler($key);\nsession_set_save_handler($handler, true);\nsession_start();\n\n// устанавливаем и получаем значения из $_SESSION\n```\n\n> **Зауваження** :\n> \n> Так як методи цього класу призначені для внутрішніх викликів з PHP, як частина нормального процесу роботи сесій, виклики батьківських методів із дочірнього класу (іншими словами \"рідних\" обробників) буде повертати **`false`** доти, доки сесія не буде запущена (автоматично або прямим викликом [session\\_start()](function.session-start.md)). Це важливий момент для розуміння, особливо під час тестування, де методи класу можуть бути викликані вручну.\n\n## Зміст\n\n-   [SessionHandler::close](sessionhandler.close.md) \\- Закриває сесію\n-   [SessionHandler::create\\_sid](sessionhandler.create-sid.md)— Повертає новий ідентифікатор сесії\n-   [SessionHandler::destroy](sessionhandler.destroy.md) \\- Знищує сесію\n-   [SessionHandler::gc](sessionhandler.gc.md) \\- Очищає старі сесії\n-   [SessionHandler::open](sessionhandler.open.md) \\- Ініціалізує сесію\n-   [SessionHandler::read](sessionhandler.read.md)— Зчитує дані сесії\n-   [SessionHandler::write](sessionhandler.write.md)— Записує дані сесії\n","title":"Клас SessionHandler","contentType":2,"navigation":[{"function.session-write-close.md":"« session\\_write\\_close"},{"sessionhandler.close.md":"SessionHandler::close »"},{"index.md":"PHP Manual"},{"book.session.md":"Сесії"}]}},"__N_SSG":true}