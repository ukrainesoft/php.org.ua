- [«Підмаски](regexp.reference.subpatterns.md)
- [Зворотні посилання »](regexp.reference.back-references.md)

- [PHP Manual](index.md)
- [Опис синтаксису Perl-сумісних регулярних
виразів](reference.pcre.pattern.syntax.md)
- повторення

## Повторення

Повторення задається за допомогою квантифікаторів, що йдуть за будь-яким з
наведених нижче елементів:

- довільним, можливо екранованим символом
- метасимволом "крапка"
- символьним класом
- Посиланням на попередній фрагмент шаблону (дивіться наступний розділ)
- взятої в круглий дужки підмаскою (якщо це не твердження -
дивіться далі)

Загальний квантифікатор повторення вказує мінімальне та максимальне
допустима кількість збігів, згідно з двома числами, укладеними в
фігурні дужки та розділені коми. Числа повинні бути меншими ніж
65536, і перше число не повинне перевищувати друге за значенням. Наприклад:
`z{2,4}` відповідає "zz", "zzz" або "zzzz". Закриваюча фігурна
дужка сама собою не є спеціальним символом. У разі якщо
друге число опущено, але кома присутня, немає верхньої межі; в
у випадку, якщо і друге число і кома опущені, потрібно точне число
повторень. Таким чином `[aeiou]{3,}` відповідає як мінімум трьом
послідовним голосним (а також будь-якій їх кількості вище трьох),
час як `\d{8}` відповідає рівно восьми цифрам. Відкриваюча
фігурна дужка, розташована в неприпустимій для квантифікатора
позиції, яка не відповідає синтаксису квантифікатора,
інтерпретується як звичайний символьний рядок. Наприклад, {,6} не
є квантифікатором, а інтерпретується як символьний рядок з
чотири символи.

Квантифікатор {0} є допустимим і поводиться таким чином, ніби
б сам квантифікатор і попередній елемент відсутні.

Для зручності (а також зворотної сумісності) три найбільш
поширених квантифікаторів мають односимвольні абревіатури:

| | |
|-----|----------------------|
| `*` | еквівалентний `{0,}` |
| `+` | еквівалентний `{1,}` |
| `?` еквівалентний `{0,1}` |

**Односимвольні квантифікатори**

Можна конструювати нескінченні цикли, вказавши після шаблону,
збігається з порожнім рядком, квантифікатор, який не має верхнього
межі, наприклад: `(a?)*`

Ранні версії Perl та PCRE видавали помилку під час компіляції для таких
шаблонів. Однак, оскільки бувають випадки, коли такі шаблони могли
було б корисно, була додана підтримка таких шаблонів. Але якщо будь-яке
повторення такої підмаски практично не збігається з жодними символами,
цикл примусово переривається.

За замовчуванням, всі квантифікатори є "жадібними", це означає, що
вони збігаються максимально можливу кількість разів (але не більше, ніж
максимально допустима кількість разів), не призводячи до неможливості
зіставлення інших елементів шаблона. Класичний приклад проблем,
які можуть виникнути у зв'язку з такою особливістю квантифікаторів -
знаходження коментарів у C-програмах. Коментар вважається
довільний текст, що знаходиться всередині символьних комбінацій /\* та \*/
(при цьому символи '/' і '\*' також можуть бути частиною коментаря).
Спроба знайти коментарі за допомогою шаблону `/\*.*\*/` у рядку
`/* перший коментар */ не коментар /* другий коментар */`
закінчиться невдачею, оскільки зазначений шаблон відповідає всій
рядку цілком (через жадібність квантифікатора '\*').

Однак, якщо відразу після квантифікатора йде запитальний знак, він
стає "лінивим" і відповідає мінімально допустимій кількості
разів. Таким чином, шаблон `/\*.*?\*/` коректно знаходить усі коментарі
мови Сі. Використання символу '?' після квантифікатора впливає
виключно на його жадібність, і не зачіпає жодних інших властивостей.
Не слід плутати використання символу '?' як, власне,
квантифікатора (нуль або одна відповідність) і як обмежувача
жадібності. Також внаслідок його двоїстої функціональності може
використовуватися наступний запис: `\d??\d`, який насамперед
відповідає одній цифрі, але може відповідати і двом цифрам,
якщо це необхідно для відповідності інших елементів шаблону.

У випадку, якщо встановлено опцію
[PCRE_UNGREEDY](reference.pcre.pattern.modifiers.md) (відсутня у
Perl), квантифікатори не є жадібними за промовчанням, але можуть
ставати такими, якщо за ними слідує символ '?'. Говорячи іншими
словами, знак питання інвертує жадібність квантифікаторів.

Квантифікатори, за якими слідує `+`, є "захоплюючими". Вони
поглинають стільки символів, скільки можуть і не повертаються назад
збігу залишку шаблону. Таким чином `.*abc` збігається з "aabc", а
`.*+abc` - ні, тому що `.*+` захопить весь рядок цілком.
Захоплюючі квантифікатори можуть бути використані для прискорення
обробки.

Якщо використовується підмаска з квантифікатором, для якого
задано мінімальну кількість повторень (більше одного), або задано
максимальну кількість повторень, то для відкомпілюваного шаблону
потрібно більше пам'яті (пропорційно мінімуму або максимуму
відповідно).

Якщо шаблон починається з .\* або .{0,}, і встановлено
модифікатор [PCRE_DOTALL](reference.pcre.pattern.modifiers.md)
(є аналогом Perl-опції /s), який дозволяє метасимволу
"точка" відповідатиме перекладам рядків, шаблон неявно заякорюється.
Це відбувається оскільки всі наступні конструкції будуть
зіставлятися з кожною символьною позицією в тексті, що обробляється, і,
як наслідок, початок рядка - єдина позиція, що дає найбільше
повний збіг. PCRE розглядає кожен такий шаблон, якби
йому передувала послідовність \A. Якщо відомо, що
дані не містять перекладів рядків, а сам шаблон починається на .\*,
рекомендується використовувати
[PCRE_DOTALL](reference.pcre.pattern.modifiers.md) для оптимізації
шаблону, або використовувати метасимвол '^' для вказівки явного
заякорювання.

Якщо захоплююча підмаска повторюється, результуючим
значенням підмаски буде підрядок, що збігається з результатом останньої
ітерації. Наприклад, після того, як `(tweedle[dume]{3}\s*)+` співпаде з
"tweedledum tweedledee", результуючим значенням підмаски буде
"tweedledee". Однак, якщо присутні вкладені захоплюючі
підмаски, відповідні значення можуть бути встановлені у попередніх
ітераціях. Наприклад, після того, як `/(a|(b))+/` співпаде з "aba",
значенням другого захопленого підрядка буде "b".
