- [«do-while](control-structures.do.while.md)
- [foreach »](control-structures.foreach.md)

- [PHP Manual](index.md)
- [Керування конструкції](language.control-structures.md)
- for

## for

(PHP 4, PHP 5, PHP 7, PHP 8)

Цикл `for` найскладніший цикл у PHP. Він поводиться так само, як і в мові
C. Синтаксис циклу `for` наступний:

for (expr1; expr2; expr3)
statement

Перший вираз (`expr1`) завжди обчислюється (виконується) лише один
раз на початку циклу.

На початку кожної ітерації оцінюється вираз `expr2`. Якщо воно
приймає значення **`true`**, то цикл триває та виконуються
вкладені оператори. Якщо воно набуває значення **`false`**, виконання
циклу закінчується.

Наприкінці кожної ітерації вираз `expr3` обчислюється (виконується).

Кожен із виразів може бути порожнім або містити кілька виразів,
розділених комами. В `expr2` всі вирази, розділені комами,
обчислюються, але результат береться із останнього. Якщо вираз `expr2`
відсутня, це означає, що цикл виконуватиметься нескінченно. (PHP
неявно сприймає це значення як **`true`**, так само, як у мові C).
Це може бути не так марно, як ви могли подумати, оскільки часто
необхідно перервати цикл, використовуючи умовний оператор
[`break`](control-structures.break.md) замість використання виразу
у циклі `for`, яке набуває справжнього значення.

Розглянемо такі приклади. Усі вони відображають числа від 1 до 10:

` <?php/* приклад 1 */for ($i u003d 1; $i <u003d 10; $i++) {    echo $i;}/* приклад 2 */for ($i u003d 1; ; if ($i > 10) {         break; }   echo $i;}/* приклад 3 */$i u003d 1;for (; ; ) {    if ($i > 10) {         break; }   echo $i; $i++;}/* приклад 4 */for ($i u003d 1, $j u003d 0; $i <u003d 10; $j +u003d $i, print $i, $i++);?> `

Звичайно, перший приклад здається найкращим (або, можливо, четвертий),
але ви можете виявити, що можливість використовувати порожні вирази в
циклах `for` може стати зручною у багатьох випадках.

PHP також підтримує альтернативний синтаксис з двокрапкою для циклів
`for`.

for (expr1; expr2; expr3):
statement
...
endfor;

Перебір масивів як показано нижче - це звичайна справа для багатьох
користувачів.

`<?php/* * Це масив з деякими даними, ми ми хочемо змінити * при роботі цикла. */$people u003d array(    array('name' u003d> 'Kalle', 'salt' u003d> 856412),    array('name' u003d> 'Pierre', 'salt' u003d>$2; u003d 0; $i < count($people); ++$i) {    $people[$i]['salt'] u003d mt_rand(000000, 999999);}?> `

Вищенаведений код може працювати повільно, оскільки розмір масиву
обчислюється у кожній ітерації. Оскільки розмір не змінюється, цикл може
бути легко оптимізований за допомогою проміжної змінної, в яку
буде записано розмір масиву, замість повторюваних викликів функції
[count()](function.count.md):

` <?php$people u003d array(    array('name' u003d> 'Kalle', 'salt' u003d> 856412),   array('name' u003d> 'Pierre', 'salt' u003d>> $i u003d 0, $size u003d count($people); $i < $size; ++$i) {    $people[$i]['salt'] u003d mt_rand(000000, 99999')
