- [« Змінні змінних](language.variables.variable.md)
- [Константи »](language.constants.md)

- [PHP Manual](index.md)
- [Змінні](language.variables.md)
- Змінні ззовні PHP

## Змінні ззовні PHP

### HTML-форми (GET та POST)

Коли відбувається відправлення даних форми PHP-скрипту, інформація з цієї
Форма автоматично стає доступною йому. Існує кілька
способів отримання цієї інформації, наприклад:

**Приклад #1 Проста HTML-форма**

```htmlcode
<form actionu003d"foo.php" methodu003d"post">
Ім'я: <input typeu003d"text" nameu003d"username" /><br />
Email: <input typeu003d"text" nameu003d"email" /><br />
<input typeu003d"submit" nameu003d"submit" valueu003d"Відправь мене!" />
</form>
````

Є лише два способи отримати доступ до даних із форм HTML. Доступні
Тепер методи наведені нижче:

**Приклад #2 Доступ до даних із простої HTML-форми, надісланої через
POST**

` <?phpecho $_POST['username'];echo $_REQUEST['username'];?> `

GET-форма використовується аналогічно, за винятком того, що замість POST,
вам потрібно буде використати відповідну певну змінну
GET. GET відноситься також до `QUERY_STRING` (інформація в URL після '?').
Так, наприклад, `http://www.example.com/test.php?idu003d3` містить
GET-дані, доступні як `$_GET['id']`. Дивіться також $_REQUEST.

> **Примітка**:
>
> Точки та прогалини в іменах змінних перетворюється на знаки
> підкреслення. Наприклад, `<input nameu003d"a.b" />` стане
> `$_REQUEST["a_b"]`.

PHP також розуміє масиви у контексті змінних форми (дивіться
[відповідні FAQ](faq.md.md)). Наприклад, ви можете
згрупувати пов'язані змінні разом або використати цю
можливість отримання значень списку множинного вибору select.
Наприклад, давайте відправимо форму самої собі, а після відправки відобразимо
дані:

**Приклад #3 Більш складні змінні форми**

` <?phpif ($_POST) {    echo '<pre>'; echo htmlspecialchars(print_r($_POST, true)); echo '</pre>';}?><form actionu003d"" methodu003d"post">    Ім'я:  <input typeu003d"text" nameu003d"personal[name]" /><br />    Email: <input typeu003d"text" nameu003d"personal[email]" /><br />    Пиво: <br />    <select multiple nameu003d"beer[]">         <option  option valueu003d"guinness">Guinness</option>        <option valueu003d"stuttgarter">Stuttgarter Schwabenbräu</option>    </select><br />     | /></form>`

> **Примітка**: Якщо зовнішнє ім'я змінної починається з коректного
> синтаксису масиву, що завершують символи мовчки ігноруються. Наприклад,
> `<input nameu003d"foo[bar]baz">` стане `$_REQUEST['foo']['bar']`.

#### Імена змінних кнопки-зображення

При надсиланні форми замість стандартної кнопки можна використовувати
зображення за допомогою тега такого вигляду:

```htmlcode
<input typeu003d"image" srcu003d"image.gif" nameu003d"sub" />
````

Коли користувач клацне десь на зображенні, відповідна
форма буде передана на сервер із двома додатковими змінними -
`sub_x` та `sub_y`. Вони містять координати натискання користувача на
зображення. Досвідчені програмісти можуть помітити, що насправді
імена змінних, надісланих браузером, містять точку, а не
підкреслення, але PHP автоматично перетворює точку на підкреслення.

### HTTP Cookies

PHP прозоро підтримує HTTP cookies як визначено в [» RFC
6265](http://www.faqs.org/rfcs/rfc6265). Cookies - це механізм для
зберігання даних у віддаленому браузері і, таким чином, відстеження та
ідентифікації користувачів, що повернулися. Ви можете встановити cookies,
використовуючи функцію [setcookie()](function.setcookie.md). Cookies
є частиною HTTP-заголовка, тому функція SetCookie повинна
викликатися до того, як браузеру буде відправлений будь-який
висновок. Це те ж обмеження, що й для функції
[header()](function.header.md). Дані, що зберігаються в cookie, доступні
у відповідних масивах даних cookie, таких як `$_COOKIE` та
`$_REQUEST`. Подробиці та приклади дивіться у довідковій сторінці
[setcookie()](function.setcookie.md).

> **Примітка**: Починаючи з PHP 7.2.34, 7.3.23 та 7.4.11, відповідно,
> *імена* вхідних cookie більше не декодуються з URL-закодованої
> рядки з міркувань безпеки.

Якщо ви бажаєте призначити безліч значень однієї змінної cookie, ви
можете привласнити їх як масив. Наприклад:

`<?php setcookie("MyCookie[foo]", 'Testing 1', time()+3600); setcookie("MyCookie[bar]", 'Testing 2', time()+3600);?> `

Це створить дві різні cookie, хоча у вашому скрипті `MyCookie` буде
тепер одним масивом. Якщо ви хочете встановити саме одну cookie з
безліччю значень, спочатку розгляньте можливість використання до
значенням такі функції, як [serialize()](function.serialize.md) або
[explode()](function.explode.md).

Зверніть увагу, що cookie замінить попередню cookie з тим самим ім'ям
у вашому браузері, якщо шлях або домен не відрізняються. Так, для
програми кошика покупок ви, можливо, захочете зберегти лічильник. То
є:

**Приклад #4 Приклад використання
[setcookie()](function.setcookie.md)**

` <?phpif (isset($_COOKIE['count'])) {   $count u003d $_COOKIE['count'] + 1;} else {   $count u003d 1;}setcookie('count' )+3600);setcookie("Cart[$count]", $item, time()+3600);?> `

### Точки в іменах змінних, що приходять

Як правило, PHP не змінює імен змінних, що передаються скрипту. Проте
слід зазначити, що точка не є коректним символом у імені
змінної PHP. Тому розглянемо такий запис:

`<?php$varname.ext; /* невірне ім'я змінної */?> `

В даному випадку інтерпретатор бачить змінну $varname, після якої
йде оператор конкатенації, а потім голий рядок (тобто не
укладений у лапки рядок, що не відповідає жодному з ключових
або зарезервованих слів) 'ext'. Очевидно, що це не дасть очікуваного
результату.

З цієї причини важливо відзначити, що PHP автоматично замінюватиме
будь-які точки в іменах, що надходять змінних на символи підкреслення.

### Визначення типів змінних

Оскільки PHP визначає типи змінних та перетворює їх (як правило)
при необхідності, не завжди очевидно, який тип має дана
змінна будь-якої миті часу. PHP містить кілька функцій,
що дозволяють визначити тип змінної, таких як:
[gettype()](function.gettype.md),
[is_array()](function.is-array.md),
[is_float()](function.is-float.md), [is_int()](function.is-int.md),
[is_object()](function.is-object.md) та
[is_string()](function.is-string.md). Дивіться також розділ
[Типи](language.types.md).

HTTP є текстовим протоколом, і більшість, якщо не все,
вміст, який приходить у [суперглобальні
масиви](language.variables.superglobals.md), наприклад, `$_POST` та
`$_GET`, залишиться у вигляді рядків. PHP не буде перетворювати значення в
певний тип. У наведеному нижче прикладі `$_GET["var1"]` буде
містити рядок "null", а `$_GET["var2"]` - рядок "123".

/index.php?var1u003dnull&var2u003d123

### Список змін

| Версія | Опис |
|------------------------|------------------------ -------------------------------------------------- --------------------------------|
| 7.2.34, 7.3.23, 7.4.11 | *імена* вхідних cookie більше не декодуються з URL-закодованого рядка з міркувань безпеки. |
