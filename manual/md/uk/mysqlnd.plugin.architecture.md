- [« Отримання API плагінів mysqlnd](mysqlnd.plugin.obtaining.md)
- [API плагінів mysqlnd »](mysqlnd.plugin.api.md)

- [PHP Manual](index.md)
- [API для плагінів до вбудованого драйвера MySQL](mysqlnd.plugin.md)
- Архітектура плагінів MySQL Native Driver

## Архітектура плагінів MySQL Native Driver

У цій секції розглянуто архітектуру плагінів `mysqlnd`.

*Поверхневий огляд MySQL Native Driver*

Перед початком розробки плагінів `mysqlnd`, корисно ознайомитись, як
сам собою організований `mysqlnd`. `Mysqlnd` складається з наступних
модулів:

| Модулі статистики mysqlnd_statistics.c |
|-----------------------------------|------------- -----------|
| Поєднання | mysqlnd.c |
| Результуючий набір mysqlnd_result.c |
| Методи результуючого набору | mysqlnd_result_meta.c |
| Оператор | mysqlnd_ps.c |
| Мережа | mysqlnd_net.c |
| Протокол обміну mysqlnd_wireprotocol.c |

**Організаційна схема mysqlnd, помодульно**

*Об'єктно-орієнтована парадигма C*

На рівні коду `mysqlnd` використовує патерн C для реалізації
об'єктно-орієнтованого підходу

C об'єкти описують використовуючи `struct`. Члени структури є
властивостями об'єкта. Члени структури, що вказують на функції, є
методами.

На відміну від таких мов як C++ або Java, C немає фіксованих правил
успадкування. Проте є деякі домовленості, яким
необхідно слідувати, але ми обговоримо пізніше.

*Життєвий цикл PHP*

При розгляді життєвого циклу PHP існує два основних цикли:

- Цикл старту та зупинки двигуна PHP

- Цикл обробки запиту

При старті двигуна PHP, перш за все викликається функція ініціалізації
модулів (MINIT) кожного зареєстрованого модуля. Це дозволяє
кожному модулю встановити змінні та виділити ресурси, які будуть
задіяні весь час життя процесу движка PHP. Коли двигун PHP
вимикається, він викликає функцію зупинки модулів (MSHUTDOWN) для
кожного модуля.

Протягом життєвого циклу двигуна PHP, він приймає деяке
кількість запитів. Кожен запит породжує новий цикл життя. На
кожен запит, двигун PHP викликає функцію ініціалізації для кожного
модуля. Модуль може зробити виставлення змінних та виділення
ресурсів, необхідних обслуговування запита. Після закінчення життя
Запит, двигун викликає функцію зупинки запиту (RSHUTDOWN) для
кожного модуля, що дозволяє зробити необхідні чистки.

*Як працює плагін*

Плагін `mysqlnd` працює перехоплюючи виклики модулів, які використовують
`mysqlnd`, до `mysqlnd`. Це досягається заміною таблиці функцій
`mysqlnd` на створену плагіном.

Наступний код демонструє заміну таблиці функцій mysqlnd:

/* сховище оригінальної таблиці */
struct st_mysqlnd_conn_methods org_methods;

void minit_register_hooks(TSRMLS_D) {
/* активна таблиця функцій */
struct st_mysqlnd_conn_methods * current_methods
u003d mysqlnd_conn_get_methods();

/* Бекап оригінальної таблиці */
memcpy(&org_methods, current_methods,
sizeof(struct st_mysqlnd_conn_methods);

/* встановлення нових методів */
current_methods->query u003d MYSQLND_METHOD(my_conn_class, query);
}

Маніпуляцією з таблицею функцій з'єднання необхідно займатися
етапі ініціалізації модуля (MINIT) Таблиця функцій – це глобальний
ресурс, що розділяється. У багатопотоковому оточенні, зі складанням TSRM,
маніпуляція глобальним ресурсом, що розділяється на етапі обробки запиту
призведе до конфліктів.

> **Примітка**:
>
> Не використовуйте будь-яку логіку, пов'язану з фіксованим розміром
> під час маніпуляції з таблицею функцій `mysqlnd`. Завжди додавайте нові
> методи наприкінці таблиці, оскільки сама таблиця може у майбутньому будь-який
> момент змінити.

*Виклик батьківських методів*

Якщо записи оригінальної таблиці функцій були збережені, завжди
залишається можливість викликати оригінальний метод – батьківський.

У деяких випадках, наприклад, для Connection::stmt_init(), життєво
важливо спочатку викликати батьківський метод, і тільки потім робити що-небудь
у новому методі.

MYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,
const char *query, unsigned int query_len TSRMLS_DC) {

php_printf("my_conn_class::query(query u003d %s)
", Query);

query u003d "SELECT 'query rewritten' FROM DUAL";
query_len u003d strlen (query);

return org_methods.query(conn, query, query_len); /* Повернення з викликом батька */
}

*Розширення властивостей*

Об'єкти `mysqlnd` представлені як C struct. Неможливо додати члена до
C struct під час виконання. Користувачі об'єктів mysqlnd не можуть
просто додати властивості об'єкту.

Довільні дані (властивості) можуть бути додані до об'єкта `mysqlnd`
з використанням відповідної функції із сімейства
`mysqlnd_plugin_get_plugin_<object>_data()`. При розміщенні об'єкту
`mysqlnd` резервується місце в кінці об'єкта для утримання `void *`
вказівника на довільні дані. `mysqlnd` резервує місце для одного
`void*` покажчика на плагін.

У наступній таблиці показано, як обчислити положення вказівника для
конкретного плагіна:

| Адреса пам'яті Вміст |
|--------------------------|---------------------- ---------------------|
| 0 | Початок об'єкту mysqlnd(C struct) |
| n | Кінець об'єкту mysqlnd (C struct) |
| n + (m x sizeof(void\*)) | void\* для даних об'єкта плагіна номер m |

**Розрахунок покажчика для mysqlnd**

Якщо ви плануєте робити підклас від одного з конструкторів об'єкту
`mysqlnd`, які дозволені, майте це на увазі!

Наступний код демонструє розширення властивостей:

/* Будь-які дані, які ми хочемо додати */
typedef struct my_conn_properties {
unsigned long query_counter;
} MY_CONN_PROPERTIES;

/* ідентифікатор плагіна */
unsigned int my_plugin_id;

void minit_register_hooks(TSRMLS_D) {
/* отримуємо унікальний ідентифікатор плагіна */
my_plugin_id u003d mysqlnd_plugin_register();
/* snip - see Extending Connection: methods */
}

static MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {
MY_CONN_PROPERTIES** props;
props u003d (MY_CONN_PROPERTIES**) mysqlnd_plugin_get_plugin_connection_data(
conn, my_plugin_id);
if (!props || !(*props)) {
*props u003d mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);
(*props)->query_counter u003d 0;
}
return props;
}

Розробник плагіна відповідає за керування пам'яттю даних плагіна.

Рекомендується використовувати керування пам'яттю `mysqlnd` для даних
плагіна. Ці функції називаються використовуючи такі угоди: `mnd_*loc()`.
Управління пам'яттю `mysqlnd` має низку корисних властивостей, таких як
використання налагоджувального модуля управління пам'яттю в неналагоджувальних
складання.

| | Коли робити підклас? | Кожен екземпляр має власну таблицю функцій? | Як створювати підклас? |
|---------------------------------------------|--- ------------------------|------------------------- ---------------------------------|---------------- -------------------------------------------------- -------------------|
| Сполука (MYSQLND) | MINIT | Ні | mysqlnd_conn_get_methods() |
| Результативний набір (MYSQLND_RES) | MINIT or later | Так | mysqlnd_result_get_methods() або методом об'єкта, що маніпулює таблицею функцій |
| Результативний набір (MYSQLND_RES_METADATA) | MINIT | Ні | mysqlnd_result_metadata_get_methods() |
| Оператор (MySQLND_STMT) | MINIT | Ні | mysqlnd_stmt_get_methods() |
| Мережа (MYSQLND_NET) MINIT чи пізніше | Так | mysqlnd_net_get_methods() або методом об'єкта, що маніпулює таблицею функцій
| Протокол обміну (MYSQLND_PROTOCOL) MINIT чи пізніше | Так | mysqlnd_protocol_get_methods() або методом об'єкта, що маніпулює таблицею функцій |

**Коли та як створювати підклас**

Ви не повинні маніпулювати таблицею функцій після MINIT, якщо це прямо
не дозволено у таблиці вище.

Деякі класи містять покажчик таблицю функцій методів. всі
екземпляри подібних класів повинні ділити одну й ту саму таблицю функцій.
Для того, щоб уникнути хаосу, особливо в багатопотоковому оточенні,
керувати такими таблицями функцій слід лише під час MINIT.

Інші класи використовують копії глобально поділених таблиць функцій.
Таблиця функцій створюється одночасно з об'єктом. Кожен об'єкт
використовує таблицю. Це дає вам дві можливості: ви можете
керувати таблицею функцій за промовчанням для об'єкта під час MINIT, а
також ви можете змінювати методи об'єкта, не торкаючись інших екземплярів.
цього ж класу.

Перевага таблиці функцій у продуктивності, так як
немає потреби копіювати таблицю функцій окремо для кожного об'єкта.

[TABLE]

**Статус конструктора**

Настійно рекомендується не замінювати конструктор повністю. Конструктори
виробляють виділення пам'яті. Виділення пам'яті життєво необхідне
API плагінів `mysqlnd` та для логіки об'єкта `mysqlnd`. Якщо вам не
страшні попередження і хочете сильно поміняти конструктор, то хоча б
Викличте батьківський конструктор перш, ніж що-небудь робити.

Незважаючи на всі попередження, це може бути корисним для конструктора
підкласу. Конструктори – відмінне місце для зміни таблиці функцій
для об'єктів, які не використовують розділену таблицю, таких як
результуючий набір, мережа, протокол обміну.

| | Похідний метод має викликати батьківський? | Деструктор
|-----------------------------------|------------- -----------------------------------|-------------- -------------------|
| Поєднання | так, після виконання методу | free_contents(), end_psession() |
| Результуючий набір так, після виконання методу | free_result() |
| Методи результуючого набору | так, після виконання методу | free() |
| Оператор | так, після виконання методу | dtor(), free_stmt_content() |
| Мережа | так, після виконання методу | free() |
| Протокол обміну так, після виконання методу | free() |

**Статус знищення**

Деструктори є відповідним місцем, щоб звільнити ресурси,
займані властивостями `mysqlnd_plugin_get_plugin_<object>_data()`.

Перелічені деструктори можуть не співпадати з актуальними методами
`mysqlnd` для очищення самого об'єкта. Однак вони є найкращим
місцем, куди можна вклинитися для очищення даних свого плагіна. Так
як і з конструкторами, ви можете повністю перевизначити ці
методи, але це не рекомендується. Якщо вам необхідно вставити в
кожен із перерахованих методів очищення даних свого плагіна, то
необхідно забезпечити запуск батьківських методів `mysqlnd`.

Рекомендований метод для плагінів – виконати код очищення даних
плагіна і відразу після цього викликати батьківський метод.
