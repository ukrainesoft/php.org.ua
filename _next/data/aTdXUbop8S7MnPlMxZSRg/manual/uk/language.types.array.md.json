{"pageProps":{"page":{"slug":"language.types.array.md","content":"## Масиви\n\nМасив у PHP – це впорядкована структура даних, яка пов'язує *значения* и*ключі*. Цей тип даних оптимізований для різних цілей, тому з ним працюють як з масивом, списком (вектором), хеш-таблицею (реалізацією карти), словником, колекцією, стеком, чергою і, можливо, ще чимось. Оскільки значення масиву бувають інші масиви, також доступні дерева і багатовимірні масиви.\n\nПояснення цих структур даних виходить за рамки цього посібника, але щонайменше один приклад буде наведено для кожної з них. За додатковою інформацією звертаються до великого обсягу літератури на цю велику тему.\n\n### Синтаксис\n\n#### Определение при помощи[array()](function.array.md)\n\nМасив (array) створюють мовною конструкцією [array()](function.array.md). Як аргументи вона приймає будь-яку кількість розділених комами пар `ключ => значення`\n\n```synopsis\narray(\n    key  => value,\n    key2 => value2,\n    key3 => value3,\n    ...\n)\n```\n\nКома після останнього елемента масиву необов'язкова і її можна опустити. Зазвичай це робиться для однорядкових масивів, краще віддати перевагу `array(1, 2)` замість `array(1, 2, )`. Для багаторядкових масивів, навпаки, зазвичай вказують кому, що висить, так як спрощує додавання нових елементів в кінець масиву.\n\n> **Зауваження** :\n> \n> Існує короткий синтаксис масиву, який замінює мовну конструкцію `array()` вираз `[]`\n\n**Приклад #1 Простий масив**\n\n```php\n<?php\n\n$array = array(\n    \"foo\" => \"bar\",\n    \"bar\" => \"foo\",\n);\n\n// Работа с коротким синтаксисом массива\n$array = [\n    \"foo\" => \"bar\",\n    \"bar\" => \"foo\",\n];\n\n?>\n```\n\nКлюч масиву (key) можна вказувати або як ціле значення (int), або як рядок (string). Значення масиву (value) може належати будь-якому типу даних.\n\nДодатково відбудуться такі перетворення ключа key:\n\n-   Рядки (string), що містять ціле число (int) (за винятком випадків, коли перед числом вказують знак`+` ), будуть перетворені на ціле число (int). Наприклад, ключ зі значенням`«8»`збережеться зі значенням`8`. При цьому значення`«08»`не перетворюється, оскільки воно - не коректне десяткове ціле.\n-   Числа з плаваючою точкою (float) також перетворюються на цілі значення (int) - дробова частина буде відкинута. Наприклад, ключ зі значенням`8.7`буде збережеться зі значенням`8`\n-   Логічний тип (bool) також перетворюється на цілий тип (int). Наприклад, ключ зі значенням\\*\\*`true`**збережеться зі значенням , а ключ зі значенням**`false`\\*\\*збережеться зі значенням\n-   Тип null перетворюється на порожній рядок. Наприклад, ключ зі значенням`null`збережеться зі значенням`\"\"`\n-   Масиви (array) та об'єкти (object)*не можна*вказувати як ключі. Це згенерує попередження:`Неприпустимий тип зміщення (Illegal offset type)`\n\nЯкщо декількома елементами в оголошенні масиву вказано однаковий ключ, лише останній буде збережено, а інші будуть перезаписані.\n\n**Приклад #2 Приклад перетворення типів та перезапису елементів**\n\n```php\n<?php\n\n$array = array(\n    1    => \"a\",\n    \"1\"  => \"b\",\n    1.5  => \"c\",\n    true => \"d\",\n);\nvar_dump($array);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(1) {\n  [1]=>\n  string(1) \"d\"\n}\n```\n\nОскільки всі ключі в наведеному прикладі перетворюються на , значення буде перезаписано на кожен новий елемент і залишиться тільки останнє значення `«d»`\n\nPHP дозволяє масивам містити одночасно цілі (int) і рядкові (string) ключі, оскільки PHP однаково сприймає індексні та асоціативні масиви.\n\n**Приклад #3 Змішані цілочислові (int) та рядкові (string) ключі**\n\n```php\n<?php\n\n$array = array(\n    \"foo\" => \"bar\",\n    \"bar\" => \"foo\",\n    100   => -100,\n    -100  => 100,\n);\nvar_dump($array);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(4) {\n  [\"foo\"]=>\n  string(3) \"bar\"\n  [\"bar\"]=>\n  string(3) \"foo\"\n  [100]=>\n  int(-100)\n  [-100]=>\n  int(100)\n}\n```\n\nКлюч (key) – необов'язковий. Якщо він не вказаний, PHP інкрементує попереднє найбільше ціле (int) значення ключа.\n\n**Приклад #4 Індексні масиви без ключа**\n\n```php\n<?php\n\n$array = array(\"foo\", \"bar\", \"hallo\", \"world\");\nvar_dump($array);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(4) {\n  [0]=>\n  string(3) \"foo\"\n  [1]=>\n  string(3) \"bar\"\n  [2]=>\n  string(5) \"hallo\"\n  [3]=>\n  string(5) \"world\"\n}\n```\n\nДозволено вказувати ключ одним елементам та пропускати для інших:\n\n**Приклад #5 Ключі для деяких елементів**\n\n```php\n<?php\n\n$array = array(\n         \"a\",\n         \"b\",\n    6 => \"c\",\n         \"d\",\n);\nvar_dump($array);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(4) {\n  [0]=>\n  string(1) \"a\"\n  [1]=>\n  string(1) \"b\"\n  [6]=>\n  string(1) \"c\"\n  [7]=>\n  string(1) \"d\"\n}\n```\n\nВидно, что последнее значение`«d»` надалося ключу `7`. Це сталося тому, що перед цим найбільшим значенням цілого ключа було `6`\n\n**Приклад #6 Розширений приклад перетворення типів та перезапису елементів**\n\n```php\n<?php\n\n$array = array(\n    1    => 'a',\n    '1'  => 'b', // значение «b» перезапишет значение «a»\n    1.5  => 'c', // значение «c» перезапишет значение «b»\n    -1 => 'd',\n    '01'  => 'e', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1\n    '1.5' => 'f', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1\n    true => 'g', // значение «g» перезапишет значение «c»\n    false => 'h',\n    '' => 'i',\n    null => 'j', // значение «j» перезапишет значение «i»\n    'k', // значение «k» присваивается ключу 2. Потому что самый большой целочисленный ключ до этого был 1\n    2 => 'l', // значение «l» перезапишет значение «k»\n);\n\nvar_dump($array);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(7) {\n  [1]=>\n  string(1) \"g\"\n  [-1]=>\n  string(1) \"d\"\n  [\"01\"]=>\n  string(1) \"e\"\n  [\"1.5\"]=>\n  string(1) \"f\"\n  [0]=>\n  string(1) \"h\"\n  [\"\"]=>\n  string(1) \"j\"\n  [2]=>\n  string(1) \"l\"\n}\n```\n\nЦей приклад включає всі варіації перетворення ключів та перезапису елементів\n\n#### Доступ до елементів масиву через синтаксис квадратних дужок\n\nДоступ до елементів масиву можна отримувати, використовуючи синтакс. `array[key]`\n\n**Приклад #7 Доступ до елементів масиву**\n\n```php\n<?php\n\n$array = array(\n    \"foo\" => \"bar\",\n    42    => 24,\n    \"multi\" => array(\n         \"dimensional\" => array(\n             \"array\" => \"foo\"\n         )\n    )\n);\n\nvar_dump($array[\"foo\"]);\nvar_dump($array[42]);\nvar_dump($array[\"multi\"][\"dimensional\"][\"array\"]);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(3) \"bar\"\nint(24)\nstring(3) \"foo\"\n```\n\n> **Зауваження** :\n> \n> До PHP 8.0.0 квадратні та фігурні дужки могли взаємозамінюватися при доступі до елементів масиву (наприклад, у наведеному прикладі `$array[42]`и`$array{42}` робили те саме). Синтаксис фігурних дужок застарів із PHP 7.4.0 і більше не підтримується з PHP 8.0.0.\n\n**Приклад #8 Розіменування масиву**\n\n```php\n<?php\n\nfunction getArray() {\n    return array(1, 2, 3);\n}\n\n$secondElement = getArray()[1];\n\n?>\n```\n\n> **Зауваження** :\n> \n> Спроба доступу до невизначеного ключа в масиві — це те саме, що й спроба доступу до будь-якої іншої невизначеної змінної: буде видано помилку рівня **`E_WARNING`**(ошибка уровня\\*\\*`E_NOTICE`\\*\\* до PHP 8.0.0), і результат дорівнюватиме **`null`**\n\n> **Зауваження** :\n> \n> Спроба розіменувати не масив, а скалярне значення, яке відрізняється від рядка (string), віддасть **`null`**, Тоді як розйменування рядка (string) трактує її як індексний масив. При такій спробі до PHP 7.4.0 не видавалося повідомлення про помилку. З PHP 7.4.0 видається помилка рівня **`E_NOTICE`**; з PHP 8.0.0 видається помилка рівня **`E_WARNING`**\n\n#### Створення та модифікація із застосуванням синтаксису квадратних дужок\n\nРозробник може змінювати існуючий масив явною установкою значень.\n\nЦе робиться шляхом присвоєння значень масиву (array) із зазначенням ключа у квадратних дужках. Крім того, якщо опустити ключ, вийде порожня пара дужок (`[]`\n\n```synopsis\n$arr[key] = value;\n    $arr[] = value;\n    // Ключ key может принадлежать типу int или string\n    // Значение value может быть любым значением любого типа\n```\n\nЯкщо масив $arr ще не існує або для нього встановлено значення \\*\\*`null`** або **`false`\\*\\*він буде створений. Таким чином, це ще один спосіб визначити масив array. Однак такий спосіб застосовувати не рекомендовано, оскільки якщо змінна $arr вже містить значення (наприклад, рядок (string) із змінної запиту), то це значення залишиться на місці та вираз `[]` може означати [доступ до символу в рядку](language.types.string.md#language.types.string.substr). Краще ініціалізувати змінну явним наданням значення.\n\n> **Зауваження**: Починаючи з PHP 7.1.0 оператор порожнього індексу на рядку викине фатальну помилку Раніше рядок мовчки перетворювався на масив.\n\n> **Зауваження**: З PHP 8.1.0 спосіб, яким створювали новий масив приведенням до нього значення **`false`**, застарілий. Спосіб, яким створюють новий масив приведенням до нього значення **`null`** і невизначеного значення, як і раніше, доступний.\n\nДля зміни конкретного значення елементу просто надають нове значення, вказуючи його ключ. Якщо потрібно видалити пару ключ/значення, необхідно викликати конструкцію [unset()](function.unset.md)\n\n```php\n<?php\n\n$arr = array(5 => 1, 12 => 2);\n\n$arr[] = 56;    // В этом месте скрипта это\n                // то же самое, что и $arr[13] = 56;\n\n$arr[\"x\"] = 42; // Это добавляет в массив новый\n                // элемент с ключом «x»\n\nunset($arr[5]); // Это удаляет элемент из массива\n\nunset($arr);    // Это удаляет весь массив\n\n?>\n```\n\n> **Зауваження** :\n> \n> Як було сказано раніше, якщо розробник не вказав ключ, то буде взято максимальний з існуючих цілих (int) індексів, і новим ключем буде це максимальне значення (в крайньому випадку 0) плюс 1. Якщо цілих (int) індексів ще немає, то ключем буде (нуль).\n> \n> Враховують, що максимальне ціле значення ключа *не обов'язково існує в масиві в даний момент*. Воно могло існувати в масиві якийсь час з останньої переіндексації. Наступний приклад це ілюструє:\n> \n> ```php\n> <?php\n> \n> // Створюємо простий масив.\n> $array = array(1, 2, 3, 4, 5);\n> print_r($array);\n> \n> // Тепер видаляємо кожен елемент, але масив залишаємо недоторканим:\n> foreach ($array as $i => $value) {\n>     unset($array[$i]);\n> }\n> print_r($array);\n> \n> // Додаємо елемент (зверніть увагу, що новим ключем буде 5, а чи не 0).\n> $array[] = 6;\n> print_r($array);\n> \n> // Переіндексація:\n> $array = array_values($array);\n> $array[] = 7;\n> print_r($array);\n> \n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> Array\n> (\n>     [0] => 1\n>     [1] => 2\n>     [2] => 3\n>     [3] => 4\n>     [4] => 5\n> )\n> Array\n> (\n> )\n> Array\n> (\n>     [5] => 6\n> )\n> Array\n> (\n>     [0] => 6\n>     [1] => 7\n> )\n> ```\n\n#### Деструктуризація масиву\n\nМасиви можна деструктурувати мовними конструкціями `[]` (починаючи з PHP 7.1.0) або [list()](function.list.md). Ці мовні конструкції можна використовувати для деструктуризації масиву на окремі змінні.\n\n```php\n<?php\n\n$source_array = ['foo', 'bar', 'baz'];\n[$foo, $bar, $baz] = $source_array;\necho $foo;    // выведет «foo»\necho $bar;    // выведет «bar»\necho $baz;    // выведет «baz»\n\n?>\n```\n\nДеструктуризацію масиву також виконують у конструкції [foreach](control-structures.foreach.md) для деструктуризації багатовимірного масиву під час ітерації масивом.\n\n```php\n<?php\n\n$source_array = [\n    [1, 'John'],\n    [2, 'Jane'],\n];\nforeach ($source_array as [$id, $name]) {\n    // логика работы с $id и $name\n}\n\n?>\n```\n\nЕлементи масиву будуть проігноровані, якщо змінна не вказана. Деструктуризація масиву починається з індексу\n\n```php\n<?php\n\n$source_array = ['foo', 'bar', 'baz'];\n\n// Присваивание элемента с индексом 2 переменной $baz\n[, , $baz] = $source_array;\n\necho $baz;    // выведет \"baz\"\n\n?>\n```\n\nЗ PHP 7.1.0 асоціативні масиви також можна деструктурувати. Це спрощує вибір потрібного елемента в масивах з числовим індексом, оскільки індекс може бути явно.\n\n```php\n<?php\n\n$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];\n\n// Присваивание элемента с индексом «baz» переменной $three\n['baz' => $three] = $source_array;\n\necho $three;    // выведет 3\n\n$source_array = ['foo', 'bar', 'baz'];\n\n// Присваивание элемента с индексом 2 переменной $baz\n[2 => $baz] = $source_array;\n\necho $baz;    // выведет «baz»\n\n?>\n```\n\nДеструктуризацією масив користуються, щоб поміняти дві змінні місця.\n\n```php\n<?php\n\n$a = 1;\n$b = 2;\n[$b, $a] = [$a, $b];\necho $a;    // выведет 2\necho $b;    // выведет 1\n\n?>\n```\n\n> **Зауваження** :\n> \n> Оператор`...` не підтримується у привласненнях.\n\n> **Зауваження** :\n> \n> Спроба отримати доступ до невизначеного ключа масиву аналогічна до будь-якої іншої невизначеної змінної: буде видано повідомлення про помилку рівня **`E_WARNING`** (помилки рівня **`E_NOTICE`**до PHP 8.0.0), а результатом будет значение**`null`**\n\n### Корисні функції\n\nДля роботи з масивами є чимало корисних функцій. Докладніше про це розказано у розділі « [Функції для роботи з масивами](ref.array.md) ».\n\n> **Зауваження** :\n> \n> Мовна конструкція [unset()](function.unset.md) вміє видаляти ключі масиву. Зверніть увагу, що масив *НЕ* буде переіндексовано. Якщо потрібно поведінку в стилі «видалити та зрушити», можна переіндексувати масив функцією [array\\_values()](function.array-values.md)\n> \n> ```php\n> <?php\n> \n> $a = array(1 => 'один', 2 => 'два', 3 => 'три');\n> unset($a[2]);\n> /* дасть масив, поданий так:\n>    $a = array(1 => 'один', 3 => 'три');\n>    а НЕ так:\n>    $a = array(1 => 'один', 2 => 'три');\n> */\n> \n> $ b = array_values ​​($ a);\n> // Тепер $b це array(0 => 'один', 1 => 'три')\n> ?>\n> ```\n\nУправляющая конструкция[foreach](control-structures.foreach.md) Існує спеціально для масивів. Вона пропонує простий спосіб перебору масиву.\n\n### Що можна і не можна робити з масивами\n\n#### Чому вираз `$foo[bar]` неправильно?\n\nРекомендовано укладати в лапки рядковий літерал в індексі асоціативного масиву. Наприклад, потрібно писати `$foo['bar']`, а не`$foo[bar]`. Але чому? Часто у старих скриптах можна зустріти наступний синтаксис:\n\n```php\n<?php\n\n$foo[bar] = 'враг';\necho $foo[bar];\n// и т. д.\n\n?>\n```\n\nЦе не так, хоч і працює. Причина в тому, що цей код містить невизначену константу (`bar`), а не рядок (`'bar'` - Зверніть увагу на лапки). Це працює, тому що PHP автоматично перетворює *«голий рядок»* (не укладений у лапки рядок, який не відповідає жодному з відомих символів мови) у рядок зі значенням цього «голого рядка». Наприклад, якщо константа з ім'ям \\*\\*`bar`\\*\\*не определена, то PHP заменит bar на строку`«bar»` і працюватиме з нею.\n\n**Увага**\n\nРезервний варіант для обробки невизначеної константи як порожнього рядка видає помилку рівня **`E_NOTICE`**. Починаючи з PHP 7.2.0, поведінка оголошена застарілою і видає помилку рівня. **`E_WARNING`**. Починаючи з PHP 8.0.0 видалено та викидає виняток [Error](class.error.md)\n\n> **Зауваження**: Це не означає, що потрібно *завжди* укладати ключ у лапки. Не обов'язково укладати в лапки [константи](language.constants.md) або [змінні](language.variables.md)оскільки це завадить PHP обробляти їх.\n> \n> ```php\n> <?php\n> \n> error_reporting(E_ALL);\n> ini_set('display_errors', true);\n> ini_set('html_errors', false);\n> \n> // Простий масив:\n> $array = array(1, 2);\n> $ count = count ($ array);\n> \n> for ($i = 0; $i < $count; $i++) {\n>     echo \"\\nПеревіряємо $i: \\n\";\n>     echo \"Погано:\". $array['$i'] . \"\\n\";\n>     echo \"Добре: \". $array[$i] . \"\\n\";\n>     echo \"Погано: {$array['$i']}\\n\";\n>     echo \"Добре: {$array[$i]}\\n\";\n> }\n> \n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> Перевіряємо 0:\n> Notice: Undefined index: $i in /path/to/script.md on line 9\n> Погано:\n> Добре: 1\n> Notice: Undefined index: $i in /path/to/script.md on line 11\n> Погано:\n> Добре: 1\n> \n> Перевіряємо 1:\n> Notice: Undefined index: $i in /path/to/script.md on line 9\n> Погано:\n> Добре: 2\n> Notice: Undefined index: $i in /path/to/script.md on line 11\n> Погано:\n> Добре: 2\n> ```\n\nДодаткові приклади, що підтверджують цей факт:\n\n```php\n<?php\n\n// Показываем все ошибки\nerror_reporting(E_ALL);\n\n$arr = array('fruit' => 'apple', 'veggie' => 'carrot');\n\n// Верно\nprint $arr['fruit'];  // apple\nprint $arr['veggie']; // carrot\n\n// Неверно. Это работает, но из-за неопределённой константы с\n// именем fruit также выдаёт ошибку PHP уровня E_NOTICE\n//\n// Notice: Use of undefined constant fruit - assumed 'fruit' in...\nprint $arr[fruit];    // apple\n\n// Давайте определим константу, чтобы продемонстрировать, что\n// происходит. Присвоим константе с именем fruit значение «veggie».\ndefine('fruit', 'veggie');\n\n// Теперь обратите внимание на разницу\nprint $arr['fruit'];  // apple\nprint $arr[fruit];    // carrot\n\n// Внутри строки это нормально. Внутри строк константы не\n// рассматриваются, так что ошибки E_NOTICE здесь не произойдёт\nprint \"Hello $arr[fruit]\";      // Hello apple\n\n// С одним исключением: фигурные скобки вокруг массивов внутри\n// строк позволяют константам там находиться\nprint \"Hello {$arr[fruit]}\";    // Hello carrot\nprint \"Hello {$arr['fruit']}\";  // Hello apple\n\n// Это не будет работать и вызовет ошибку обработки:\n// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'\n// Это, конечно, также действует и с суперглобальными переменными в строках\nprint \"Hello $arr['fruit']\";\nprint \"Hello $_GET['foo']\";\n\n// Ещё одна возможность — конкатенация\nprint \"Hello \" . $arr['fruit']; // Hello apple\n\n?>\n```\n\nЯкщо директива [error\\_reporting](errorfunc.configuration.md#ini.error-reporting)настроена на режим отображения ошибок уровня\\*\\*`E_NOTICE`**(наПриклад,**`E_ALL`\\*\\*), помилки відразу будуть видні. За замовчуванням директива [error\\_reporting](errorfunc.configuration.md#ini.error-reporting) налаштована те що, щоб не показувати попередження.\n\nЯк зазначено у розділі [про синтаксис](language.types.array.md#language.types.array.syntax), усередині квадратних дужок («`[`» та «`]`») має бути вираз. Тобто такий код працює:\n\n```php\n<?php\n\necho $arr[somefunc($bar)];\n\n?>\n```\n\nЦе приклад роботи з функцією, що повертається значенням як індекс масиву. PHP також знає про константів:\n\n```php\n<?php\n\n$error_descriptions[E_ERROR]   = \"Произошла фатальная ошибка\";\n$error_descriptions[E_WARNING] = \"PHP сообщает о предупреждении\";\n$error_descriptions[E_NOTICE]  = \"Это лишь неофициальное замечание\";\n\n?>\n```\n\nОбратите внимание, что\\*\\*`E_ERROR`\\*\\* — це такий самий допустимий ідентифікатор, як і `bar` у першому прикладі. Але останній приклад по суті еквівалентний такому запису:\n\n```php\n<?php\n\n$error_descriptions[1] = \"Произошла фатальная ошибка\";\n$error_descriptions[2] = \"PHP выдал предупреждение\";\n$error_descriptions[8] = \"Это просто уведомление\";\n\n?>\n```\n\nоскільки значення константи **`E_ERROR`** відповідає значенню и т. д.\n\n##### То що ж у цьому поганого?\n\nКолись у майбутньому команда розробників PHP, можливо, захоче додати ще одну константу або ключове слово, або константа з іншого коду може втрутитися. Наприклад, неправильно використовувати слова `empty`и`default`, оскільки вони відносяться до [зарезервованим ключовим словам](reserved.md)\n\n> **Зауваження**: Повторимо, усередині рядка (string) у подвійних лапках допустимо не оточувати індекси масиву лапками, тому `«$foo[bar]»` - Припустима запис. У прикладах вище пояснено, чому додаткова інформація дана в розділі [про обробку змінних у рядках](language.types.string.md#language.types.string.parsing)\n\n### Перетворення на масив\n\nПеретворення цілого числа (int), числа з плаваючою точкою (float), рядки (string), логічного значення (bool) або ресурсу (resource) у масив — створює масив з одним елементом з індексом 0 та значенням скаляра, який було перетворено. Говорячи інакше, вираз `(array) $scalarValue` аналогічно виразу `array($scalarValue)`\n\nЯкщо об'єкт (object) буде перетворено на масив, елементами масиву будуть властивості (змінні-члени) цього об'єкта. Ключами будуть імена змінних-членів, з наступними примітними винятками: цілі численні властивості стануть недоступні; до закритих полів класу (private) на початок буде дописано ім'я класу; до захищених полів класу (protected) на початок буде додано символ '\\*'. Ці додані з обох сторін значення також отримають `NUL`\\-байти. Неініціалізовані [типізовані властивості](language.oop5.properties.md#language.oop5.properties.typed-properties) автоматично відкидаються.\n\n```php\n<?php\n\nclass A {\n    private $B;\n    protected $C;\n    public $D;\n    function __construct()\n    {\n        $this->{1} = null;\n    }\n}\nvar_export((array) new A());\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray (\n  '' . \"\\0\" . 'A' . \"\\0\" . 'B' => NULL,\n  '' . \"\\0\" . '*' . \"\\0\" . 'C' => NULL,\n  'D' => NULL,\n  1 => NULL,\n)\n```\n\nЦе може викликати дещо несподівану поведінку:\n\n```php\n<?php\n\nclass A {\n    private $A; // Это станет '\\0A\\0A'\n}\nclass B extends A {\n    private $A; // Это станет '\\0B\\0A'\n    public $AA; // Это станет 'AA'\n}\nvar_dump((array) new B());\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(3) {\n  [\"BA\"]=>\n  NULL\n  [\"AA\"]=>\n  NULL\n  [\"AA\"]=>\n  NULL\n}\n```\n\nНаведений код покаже 2 ключі з ім'ям «AA», хоча один із них насправді має ім'я «\\\\0A\\\\0A».\n\nЯкщо перетворити на масив значення **`null`**, вийде порожній масив\n\n### Порівняння\n\nМасиви порівнюють функцією [array\\_diff()](function.array-diff.md) і [операторами масивів](language.operators.array.md)\n\n### Розпакування масиву\n\nМасив, перед яким вказано оператора `...`, буде розпакований під час визначення масиву Тільки масиви та об'єкти, які реалізують інтерфейс [Traversable](class.traversable.md), можна розпаковувати. Розпакування масиву оператором `...` доступна починаючи з PHP 7.4.0.\n\nМасив можна розпаковувати кілька разів і додавати звичайні елементи до або після оператора. `...` :\n\n**Приклад #9 Просте розпакування масиву**\n\n```php\n<?php\n\n// Применение короткого синтаксиса массива.\n// Работает также с синтаксисом array().\n$arr1 = [1, 2, 3];\n$arr2 = [...$arr1]; // [1, 2, 3]\n$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]\n$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]\n$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]\n\nfunction getArr() {\n  return ['a', 'b'];\n}\n\n$arr6 = [...getArr(), 'c' => 'd']; // ['a', 'b', 'c' => 'd']\n\n?>\n```\n\nРаспаковка массива оператором`...` дотримується семантики функції [array\\_merge()](function.array-merge.md). Тобто пізніші рядкові ключі перезаписують раніші, а цілочисленні ключі перенумеровуються:\n\n**Приклад #10 Розпакування масиву з дублюючим ключем**\n\n```php\n<?php\n\n// строковый ключ\n$arr1 = [\"a\" => 1];\n$arr2 = [\"a\" => 2];\n$arr3 = [\"a\" => 0, ...$arr1, ...$arr2];\nvar_dump($arr3); // [\"a\" => 2]\n\n// целочисленный ключ\n$arr4 = [1, 2, 3];\n$arr5 = [4, 5, 6];\n$arr6 = [...$arr4, ...$arr5];\nvar_dump($arr6); // [1, 2, 3, 4, 5, 6]\n// Который [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]\n// где исходные целочисленные ключи не были сохранены.\n\n?>\n```\n\n> **Зауваження** :\n> \n> Ключі, тип яких не належить ні цілими числами, ні рядками, викидають виняток [TypeError](class.typeerror.md). Такі ключі генеруються лише об'єктом [Traversable](class.traversable.md)\n\n> **Зауваження** :\n> \n> До PHP 8.1 розпакування масиву з рядковим ключем не підтримувалося:\n> \n> ```php\n> <?php\n> \n> $arr1 = [1, 2, 3];\n> $arr2 = ['a' => 4];\n> $arr3 = [...$arr1, ...$arr2];\n> // Error error: Uncaught Error: Cannot unpack array with string keys in example.php:5\n> $arr4 = [1, 2, 3];\n> $ arr5 = [4, 5];\n> $arr6 = [...$arr4, ...$arr5]; // працює. [1, 2, 3, 4, 5]\n> \n> ?>\n> ```\n\n### Приклади\n\nМасив у PHP - гнучкий тип даних. Ось кілька прикладів:\n\n```php\n<?php\n\n// Этот код:\n$a = array( 'color' => 'красный',\n            'taste' => 'сладкий',\n            'shape' => 'круг',\n            'name'  => 'яблоко',\n            4        // ключом будет 0\n          );\n\n$b = array('a', 'b', 'c');\n\n// ...эквивалентен этому:\n$a = array();\n$a['color'] = 'красный';\n$a['taste'] = 'сладкий';\n$a['shape'] = 'круг';\n$a['name']  = 'яблоко';\n$a[]        = 4;        // ключом будет 0\n\n$b = array();\n$b[] = 'a';\n$b[] = 'b';\n$b[] = 'c';\n\n// после выполнения приведённого кода, переменная $a будет массивом\n// array('color' => 'красный', 'taste' => 'сладкий', 'shape' => 'круг',\n// 'name' => 'яблоко', 0 => 4), а переменная $b будет\n// array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').\n\n?>\n```\n\n**Приклад #11 Виклик мовної конструкції array()**\n\n```php\n<?php\n\n// Массив как карта (свойств)\n$map = array(\n    'version'    => 4,\n    'OS'         => 'Linux',\n    'lang'       => 'english',\n    'short_tags' => true\n);\n\n// строго числовые ключи\n$array = array(\n    7,\n    8,\n    0,\n    156,\n    -10\n);\n// это то же самое, что и array(0 => 7, 1 => 8, ...)\n\n$switching = array(\n    10,         // ключ = 0\n    5    =>  6,\n    3    =>  7,\n    'a'  =>  4,\n    11,         // ключ = 6 (максимальным числовым индексом было 5)\n    '8'  =>  2, // ключ = 8 (число!)\n    '02' => 77, // ключ = '02'\n    0    => 12  // значение 10 будет перезаписано на 12\n);\n\n// пустой массив\n$empty = array();\n\n?>\n```\n\n**Приклад #12 Колекція**\n\n```php\n<?php\n\n$colors = array('красный', 'голубой', 'зелёный', 'жёлтый');\n\nforeach ($colors as $color) {\n    echo \"Вам нравится $color?\\n\";\n}\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nВам нравится красный?\nВам нравится голубой?\nВам нравится зелёный?\nВам нравится жёлтый?\n```\n\nБезпосередня зміна значень масиву допустима через передачу значень посилання.\n\n**Приклад #13 Зміна елемента в циклі**\n\n```php\n<?php\n\nforeach ($colors as &$color) {\n    $color = mb_strtoupper($color);\n}\nunset($color); /* это нужно, чтобы очередные записи в\n                  переменной $color не меняли последний элемент массива */\n\nprint_r($colors);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => КРАСНЫЙ\n    [1] => ГОЛУБОЙ\n    [2] => ЗЕЛЁНЫЙ\n    [3] => ЖЁЛТЫЙ\n)\n```\n\nНаступний приклад створює масив, індексація якого починається з одиниці.\n\n**Приклад #14 Індекс, що починається з одиниці**\n\n```php\n<?php\n\n$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');\nprint_r($firstquarter);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [1] => 'Январь'\n    [2] => 'Февраль'\n    [3] => 'Март'\n)\n```\n\n**Приклад #15 Заповнення масиву**\n\n```php\n<?php\n\n// заполняем массив всеми элементами из директории\n$handle = opendir('.');\nwhile (false !== ($file = readdir($handle))) {\n    $files[] = $file;\n}\nclosedir($handle);\n\n?>\n```\n\nМасиви впорядковані. Порядок змінюють різними функціями сортування. Докладніше про це розказано у розділі « [Функції для роботи з масивами](ref.array.md) ». Для підрахунку кількості елементів у масиві викликають функцію [count()](function.count.md)\n\n**Приклад #16 Сортування масиву**\n\n```php\n<?php\n\nsort($files);\nprint_r($files);\n\n?>\n```\n\nОскільки значення масиву дозволяється бути будь-яким, значення може бути також іншим масивом. Тому дозволено створювати рекурсивні та багатовимірні масиви.\n\n**Приклад #17 Рекурсивні та багатовимірні масиви**\n\n```php\n<?php\n\n$fruits = array ( \"fruits\"  => array ( \"a\" => \"апельсин\",\n                                       \"b\" => \"банан\",\n                                       \"c\" => \"яблоко\"\n                                     ),\n                  \"numbers\"   => array ( 1,\n                                       2,\n                                       3,\n                                       4,\n                                       5,\n                                       6\n                                     ),\n                  \"holes\"   => array (      \"первая\",\n                                       5 => \"вторая\",\n                                            \"третья\"\n                                     )\n                );\n\n// Несколько Прикладов доступа к значениям предыдущего массива\necho $fruits[\"holes\"][5];    // напечатает «вторая»\necho $fruits[\"fruits\"][\"a\"]; // напечатает «апельсин»\nunset($fruits[\"holes\"][0]);  // удалит «первая»\n\n// Создаст новый многомерный массив\n$juices[\"apple\"][\"green\"] = \"хороший\";\n\n?>\n```\n\nНадання масиву включає копіювання значення. Щоб скопіювати масив за посиланням, вказують [оператор присвоювання за посиланням](language.operators.md)\n\n```php\n<?php\n\n$arr1 = array(2, 3);\n$arr2 = $arr1;\n$arr2[] = 4; // Массив $arr2 изменился,\n             // Массив $arr1 всё ещё выглядит так: array(2, 3)\n\n$arr3 = &$arr1;\n$arr3[] = 4; // Теперь массивы $arr1 и $arr3 одинаковы\n\n?>\n```\n","title":"Масиви","contentType":2,"navigation":[{"language.types.numeric-strings.md":"Числові рядки"},{"language.types.object.md":"Об'єкти »"},{"index.md":"PHP Manual"},{"language.types.md":"Типи"}]}},"__N_SSG":true}