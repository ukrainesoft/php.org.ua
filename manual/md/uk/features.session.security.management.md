- [«Безпека сесій](session.security.md)
- [INI-налаштування безпеки сесій »](session.security.ini.md)

- [PHP Manual](index.md)
- [Безпека сесій](session.security.md)
- Базові засади управління сесіями

## Базові принципи управління сесіями

### Безпека сесії

Модуль сесії не гарантує, що сесійна інформація, що зберігається
доступна лише користувачеві, який створив сесію. Необхідно прийняти
додаткові заходи щодо захисту конфіденційності сесії, ґрунтуючись на
пов'язаних із нею даних.

Оцінка важливості даних, що передаються у рамках сесії, важлива для вибору
заходів щодо захисту цієї інформації; все має свою ціну і зазвичай
додаткові заходи захисту призводять до погіршення зручності кінцевого
користувача. Наприклад, якщо необхідно захистити користувача від
найпростіших методів соціальної інженерії слід включити
`session.use_only_cookies`. В даному випадку з боку користувача
ПЗ обов'язкова підтримка cookie, інакше механізм сесій не буде
працювати.

Існує кілька способів витоку існуючого ідентифікатора сесії
третім особам. Наприклад, ін'єкції JavaScript, передача ідентифікатора
сесії в URL, перехоплення пакетів, фізичний доступ до пристрою та ін.
Перехоплений ідентифікатор сесії дозволить третім особам отримати
доступ до всіх ресурсів, пов'язаних із цією сесією. По-перше, передача
ідентифікатор сесії в URL. Під час переходу на зовнішній сайт ідентифікатор
сесії користувача та адреса ресурсу можуть потрапити до статистики переходів
цього сайту. По-друге, при активнішій атаці можливо
прослуховування мережного трафіку зловмисником. Якщо канал передачі
даних не зашифрований, ідентифікатори сесії будуть передані у вигляді
простий текст. У такому разі рішенням є обов'язкове
використання SSL/TLS користувачами під час доступу до сайту. Для цих цілей
слід застосовувати HSTS.

> **Примітка**: Навіть HTTPS іноді може не захистити конфіденційні
> дані. Наприклад, уразливості типу CRIME, BEAST можуть дозволити
> зловмиснику отримати доступ до даних. Багато мереж використовують проксі
> HTTPS MITM для аудиту. Атакуючі можуть налаштувати такі проксі.

### Неадаптивне управління сесіями

В даний час PHP використовує адаптивне управління сесіями з
замовчуванням. Адаптивне керування сесіями несе додаткові ризики.

Якщо
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)
включений і обробник збереження сесії це підтримує,
неініціалізований сесійний ID відкидається і створюється новий. Це
захищає від атак, які змушують користувача використовувати заздалегідь
відомий ID. Атакуючий може розміщувати посилання або надсилати листи,
які містять сесійний ID. Наприклад
http://example.com/page.php?PHPSESSIDu003d123456789 . Якщо опція
[session.use_trans_sid](session.configuration.md#ini.session.use-trans-sid)
включена, то жертва відкриє сесію із цим ідентифікатором. Опція
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)
зменшує цей ризик.

**Увага**

Визначений користувачем обробник збереження також може
підтримувати строгий сесійний режим шляхом реалізації функції/методу
перевірки коректності ідентифікатора сесії Усі певні
Користувачем обробники збереження повинні його продавати.

Cookie із сесійним ID має встановлюватися із зазначенням параметрів
domain, path, httponly, secure та, починаючи з PHP 7.3, атрибут SameSite.
Їхня пріоритетність визначається браузерами. Спираючись на цю
пріоритетність, атакуючий може встановити сесійний ID, який
використовуватиметься нескінченно. Застосування
[session.use_only_cookies](session.configuration.md#ini.session.use-only-cookies)
не вирішує цієї проблеми.
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)
зменшує ризик.
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)u003dOn,
не допускає використання неініціалізованих сесійних ID.

> **Примітка**: Навіть при зменшенні ризику за допомогою
> [session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)
> атакуючий все ще може змусити користувача використовувати вже
> ініціалізовану сесію, створену атакуючим. Наприклад
> JavaScript-ін'єкція. Ця атака може бути пом'якшена, якщо слідувати
> рекомендації цього посібника. Якщо ви дотримуєтеся цього керівництва,
> ви повинні увімкнути
> [session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode),
> використовувати управління сесіями на основі тимчасових міток та
> перестворювати ідентифікатор сесії за допомогою
> [session_regenerate_id()](function.session-regenerate-id.md), як
> Рекомендується. Якщо ви це зробите, ідентифікатор сесії
> зловмисника у результаті буде вилучено. Якщо відбувся доступ до миттєвої
> сесії, ви повинні зберегти всі дані активних сесій користувача.
> Це дозволить подальшого розслідування причин того, що сталося. Після
> цього, примусово змусіть користувача вийти зі всіх активних
> сесій, тобто вимагайте від користувачів переавторизації. Це
> дозволить запобігти атакі з використанням краденої сесії.

**Увага**

Доступ до сесії, що минув, не завжди означає атаку. Нестабільне мережеве
з'єднання та/або негайне видалення активної сесії може спричинити
собою подібна поведінка.

З PHP 7.1.0 додано функцію
[session_create_id()](function.session-create-id.md). Ця функція
може бути корисною для створення ідентифікатора сесії з використанням
ідентифікатора користувача як префікс для досягнення більшої
керованості. При її використанні необхідно вирішувати
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode).
В іншому випадку несумлінні користувачі зможуть встановлювати
підроблені ідентифікатори сесій інших користувачів.

> **Примітка**: У версіях PHP до 7.1.0 необхідно використовувати CSPRNG,
> тобто /dev/urandom або [random_bytes()](function.random-bytes.md)
> та функції хешування для створення нового ідентифікатора сесії.
> [session_create_id()](function.session-create-id.md) має
> вбудована функціональність виявлення колізій та генерує
> ідентифікатор на основі INI-налаштувань. Використання
> [session_create_id()](function.session-create-id.md) є
> кращою практикою.

### Перестворення ідентифікатора сесії

Використання
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode) -
це добре, але замало. Розробник також має використовувати
[session_regenerate_id()](function.session-regenerate-id.md) для
забезпечення безпеки сесій.

Перестворення ідентифікаторів сесій сильно зменшує ризик крадіжки сесії,
відповідно треба на періодичній основі запускати
[session_regenerate_id()](function.session-regenerate-id.md).
Наприклад, перестворювати ідентифікатор сесії кожні 15 хвилин для особливо
секретні дані. Навіть якщо сесію вкрадуть, вона скоро стане
спливла і спроба її використовувати призведе до помилки сесії.

Ідентифікатор сесії повинен перетворюватися при підвищенні привілеїв
користувача, наприклад, при аутентифікації. Функція
[session_regenerate_id()](function.session-regenerate-id.md) має
викликатись до запису авторизаційної інформації в $\_SESSION.
([session_regenerate_id()](function.session-regenerate-id.md)
зберігає дані поточної сесії автоматично. Переконайтеся, що тільки
поточна сесія відзначена як авторизована.

Розробники *НЕ ПОВИННІ* покладатися на механізм закінчення терміну дії
ідентифікатора сесії за допомогою
[session.gc_maxlifetime](session.configuration.md#ini.session.gc-maxlifetime).
Атакуючі можуть періодично отримувати доступ до сесії для запобігання
її терміну дії та продовжувати використовувати ідентифікатор жертви,
включаючи автентифіковані сесії.

Натомість, ви повинні самостійно реалізувати управління даними
сесії, базуючись на тимчасовій мітці.

**Увага**

Незважаючи на те, що менеджер сесій може прозоро керувати тимчасовими
мітками, ця функціональність не реалізована. Дані старих сесій
зберігаються до моменту запуску збирача сміття. В той же час,
розробники повинні переконатися, що дані сесій, що минув, видалені.
Проте розробники не повинні видаляти дані активних сесій негайно.
Наприклад, ніколи не викликайте `session_regenerate_id(true);` і
**session_destroy()** спільно для активних сесій. Це може
здатися суперечливим, але це обов'язкова вимога.

[session_regenerate_id()](function.session-regenerate-id.md)
замовчуванням *не* видаляє старі сесії. Застарілі авторизовані сесії
можуть бути доступні для використання. Розробники повинні припинити будь-яку
можливість використання старих сесій будь-ким, заборонивши доступ до
скінченим сесіям самостійно, використовуючи тимчасові мітки.

**Увага**

Негайне видалення активних сесій може спричинити небажані
побічні ефекти. Сесія може перерватися через нестабільність мережі або
конкурентного доступу до сайту/додатку.

Потенційний недобросовісний доступ буде неможливо відстежити та
проаналізувати, якщо дані сесій негайно видалятимуться.

Замість негайного видалення старих сесій ви повинні зберігати їх
нетривалий час, наприклад, встановивши спеціальний прапор та час
остаточного закінчення сесії в $\_SESSION, заборонивши будь-кому
звертатись до цих даних.

Ви не повинні забороняти доступ до старих сесій відразу після виклику
[session_regenerate_id()](function.session-regenerate-id.md).
Необхідно зачекати кілька секунд для стабільних мережевих з'єднань
і кілька хвилин для нестабільних, наприклад для WiFi або мобільного
інтернету.

Якщо користувач намагається отримати доступ до сесії, ви не
повинні його надавати. У цьому випадку рекомендується видаляти статус
"авторизований" з усіх активних сесій користувача, оскільки це дуже
схоже на атаку.

[session.use_only_cookies](session.configuration.md#ini.session.use-only-cookies)
та правильне використання
[session_regenerate_id()](function.session-regenerate-id.md) можуть
привести до персональної DoS за допомогою установки невдалої cookie.
Якщо таке відбувається, ви можете попросити користувача видалити
cookie та попередити його про можливі проблеми з безпекою.
Атакуючий може встановлювати шкідливі cookie через вразливість
веб-застосунку (тобто JavaScript-ін'єкція), вразливість у браузерному
плагіні і т.д.

**Увага**

Не недооцінюйте ризику DoS. `use_strict_modeu003dOn` обов'язковий для спільної
безпеки ідентифікаторів сесій! Усі сайти повинні використовувати
`use_strict_mode`.

DoS (відмова в обслуговуванні) може статися лише тоді, коли обліковий запис
перебуває під атакою. Найчастіша передумова для нього -
JavaScript-ін'єкція.

### Видалення даних сесії

Дані сесій, що минув, повинні бути недоступні та видалені. Існуючий
Механізм управління сесіями робить це не дуже добре.

Дані сесій, що минув, треба видаляти так швидко, як тільки можливо. З
з іншого боку, дані активних сесій НЕ ПОВИННІ видалятися відразу. Для
забезпечення цих суперечливих вимог, ви ПОВИННІ самостійно
реалізувати механізм контролю за минулими сесіями на базі тимчасових
міток.

Встановлюйте та керуйте тимчасовими мітками життя сесії через
$\_SESSION. Забороняйте доступ до даних сесій, що минув. Якщо виявлено
спроба доступу до даних застарілої сесії, знімайте статус авторизації
з усіх активних сесій користувача та змушуйте його
переавторизуватися. Доступ до даних сесії, що минув, може означати
атаку. Для забезпечення такої поведінки ви повинні відстежувати все
активні сесії користувача.

> **Примітка**: Доступ до сесії, що минув, може також статися через
> нестабільного мережного доступу та/або конкурентного доступу до
> додатку/сайту. Сервер може спробувати встановити новий
> ідентифікатор сесії через cookie, але пакет "Set-Cookie" може не
> дійти клієнта через поганий зв'язок. Одне з'єднання може викликати
> перестворення ідентифікатора за допомогою
> [session_regenerate_id()](function.session-regenerate-id.md), а
> інше, водночас, може отримати нового ідентифікатора.
> Отже, ви повинні заборонити доступ до сесій, що закінчилися, трохи
> Пізніше. Тобто управління сесіями на базі тимчасових міток є
> обов'язковим.

Коротше кажучи, не знищуйте дані сесії не за допомогою
[session_regenerate_id()](function.session-regenerate-id.md), ні
[session_destroy()](function.session-destroy.md), а використовуйте
механізм доступу до сесії з урахуванням тимчасових міток. Нехай
[session_gc()](function.session-gc.md) сам видаляє старі сесії з
сховища.

### Сесії та блокування

За замовчуванням дані сесії заблоковані, щоб уникнути стану
гонки. Блокування обов'язкове для забезпечення консистентності даних
сесії між запитами.

Проте блокування може бути використане атакуючим для організації
DoS-атаки. Для зменшення ризику DoS з використанням блокування сесій,
мінімізуйте їх. Використовуйте блокування "read only", коли сесію не
потрібно оновлювати. Використовуйте опцію 'read_and_close' з
[session_start()](function.session-start.md).
`session_start(['read_and_close'u003d>1]);` Закривайте сесію за допомогою
[session_commit()](function.session-commit.md) відразу, як тільки ви
перестали оновлювати $\_SESSION.

Поточний механізм управління сесіями *не слідкує* за змінами
$\_SESSION, доки сесія неактивна. Це ваша зона відповідальності
стежити за тим, щоб такого не траплялося.

### Активні сесії

Розробники повинні стежити за активними сесіями кожного користувача та
сповіщати його, скільки є активних сесій, з яких IP (і де
географічно), як довго вони активні тощо. PHP не зробить цього за
вас. Ви маєте це робити.

Є кілька шляхів реалізації. Ви можете зберігати всю потрібну інформацію
у спеціальній базі даних. Отже, коли сесія буде видалена збирачем
сміття, ви повинні це відслідковувати та відповідно оновлювати свою базу
даних.

Найпростіший спосіб - використовувати ідентифікатор користувача в
як префікс для ідентифікатора сесії та зберігати всю необхідну
інформацію у $\_SESSION. Багато баз даних вміють досить швидко
вибирати рядки за префіксом. Ви можете використовувати
[session_regenerate_id()](function.session-regenerate-id.md) та
[session_create_id()](function.session-create-id.md) для цього.

**Увага**

Ніколи не використовуйте конфіденційні дані як префікс. Якщо
ідентифікатор користувача конфіденційний, розгляньте можливість
використовувати функцію [hash_hmac()](function.hash-hmac.md).

**Увага**

Для подібного налаштування потрібно увімкнення
[session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode).
Переконайтеся, що ця опція увімкнена, інакше база даних активних сесій
може бути скомпрометована.

Управління сесіями на базі тимчасових міток є обов'язковим для
визначення застарілих сесій. Якщо виявлено спробу доступу до
застарілої сесії, необхідно скинути прапори авторизації для всіх
активних сесій користувача.

### Сесії та автоматичний вхід

Розробники НЕ ПОВИННІ використовувати довгоживучі сесії для реалізації
автоматичного входу в систему, тому що це різко підвищує
ймовірність крадіжки сесії. Автоматичний вхід до системи повинен
реалізовуватись розробником самостійно.

Встановлюйте безпечні хешовані одноразові ключі як
ключів автологіну за допомогою [setcookie()](function.setcookie.md).
Використовуйте безпечне хешування, сильніше ніж SHA-2, наприклад
SHA-256 або вище з випадковими даними з
[random_bytes()](function.random-bytes.md) або /dev/urandom.

Якщо користувач не авторизований, перевірте, чи коректний одноразовий
ключ автологіну. Якщо ключ коректний, авторизуйте користувача та
встановіть новий одноразовий ключ. Ключ автологіну обов'язково
повинен бути одноразовим, тобто ніколи не використовуйте його повторно, а
завжди створюйте новий.

Ключ автологіна – це дуже довгоживучий ключ авторизації. Його треба
захищати по максимуму. Використовуйте параметри
path/httponly/secure/SameSite під час встановлення cookie для його захисту.
Ніколи не передавайте ключ автологіну, крім випадків, коли це
необхідно.

Розробник має реалізувати функціонал, який відключає
автоматичний вхід до системи та видаляє непотрібні "cookie", встановлені
на його реалізації.

### CSRF (Міжсайтова підробка запиту)

Сесії та авторизація не захищають від атак типу CSRF. Розробники повинні
самостійно реалізовувати захист.

[output_add_rewrite_var()](function.output-add-rewrite-var.md) може
використовуватися для захисту від CSRF. Читайте керівництво для
подробиць.

> **Примітка**: До PHP 7.2.0 використовувався один і той же буфер виводу та
> Налаштування INI для "trans sid". Так що використання
> [output_add_rewrite_var()](function.output-add-rewrite-var.md) з PHP
> Попередніх версій не рекомендується.

Багато кадрів підтримують захист від CSRF. Зверніться до документації
свого фреймворку для більш детальної інформації.

Починаючи з PHP 7.3, для сесійної cookie можна встановити атрибут
SameSite. Це забезпечить додатковий захист проти CSRF.
