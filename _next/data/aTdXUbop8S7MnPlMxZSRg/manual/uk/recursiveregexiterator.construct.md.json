{"pageProps":{"page":{"slug":"recursiveregexiterator.construct.md","content":"# RecursiveRegexIterator::\\_\\_construct\n\n(PHP 5 >= 5.2.0, PHP 7, PHP 8)\n\nRecursiveRegexIterator::\\_\\_construct - Конструктор класу RecursiveRegexIterator\n\n### Опис\n\npublic **RecursiveRegexIterator::\\_\\_construct**  \n[RecursiveIterator](class.recursiveiterator.md) `$iterator`,  \nstring`$pattern`,  \nint`$mode`\\= RecursiveRegexIterator::MATCH,  \nint`$flags`  \nint`$pregFlags`  \n) .\n\nСтворює новий об'єкт-ітератор регулярного вираження.\n\n### Список параметрів\n\n`iterator`\n\nРекурсивний ітератор якого потрібно застосувати фільтр з урахуванням регулярного висловлювання.\n\n`pattern`\n\nРегулярний вираз.\n\n`mode`\n\nРежим роботи, список доступних режимів наведено в описі методу [RegexIterator::setMode()](regexiterator.setmode.md)\n\n`flags`\n\nСпеціальні прапори. Список доступних прапорів наведено в описі методу [RegexIterator::setFlags()](regexiterator.setflags.md)\n\n`pregFlags`\n\nПрапори регулярного виразу. Список прапорів залежить від режиму роботи:\n\n**[RegexIterator](class.regexiterator.md)preg\\_flags**\n\n| режим работы | доступные флаги |\n| --- | --- |\n| RecursiveRegexIterator::ALL\\_MATCHES | Смотрите[preg\\_match\\_all()](function.preg-match-all.md) |\n| RecursiveRegexIterator::GET\\_MATCH | Смотрите[preg\\_match()](function.preg-match.md) |\n| RecursiveRegexIterator::MATCH | Смотрите[preg\\_match()](function.preg-match.md) |\n| RecursiveRegexIterator::REPLACE | ні |\n| RecursiveRegexIterator::SPLIT | Смотрите[preg\\_split()](function.preg-split.md) |\n\n### Приклади\n\n**Приклад #1 Приклад використання** RecursiveRegexIterator::\\_\\_construct()\\*\\*\\*\\*\n\nСтворює новий об'єкт-ітератор RegexIterator, який вибирає всі рядки, що починаються зі слова 'test'.\n\n```php\n<?php\n$rArrayIterator = new RecursiveArrayIterator(array('test1', array('tet3', 'test4', 'test5')));\n$rRegexIterator = new RecursiveRegexIterator($rArrayIterator, '/^test/',\n    RecursiveRegexIterator::ALL_MATCHES);\n\nforeach ($rRegexIterator as $key1 => $value1) {\n\n    if ($rRegexIterator->hasChildren()) {\n\n        // выведем все дочерние элементы\n        echo \"Дочерние элементы: \";\n        foreach ($rRegexIterator->getChildren() as $key => $value) {\n            echo $value . \" \";\n        }\n        echo \"\\n\";\n    } else {\n        echo \"Нет дочерних элементов\\n\";\n    }\n\n}\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nНет дочерних элементов\nДочерние элементы: test4 test5\n```\n\n### Дивіться також\n\n-   [preg\\_match()](function.preg-match.md) \\- Виконує перевірку на відповідність регулярному виразу\n-   [preg\\_match\\_all()](function.preg-match-all.md) \\- Виконує глобальний пошук шаблону у рядку\n-   [preg\\_replace()](function.preg-replace.md) \\- Виконує пошук та заміну за регулярним виразом\n-   [preg\\_split()](function.preg-split.md) \\- Розбиває рядок за регулярним виразом\n","title":"RecursiveRegexIterator::\\_\\_construct","contentType":2,"navigation":[{"class.recursiveregexiterator.md":"« RecursiveRegexIterator"},{"recursiveregexiterator.getchildren.md":"RecursiveRegexIterator::getChildren »"},{"index.md":"PHP Manual"},{"class.recursiveregexiterator.md":"RecursiveRegexIterator"}]}},"__N_SSG":true}