{"pageProps":{"page":{"slug":"function.oci-bind-by-name.md","content":"# oci\\_bind\\_by\\_name\n\n(PHP 5, PHP 7, PHP 8, PECL OCI8 >= 1.1.0)\n\noci\\_bind\\_by\\_name — Прикріплює змінну PHP до відповідної мітки у SQL-вираженні\n\n### Опис\n\n```methodsynopsis\noci_bind_by_name(    resource $statement,    string $param,    mixed &$var,    int $max_length = -1,    int $type = 0): bool\n```\n\nПрикрепляет переменную`var`к метке`param`. Таке прикріплення дозволяє підвищити продуктивність та уникнути SQL-ін'єкцій.\n\nПрикріплення змінної дозволяє базі даних повторно використовувати кешовані контекстні вирази від попередніх запитів, навіть якщо вони спочатку були запущені іншим користувачем чи процесом. Це також знижує ризик ін'єкцій SQL, оскільки дані в такому випадку ніколи не розглядаються як інструкції SQL. Дані не потрібно екранувати або укладати в лапки.\n\nПрикріплені PHP-змінні можуть бути змінені та знову виконані без необхідності повторного оброблення запиту або повторного прикріплення.\n\nУ Oracle прикріплення змінних зазвичай поділяють на `IN` (прикріплює значення, що передаються в базу даних) та `OUT` (Прикріплює значення, що повертаються PHP). Змінна може бути одночасно `IN`и`OUT`. Незалежно від цього характер прикріплення змінних буде визначено під час виконання.\n\nНеобхідно вказати `max_length`при использовании`OUT`\\-прив'язки, що дозволяє PHP зарезервувати більше пам'яті для зберігання значення, що повертається\n\nДля`IN`\\-привязки рекомендуется также указать параметр`max_length`, якщо вираз виконується кілька разів із різними значеннями PHP-змінної. В іншому випадку Oracle може урізати розмір даних до розміру початкового значення змінної PHP. Якщо максимальна довжина невідома, рекомендується викликати **oci\\_bind\\_by\\_name()** перед кожним викликом [oci\\_execute()](function.oci-execute.md). Прикріплення невиправдано великої змінної вплине процес збереження бази даних.\n\nВигляд прикріплення вказує Oracle як працювати з пам'яттю під час читання даних. Для `IN`\\-прикріплення адрес у пам'яті повинен містити допустимі дані під час виклику [oci\\_execute()](function.oci-execute.md). . Це означає, що значення змінної має бути у пам'яті під час виконання. Якщо це не так, можливі некоректні результати або помилки на кшталт \"ORA-01460: unimplemented or unreasonable conversion requested\" (запитані нездійсненні або некоректні перетворення) `OUT`\\-Прикріплення основною ознакою є встановлення значення змінну PHP.\n\nДля виразу, що багаторазово виконується, прив'язка одних і тих же значень може зменшити можливості оптимізатора Oracle з вироблення найкращого варіанту виконання інструкції. Тривале прикріплення виразів, які рідко виконуються, може також принести користі. Тим не менш, в обох випадках, прикріплення є більш безпечним, ніж конкатенація рядка запиту та неперевірених даних користувача.\n\n### Список параметрів\n\n`statement`\n\nДопустимий ідентифікатор виразу OCI8.\n\n`param`\n\nМітка з префіксом у вигляді двокрапки, що використовується у виразі. Двокрапка опціонально в `param`Oracle не использует знак вопроса для меток.\n\n`var`\n\nПеременная PHP, ассоциированная с`param`\n\n`max_length`\n\nВстановлює максимальний розмір даних. Якщо вказати -1, функція буде використовувати поточний розмір змінної `var` як максимальне. При цьому змінна `var` має існувати та містити дані під час виклику **oci\\_bind\\_by\\_name()**\n\n`type`\n\nТип даних, до якого Oracle наводитиме значення. За замовчуванням `type`имеет значение\\*\\*`SQLT_CHR`\\*\\*. Oracle наводить дані від даного типу до типу поля (або типу змінної PL/SQL), якщо це можливо.\n\nЯкщо необхідно прикріпити змінну абстрактного типу (LOB/ROWID/BFILE), слід попередньо використовувати [oci\\_new\\_descriptor()](function.oci-new-descriptor.md)Параметр`length` не використовується для абстрактних типів і повинен бути встановлений -1.\n\nДопустимі значення параметра `type` :\n\n-   \\*\\*`SQLT_BFILEE`** або **`OCI_B_BFILE`\\*\\*- для BFILE-об'єктів;\n    \n-   \\*\\*`SQLT_CFILEE`** або **`OCI_B_CFILEE`\\*\\*- для CFILE-об'єктів;\n    \n-   \\*\\*`SQLT_CLOB`** або **`OCI_B_CLOB`\\*\\*- для CLOB-об'єктів;\n    \n-   \\*\\*`SQLT_BLOB`** або **`OCI_B_BLOB`\\*\\*- для BLOB-об'єктів;\n    \n-   \\*\\*`SQLT_RDD`** або **`OCI_B_ROWID`\\*\\*- для ROWID-об'єктів;\n    \n-   \\*\\*`SQLT_NTY`** або **`OCI_B_NTY`\\*\\*- для іменованих типів дати;\n    \n-   \\*\\*`SQLT_INT`** або **`OCI_B_INT`\\*\\*- для цілих чисел;\n    \n-   \\*\\*`SQLT_CHR`\\*\\*- для символів VARCHAR;\n    \n-   \\*\\*`SQLT_BIN`** або **`OCI_B_BIN`\\*\\*- для RAW-полів;\n    \n-   \\*\\*`SQLT_LNG`\\*\\*- для LONG-полів;\n    \n-   \\*\\*`SQLT_LBI`\\*\\*- для LONG RAW полів;\n    \n-   \\*\\*`SQLT_RSET`\\*\\*- для курсорів, створених функцією[oci\\_new\\_cursor()](function.oci-new-cursor.md)\n    \n-   \\*\\*`SQLT_BOL`** або **`OCI_B_BOL`\\*\\*- для PL/SQL BOOLEAN (Потрібен Oracle Database 12c)\n    \n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Додавання даних із використанням **oci\\_bind\\_by\\_name()****\n\n```php\n<?php\n\n// Создание таблицы:\n//   CREATE TABLE mytab (id NUMBER, text VARCHAR2(40));\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn,\"INSERT INTO mytab (id, text) VALUES(:id_bv, :text_bv)\");\n\n$id = 1;\n$text = \"Data to insert     \";\noci_bind_by_name($stid, \":id_bv\", $id);\noci_bind_by_name($stid, \":text_bv\", $text);\noci_execute($stid);\n\n// В таблице содержится: 1, 'Data to insert     '\n\n?>\n```\n\n**Приклад #2 Одна прив'язка для багаторазового використання**\n\n```php\n<?php\n\n// Создание таблицы:\n//   CREATE TABLE mytab (id NUMBER);\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$a = array(1,3,5,7,11);  // данные для вставки\n\n$stid = oci_parse($conn, 'INSERT INTO mytab (id) VALUES (:bv)');\noci_bind_by_name($stid, ':bv', $v, 20);\nforeach ($a as $v) {\n    $r = oci_execute($stid, OCI_DEFAULT);  // не использовать автоматическое завершение транзакции\n}\noci_commit($conn); // завершение транзакции\n\n// Таблица содержит пять записей: 1, 3, 5, 7, 11\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #3 Прикрепление в цикле`foreach`**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$sql = 'SELECT * FROM departments WHERE department_name = :dname AND location_id = :loc';\n$stid = oci_parse($conn, $sql);\n\n$ba = array(':dname' => 'IT Support', ':loc' => 1700);\n\nforeach ($ba as $key => $val) {\n\n    // oci_bind_by_name($stid, $key, $val) не работает,\n    // потому что прикрепляет каждое значение в одно место: $val\n    // Вместо этого следует указывать конкретное место: $ba[$key]\n    oci_bind_by_name($stid, $key, $ba[$key]);\n}\n\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS);\nforeach ($row as $item) {\n    print $item.\"<br>\\n\";\n}\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #4 Прикріплення до виразу WHERE**\n\n```php\n<?php\n\n$conn = oci_connect(\"hr\", \"hrpwd\", \"localhost/XE\");\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$sql = 'SELECT last_name FROM employees WHERE department_id = :didbv ORDER BY last_name';\n$stid = oci_parse($conn, $sql);\n$didbv = 60;\noci_bind_by_name($stid, ':didbv', $didbv);\noci_execute($stid);\nwhile (($row = oci_fetch_array($stid, OCI_ASSOC)) != false) {\n    echo $row['LAST_NAME'] .\"<br>\\n\";\n}\n\n// Выводом будет\n//    Austin\n//    Ernst\n//    Hunold\n//    Lorentz\n//    Pataballa\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #5 Прикріплення до виразу LIKE**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n// Поиск всех городов, начинающихся на 'South'\n$stid = oci_parse($conn, \"SELECT city FROM locations WHERE city LIKE :bv\");\n$city = 'South%';  // '%' - это знак шаблона SQL\noci_bind_by_name($stid, \":bv\", $city);\noci_execute($stid);\noci_fetch_all($stid, $res);\n\nforeach ($res['CITY'] as $c) {\n    print $c . \"<br>\\n\";\n}\n// Выводом будет:\n//   South Brunswick\n//   South San Francisco\n//   Southlake\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #6 Прикріплення до виразу REGEXP\\_LIKE**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n// Поиск названий городов, содержащих 'ing'\n$stid = oci_parse($conn, \"SELECT city FROM locations WHERE REGEXP_LIKE(city, :bv)\");\n$city = '.*ing.*';\noci_bind_by_name($stid, \":bv\", $city);\noci_execute($stid);\noci_fetch_all($stid, $res);\n\nforeach ($res['CITY'] as $c) {\n    print $c . \"<br>\\n\";\n}\n// Выводом будет:\n//   Beijing\n//   Singapore\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\nДля невеликої фіксованої кількості умов у вираженні IN використовуються індивідуальні імена змінних. Невідомі значення під час виконання можуть бути встановлені в NULL. Це дозволяє використовувати один вираз декільком користувачам, що підвищує ефективність кешування Oracle DB.\n\n**Приклад #7 Прикріплення кількох значень у вираз IN**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$sql = 'SELECT last_name FROM employees WHERE employee_id in (:e1, :e2, :e3)';\n$stid = oci_parse($conn, $sql);\n$mye1 = 103;\n$mye2 = 104;\n$mye3 = NULL; // притворимся, что не получили это значение\noci_bind_by_name($stid, ':e1', $mye1);\noci_bind_by_name($stid, ':e2', $mye2);\noci_bind_by_name($stid, ':e3', $mye3);\noci_execute($stid);\noci_fetch_all($stid, $res);\nforeach ($res['LAST_NAME'] as $name) {\n    print $name .\"<br>\\n\";\n}\n\n// Выводом будет:\n//   Ernst\n//   Hunold\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #8 Прикріплення ROWID, що повертається запитом**\n\n```php\n<?php\n\n// Создадим и наполним таблицу:\n//   CREATE TABLE mytab (id NUMBER, salary NUMBER, name VARCHAR2(40));\n//   INSERT INTO mytab (id, salary, name) VALUES (1, 100, 'Chris');\n//   COMMIT;\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT ROWID, name FROM mytab WHERE id = :id_bv FOR UPDATE');\n$id = 1;\noci_bind_by_name($stid, ':id_bv', $id);\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS);\n$rid = $row['ROWID'];\n$name = $row['NAME'];\n\n// Переведём имя в верхний регистр и зафиксируем изменения\n$name = strtoupper($name);\n$stid = oci_parse($conn, 'UPDATE mytab SET name = :n_bv WHERE ROWID = :r_bv');\noci_bind_by_name($stid, ':n_bv', $name);\noci_bind_by_name($stid, ':r_bv', $rid, -1, OCI_B_ROWID);\noci_execute($stid);\n\n// Теперь таблица содержит: 1, 100, CHRIS\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #9 OUT-прикріплення ROWID, яке повертається при INSERT**\n\n```php\n<?php\n\n// В данном Прикладе добавляется запись с идентификатором и именем,\n// после чего увеличивается заработная плата\n// Создание таблицы:\n//   CREATE TABLE mytab (id NUMBER, salary NUMBER, name VARCHAR2(40));\n//\n// На основе собственных ROWID на Прикладе thies[at]thieso.net (980221)\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$sql = \"INSERT INTO mytab (id, name) VALUES(:id_bv, :name_bv)\n        RETURNING ROWID INTO :rid\";\n\n$ins_stid = oci_parse($conn, $sql);\n\n$rowid = oci_new_descriptor($conn, OCI_D_ROWID);\noci_bind_by_name($ins_stid, \":id_bv\",   $id,    10);\noci_bind_by_name($ins_stid, \":name_bv\", $name,  32);\noci_bind_by_name($ins_stid, \":rid\",     $rowid, -1, OCI_B_ROWID);\n\n$sql = \"UPDATE mytab SET salary = :salary WHERE ROWID = :rid\";\n$upd_stid = oci_parse($conn, $sql);\noci_bind_by_name($upd_stid, \":rid\", $rowid, -1, OCI_B_ROWID);\noci_bind_by_name($upd_stid, \":salary\", $salary,   32);\n\n// идентификаторы и имена для вставки\n$data = array(1111 => \"Larry\",\n              2222 => \"Bill\",\n              3333 => \"Jim\");\n\n// Заработная плата для каждого сотрудника\n$salary = 10000;\n\n// Вставка и немедленное обновление каждой строки\nforeach ($data as $id => $name) {\n    oci_execute($ins_stid);\n    oci_execute($upd_stid);\n}\n\n$rowid->free();\noci_free_statement($upd_stid);\noci_free_statement($ins_stid);\n\n// Показать новые записи\n$stid = oci_parse($conn, \"SELECT * FROM mytab\");\noci_execute($stid);\nwhile ($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) {\n    var_dump($row);\n}\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #10 Прикріплення для збереження функції PL/SQL**\n\n```php\n<?php\n\n//  Перед запуском PHP-сценария, создайте хранимую функцию в\n//  SQL*Plus или SQL Developer:\n//\n//  CREATE OR REPLACE FUNCTION myfunc(p IN NUMBER) RETURN NUMBER AS\n//  BEGIN\n//      RETURN p * 3;\n//  END;\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message']), E_USER_ERROR);\n}\n\n$p = 8;\n\n$stid = oci_parse($conn, 'begin :r := myfunc(:p); end;');\noci_bind_by_name($stid, ':p', $p);\n\n// Возвращаемое значение OUT-прикреплено. По умолчаннию типом данных будет строка.\n// Прикрепление со значением 40 означает, что будет возвращено 40 символов.\noci_bind_by_name($stid, ':r', $r, 40);\n\noci_execute($stid);\n\nprint \"$r\\n\";   // выведет 24\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #11 Прикріплення параметрів для PL/SQL збереженої процедури**\n\n```php\n<?php\n\n//  Перед запуском PHP-сценария, создайте хранимую процедуру в\n//  SQL*Plus или SQL Developer:\n//\n//  CREATE OR REPLACE PROCEDURE myproc(p1 IN NUMBER, p2 OUT NUMBER) AS\n//  BEGIN\n//      p2 := p1 * 2;\n//  END;\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message']), E_USER_ERROR);\n}\n\n$p1 = 8;\n\n$stid = oci_parse($conn, 'begin myproc(:p1, :p2); end;');\noci_bind_by_name($stid, ':p1', $p1);\n\n// Второй параметр процедуры OUT-прикреплён. По умолчаннию типом данных будет строка.\n// Прикрепление со значением 40 означает, что будет возвращено 40 символов.\noci_bind_by_name($stid, ':p2', $p2, 40);\n\noci_execute($stid);\n\nprint \"$p2\\n\";   // выведет 16\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #12 Прикріплення об'єкта CLOB**\n\n```php\n<?php\n\n// Перед запуском создаём таблицу:\n//     CREATE TABLE mytab (mykey NUMBER, myclob CLOB);\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message']), E_USER_ERROR);\n}\n\n$mykey = 12343;  // произвольный ключ для Приклада\n\n$sql = \"INSERT INTO mytab (mykey, myclob)\n        VALUES (:mykey, EMPTY_CLOB())\n        RETURNING myclob INTO :myclob\";\n\n$stid = oci_parse($conn, $sql);\n$clob = oci_new_descriptor($conn, OCI_D_LOB);\noci_bind_by_name($stid, \":mykey\", $mykey, 5);\noci_bind_by_name($stid, \":myclob\", $clob, -1, OCI_B_CLOB);\noci_execute($stid, OCI_DEFAULT);\n$clob->save(\"A very long string\");\n\noci_commit($conn);\n\n// Получение CLOB-данных\n\n$query = 'SELECT myclob FROM mytab WHERE mykey = :mykey';\n\n$stid = oci_parse ($conn, $query);\noci_bind_by_name($stid, \":mykey\", $mykey, 5);\noci_execute($stid);\n\nprint '<table border=\"1\">';\nwhile ($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_LOBS)) {\n    print '<tr><td>'.$row['MYCLOB'].'</td></tr>';\n    // В цикле, очищение больших переменных перед повторным получением данных, уменьшает пиковое потребление памяти PHP\n    unset($row);\n}\nprint '</table>';\n\n?>\n```\n\n**Приклад #13 Прикріплення PL/SQL BOOLEAN**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message']), E_USER_ERROR);\n}\n\n$plsql =\n  \"begin\n    :output1 := true;\n    :output2 := false;\n   end;\";\n\n$s = oci_parse($c, $plsql);\noci_bind_by_name($s, ':output1', $output1, -1, OCI_B_BOL);\noci_bind_by_name($s, ':output2', $output2, -1, OCI_B_BOL);\noci_execute($s);\nvar_dump($output1);  // true\nvar_dump($output2);  // false\n\n?>\n```\n\n### Примітки\n\n**Увага**\n\nНе используйте[addslashes()](function.addslashes.md) одночасно з **oci\\_bind\\_by\\_name()**, так як лапок бути не повинно. Всі зазначені лапки будуть записані до бази даних, тому що **oci\\_bind\\_by\\_name()** вставляє дані дослівно і не видаляє лапки або символи екранування.\n\n> **Зауваження** :\n> \n> Якщо прикріплюється рядок до `CHAR`\\-полю у виразі `WHERE`, помните, что Oracle использует при сравнении значения`CHAR`, доповнені пробілами. Змінна PHP повинна бути доповнена пробілами до того ж розміру, що і поле, щоб вираз `WHERE` виконувалося правильно.\n\n> **Зауваження** :\n> \n> Переменная PHP`var` є посиланням. Деякі види циклів можуть працювати не так, як очікується:\n> \n> ```php\n> <?php\n> foreach ($myarray as $key => $value)  {\n>     oci_bind_by_name($stid, $key, $value);\n> }\n> ?>\n> ```\n> \n> У цьому випадку кожен ключ прикріплюється до $value, тому всі прикріплені змінні вказують на значення останньої ітерації циклу. Натомість слід використовувати:\n> \n> ```php\n> <?php\n> foreach ($myarray as $key => $value) {\n>     oci_bind_by_name($stid, $key, $myarray[$key]);\n> }\n> ?>\n> ```\n\n### Дивіться також\n\n-   [oci\\_bind\\_array\\_by\\_name()](function.oci-bind-array-by-name.md) \\- Пов'язує PHP масив з масивом Oracle PL/SQL\n-   [oci\\_parse()](function.oci-parse.md) \\- готує запит до виконання\n","title":"oci\\_bind\\_by\\_name","contentType":2,"navigation":[{"function.oci-bind-array-by-name.md":"« oci\\_bind\\_array\\_by\\_name"},{"function.oci-cancel.md":"oci\\_cancel »"},{"index.md":"PHP Manual"},{"ref.oci8.md":"OCI8 Функції"}]}},"__N_SSG":true}