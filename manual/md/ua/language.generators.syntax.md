- [«Знайомство з генераторами](language.generators.overview.md)
- [Порівняння генераторів з об'єктами класу Iterator
»](language.generators.comparison.md)

- [PHP Manual](index.md)
- [Генератори](language.generators.md)
- Синтаксис генераторів

## Синтаксис генераторів

Генератор в цілому виглядає як звичайна функція, за винятком того, що
замість повернення одного значення, генератор перебиратиме стільки
значень, скільки потрібно. Будь-яка функція, що містить
[yield](language.generators.syntax.md#control-structures.yield),
є функцією генератора.

Коли викликається генератор, він повертає об'єкт, який можна
ітерувати. Коли ви ітеруєте цей об'єкт (наприклад, у циклі
[foreach](control-structures.foreach.md)), PHP викликає методи
ітерації об'єкта щоразу, коли вам потрібно нове значення, після чого
зберігає стан генератора та при наступному виклику повертає
наступне значення.

Коли всі значення у генераторі закінчилися, генератор просто завершить
роботу, нічого не повернувши. Після цього основний код продовжить роботу, як
якби у масиві закінчилися елементи для перебору.

> **Примітка**:
>
> Генератори можуть повертати значення, які можна отримати за допомогою
> [Generator::getReturn()](generator.getreturn.md).

### Ключове слово **yield**

Вся суть генератора полягає у ключовому слові **yield**. В самому
простому варіанті оператор "yield" можна розглядати як оператор
"return", за винятком того, що замість припинення роботи функції,
"yield" тільки зупиняє її виконання та повертає поточне
значення, і при наступному виклику функції вона відновить виконання з
місця, на якому перервалась.

**Приклад #1 Простий приклад видачі значень**

` <?phpfunction gen_one_to_three() {    for ($i u003d 1; $i <u003d 3; $i++) {         // Зверніть увага, і yield $i; }}$generator u003d gen_one_to_three();foreach ($generator as $value) {    echo "$value
";}?> `

Результат виконання цього прикладу:

1
2
3

> **Примітка**:
>
> Послідовність цілих чисел буде пов'язана з одержуваними від
> генератора значеннями, як перебирається неасоціативний масив.

**Застереження**

Значення, яке присвоєно `$data`, - це значення, передане
[Generator::send()](generator.send.md) або **`null`**, якщо замість
це викликається [Generator::next()](generator.next.md).

#### Отримання значень із ключами

PHP підтримує асоціативні масиви, і генератори не є
винятком. Так само як можна набувати прості значення, як показано
вище, ви можете отримати значення з ключами.

Синтаксис отримання ключ/значення дуже схожий на синтаксис асоціативних
масивів, як показано нижче.

**Приклад #2 Отримання пар ключ/значення**

` <?php/* $input містить пари ключ/значення розділені точкою з|ком| */$input u003d <<<'EOF'1;PHP;Любит знаки долара2; input) {    foreach (explode("
", $input) as $line) {        $fields u003d explode(';', $line);        $id u003d array_shift($fields);        yield $id u003d> $fields;    }}foreach (input_parser($input) as $id u003d> $fields) {    echo "$id:
";   echo "    $fields[0]
";   echo "    $fields[1]
";}?> `

Результат виконання цього прикладу:

1:
PHP
Любить знаки долара
2:
Python
Любить прогалини
3:
Ruby
Любить блоки

**Застереження**

Також як і для одиночних значень, отримання пар ключ/значення
висловлюваннях вимагає обертання їх у дужки:

` $data u003d (yield $key u003d> $value);`

#### Отримання NULL

Для отримання **`null`** необхідно викликати "yield" без аргументів. Ключ
згенерується автоматично.

**Приклад #3 Отримання **`null`****

` <?phpfunction gen_three_nulls() {    foreach (range(1, 3) as $i) {        yield; }}var_dump(iterator_to_array(gen_three_nulls()));?> `

Результат виконання цього прикладу:

array(3) {
[0]u003d>
NULL
[1]u003d>
NULL
[2]u003d>
NULL
}

#### Отримання значення за посиланням

Генератори можуть надавати значення за посиланням. Це робиться так само, як
[повернення посилань з функцій](functions.returning-values.md)":
додавання амперсанди (&) перед ім'ям функції.

**Приклад #4 Отримання значень за посиланням**

` <?phpfunction &gen_reference() {    $value u003d 3; while($value > 0) {       yield $value; }}/* Зверніть увага, що ми можемо змінювати $number в циклі, і * так як генератор повертає посилання, $value * в gen_reference() так. */foreach (gen_reference() as &$number) {   echo (--$number).'... ';}?> `

Результат виконання цього прикладу:

2... 1... 0...

#### Делегування генератора за допомогою **yield from**

Делегування генератора дозволяє вам отримувати значення з іншого
генератора, об'єкта [Traversable](class.traversable.md), або масиву,
використовуючи **yield from**. Зовнішній генератор повертатиме значення з
внутрішнього генератора, об'єкта або масиву, до того моменту, поки вони
їх віддають, після чого продовжиться виконання зовнішнього генератора.

Якщо генератор використовується з **yield from**, то вираз **yield
from** також повертатиме значення з внутрішнього генератора.

**Застереження**

# Збереження в масив (наприклад, за допомогою [iterator_to_array()](function.iterator-to-array.md))

**yield from** не скидає ключі. Ключі, повернені з об'єкту
[Traversable](class.traversable.md) або масиву зберігаються. Таким
Таким чином, деякі значення можуть перетинатися за ключами з іншими
**yield** або **yield from**, що при записі в масив потягне за
собою перезапис колишніх значень.

Загальний випадок, коли це має значення, це коли
[iterator_to_array()](function.iterator-to-array.md) повертає масив
з ключами за замовчуванням. В цьому випадку можна отримати несподіваний
результат. [iterator_to_array()](function.iterator-to-array.md) має
другий параметр `use_keys`, який можна встановити в **`false`**, для
генерації власних ключів та ігнорування ключів, переданих з
об'єкта [Generator](class.generator.md).

**Приклад #5 **yield from** з
[iterator_to_array()](function.iterator-to-array.md)**

`<?phpfunction inner() {    yield 1; // ключ 0    yield 2; // ключ 1    yield 3; // ключ 2}function gen() {    yield 0; // ключ 0    yield from inner(); // ключі 0-2   yield 4; // ключ 1}// Задайте false другим параметром для отримання масиву [0, 1, 2, 3, 4]var_dump(iterator_to_array(gen()));?> `

Результат виконання цього прикладу:

array(3) {
[0]u003d>
int(1)
[1]u003d>
int(4)
[2]u003d>
int(3)
}

**Приклад #6 Основи використання **yield from****

`<?phpfunction count_to_ten() {    yield 1; yield 2; yield from [3, 4]; yield from new ArrayIterator([5, 6]); yield from seven_eight(); yield 9; yield 10;}function seven_eight() {    yield 7; yield from eight();}function eight() {   yield 8;}foreach (count_to_ten() as $num) {    echo "$num ";}?> `

Результат виконання цього прикладу:

1 2 3 4 5 6 7 8 9 10

**Приклад #7 **yield from** та значення, що повертаються**

`<?phpfunction count_to_ten() {    yield 1; yield 2; yield from [3, 4]; yield from new ArrayIterator([5, 6]); yield from seven_eight(); return yield from nine_ten();}function seven_eight() {   yield 7; yield from eight();}function eight() {   yield 8;}function nine_ten() {    yield 9; return 10;}$gen u003d count_to_ten();foreach ($gen as $num) {   echo "$num ";}echo $gen->getReturn();?> `

Результат виконання цього прикладу:

1 2 3 4 5 6 7 8 9 10
