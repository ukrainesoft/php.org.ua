{"pageProps":{"page":{"slug":"language.types.callable.md","content":"## Функції зворотного дзвінка (callback-функції)\n\nCallback-функції можуть бути позначені оголошенням типу [callable](language.types.callable.md)\n\nДеякі функції, такі як [call\\_user\\_func()](function.call-user-func.md) або [usort()](function.usort.md), приймають певні користувачем callback-функції як параметр. Callback-функції може бути як простими функціями, і методами об'єктів, включаючи статичні методи класів.\n\n### Передача\n\nУ PHP функції передаються на ім'я у вигляді рядка. Можна використовувати будь-які вбудовані або створені користувачем функції, за винятком конструкцій мови, таких як: [array()](function.array.md) [echo](function.echo.md) [empty()](function.empty.md) [eval()](function.eval.md) [exit()](function.exit.md) [isset()](function.isset.md) [list()](function.list.md) [print](function.print.md) або [unset()](function.unset.md)\n\nМетод створеного об'єкта (object) передається як масив, що містить об'єкт за індексом 0 та ім'я методу за індексом 1. Доступ до закритих та захищених методів дозволено зсередини класу.\n\nСтатичні методи класу також можуть бути викликані без створення екземпляра об'єкта класу шляхом передачі імені класу замість об'єкта в елементі масиву з індексом 0 або виконання `'ClassName::methodName'`\n\nКрім звичайних функцій користувача, в якості callback-функції можна передавати [анонімні функції](functions.anonymous.md) і [стрілочні функції](functions.arrow.md)\n\n> **Зауваження** :\n> \n> Починаючи з PHP 8.1.0, у [Callback-функцій як об'єктів першого класу](functions.first_class_callable_syntax.md) та сама семантика, що й у цього методу.\n\nЯк правило, будь-який об'єкт, що реалізує [\\_\\_invoke()](language.oop5.magic.md#object.invoke), також може бути передано до параметра callback.\n\n**Приклад #1 Приклад callback-функції**\n\n```php\n<?php\n\n// Приклад callback-функции\nfunction my_callback_function() {\n    echo 'Привет, мир!';\n}\n\n// Приклад callback-метода\nclass MyClass {\n    static function myCallbackMethod() {\n        echo 'Привет, мир!';\n    }\n}\n\n// Тип 1: Простой callback\ncall_user_func('my_callback_function');\n\n// Тип 2: Вызов статического метода класса\ncall_user_func(array('MyClass', 'myCallbackMethod'));\n\n// Тип 3: Вызов метода класса\n$obj = new MyClass();\ncall_user_func(array($obj, 'myCallbackMethod'));\n\n// Тип 4: Вызов статического метода класса\ncall_user_func('MyClass::myCallbackMethod');\n\n// Тип 5: Вызов относительного статического метода\nclass A {\n    public static function who() {\n        echo \"A\\n\";\n    }\n}\n\nclass B extends A {\n    public static function who() {\n        echo \"B\\n\";\n    }\n}\n\ncall_user_func(array('B', 'parent::who')); // A, устарело, начиная с PHP 8.2.0\n\n// Тип 6: Объекты, реализующие __invoke, могут быть использованы как callback\nclass C {\n    public function __invoke($name) {\n        echo 'Привет ', $name, \"\\n\";\n    }\n}\n\n$c = new C();\ncall_user_func($c, 'PHP!');\n?>\n```\n\n**Приклад #2 Приклад callback-функції з використанням замикання**\n\n```php\n<?php\n// Наше замыкание\n$double = function($a) {\n    return $a * 2;\n};\n\n// Диапазон чисел\n$numbers = range(1, 5);\n\n// Использование замыкания в качестве callback-функции\n// для удвоения каждого элемента в нашем диапазоне\n$new_numbers = array_map($double, $numbers);\n\nprint implode(' ', $new_numbers);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n2 4 6 8 10\n```\n\n> **Зауваження** :\n> \n> Callback-функції, зареєстровані такими функціями як [call\\_user\\_func()](function.call-user-func.md) і [call\\_user\\_func\\_array()](function.call-user-func-array.md), не будуть викликані за наявності не спійманого виключення, кинутого у попередній callback-функції.\n","title":"Функції зворотного дзвінка (callback-функції)","contentType":2,"navigation":[{"language.types.resource.md":"« Ресурс"},{"language.types.mixed.md":"Mixed »"},{"index.md":"PHP Manual"},{"language.types.md":"Типи"}]}},"__N_SSG":true}