- [«PDO::lastInsertId](pdo.lastinsertid.md)
- [PDO::query »](pdo.query.md)

- [PHP Manual](index.md)
- [PDO](class.pdo.md)
- готує запит до виконання та повертає пов'язаний із цим
запитом об'єкт

# PDO::prepare

(PHP 5 \>u003d 5.1.0, PHP 7, PHP 8, PHP 8,PECL pdo \>u003d 0.1.0)

PDO::prepare — Готує запит до виконання та повертає пов'язаний
із цим запитом об'єкт

### Опис

public **PDO::prepare**(string `$query`, array `$options` u003d \[\]):
[PDOStatement](class.pdostatement.md)\|false

Підготовка SQL-запиту до бази даних до запуску за допомогою методу
[PDOStatement::execute()](pdostatement.execute.md). Запит може
містити іменовані (:name) або неіменовані (?) псевдозмінні,
які будуть замінені реальними значеннями під час запуску запиту на
Виконання. Використовувати одночасно і іменовані, і неіменовані
псевдозмінні в одному запиті не можна, потрібно вибрати щось одне.
Використовуйте псевдозмінні, щоб прив'язати до запиту
введення, не включайте дані, введені користувачем, безпосередньо на запит.

Ви повинні підбирати унікальні імена псевдозмінних для кожного
значення, яке необхідно передавати в запит під час виклику
[PDOStatement::execute()](pdostatement.execute.md). Не можна
використовувати одну псевдозмінну у запиті більше одного разу, крім
варіанти, коли включено режим емуляції.

> **Примітка**:
>
> Псевдозмінні повинні представляти лише одиничний обсяг даних. Ні
> частина значення, ні службове слово, ні ім'я поля, ні будь-яку
> довільну частину запиту. Наприклад, ви не можете пов'язати
> псевдозмінну з кількома значеннями для вставки в конструкцію
> IN().

Виклик **PDO::prepare()** та
[PDOStatement::execute()](pdostatement.execute.md) для запитів,
які будуть запускатися багаторазово з різними параметрами, підвищує
продуктивність програми, дозволяючи драйверу кешувати на клієнті
та/або сервері план виконання запиту та метадані, а також допомагає
уникнути SQL-ін'єкцій, тому що немає необхідності екранувати
параметри, що передаються.

Якщо драйвер не підтримує запити, що підготовляються, PDO вміє їх
емулювати, а також може замінювати псевдозмінні на те, що більше
підходить, якщо, наприклад, драйвер підтримує лише іменовані або,
навпаки, лише неіменовані псевдозмінні.

> **Примітка**: Синтаксичний аналізатор, що використовується для емульованих
> підготовлених операторів та для перезапису іменованих параметрів або
> параметрів стилю знака питання, підтримує нестандартні
> зворотні сліші для одинарних та подвійних лапок. Це означає, що
> завершальні лапки, що безпосередньо передують зворотною косою
> чорті, не розпізнаються як такі, що може призвести до неправильного
> виявлення параметрів, що призведе до збою підготовленого оператора
> під час виконання. Обхідний шлях - не використовувати емульовану
> підготовку до таких SQL-запитів та уникати перезапису параметрів,
> використовуючи стиль параметрів, який спочатку підтримується
> драйвером.

Починаючи з PHP 7.4.0, можна уникнути екранування знаків питання,
подвоївши їх. Це означає, що рядок `??` буде перетворено на `?` при
надсилання запиту до бази даних.

### Список параметрів

`query`
Це має бути коректний SQL-запит із погляду цільової СУБД.

`options`
Цей масив містить одну або більше пар ключ u003d значення для установки
значень атрибутів об'єкта PDOStatement, який буде повернено з
цього методу. В основному, ви будете використовувати цей масив для
присвоєння значення `PDO::ATTR_CURSOR` атрибуту `PDO::CURSOR_SCROLL`,
щоб отримати курсор, що прокручується. Деякі драйвери можуть мати
свої специфічні налаштування, які можна задати під час підготовки
запиту.

### Значення, що повертаються

Якщо СУБД успішно підготувала запит, **PDO::prepare()** повертає
об'єкт [PDOStatement](class.pdostatement.md). Якщо підготувати запит
не вдалося, **PDO::prepare()** повертає **`false`** або викидає
виняток [PDOException](class.pdoexception.md) (залежить від поточного
режиму обробки помилок (pdo.error-handling.md)).

> **Примітка**:
>
> Емульовані підготовлені запити не створюються на сервері баз даних,
> тому **PDO::prepare()** не може перевірити правильність
> побудованого запиту.

### Приклади

**Приклад #1 Підготовка SQL-запиту з іменованими параметрами**

`<?php/* Виконання запиту з передачею йому масива параметрів */$sql u003d 'SELECT name, colour, calories   FROM fruit     WHERE calo         ¦¦ , array(PDO::ATTR_CURSOR u003d> PDO::CURSOR_FWDONLY));$sth->execute(array('calories' u003d> 150, 'colour' u003d> 'red'));$red u003d $sth->fetchAl ();/* Ключі масиву також можуть починатися з двоточки ":" (необов'язково) */$sth->execute(array(':calories' u003d> 175, ':colour' u003d> ) u003d $sth->fetchAll();?> `

**Приклад #2 Підготовка SQL-запиту з неназваними параметрами (символ
'?')**

`<?php/* Виконання запиту з передачею йому масиву параметрів */$sth u003d $dbh->prepare('SELECT name, colour, calories    FROM fruit                                                        array(150, 'red'));$red u003d $sth->fetchAll();$sth->execute(array(175, 'yellow'));$yellow u003d $sth->fetchAll();?> `

**Приклад #3 Підготовка SQL-запиту з екранованим питанням
знаком**

` <?php/* зауваження: працює тільки з базами даних PostgreSQL */$sth u003d $dbh->prepare('SELECT * FROM issues WHERE tag::jsonb ?? ?'' ']);$featureIssues u003d $sth->fetchAll();$sth->execute(['performance']);$performanceIssues u003d $sth->fetchAll();?> `

### Дивіться також

- [PDO::exec()](pdo.exec.md) - Виконує SQL-запит і повертає
кількість порушених рядків
- [PDO::query()](pdo.query.md) - Готує та виконує
вираз SQL без наповнювачів
- [PDOStatement::execute()](pdostatement.execute.md) - Запускає
підготовлений запит на виконання
