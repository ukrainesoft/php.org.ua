- [« Транзакції та автоматична фіксація
змін](pdo.transactions.md)
- [Помилки та їх обробка»](pdo.error-handling.md)

- [PHP Manual](index.md)
- [PDO](book.pdo.md)
- Підготовлені запити та процедури, що зберігаються.

# Підготовлені запити та процедури, що зберігаються

Більшість баз даних підтримують концепцію підготовлених запитів.
Що це таке? Це можна описати, як вид скомпілюваного
шаблону SQL запиту, який запускатиметься додатком та
налаштовуватись за допомогою вхідних параметрів. У підготовлених запитів
є дві головні переваги:

- Запит необхідно якось підготувати і потім його можна запускати
стільки разів, скільки потрібно, причому як з тими ж, так і з
різними параметрами. Коли запит підготовлено, СУБД
аналізує його, компілює та оптимізує план його виконання. В
у разі складних запитів цей процес може займати відчутний час та
помітно уповільнити роботу програми, якщо потрібно багато разів
виконувати запит із різними параметрами. При використанні
підготовленого запиту СУБД аналізує/компілює/оптимізує
запит будь-якої складності тільки один раз, а програма запускає на
виконання вже підготовлений шаблон. Таким чином підготовлені
запити споживають менше ресурсів та працюють швидше.
- Параметри підготовленого запиту не потрібно екранувати
лапками; драйвер робить це автоматично. Якщо у додатку
використовуються виключно підготовлені запити, розробник може
бути впевнений, що ніяких SQL-ін'єкцій статися не може (проте,
якщо інші частини тексту запиту створюються з неекранованим
введенням, то SQL ін'єкція, як і раніше, можлива).

Підготовлені запити також корисні тим, що PDO може їх эмулировать,
якщо драйвер бази даних немає такої функціональності. Це означає,
що програма може користуватися однією і тією ж методикою доступу до
даним незалежно від можливостей СУБД.

**Приклад #1 Вставки, що повторюються, в базу з використанням підготовлених
запитів**

У цьому прикладі 2 рази виконується INSERT запит з різними значеннями
`name` та `value`, які підставляються замість відповідних
псевдозмінних:

` <?php$stmt u003d $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (:name, :value)");$stmt->bindParam(':name', $name);$stmt ->bindParam(':value', $value);// вставимо одну рядок$name u003d 'one';$value u003d 1;$stmt->execute();// тепер іншу рядок з іншими  two';$value u003d 2;$stmt->execute();?> `

**Приклад #2 Вставки, що повторюються, в базу з використанням підготовлених
запитів**

У цьому прикладі 2 рази виконується INSERT запит з різними значеннями
`name` і `value`, які підставляються замість псевдозмінних `?`.

` <?php$stmt u003d $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (?, ?)");$stmt->bindParam(1, $name);$stmt->bindParam(2 , $value);// вставимо одне рядок$name u003d 'one';$value u003d 1;$stmt->execute();// тепер інше рядок з іншими значеннями$name u003d 'two'; $stmt->execute();?> `

**Приклад #3 Вибір даних за допомогою підготовлених запитів**

У цьому прикладі проводиться вибірка з бази за ключом, що вводить
Користувач через форму. Користувальницьке введення автоматично
полягає в лапки, тому немає ризику ін'єкції SQL.

` <?php$stmt u003d$dbh->prepare("SELECT * FROM REGISTRY where name u003d ?");$stmt->execute([$_GET['name']]);foreach ($stmt as $row) {  print_r($row);}?> `

**Приклад #4 Виклик збереженої процедури з вихідними параметрами**

Якщо СУБД підтримує вихідні параметри, програма може користуватися
ними також як і вхідними. Вихідні параметри зазвичай використовують для
отримання даних із процедур, що зберігаються. Користуватися вихідними
параметрами дещо складніше, тому що розробнику необхідно знати
максимальний розмір добутих значень ще на етапі завдання цих
параметрів. Якщо отримане значення виявиться більшим, ніж
передбачалося, буде викликано помилку.

` <?php$stmt u003d $dbh->prepare("CALL sp_returns_string(?)");$stmt->bindParam(1, $return_value, PDO::PARAM_STR, 4000);// виклик зберігається$ execute();print "процедура вернула $return_value
";?> `

**Приклад #5 Виклик збереженої процедури з вхідним/вихідним параметром**

Можна встановити параметр одночасно вхідним і вихідним; синтаксис при
це той же, що і для вихідних параметрів. У наступному прикладі рядок
'привіт' передається в процедуру, що зберігається, а потім цей рядок буде
замінена значенням, що повертається.

` <?php$stmt u003d $dbh->prepare("CALL sp_takes_string_returns_string(?)");$value u003d 'привіт';$stmt->bindParam(1, $value, PDO::PARAM_STR|PDO::PARAM 4000);// виклик хронічної процедури $ stmt-> execute (); print "процедура повернула $ value
";?> `

**Приклад #6 Неправильне використання псевдозмінної**

` <?php$stmt u003d $dbh->prepare("SELECT * FROM REGISTRY where name LIKE '%?%'");$stmt->execute([$_GET['name']]);// псевдозмінна може використовуватися тільки в виді окремого значення$stmt u003d $dbh->prepare("SELECT * FROM REGISTRY where name LIKE ?");$stmt->execute(["%$_GET[name]%"]);
