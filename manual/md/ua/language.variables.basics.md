- [« Змінні](language.variables.md)
- [Предвизначені змінні »](language.variables.predefined.md)

- [PHP Manual](index.md)
- [Змінні](language.variables.md)
- Основи

## Основи

Змінні в PHP представлені знаком долара з наступним ім'ям
змінної. Ім'я змінної чутливе до регістру.

Імена змінних відповідають тим самим правилам, як і інші
найменування у PHP. Правильне ім'я змінної має починатися з літери
або символу підкреслення і складатися з букв, цифр та символів
підкреслення у будь-якій кількості. Це можна відобразити регулярним
виразом: `^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$`

> **Примітка**: Під літерами тут маються на увазі символи a-z, A-Z та
> Байти від 128 до 255 (`0x80-0xff`).

> **Примітка**: `$this` - це спеціальна змінна, якої не можна
> нічого привласнювати. До PHP 7.1.0 було можливе непряме присвоєння
> (наприклад, з використанням [змінних
> змінних](language.variables.variable.md)).

**Підказка**

Дивіться також [Інструкція по імену](userlandnaming.md).

Для отримання інформації про функції роботи зі змінними звертайтесь до розділу
[функцій роботи зі змінними](ref.var.md).

` <?php$var u003d 'Боб';$Var u003d 'Джо';echo "$var, $Var"; // виведе "Боб, Джо"$4site u003d 'є ще ні'; // неправильно; починається з цифри$_4site u003d 'ще ні'; // Правильно; починається з символу підкреслення$täyte u003d 'mansikka'; // Правильно; 'ä' це (Розширений) ASCII 228.?> `

За умовчанням змінні завжди надаються за значенням. Тобто коли
ви привласнюєте вираз змінної, все значення оригінального
вирази копіюється у цю змінну. Це означає, наприклад, що
після того, як одній змінній присвоєно значення інший, зміна
однією з них не впливає на іншу. Додаткову інформацію про це
способі присвоєння дивіться у розділі
[Вирази](language.expressions.md).

PHP також пропонує інший спосіб присвоєння значень змінним:
[Присвоєння за посиланням](language.references.md). Це означає, що
нова змінна просто посилається (інакше кажучи, стає
псевдонімом" або "вказує") на оригінальну змінну.
нової змінної відбиваються на оригіналі, і навпаки.

Для присвоєння посилання, просто додайте амперсанд (&) до початку імені
присвоюється (вихідної) змінної. Наприклад, наступний фрагмент коду
двічі виводить ''Мене звуть Боб'':

`<?php$foo u003d 'Боб'; // Привласнює $foo значення 'Боб'$bar u003d &$foo; // Посилання на $foo через $bar.$bar u003d "Мене звуть $bar"; // Зміна $bar...echo $bar;echo $foo; // мінює і $foo.?> `

За посиланням можуть бути присвоєні лише іменовані
змінні.

` <?php$foo u003d 25;$bar u003d &$foo; // Це вірне присвоєння.$bar u003d &(24 * 7); // Неправильно; посилання на неіменоване вираз.function test(){  return 25;}$bar u003d &test(); // Неправильно.?> `

Хорошою практикою вважається ініціалізувати змінні, хоча в PHP це
і не є обов'язковою вимогою. Неініціалізовані змінні
приймають значення за замовчуванням залежно від їх типу, який
визначається з контексту їх першого використання: булеви приймають
значення **`false`**, цілі числа та числа з плаваючою точкою - нуль,
рядки (наприклад, при використанні [echo](function.echo.md)) -
порожній рядок, а масиви стають порожніми масивами.

**Приклад #1 Значення за замовчуванням у неініціалізованих змінних**

`<?php// Невстановлена І не має посилань (тобто без контексту використання) змінна; виведе NULLvar_dump($unset_var);// Бульове застосування; виведе 'false' (Докладніше за цього синтаксису дивіться розділ про тернарний оператор)echo($unset_bool ? "true
" : "false
");// Строкове використання; виведе 'string(3) "abc"'$unset_str .u003d 'abc';var_dump($unset_str);// Цілочисленне використання; виведе 'int(25)'$unset_int 5 // 0 + 25 u003d> 25var_dump($unset_int);// Використання в кількості  з плаваючою точкою(float/double); виведе 'float(1.25)'$1; як масиву; виведе array(1) {  [3]u003d> string(3) "def" }$unset_arr[3] u003d "def"; // array() + array(3 u003d>> > array(3 u003d> "def")var_dump($unset_arr);// Використання якобъекта; створює новий об'єкт stdClass (дивіться http://www.php.net/manual/ru/reserved.classes. Виведе: object(stdClass)#1 (1) {  ["foo"]u003d>  string(3) "bar" }$unset_obj->foo u003d 'bar';var_dump($unset_obj);?> `

Покладатися на значення за замовчуванням неініціалізованих змінних
досить проблематично при включенні файлу в інший файл, який використовує
змінну з таким самим ім'ям. У разі роботи з неініціалізованою
змінною викликається помилка рівня [E_NOTICE](), крім випадку
додавання елементів у неініціалізований масив. Для виявлення
ініціалізації змінної може бути використана мовна конструкція
[isset()](function.isset.md).
