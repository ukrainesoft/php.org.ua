- [« Продуктивність](regexp.reference.performance.md)
- [Відмінність від Perl »](reference.pcre.pattern.differences.md)

- [PHP Manual](index.md)
- [Регулярні висловлювання PCRE](pcre.pattern.md)
- Модифікатори шаблонів

# Модифікатори шаблонів

Нижче наведені всі доступні на сьогоднішній день модифікатори. Ім'я,
взяте в круглі дужки, вказує внутрішнє PCRE-ім'я для даного
модифікатор. Прогалини та переклади рядків у модифікаторах ігноруються,
інші символи викликають помилки.

> *i* (`PCRE_CASELESS`)
> Якщо цей модифікатор використовується, символи у шаблоні відповідають
> символів як верхнього, і нижнього регістру.
>
> *m* (`PCRE_MULTILINE`)
> За замовчуванням PCRE обробляє дані як символьну однорядкову
> рядок (навіть якщо він містить кілька роздільників рядків).
> Метасимвол початку рядка '^' відповідає лише початку
> оброблюваного тексту, у той час як метасимвол "кінець рядка" '$'
> відповідає кінцю тексту, або позиції перед завершальним текстом
> перекладом рядка (якщо модифікатор *D* не встановлений). В
> Perl ситуація повністю аналогічна. Якщо цей модифікатор
> використовується, метасимволи "початок рядка" і "кінець рядка" також
> відповідають позиціям перед довільним символом перекладу та рядки
> і, відповідно, після, як і на самому початку і наприкінці рядка.
> Це відповідає Perl-модифікатору /m. У випадку, якщо оброблюваний
> текст не містить символів перекладу рядка або шаблон не містить
> метасимволів '^' або '$', даний модифікатор не має жодного
> ефекту.
>
> *s* (`PCRE_DOTALL`)
> Якщо цей модифікатор використовується, метасимвол "точка" у шаблоні
> відповідає всім символам, включаючи переклад рядків. Без нього – все
> символи, крім перекладів рядків. Цей модифікатор еквівалентний запису
> /s у Perl. Клас символів, побудований на запереченні, наприклад \[^a\],
> завжди відповідає перекладу рядка, незалежно від цього
> Модифікатор.
>
> *x* (`PCRE_EXTENDED`)
> Якщо використовується модифікатор, неекрановані пробіли,
> символи табуляції та порожнього рядка будуть проігноровані у шаблоні,
> якщо вони не є частиною символьного класу. Також ігноруються усі
> символи між неекранованим символом '#' (якщо він не є
> частиною символьного класу) та символом перекладу рядка (включаючи самі
> символи '
'і '#'). Це еквівалентно Perl-модифікатору /x, і
> дозволяє розміщувати коментар у складних шаблонах. Примітка: це
> стосується лише символьних даних. Пробільні символи не фігурують у
> службових символьних послідовностях, наприклад,
> послідовності '(?('), що відкриває умовну підмаску.
>
> *A* (`PCRE_ANCHORED`)
> Якщо використовується модифікатор, відповідність шаблону буде
> досягатися лише тому випадку, якщо він " заякорен " , тобто
> відповідає початку рядка, у якому виконується пошук. Того ж
> ефекту можна досягти підходящою конструкцією з вкладеним шаблоном,
> яка є єдиним способом реалізації цієї поведінки в
> Perl.
>
> *D* (`PCRE_DOLLAR_ENDONLY`)
> Якщо використовується цей модифікатор, метасимвол $ у шаблоні
> відповідає лише закінченню оброблюваних даних. Без цього
> модифікатора метасимвол $ відповідає також позиції перед останнім
> символом, якщо ним є переклад рядка (але не
> поширюється будь-які інші переклади рядків). Цей модифікатор
> ігнорується, якщо використовується модифікатор *m*. У мові Perl
> аналогічний модифікатор відсутній.
>
> *S*
> Якщо планується багаторазово використовувати шаблон, має
> сенс витратити трохи більше часу на його аналіз, щоб зменшити
> час виконання. Якщо цей модифікатор використовується,
> Додатковий аналіз шаблону. На сьогодні це має сенс
> тільки для "незаякорених" шаблонів, що не починаються з будь-якого
> певного символу.
>
> *U* (`PCRE_UNGREEDY`)
> Цей модифікатор інвертує жадібність квантіфікаторів, таким чином
> вони за промовчанням не жадібні. Але стають жадібними, якщо за ними
> слідує символ `?`. Така можливість не сумісна з Perl. Його також
> можна встановити за допомогою (`?U`) [установки модифікатора всередині
> шаблона](regexp.reference.internal-options.md) або додавши знак
> питання після квантифікатора (наприклад, `.*?`).
>
> > **Примітка**:
> >
> > У нежаданому режимі зазвичай неможливий збіг символів, що перевищують
> > [pcre.backtrack_limit](pcre.configuration.md#ini.pcre.backtrack-limit).
>
> *X* (`PCRE_EXTRA`)
> Цей модифікатор включає додаткову функціональність PCRE,
> яка не сумісна з Perl: будь-який зворотний сліш у шаблоні,
> яким слідує символ, що не має спеціального значення, призводять до
> помилки. Це пов'язано з тим, що такі комбінації зарезервовані
> для подальшого розвитку. За замовчуванням же, як і в Perl, слідкуєш з
> наступним за ним символом без спеціального значення трактується як
> друкарська помилка. На сьогоднішній день це всі можливості, що керуються
> даним модифікатором
>
> *J* (`PCRE_INFO_JCHANGED`)
> Модифікатор (?J) змінює значення локальної опції `PCRE_DUPNAMES` -
> підшаблони можуть мати однакові імена. Модифікатор J
> підтримується із версії PHP 7.2.0.
>
> *u* (`PCRE_UTF8`)
> Цей модифікатор включає додаткову функціональність PCRE,
> яка не сумісна з Perl: шаблон та цільовий рядок обробляються
> як UTF-8 рядки. Неприпустимий цільовий рядок призводить до того, що
> функції preg\_\* нічого не знаходять, а неправильний шаблон призводить до
> помилки рівня E_WARNING. П'ятий та шостий октети UTF-8
> Послідовності розглядаються неприпустимими.
