- [«Оголошення типів](language.types.declarations.md)
- [Змінні »](language.variables.md)

- [PHP Manual](index.md)
- [Типи](language.types.md)
- маніпуляції з типами

## Маніпуляції з типами

PHP не вимагає явного визначення типу при оголошенні змінної. В цьому
у разі тип змінної визначається значенням, яке вона зберігає. То
є, якщо змінній `$var` надається значення типу рядок
(string), то $var змінить тип на рядок (string). Якщо після цього
змінною `$var` буде присвоєно значення типу ціле число (int), то
вона змінить тип ціле число (int).

У певних контекстах PHP може спробувати автоматично
перетворити тип значення на інший. Існують такі різні
контексти:

- Числовий контекст
- Рядковий контекст
- Логічний контекст
- Контекст цілих чисел та рядків
- Порівняльний контекст
- Контекст функцій

> **Примітка**: Коли значення потрібно інтерпретувати як інший тип,
> саме значення *не* змінює тип.

Щоб примусово встановити тип змінної, дивіться розділ
[Приведення
типу](language.types.type-juggling.md#language.types.typecasting).
Щоб змінити тип змінної, дивіться опис функції
[settype()](function.settype.md).

### Числовий контекст

Контекст під час використання [арифметичного
оператора] (language.operators.arithmetic.md).

У даному контексті, якщо один з операндів є числом з плаваючою
точкою (float) (або не інтерпретується як ціле число (int)), обидва
операнда інтерпретуються як число з плаваючою точкою (float) та
результатом буде число з плаваючою точкою (float). В іншому випадку
операнди будуть інтерпретовані як ціле число (int) та результатом
також буде ціле число (int). Починаючи з PHP 8.0.0, якщо один з
операндів не може бути інтерпретований, викидається помилка
[TypeError](class.typeerror.md).

### Рядковий контекст

Контекст під час використання функцій [echo](function.echo.md),
[print](function.print.md), [інтерполяції
строк](language.types.string.md#language.types.string.parsing) або
строкового [оператора конкатенації](language.operators.string.md).

У даному контексті значення інтерпретуватиметься як рядок
(string).

### Логічний контекст

Контекст при використанні умовних операторів, [тернарного
оператора](language.operators.comparison.md#language.operators.comparison.ternary)
або [логічний оператор](language.operators.logical.md).

У цьому контексті значення інтерпретуватиметься як логічне
значення (bool).

### Контекст цілих чисел та рядків

Контекст при використанні [побітових
операторів](language.operators.bitwise.md).

У даному контексті, якщо у всіх операндів тип рядка (string), результат
також буде рядком (string). Інакше операнди будуть
інтерпретовані як ціле число (int) і результат також буде цілим
числом (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути
інтерпретований, то буде викинута помилка
[TypeError](class.typeerror.md).

### Порівняльний контекст

Контекст під час використання [оператора
порівняння] (language.operators.comparison.md).

Перетворення типів, що відбуваються в цьому контексті, пояснюються в
[таблиці порівняння різних
типів](language.operators.comparison.md#language.operators.comparison.types)
розділу Оператори порівняння.

### Контекст функцій

Контекст, коли значення передається типізованим параметром, властивістю
або повертається з функції, в якій оголошено тип повертається
значення.

У цьому контексті, коли активний режим суворої типізації (за замовчуванням),
тільки скалярні значення можуть бути перетворені на інше скалярне
значення. Для оголошень простих типів поведінка така:

- Оголошення типу bool: значення інтерпретується як логічне
значення (bool). Оголошення типу int: значення інтерпретується як
ціле число (int), якщо перетворення добре визначене. Наприклад,
рядок є [числовий
рядком](language.types.numeric-strings.md). Оголошення типу
float: значення інтерпретується як число з плаваючою точкою
(float) якщо перетворення добре визначене. Наприклад, рядок
є [числовим рядком](language.types.numeric-strings.md).
Оголошення типу string: значення інтерпретується як рядок
(string).

Якщо оголошення типу є об'єднаним, дивіться розділ [Приведення
для об'єднаних
типів](language.types.declarations.md#language.types.declarations.union.coercive).

**Увага**

[Внутрішні функції](functions.internal.md) автоматично підставляють
**`null`** до скалярних типів, це поведінка *ЗАСТАРІЛО* у PHP 8.1.0.

### Приведення типів

Приведення типу перетворює значення до вибраного типу, записуючи тип у
круглих дужках перед значенням, що перетворюється.

`<?php$foo u003d 10; // $foo - це ціле число$bar u003d (bool) $foo; // $bar - це логічне значення?> `

Допускаються такі типи:

- `(int)` - приведення типу до цілого числа (int)
- `(bool)` - приведення типу до логічного значення (bool)
- `(float)` - приведення типу до плаваючої точки (float)
- `(string)` - приведення типу до рядка (string)
- `(array)` - приведення типу до масиву (array)
- `(object)` - приведення типу до об'єкта (object)
- `(unset)` - приведення типу до NULL

> **Примітка**:
>
> `(integer)` є псевдонімом приведення типу `(int)`. `(boolean)`
> є псевдонімом приведення типу `(bool)`. `(binary)` є
> псевдонімом приведення типу `(string)`. `(double)` і `(real)` є
> псевдонімами приведення типу `(float)`. Ці приведення не використовують
> канонічне ім'я типу і не рекомендується.

**Увага**

Псевдонім приведення типу `(real)` застарів, починаючи з PHP 8.0.0.

**Увага**

Приведення типу `(unset)` застаріло, починаючи з версії PHP 7.2.0. Зверніть
увагу, що приведення `(unset)` рівносильне присвоєнню змінної або
виклику NULL. Приведення `(unset)` видалено у PHP 8.0.0.

**Застереження**

Приведення типу `(binary)` та префікс `b` існують для прямої
підтримки. В даний час `(binary)` та `(string)` ідентичні, проте
це може змінитися і не слід покладатися.

> **Примітка**:
>
> Пробіли ігноруються у круглих дужках під час наведення типу. Таким
> Таким чином, наступні два типи еквівалентні:
>
> ` <?php$foo u003d (int) $bar;$foo u003d ( int ) $bar;?> `

Приведення рядків (string) та змінних до бінарних рядків (string):

` <?php$binary u003d (binary) $string;$binary u003d b"binary string";?> `

> **Примітка**: Замість приведення змінної до типу рядок (string)
> можна також укласти змінну подвійні лапки.
>
> `<?php$foo u003d 10; // $foo є цілом числом$str u003d "$foo"; // $str є рядком$fst u003d (string) $foo; // $fst також є рядком// Виводить, "вони однакові"if ($fst u003du003du003d $str) {    echo "вони однакові";}?> `

Може бути неочевидно, що саме відбудеться при перетворенні між
певними типами. Для отримання додаткової інформації дивіться
ці розділи:

- [Перетворення типу до логічного значення
(boolean)](language.types.boolean.md#language.types.boolean.casting)
- [Перетворення типу до цілого числа
(integer)](language.types.integer.md#language.types.integer.casting)
- [Перетворення типу до плаваючої точки
(float)](language.types.float.md#language.types.float.casting)
- [Перетворення типу до рядка
(string)](language.types.string.md#language.types.string.casting)
- [Перетворення типу до масиву
(array)](language.types.array.md#language.types.array.casting)
- [Перетворення типу до об'єкта
(object)](language.types.object.md#language.types.object.casting)
- [Перетворення типу ресурсу
(resource)](language.types.resource.md#language.types.resource.casting)
- [Перетворення типу до
NULL](language.types.null.md#language.types.null.casting)
- [Таблиці порівняння типів](types.comparisons.md)

> **Примітка**: Оскільки PHP підтримує індексацію у рядках
> (string) за допомогою зсуву, використовуючи той же синтаксис, що і
> індексація масивах (array), наступний приклад справедливий всім
> версій PHP:
>
> ` <?php$a    u003d 'car'; // $a є рядком$a[0] u003d 'b'; // $a  як і раніше є рядкомecho $a; // Bar?> `
>
> Додаткову інформацію див. у розділі [Доступ до символу в
> рядку та його
> редагування](language.types.string.md#language.types.string.substr).
