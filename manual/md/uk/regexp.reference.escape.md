- [«Метасимволи](regexp.reference.meta.md)
- [Властивості Unicode-символів »](regexp.reference.unicode.md)

- [PHP Manual](index.md)
- [Опис синтаксису Perl-сумісних регулярних
виразів](reference.pcre.pattern.syntax.md)
- Екрануючі послідовності

## Екрануючі послідовності

Зворотна коса характеристика ('\') має кілька застосувань. Насамперед,
якщо вона передує не буквенно-цифровому символу, вона знімає з нього
спеціальне значення, що він міг мати. Застосування зворотної косою
риси як екрануючого символу допустимо як у символьному класі, так і
поза ним.

Наприклад, якщо ви хочете задати відповідність символу "\*", у шаблоні
необхідно вказати "\\*". Це запобіжить трактуванню наступного
символу як метасимволу з особливим значенням. Завжди безпечно
екранувати не буквено-цифрові символи за допомогою \, якщо ви хочете
переконатися, що вони означають у шаблоні себе. В окремому випадку для
зіставлення з самим символом зворотної косою межі, використовуйте запис
"\".

> **Примітка**:
>
> [PHP-рядки](language.types.string.md#language.types.string.syntax),
> ув'язнені в одинарні і подвійні лапки, по-особливому інтерпретують
> зворотну косу межу. Таким чином, якщо необхідно зіставити \ с
> регулярним виразом \\, у PHP-коді потрібно використовувати "\\\"
> або '\\\'.

У випадку, якщо вказано модифікатор
[PCRE_EXTENDED](reference.pcre.pattern.modifiers.md), пробільні
символи шаблону (поза описом символьного класу) ігноруються. Також
ігнорується частина рядка, що знаходиться між символом "#" (знову ж таки, не
що бере участь в описі символьного класу) та наступним символом перекладу
рядки. У такому випадку зворотний сліш можна застосовувати як екрануючий
символ для вказівки входжень пробельних символів або символу "#"
шаблон.

Друге застосування зворотного сліша полягає в тому, що він дозволяє
використовувати недруковані символи у видимій формі в описі шаблону. При
тому, що в PCRE немає обмежень на використання недрукованих символів
(виключаючи бінарний нуль, який інтерпретується як кінець шаблону),
при редагуванні програмного коду в будь-якому текстовому редакторі
набагато зручніше використовувати такі комбінації, ніж реальні символи,
які вони представляють:

* *
символ оповіщення, сигнал (BEL, шістнадцятковий код 07)


"Ctrl+x", де x – довільний символ

* *
escape (шістнадцятковий код 1B)

* *
розрив сторінки (шістнадцятковий код 0C)

*
*
переклад рядка (шістнадцятковий код 0A)

*\p{xx}*
символ з властивістю xx, докладніше дивіться
unicode](regexp.reference.unicode.md)

*\P{xx}*
символ без властивості xx, докладніше дивіться
unicode](regexp.reference.unicode.md)

**
повернення каретки (шістнадцятковий код 0D)

*\R*
розрив рядка: збігається з
, і

* *
табуляція (шістнадцятковий код 09)

*\xhh*
символ з шістнадцятковим кодом hh

*\ddd*
символ із вісімковим кодом ddd, або посилання на підмаску

Якщо бути точнішим, комбінація "
чином: якщо "x" - символ нижнього регістру, він перетворюється на
верхній регістр. Після цього шостий біт символу (шістнадцятковий код
40) інвертується. Таким чином "
шістнадцяткове значення 1A, у той час як "
шістнадцяткове значення 3B, а "

Після "\x" зчитуються ще дві шістнадцяткові цифри (вони можуть бути
записані у нижньому або верхньому регістрі). У режимі UTF-8 дозволяється
використання "`\x{...}`", де вміст дужок є рядком з
шістнадцяткових цифр. Вона інтерпретується як символ UTF-8 character
з кодом, що збігається з цим шістнадцятковим числом. Вихідна
шістнадцяткова екрануюча послідовність, `\xhh`, збігається з
двобайтним UTF-8 символом, якщо його значення перевищує 127.

Після "``" зчитуються дві вісімкові цифри. Якщо в записі менше
двох цифр, будуть використані всі фактично присутні цифри. Таким
Таким чином, послідовність "`x" буде інтерпретована як два
бінарних нуля, за якими слідує символ оповіщення (дзвінок). В разі,
якщо ви використовуєте представлення числа у вісімковому коді, переконайтеся,
що за початковим нулем йдуть дві значущі цифри.

Обробка зворотного сліша, за яким слідує ненульова цифра, дещо
складніше. Поза символьним класом PCRE сприймає зворотний сліш і
наступні його цифри як десяткове число. Якщо отримане значення
менше десяти, або якщо шаблон містить щонайменше таке ж
кількість попередніх поточної позиції підмасок, вся конструкція
інтерпретується як *посилання на підмаску*. Більш детальний опис
буде наведено нижче під час обговорення механізму роботи підмасок.

Всередині символьного класу, або якщо отримане значення більше 9
відповідна кількість попередніх підмасок відсутня, PCRE
зчитує до трьох вісімкових цифр, що йдуть за зворотним слішем, і
генерує один байт з останніх 8-ми значущих бітів отриманого
значення. Всі наступні цифри позначають себе. Наприклад:

* *
ще один спосіб запису пробілу

* *
те саме у разі, якщо даного запису передує менше сорока
підмасок

* *
завжди інтерпретується як посилання на підмаску

* *
може бути як зворотним посиланням, так і альтернативним записом символу
табуляції

* *
завжди інтерпретується як символ табуляції

*K*
символ табуляції, за яким слідує цифра "3"

*K*
інтерпретується як символ з вісімковим кодом 113 (оскільки посилань на
підмаски не може бути більш ніж 99)

*�*
байт, що повністю складається з одиничних бітів

*\81*
або зворотне посилання, або бінарний нуль, за яким слідують цифри "8" та
"1"

Слід пам'ятати, що вісімкові значення, що перевищують 100, слід
писати без лідируючого нуля, тому що читається не більше трьох вісімкових
цифр.

Усі послідовності, що визначають однобайтне значення, можуть
зустрічатися як усередині, і поза символьних класів. Крім того, всередині
символьного класу запис "``" інтерпретується як символ повернення
('backspace', шістнадцятковий код 08). Поза символьним класом вона
має інше значення (яке саме описано нижче).

Третє використання зворотного сліша – вказівка загального типу символів:

*\d*
будь-яка десяткова цифра

*\D*
будь-який символ, крім десяткової цифри

*\h*
будь-який горизонтальний символ пробілу

*\H*
будь-який символ, що не є горизонтальним пробіловим символом

*\s*
будь-який пробіловий символ

*\S*
будь-який непробільний символ

* *
будь-який вертикальний символ пробілу

*\V*
будь-який символ, що не є вертикальним пробіловим символом

*\w*
Будь-який символ, що утворює "слово"

*\W*
Будь-який символ, що не утворює "слово"

Кожна пара таких спеціальних послідовностей ділить безліч
всіх символів на дві множини, що не перетинаються. Будь-який символ
відповідає одному і лише одному безлічі з пари.

Наступні символи вважаються "пробільні": HT (9), LF (10), FF (12),
CR (13), і пробіл (32). Тим не менш, якщо йде локале-залежний пошук,
і відбудеться збіг із символами в діапазоні 128-255, вони також будуть
сприйняті як пробільні, наприклад, NBSP (A0).

Символ, що утворює "слово" - це довільна цифра, буква або символ
підкреслення, простіше кажучи, будь-який символ, який може бути частиною
"*слова*" у Perl. Визначення літер та цифр управляється символьними
таблицями, з якими було зібрано PCRE. І, як наслідок, ці набори
можуть відрізнятися у різних локалізованих дистрибутивах. Наприклад, в
локалі "fr" (Франція) деякі символи з кодом вище 128 використовуються
для запису ударних символів і відповідно відповідають масці `\w`.

Описані вище типи символів можуть застосовуватися як усередині, так і поза
символьних класів і відповідають одному символу даного типу. Якщо
поточна точка порівняння знаходиться в кінці рядка, жоден з них не
зможе збігтися, тому що немає символу, з яким могло б статися
збіг.

Четверте використання зворотного сліша - визначення деяких
формальних тверджень, що описують умови щодо розташування
особливих позицій у рядку і абсолютно не зачіпають самі символи.
Використання підмасок як складніших формальних тверджень описано
нижче. Такими керуючими послідовностями є:

* *
межа слова

*\B*
не є межею слова

*\A*
початок даних (незалежно від багаторядкового режиму)

*\Z*
кінець даних або позиція перед останнім перекладом рядка (незалежно
від багаторядкового режиму)

*\z*
кінець даних (незалежно від багаторядкового режиму)

*\G*
перша позиція, що збігається в рядку

Описані вище послідовності не можуть зустрічатися у символьних
класах (за винятком комбінації "``", яка всередині класу означає
символ повернення 'backspace').

Кордоном слова вважається така позиція у рядку, в якому з поточного та
попереднього символу лише один відповідає `\w` або `\W` (тобто один
їх відповідає `\w`, а інший `\W`). Початок або кінець рядка також
відповідають межі слова у випадку, якщо перший або відповідно
останній символ збігається з `\w`.

Спеціальні послідовності `\A`, `\Z` та `\z` відрізняються від
загальновживаних метасимволів початку рядка '^' і кінця рядка '$'
(описаних у розділі [якоря](regexp.reference.anchors.md)) тим, що
вони завжди збігаються або на самому початку або наприкінці рядка. На
них ніяк не впливають опції
[PCRE_MULTILINE](reference.pcre.pattern.modifiers.md) та
[PCRE_DOLLAR_ENDONLY](reference.pcre.pattern.modifiers.md). Різниця
між `\Z` та `\z` у тому, що `\Z` відповідає позиції перед останнім
символом у разі, якщо останній символ - переклад рядка, крім самого
кінця рядка. У той час, як `\z` відповідає виключно кінцю
даних.

Твердження `\G` є істинним лише в тому випадку, якщо поточна
позиція, що перевіряється, знаходиться на початку збігу, вказаного параметром
`offset` функції [preg_match()](function.preg-match.md). Вона
відрізняється від `\A` при ненульовому значенні параметра `offset`.

`\Q` та `\E` можуть бути використані для ігнорування метасимволів
регулярні вирази в шаблоні. Наприклад: `\w+\Q.$.\E$` збігається з одним
або більше символів, що становлять "слово", за якими слідують символи
`.$.` і якір наприкінці рядка. Зверніть увагу, що це не змінює
поведінки роздільників; наприклад, шаблон `#\Q#\E#$` некоректний, тому
що другий `#` відзначає кінець шаблону, а `\E#` інтерпретується як
неприпустимі модифікатори.

Послідовність `\K` може бути використана для скидання початку
збіги. Наприклад, шаблон `foo\Kbar` співпаде з "foobar", але повідомить
про те, що збігся лише з "bar". Використання `\K` не заважає установці
підмасок. Наприклад, якщо шаблон `(foo)\Kbar` співпаде з рядком
"foobar", першою підмаскою все одно буде "foo".
