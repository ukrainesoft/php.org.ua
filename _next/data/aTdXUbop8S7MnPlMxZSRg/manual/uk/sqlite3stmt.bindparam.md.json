{"pageProps":{"page":{"slug":"sqlite3stmt.bindparam.md","content":"# SQLite3Stmt::bindParam\n\n(PHP 5 >= 5.3.0, PHP 7, PHP 8)\n\nSQLite3Stmt::bindParam — Зв'язує параметр зі змінною підготовленого запиту\n\n### Опис\n\n```methodsynopsis\npublic SQLite3Stmt::bindParam(string|int $param, mixed &$var, int $type = SQLITE3_TEXT): bool\n```\n\nЗв'язує параметр із змінною підготовленого запиту.\n\n**Застереження**\n\nДо PHP 7.2.14 та 7.3.0, [SQLite3Stmt::reset()](sqlite3stmt.reset.md) повинен викликатись до першого виклику [SQLite3Stmt::execute()](sqlite3stmt.execute.md)якщо потрібно, щоб пов'язане значення коректно оновлювалося при наступних викликах [SQLite3Stmt::execute()](sqlite3stmt.execute.md). Якщо метод [SQLite3Stmt::reset()](sqlite3stmt.reset.md) не викликався, то пов'язане значення не змінюватиметься, навіть якщо значення, надане змінною, переданою **SQLite3Stmt::bindParam()**, змінилося або знову було викликано метод **SQLite3Stmt::bindParam()**\n\n### Список параметрів\n\n`param`\n\nАбо рядок (string) (для іменованих параметрів), або ціле число (int) (для позитивних параметрів), що ідентифікує змінну підготовленого запиту, якого має бути прив'язане значення. Якщо іменований параметр не починається з двокрапки (( `:` )) або знаку `@`, автоматично додається двокрапка ( `:` ). Позитивні параметри починаються з першого.\n\n`var`\n\nПараметр для прив'язки до змінного підготовленого запиту.\n\n`type`\n\nТип даних параметра для прив'язування.\n\n-   **`SQLITE3_INTEGER`**: Значення є цілим числом зі знаком, яке зберігається в 1, 2, 3, 4, 6 або 8 байт, залежно від величини значення.\n    \n-   **`SQLITE3_FLOAT`**: Значення є числом з плаваючою точкою, яке зберігається у вигляді 8-байтного числа IEEE з плаваючою точкою.\n    \n-   **`SQLITE3_TEXT`**: Значення є текстовим рядком, який зберігається в кодуванні бази даних (UTF-8, UTF-16BE або UTF-16-LE).\n    \n-   **`SQLITE3_BLOB`**: Значення є великим двійковим об'єктом (blob) даних, який зберігається так само, як і вхідні дані.\n    \n-   **`SQLITE3_NULL`**: Значення є значенням NULL.\n    \n\nУ PHP 7.0.7, якщо `type` опущений, то він автоматично визначається з типу `var`: bool та int розглядаються як **`SQLITE3_INTEGER`**, float як **`SQLITE3_FLOAT`**, null як **`SQLITE3_NULL`** і всі інші як **`SQLITE3_TEXT`**Раньше, если тип опущен, то по умолчанию использовался**`SQLITE3_TEXT`**\n\n> **Зауваження** :\n> \n> Якщо `var`равен\\*\\*`null`\\*\\*, він завжди обробляється як **`SQLITE3_NULL`**, независимо от заданного`type`\n\n### Значення, що повертаються\n\nПовертає \\*\\*`true`\\*\\*якщо параметр прив'язаний до змінної підготовленого запиту, \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.4.0 | Параметр`param` тепер підтримує нотацію `@param` |\n\n### Приклади\n\n**Приклад #1 Приклад використання** SQLite3Stmt::bindParam()\\*\\*\\*\\*\n\nУ прикладі показано, як один підготовлений запит із прив'язкою одного параметра може використовуватися для вставки кількох рядків із різними значеннями.\n\n```php\n<?php\n$db = new SQLite3(':memory:');\n$db->exec(\"CREATE TABLE foo (bar TEXT)\");\n\n$stmt = $db->prepare(\"INSERT INTO foo VALUES (:bar)\");\n$stmt->bindParam(':bar', $bar, SQLITE3_TEXT);\n\n$bar = 'baz';\n$stmt->execute();\n\n$bar = 42;\n$stmt->execute();\n\n$res = $db->query(\"SELECT * FROM foo\");\nwhile (($row = $res->fetchArray(SQLITE3_ASSOC))) {\n    var_dump($row);\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(1) {\n  [\"bar\"]=>\n  string(3) \"baz\"\n}\narray(1) {\n  [\"bar\"]=>\n  string(2) \"42\"\n}\n```\n\n### Дивіться також\n\n-   [SQLite3Stmt::bindValue()](sqlite3stmt.bindvalue.md) \\- Зв'язує значення параметра зі змінною підготовленого запиту\n-   [SQLite3::prepare()](sqlite3.prepare.md) \\- готує SQL-запит для виконання\n","title":"SQLite3Stmt::bindParam","contentType":2,"navigation":[{"class.sqlite3stmt.md":"« SQLite3Stmt"},{"sqlite3stmt.bindvalue.md":"SQLite3Stmt::bindValue »"},{"index.md":"PHP Manual"},{"class.sqlite3stmt.md":"SQLite3Stmt"}]}},"__N_SSG":true}