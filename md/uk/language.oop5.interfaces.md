- [«Абстрактні класи](language.oop5.abstract.md)
- [Трейти »](language.oop5.traits.md)

- [PHP Manual](index.md)
- [Класи та об'єкти](language.oop5.md)
- Інтерфейси об'єктів

## Інтерфейси об'єктів

Інтерфейси об'єктів дозволяють створювати код, який вказує, які
методи повинен реалізувати клас, без необхідності визначати, як
саме вони мають бути реалізовані. Інтерфейси поділяють простір
імен із класами та трейтами, тому вони не можуть називатися однаково.

Інтерфейси оголошуються так само, як і звичайні класи, але з використанням
ключового слова `interface` замість `class`. Тіла методів інтерфейсів
мають бути порожніми.

Усі методи, визначені в інтерфейсах, мають бути загальнодоступними, що
випливає із самої природи інтерфейсу.

На практиці інтерфейси використовуються у двох взаємодоповнюючих випадках:

- Щоб дозволити розробникам створювати об'єкти різних класів,
які можуть використовуватися взаємозамінно, оскільки вони
реалізують той самий інтерфейс або інтерфейси. Типовий приклад -
кілька служб доступу до бази даних, кілька платіжних шлюзів
або різних стратегій кешування. Різні реалізації можуть бути
замінені без будь-яких змін у коді, який їх використовує.
- Щоб дозволити функції або методу приймати та оперувати
параметром, який відповідає інтерфейсу, не переймаючись тим, що
ще може робити об'єкт чи як його реалізований. Ці інтерфейси часто
називають `Iterable`, `Cacheable`, `Renderable` і так далі, щоб
описати їхню поведінку.

Інтерфейси можуть визначати [магічні
методи](language.oop5.magic.md), вимагаючи від реалізуючих класів
реалізації цих методів.

> **Примітка**:
>
> Хоча вони підтримуються, використання
> [конструкторів](language.oop5.decon.md#language.oop5.decon.constructor)
> в інтерфейсах не рекомендується. Це значно знижує
> гнучкість об'єкта, реалізує інтерфейс. Крім того, до конструкторів
> не застосовуються правила успадкування, що може призвести до
> суперечливому і несподіваному поведінці.

### `implements`

Для реалізації інтерфейсу використовується оператор implements. Клас
повинен реалізувати всі методи, описані в інтерфейсі, інакше станеться
фатальна помилка. За бажання класи можуть реалізовувати більше одного
інтерфейсу, розділяючи кожен інтерфейс ком.

**Увага**

Клас може реалізувати два інтерфейси, які визначають метод з тим
а ім'ям, тільки якщо оголошення методу в обох інтерфейсах ідентичне.

**Увага**

Клас, що реалізує інтерфейс, може використовуватись для своїх параметрів
ім'я, відмінне від імені інтерфейсу. Однак, починаючи з PHP 8.0, у мові
підтримуються [іменовані
аргументи](functions.arguments.md#functions.named-arguments), та
викликаючий код може покладатися з ім'ям параметра в інтерфейсі. По цій
Тому рекомендується, щоб розробники використовували ті
ж імена параметрів, як і реалізований інтерфейс.

> **Примітка**:
>
> Інтерфейси можуть бути успадковані один від одного, так само, як і
> класи за допомогою оператора [extends](language.oop5.inheritance.md).

> **Примітка**:
>
> Клас, що реалізує інтерфейс, повинен оголосити всі методи в інтерфейсі
> з [сумісною сигнатурою](language.oop5.basic.md#language.oop.lsp).

### Константи (`Constants`)

Інтерфейси можуть містити константи. Константи інтерфейсів працюють
так само, як і [константи класів](language.oop5.constants.md).
До PHP 8.1.0 вони не могли бути перевизначені класом або інтерфейсом,
який їх успадковує.

### Приклади

**Приклад #1 Приклад інтерфейсу**

`<?php// Оголосимо інтерфейс 'Template'interface Template{    public function setVariable($name, $var); public function getHtml($template);}// Реалізація інтерфейсу// Це працюватиclass WorkingTemplate implements Template{   private $vars u003d []; public function setVariable($name,$var)    {        $this->vars[$name] u003d $var; }    public function getHtml($template)    {        foreach($this->vars as $name u003d> $value) {            $template u003d str_replace('{' . $name . '}', $value, $template); }    return $template; }}// Это не будет работать// Fatal error: Class BadTemplate contains 1 abstract methods// and must therefore be declared abstract (Template::getHtml)// (Фатальная ошибка: Класс BadTemplate содержит 1 абстрактный метод// и поэтому должен бути оголошений абстрактним (Template::getHtml))class BadTemplate implements Template{   private $vars u003d []; public function setVariable($name,$var)    {        $this->vars[$name] u003d $var; }}?> `

**Приклад #2 Спадкування інтерфейсів**

` <?phpinterface A{    public function foo();}interface B extends A{    public function baz(Baz $baz);}// Это сработаетclass C implements B{    public function foo()    {    }    public function baz(Baz $baz )    {    }}// Это не сработает и выдаст фатальную ошибкуclass D implements B{    public function foo()    {    }    public function baz(Foo $foo)    {    }}?> `

**Приклад #3 Множинне успадкування інтерфейсів**

` <?phpinterface A{    public function foo();}interface B{    public function bar();}interface C extends A, B{    public function baz();}class D implements C{    public function foo()    {    }    public function bar()    {    }}    public function baz()   {   }}?> `

**Приклад #4 Інтерфейси з константами**

`<?phpinterface A{   const B u003d 'Константа інтерфейсу';}// Виведе: Константа інтерфейсуecho A::B;class B implements A{   стання| 8.1.0 цей код не працює,// потому що не можна не можна перевизначати константи.echo B::B;?> `

**Приклад #5 Інтерфейси з абстрактними класами**

`<?phpinterface A{    public function foo(string $s): string; public function bar(int $i): int;}// Абстрактний клас може реалізовувати тільки частина інтерфейсу. string   { {        return$s. PHP_EOL; }}class C extends B{    public function bar(int $i): int    {        return $i * 2; }}?> `

**Приклад #6 Одночасне розширення та впровадження**

` <?phpclass One{    /* ... */}interface Usable{    /* ... */}interface Updatable{    /* ... */}// Порядок ключових зь "extends" повинно бути першим.class Two extends One implements Usable, Updatable{    /* ... */}?> `

Інтерфейс, разом з оголошеннями типів, надає чудовий спосіб
перевірки того, що певний об'єкт містить певний набір
методів. Також дивіться оператор
[instanceof](language.operators.type.md) та [оголошення
типів] (language.types.declarations.md).
