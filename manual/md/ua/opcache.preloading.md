- [« Типи ресурсів](opcache.resources.md)
- [Функції OPcache »](ref.opcache.md)

- [PHP Manual](index.md)
- [OPcache](book.opcache.md)
- Preloading

# Preloading

Починаючи з PHP 7.4.0, можна налаштувати завантаження скриптів в opcache в
момент старту PHP. Будь-які функції, класи, інтерфейси або трейти (але не
константи) у цих файлах будуть глобально доступні для всіх запитів без
необхідності їхнього явного завантаження. Таке попереднє завантаження дозволяє досягти
великих зручностей і продуктивності (бо код завжди доступний)
рахунок використання більшої кількості пам'яті. Також, при внесенні
змін до завантажених скриптів, щоб ці зміни стали доступними,
доведеться перезавантажити PHP. З цього випливає, що передзавантаження має
сенс використовувати тільки в промисловому оточенні, але не в
розробницькою.

Зверніть увагу, що баланс підвищення продуктивності та споживання
пам'яті сильно залежить від вашої програми. "Предзавантаження всього на
світлі" може бути найпростішою стратегією, але зовсім не обов'язково
найкращою. Також, передзавантаження працюватиме тільки у випадку, коли PHP
працює у режимі обслуговування запитів без перезавантаження. Таким чином,
хоч передзавантаження і можна використовувати в режимі CLI з увімкненим
opcache, проте, здебільшого безглуздо. Винятком є
використання передзавантаження з [бібліотеками
FFI] (ffi.examples-complete.md).

> **Примітка**:
>
> Завантаження не підтримується у Windows.

Налаштування передзавантаження складається з двох етапів і вимагає увімкненого
opcache. Для початку, налаштуйте
[opcache.preload](opcache.configuration.md#ini.opcache.preload) у
`php.ini`:

`` inicode
opcache.preloadu003dpreload.php
````

`preload.php` - це обов'язковий файл, який буде запущено один раз
при старті сервера (PHP-FPM, mod_php, etc.) і який завантажить код у
постійну пам'ять. Якщо PHP буде запущено під користувачем root (не
рекомендується), значення
[opcache.preload_user](opcache.configuration.md#ini.opcache.preload-user)
має містити назву системного користувача для запуску передзавантаження.
Запуск завантаження під користувачем root заборонено.

У скрипті `preload.php`, будь-який файл вказаний у
[include](function.include.md),
[include_once](function.include-once.md),
[require](function.require.md),
[require_once](function.require-once.md) або
[opcache_compile_file()](function.opcache-compile-file.md) буде
завантажений у постійну пам'ять. У наступному прикладі, будуть завантажені всі
файли `.php` у директорії `src`, якщо вони не містять `Test` в імені.

` <?php$directory u003d new RecursiveDirectoryIterator(__DIR__ . '/src');$fullTreeu003d new RecursiveIteratorIterator($directory);$phpFiles u003d new RegexIterator($f<' .php$)/i', RecursiveRegexIterator::GET_MATCH);foreach ($phpFiles as $key u003d> $file) {   require_once($file[0]);}?> `

І [include](function.include.md) та
[opcache_compile_file()](function.opcache-compile-file.md) будуть
працювати, але при цьому будуть трохи по-різному оброблені.

- [include](function.include.md) запустить код із файлу, а
[opcache_compile_file()](function.opcache-compile-file.md) немає.
Це вплине лише на умовні декларації (функції оголошені в
блоки if).
- Через те, що [include](function.include.md) запустить код,
вкладені [include](function.include.md) також будуть оброблені та
передзавантажені.
- [opcache_compile_file()](function.opcache-compile-file.md) може
завантажувати файли у будь-якому порядку. Тобто якщо файл `a.php`
визначає клас `A` та `b.php` визначає клас `B`, який
є спадкоємцем `A`, то
[opcache_compile_file()](function.opcache-compile-file.md) може
завантажити ці два файли у будь-якому порядку. При використанні
[include](function.include.md), з іншого боку, `a.php` * повинен
бути завантажений першим.
- У будь-якому випадку, якщо якийсь скрипт надалі запросить
включення вже завантаженого скрипта, то він буде виконаний, але
сутності перетворюватися нічого очікувати. Використання
[include_once](function.include-once.md) не запобігає повторному
увімкнення файлу. Можливо, потрібно завантажити файл знову, щоб
включити до нього певні глобальні константи, оскільки вони не
обробляються попереднім завантаженням.

Який підхід використовувати – залежить від бажаної поведінки. Для коду,
який використовує автозавантажувач, підхід з
[opcache_compile_file()](function.opcache-compile-file.md) дасть більше
гнучкості. З кодом, який завантажуватиметься вручну, варіант з
[include](function.include.md) може бути надійнішим.
