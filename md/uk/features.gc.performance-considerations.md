- [«Збір циклічних посилань](features.gc.collecting-cycles.md)
- [Динамічна трасування DTrace »](features.dtrace.md)

- [PHP Manual](index.md)
- [Складання сміття](features.gc.md)
- Питання продуктивності

## Питання продуктивності

У попередньому розділі нами вже говорилося, що простий збирання коріння менше
впливає на продуктивність. Хоча запис коріння в буфер в порівнянні з
повною відсутністю такої в PHP 5.2 працює повільніше, інші
зміни у роботі PHP 5.3 зробили цю втрату продуктивності
непомітною.

Є дві основні області, що впливають на продуктивність: зменшення
розміру пам'яті, що використовується, і уповільнення роботи при складання сміття.
Розглянемо їх.

### Зменшення розміру пам'яті, що використовується

Насамперед, основною причиною реалізації механізму складання сміття
є зменшення розміру пам'яті за допомогою чищення
циклічних посилань, що відбувається при досягненні відповідних
умов. У реалізації PHP це відбувається щойно заповниться кореневою
буфер або під час виклику функції
[gc_collect_cycles()](function.gc-collect-cycles.md). На графіку нижче
наведено використання пам'яті скрипта, запущеного в PHP 5.2 та PHP 5.3,
без урахування пам'яті, використовуваної самим PHP при запуску.

**Приклад #1 Приклад використання пам'яті**

` <?phpclass Foo{    public $var u003d '3.14159265359';}$baseMemory u003d memory_get_usage();for ( $i u003d 0; $i <u003d 10   $a->self u003d $a; if ( $i % 500 u003du003du003d 0 )   {        echo sprintf( '%8d: ', $i ), memory_get_usage() - $
";    }}?> `

![Порівняння використання пам'яті в PHP 5.2 та PHP
5.3](images/12f37b1c6963c1c5c18f30495416a197-gc-benchmark.png)

У цьому дуже академічному прикладі ми створюємо об'єкт, властивість a
якого задається посиланням сам об'єкт. Коли у скрипті у наступній
ітерації циклу перевизначається змінна `$a`, то відбувається типова
витік памяті. В даному випадку пропадають два контейнери zval (контейнер
об'єкта та контейнер властивості об'єкта), але визначається тільки один
корінь - віддалена змінна. Щойно пройдуть 10 000 ітерацій
(максимально у кореневому буфері буде 10 000 коренів), то запуститься
механізм складання сміття і пам'ять, що займається цим корінням, буде
звільнено. Цей процес добре видно на графіку використання пам'яті
для PHP 5.3: після кожних 10 000 ітерацій графік просідає. Сам по собі
механізм у цьому прикладі робить не так багато роботи, тому що
структура витоків дуже проста. З графіка видно, що максимальне
використання пам'яті у PHP 5.3 склало близько 9 Мб, тоді як у PHP 5.2
воно продовжує зростати.

### Уповільнення роботи

Другий областю, де складання сміття впливає на продуктивність,
є втрата часу, коли збирач сміття звільняє пам'ять. Щоб
зрозуміти ступінь цього впливу, ми трохи змінимо попередній скрипт,
додавши більше ітерацій і проміжних змінних. Змінений
скрипт:

**Приклад #2 Вплив на продуктивність**

` <?phpclass Foo{    public $var u003d '3.1415962654';}for ( $i u003d 0; $i <u003d 1000000; $i++ ){    |$a $a->self u003d $a;}echo memory_get_peak_usage(), "
";?> `

Ми запустимо скрипт двічі: із включеною опцією
[zend.enable_gc](info.configuration.md#ini.zend.enable-gc) та без неї.

**Приклад #3 Запуск скрипту**

`` shellcode
time php -dzend.enable_gcu003d0 -dmemory_limitu003d-1 -n example2.php
# і
time php -dzend.enable_gcu003d1 -dmemory_limitu003d-1 -n example2.php
````

На тестовій машині перша команда виконується приблизно 10.7 секунд, а
друга приблизно 11.4 секунди. Це приблизно на 7% повільніше. Проте,
максимальне використання пам'яті скриптом зменшилося на 98% із 931 Мб.
до 10 Мб. Цей тест не дуже науковий, але він справді демонструє
перевага з використання пам'яті, що забезпечується збирачем сміття.
Також добре те, що уповільнення для цього скрипта завжди приблизно 7%,
тоді як економія пам'яті збільшується все більше і більше при
знаходження нового сміття.

### Внутрішня статистика збирача сміття

Можна отримати трохи більше інформації про те, як механізм збирання
сміття виконується у PHP. Але для цього вам необхідно перезабрати PHP
для включення тесту продуктивності та коду для додаткового збору
даних. Необхідно встановити змінну оточення `CFLAGS` у значення
`-DGC_BENCHu003d1` до виконання команди `./configure` з вашими параметрами.
Наступні команди повинні спрацювати:

**Приклад #4 Складання PHP для включення тесту продуктивності GC**

`` shellcode
export CFLAGSu003d-DGC_BENCHu003d1
./config.nice
make clean
make
````

При запуску вищенаведеного прикладу з оновленим PHP можна побачити
наступну інформацію після завершення роботи скрипта:

**Приклад #5 Статистика GC**

`` shellcode
GC Statistics
-------------
Runs: 110
Завантажено: 2072204
Root buffer length: 0
Root buffer peak: 10000

Possible Remove from Marked
Root Buffered buffer grey
-------- -------- -------------- ------
ZVAL 7175487 1491291 1241690 3611871
ZOBJ 28506264 1527980 677581 1025731
````

Найкорисніша статистика відображена у першому блоці. Можна побачити,
що механізм складання сміття був запущений 110 разів, і сумарно було
звільнено понад 2 мільйони записів у пам'яті. Якщо складання сміття було
запущена хоча б раз, то максимальна кількість коренів у буфері завжди буде
одно 10 000.

### Висновок

В цілому, збирач сміття на PHP викличе відчутні уповільнення тільки в
час безпосередньої роботи механізму складання циклічних посилань, тоді
як у звичайних (невеликих) скриптах не повинно бути жодного падіння
продуктивність.

Однак у тих випадках, коли механізм збирання повинен спрацьовувати і
звичайних скриптах, зниження використовуваної пам'яті дозволяє одночасно
працювати на сервері більшій кількості.

Переваги найбільш очевидні для довгопрацюючих скриптів, таких як
великі набори тестів чи демони. Новий механізм також має зменшити
витоку пам'яті для додатків [» PHP-GTK](http://gtk.php.net/), які
зазвичай виконуються довше, ніж веб-скрипти.
