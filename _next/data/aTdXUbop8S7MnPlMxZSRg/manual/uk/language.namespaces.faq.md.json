{"pageProps":{"page":{"slug":"language.namespaces.faq.md","content":"## Часті питання (FAQ): що потрібно знати про простори імен\n\n(PHP 5 >= 5.3.0, PHP 7, PHP 8)\n\nЦей перелік питань поділено на дві частини: загальні питання та деякі особливості реалізації, які корисні для повного розуміння.\n\nСпершу, спільні питання.\n\n1.  [Якщо в коді не вказано простору імен, чи потрібно вважати щось із цього важливим?](language.namespaces.faq.md#language.namespaces.faq.shouldicare)\n2.  [Як звертатися до внутрішніх чи глобальних класів у просторі імен?](language.namespaces.faq.md#language.namespaces.faq.globalclass)\n3.  [Як звертатися до функцій класів у просторах імен, чи константам у їхньому просторі імен?](language.namespaces.faq.md#language.namespaces.faq.innamespace)\n4.  [Як дозволяються імена`\\my\\name`или`\\name`?](language.namespaces.faq.md#language.namespaces.faq.full)\n5.  [Як дозволяється ім'я`my\\name`?](language.namespaces.faq.md#language.namespaces.faq.qualified)\n6.  [Як дозволяється неповне ім'я класу`name`?](language.namespaces.faq.md#language.namespaces.faq.shortname1)\n7.  [Як дозволяється неповне ім'я функції або неповне ім'я константи на кшталт`name`?](language.namespaces.faq.md#language.namespaces.faq.shortname2)\n\nДеякі деталі реалізації просторів імен, які корисно розуміти.\n\n1.  [Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.](language.namespaces.faq.md#language.namespaces.faq.conflict)\n2.  [Вкладені простори імен неприпустимі.](language.namespaces.faq.md#language.namespaces.faq.nested)\n3.  [Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.](language.namespaces.faq.md#language.namespaces.faq.quote)\n4.  [Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка](language.namespaces.faq.md#language.namespaces.faq.constants)\n5.  [Неможливо перевизначити спеціальні константи **`null`** **`true`** або **`false`**](language.namespaces.faq.md#language.namespaces.faq.builtinconst)\n\n### Якщо в коді не вказано простору імен, чи потрібно вважати щось із цього важливим?\n\nНі, простори імен ніяк не впливають ні на існуючий код, ні ще не написаний код без просторів імен. Можна написати такий код, якщо потрібно:\n\n**Приклад #1 Доступ до глобальних класів поза межами імен**\n\n```php\n<?php\n\n$a = new \\stdClass;\n\n?>\n```\n\nЦе функціонально еквівалентно наступному:\n\n**Приклад #2 Доступ до глобальних класів поза простором імен**\n\n```php\n<?php\n\n$a = new stdClass;\n\n?>\n```\n\n### Як звертатися до внутрішніх чи глобальних класів у просторі імен?\n\n**Приклад #3 Доступ до внутрішніх класів у просторах імен**\n\n```php\n<?php\n\nnamespace foo;\n$a = new \\stdClass;\n\nfunction test(\\ArrayObject $parameter_type_example = null) {}\n\n$a = \\DirectoryIterator::CURRENT_AS_FILEINFO;\n\n// расширение внутреннего или глобального класса\nclass MyException extends \\Exception {}\n\n?>\n```\n\n### Як використовувати функції класів у просторах імен чи константи у власному просторі імен?\n\n**Приклад #4 Доступ до внутрішніх класів, функцій або константів у просторах імен**\n\n```php\n<?php\n\nnamespace foo;\n\nclass MyClass {}\n\n// использование класса из текущего пространства имен в качестве типа параметра\nfunction test(MyClass $parameter_type_example = null) {}\n// другой способ использовать класс из текущего пространства имен в качестве типа параметра\nfunction test(\\foo\\MyClass $parameter_type_example = null) {}\n\n// расширение класса из текущего пространства имён\nclass Extended extends MyClass {}\n\n// доступ к глобальной функции\n$a = \\globalfunc();\n\n// доступ к глобальной константе\n$b = \\INI_ALL;\n\n?>\n```\n\n### Как имена вроде`\\my\\name`или`\\name` перетворюються?\n\nІмена, які починаються з `\\`, Перетворюються до того, як вони виглядають, тобто . `\\my\\name` - це насправді `my\\name`, а`\\Exception` - це `Exception`\n\n**Приклад #5 Абсолютні імена**\n\n```php\n<?php\n\nnamespace foo;\n$a = new \\my\\name(); // создаёт экземпляр класса my\\name\necho \\strlen('hi'); // вызывает функцию strlen\n$a = \\INI_ALL; // переменной $a присваивается значение константы INI_ALL\n\n?>\n```\n\n### Як ім'я `my\\name`преобразуется?\n\nІмена, які містять зворотний сліш, але не починаються з нього, такі як `my\\name` можуть бути перетворені двома способами.\n\nЯкщо є імпортуючий вираз, який створює синонім `my` іншого імені, то цей синонім застосовується до `my`в`my\\name`\n\nВ іншому випадку, поточне ім'я простору імен стає префіксом до `my\\name`\n\n**Приклад #6 Повні імена**\n\n```php\n<?php\n\nnamespace foo;\nuse blah\\blah as foo;\n\n$a = new my\\name(); // создаёт экземпляр класса foo\\my\\name\nfoo\\bar::name(); // вызывает статический метод name в классе blah\\blah\\bar\nmy\\bar(); // вызывает функцию foo\\my\\bar\n$a = my\\BAR; // присваивает переменной $a значение константы foo\\my\\BAR\n\n?>\n```\n\n### Как неполное имя класса вроде`name` перетворюється?\n\nІмена класів, які не містять зворотного слішу, наприклад, `name` можуть бути перетворені двома способами.\n\nЯкщо є імпортуючий вираз, який створює синонім `name` іншого імені, то застосовується цей синонім.\n\nВ іншому випадку, поточне ім'я простору імен стає префіксом до `name`\n\n**Приклад #7 Неповні імена класів**\n\n```php\n<?php\n\nnamespace foo;\nuse blah\\blah as foo;\n\n$a = new name(); // создаёт экземпляр класса foo\\name\nfoo::name(); // вызывает статический метод name в классе blah\\blah\n\n?>\n```\n\n### Як неповне ім'я функції або неповне ім'я константи, наприклад, `name` перетворюється?\n\nІмена функцій або констант, які не містять зворотного слішу, наприклад, `name` можуть бути перетворені двома способами.\n\nСпочатку поточне ім'я простору імен стає префіксом до `name`\n\nПотім, якщо константа чи функція `name` не існує в поточному просторі імен, буде використано глобальну константу або функцію `name`якщо вона існує.\n\n**Приклад #8 Неповні імена функцій або констант**\n\n```php\n<?php\n\nnamespace foo;\nuse blah\\blah as foo;\n\nconst FOO = 1;\n\nfunction my() {}\nfunction foo() {}\nfunction sort(&$a)\n{\n    \\sort($a); // вызывает глобальную функцию sort\n    $a = array_flip($a);\n    return $a;\n}\n\nmy(); // вызывает foo\\my\n$a = strlen('hi'); // вызывает глобальную функцию strlen, потому что foo\\strlen не существует\n$arr = array(1,3,2);\n$b = sort($arr); // вызывает функцию foo\\sort\n$c = foo(); // вызывает функцию foo\\foo — импорт не применяется\n\n$a = FOO; // присваивает переменной $a значение константы «foo\\FOO» — импорт не применяется\n$b = INI_ALL; // присваивает переменной $b значение глобальной константы INI_ALL\n\n?>\n```\n\n### Імпортовані імена не повинні конфліктувати з класами, визначеними в файлі.\n\nНаступні комбінації скриптів допустимі:\n\nfile1.php\n\n```php\n<?php\n\nnamespace my\\stuff;\nclass MyClass {}\n\n?>\n```\n\nanother.php\n\n```php\n<?php\n\nnamespace another;\nclass thing {}\n\n?>\n```\n\nfile2.php\n\n```php\n<?php\n\nnamespace my\\stuff;\ninclude 'file1.php';\ninclude 'another.php';\n\nuse another\\thing as MyClass;\n$a = new MyClass; // создаёт экземпляр класса thing из пространства имён another\n\n?>\n```\n\nКонфлікт імен відсутній навіть незважаючи на те, що клас `MyClass` існує всередині простору імен `my\\stuff`, тому що визначення MyClass знаходиться в окремому файлі. Однак наступний приклад призводить до фатальної помилки з конфліктом імен, тому що клас MyClass визначений у тому файлі, де знаходиться оператор use.\n\n```php\n<?php\n\nnamespace my\\stuff;\nuse another\\thing as MyClass;\nclass MyClass {} // фатальная ошибка: MyClass конфликтует с выражением импорта\n$a = new MyClass;\n\n?>\n```\n\n### Вкладені простори імен неприпустимі.\n\nPHP не дозволяє вкладення просторів імен одне в інше\n\n```php\n<?php\n\nnamespace my\\stuff {\n    namespace nested {\n        class foo {}\n    }\n}\n\n?>\n```\n\nОднак, можна зімітувати вкладені простори імен так:\n\n```php\n<?php\n\nnamespace my\\stuff\\nested {\n    class foo {}\n}\n\n?>\n```\n\n### Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного слішу.\n\nВажливо розуміти це, тому що зворотний сліш усередині рядків працює як символ, що екранує. Він має бути продубльований, коли вказано всередині рядка, інакше з'являється ризик ненавмисних наслідків:\n\n**Приклад #9 Підводне каміння при вказівці імені простору імен усередині рядка з подвійними лапками**\n\n```php\n<?php\n\n$a = \"dangerous\\name\"; // \\n — это переход на новую строку внутри строки с двойными кавычками!\n$obj = new $a;\n\n$a = 'not\\at\\all\\dangerous'; // а тут нет проблем.\n$obj = new $a;\n\n?>\n```\n\nУсередині рядків, укладених в одинарні лапки, зворотний слєш як роздільник більш безпечний, але, як і раніше, рекомендована практика екранування зворотного слєша в усіх рядках є найкращим варіантом.\n\n### Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка\n\nБудь-яка невизначена константа — неповне ім'я на зразок `FOO` - буде приводити до висновку повідомлення про те, що PHP припустив, що `FOO` було значення константи. Будь-яка константа, з повним або абсолютним ім'ям, яка містить символ зворотного сліша, буде призводити до фатальної помилки, якщо не буде знайдена.\n\n**Приклад #10 Невизначені константи**\n\n```php\n<?php\n\nnamespace bar;\n$a = FOO; // выводит предупреждение: undefined constants \"FOO\" assumed \"FOO\";\n$a = \\FOO; // фатальная ошибка: undefined namespace constant FOO\n$a = Bar\\FOO; // фатальная ошибка: undefined namespace constant bar\\Bar\\FOO\n$a = \\Bar\\FOO; // фатальная ошибка: undefined namespace constant Bar\\FOO\n\n?>\n```\n\n### Неможливо перевизначити спеціальні константи **`null`** **`true`** або **`false`**\n\nБудь-яка спроба визначити константу простору імен, яка збігається з назвами спеціальних вбудованих констант, призведе до фатальної помилки.\n\n**Приклад #11 Невизначені константи**\n\n```php\n<?php\n\nnamespace bar;\nconst NULL = 0; // Фатальная ошибка;\nconst true = 'stupid'; // также фатальная ошибка;\n// и т. д.\n\n?>\n```\n","title":"Часті питання (FAQ): що потрібно знати про простори імен","contentType":2,"navigation":[{"language.namespaces.rules.md":"« Правила дозволу імен"},{"language.enumerations.md":"Перерахування »"},{"index.md":"PHP Manual"},{"language.namespaces.md":"Простори імен"}]}},"__N_SSG":true}