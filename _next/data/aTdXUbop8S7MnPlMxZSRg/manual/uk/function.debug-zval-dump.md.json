{"pageProps":{"page":{"slug":"function.debug-zval-dump.md","content":"# debug\\_zval\\_dump\n\n(PHP 4 >= 4.2.0, PHP 5, PHP 7, PHP 8)\n\ndebug\\_zval\\_dump — Виводить рядкову виставу внутрішньої структури zval\n\n### Опис\n\n```methodsynopsis\ndebug_zval_dump(mixed $value, mixed ...$values): void\n```\n\nВиводить на висновок рядкове уявлення внутрішньої структури zval (значення Zend). Це переважно корисно для розуміння або налагодження деталей реалізації Zend Engine або модулів PHP.\n\n### Список параметрів\n\n`value`\n\nОброблювана змінна.\n\n`values`\n\nНаступні змінні або значення обробки.\n\n### Значення, що повертаються\n\nФункція не повертає значення після виконання.\n\n### Приклади\n\n**Приклад #1 Приклад використання** debug\\_zval\\_dump()\\*\\*\\*\\*\n\n```php\n<?php\n$var1 = 'Hello';\n$var1 .= ' World';\n$var2 = $var1;\n\ndebug_zval_dump($var1);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(11) \"Hello World\" refcount(3)\n```\n\n> **Зауваження** **Понимание`refcount`**\n> \n> Значение`refcount`, що показується цією функцією, може бути несподіваним без детального розуміння реалізації двигуна.\n> \n> Zend Engine використовує підрахунок посилань для двох різних цілей:\n> \n> -   Оптимізація використання пам'яті за допомогою методу, званого \"копіювання при записі\", коли кілька змінних, що містять одне й те саме значення, вказують на ту саму копію в пам'яті. Коли кожна змінна змінюється, вона вказує на нову копію в пам'яті, а лічильник посилань на оригінал зменшується на 1.\n> -   Відстеження змінних, які були призначені або передані за посиланням (див.[Пояснення посилань](language.references.md)). Цей лічильник посилань зберігається в окремому посиланні zval, що вказує на zval для поточного значення. Цей додатковий zval в даний час не відображається у**debug\\_zval\\_dump()**\n> \n> Оскільки **debug\\_zval\\_dump()** приймає свої вхідні дані як звичайні параметри, що передаються за значенням, для їх передачі буде використовуватися метод копіювання під час запису: замість копіювання даних лічильник посилань буде збільшено на одиницю на час існування виклику функції. Якщо функція змінила параметр після його отримання, буде зроблено копію; оскільки це не так, покаже лічильник посилань на один вище, ніж у зухвалій області.\n> \n> Передача параметрів також запобігає відображенню змінних **debug\\_zval\\_dump()**, які були призначені на засланні. Для ілюстрації розглянемо трохи змінену версію наведеного вище прикладу:\n> \n> ```php\n> <?php\n> $ var1 = 'Hello';\n> $ var1 .= 'World';\n> // Вкажіть три змінні як посилання на те саме значення\n> $var2 =& $var1;\n> $var3 =& $var1;\n> \n> debug_zval_dump($var1);\n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> string(11) \"Hello World\" refcount(2)\n> ```\n> \n> Хоча $var1, $var2 і $var3 пов'язані як посилання, тільки *value* передається в **debug\\_zval\\_dump()**. Це значення використовується один раз набором посилань і один раз всередині функції **debug\\_zval\\_dump()**, Тому лічильник посилань дорівнює 2.\n> \n> Подальші складності виникають через оптимізацію, зроблену в двигуні для різних типів даних. Деякі типи, такі як цілі числа, не використовують копіювання при записі, тому не показують лічильник посилань взагалі. В інших випадках refcount показує додаткові копії, які використовуються всередині, наприклад, коли літерний рядок або масив зберігається як частина інструкції коду.\n\n### Дивіться також\n\n-   [var\\_dump()](function.var-dump.md) \\- Виводить інформацію про змінну\n-   [debug\\_backtrace()](function.debug-backtrace.md) \\- Генерує стек викликів функцій\n-   \"[Посилання. Роз'яснення](language.references.md)\"\n-   \"[» Посилання. Роз'яснення (від Derick Rethans)](http://derickrethans.nl/php_references_article.php)\"\n","title":"debug\\_zval\\_dump","contentType":2,"navigation":[{"function.boolval.md":"« boolval"},{"function.doubleval.md":"doubleval »"},{"index.md":"PHP Manual"},{"ref.var.md":"Функції для роботи зі змінними"}]}},"__N_SSG":true}