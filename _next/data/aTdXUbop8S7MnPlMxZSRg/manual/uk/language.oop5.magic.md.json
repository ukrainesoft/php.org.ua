{"pageProps":{"page":{"slug":"language.oop5.magic.md","content":"## Магические методы\n\nМагічні методи – це спеціальні методи, які перевизначають дію PHP за умовчанням, коли над об'єктом виконуються певні дії.\n\n**Застереження**\n\nВсе имена методов, начинающиеся с`__`зарезервовані PHP. Не рекомендується використовувати імена методів з \\_\\_ у PHP, якщо ви не бажаєте використовувати відповідну магічну функціональність.\n\nНаступні назви методів вважаються магічними: [\\_\\_construct()](language.oop5.decon.md#object.construct) [\\_\\_destruct()](language.oop5.decon.md#object.destruct) [\\_\\_call()](language.oop5.overloading.md#object.call) [\\_\\_callStatic()](language.oop5.overloading.md#object.callstatic) [\\_\\_get()](language.oop5.overloading.md#object.get) [\\_\\_set()](language.oop5.overloading.md#object.set) [\\_\\_isset()](language.oop5.overloading.md#object.isset) [\\_\\_unset()](language.oop5.overloading.md#object.unset) [\\_\\_sleep()](language.oop5.magic.md#object.sleep) [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) [\\_\\_serialize()](language.oop5.magic.md#object.serialize) [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize) [\\_\\_toString()](language.oop5.magic.md#object.tostring) [\\_\\_invoke()](language.oop5.magic.md#object.invoke) [\\_\\_set\\_state()](language.oop5.magic.md#object.set-state) [\\_\\_clone()](language.oop5.cloning.md#object.clone) і [\\_\\_debugInfo()](language.oop5.magic.md#object.debuginfo)\n\n**Увага**\n\nУсі магічні методи, за винятком [\\_\\_construct()](language.oop5.decon.md#object.construct) [\\_\\_destruct()](language.oop5.decon.md#object.destruct) і [\\_\\_clone()](language.oop5.cloning.md#object.clone) *ПОВИННІ* бути оголошені як `public`, інакше буде викликана помилка рівня **`E_WARNING`**. До PHP 8.0.0 для магічних методів [\\_\\_sleep()](language.oop5.magic.md#object.sleep) [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) [\\_\\_serialize()](language.oop5.magic.md#object.serialize) [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize) і [\\_\\_set\\_state()](language.oop5.magic.md#object.set-state) не виконувалась перевірка.\n\n**Увага**\n\nЯкщо оголошення типу використовуються для визначення магічного методу, вони повинні бути ідентичними сигнатурі, описаної в цьому документі. В іншому випадку видається фатальна помилка. До PHP 8.0.0 діагностичні повідомлення не надсилалися. Однак [\\_\\_construct()](language.oop5.decon.md#object.construct) і [\\_\\_destruct()](language.oop5.decon.md#object.destruct) не повинні оголошувати тип, що повертається; в іншому випадку видається фатальна помилка.\n\n### [\\_\\_sleep()](language.oop5.magic.md#object.sleep) і [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup)\n\n```methodsynopsis\npublic __sleep(): array\n```\n\n```methodsynopsis\npublic __wakeup(): void\n```\n\nФункция[serialize()](function.serialize.md) перевіряє, чи є у класі метод із магічним ім'ям [\\_\\_sleep()](language.oop5.magic.md#object.sleep). Якщо це так, цей метод виконується до будь-якої операції серіалізації. Він може очистити об'єкт і повинен повертати масив з іменами всіх змінних цього об'єкта, які мають бути серіалізовані. Якщо метод нічого не повертає, то серіалізується **`null`** та видається попередження **`E_NOTICE`**\n\n> **Зауваження** :\n> \n> Неприпустимо повертати в [\\_\\_sleep()](language.oop5.magic.md#object.sleep) імена закритих властивостей у батьківському класі. Це призведе до помилки рівня **`E_NOTICE`**. Натомість ви можете використовувати [\\_\\_serialize()](language.oop5.magic.md#object.serialize)\n\n> **Зауваження** :\n> \n> Починаючи з PHP 8.0.0, повернення значення, що не є масивом, з [\\_\\_sleep()](language.oop5.magic.md#object.sleep) призводить до попередження. Раніше видавалося повідомлення.\n\nПредполагаемое использование[\\_\\_sleep()](language.oop5.magic.md#object.sleep) полягає в завершенні роботи над даними, що чекають на обробку або інших подібних завдань очищення. Крім того, цей метод може бути корисним, коли є дуже великі об'єкти, які немає потреби повністю зберігати.\n\nЗ іншого боку, функція [unserialize()](function.unserialize.md) перевіряє наявність методу з магічним ім'ям [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup). Якщо є, ця функція може відновлювати будь-які ресурси, які може мати об'єкт.\n\nПредполагаемое использование[\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) полягає у відновленні будь-яких з'єднань з базою даних, які могли бути втрачені під час операції серіалізації та виконання інших операцій повторної ініціалізації.\n\n**Приклад #1 Серіалізація та десеріалізація**\n\n```php\n<?php\nclass Connection\n{\n    protected $link;\n    private $dsn, $username, $password;\n\n    public function __construct($dsn, $username, $password)\n    {\n        $this->dsn = $dsn;\n        $this->username = $username;\n        $this->password = $password;\n        $this->connect();\n    }\n\n    private function connect()\n    {\n        $this->link = new PDO($this->dsn, $this->username, $this->password);\n    }\n\n    public function __sleep()\n    {\n        return array('dsn', 'username', 'password');\n    }\n\n    public function __wakeup()\n    {\n        $this->connect();\n    }\n}?>\n```\n\n### [\\_\\_serialize()](language.oop5.magic.md#object.serialize) і [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize)\n\n```methodsynopsis\npublic __serialize(): array\n```\n\n```methodsynopsis\npublic __unserialize(array $data): void\n```\n\n[serialize()](function.serialize.md) перевіряє, чи є у класі функція з магічним ім'ям [\\_\\_serialize()](language.oop5.magic.md#object.serialize). Якщо так, то функція виконується перед будь-якою серіалізацією. Вона має створити та повернути асоціативний масив пар ключ/значення, які представляють серіалізовану форму об'єкта. Якщо масив не повернутий, буде видано [TypeError](class.typeerror.md)\n\n> **Зауваження** :\n> \n> Якщо і [\\_\\_serialize()](language.oop5.magic.md#object.serialize) і [\\_\\_sleep()](language.oop5.magic.md#object.sleep) визначено в одному і тому ж об'єкті, буде викликано лише метод [\\_\\_serialize()](language.oop5.magic.md#object.serialize). . [\\_\\_sleep()](language.oop5.magic.md#object.sleep) ігноруватиметься. Якщо об'єкт реалізує інтерфейс [Serializable](class.serializable.md), метод`serialize()` інтерфейсу ігноруватиметься, а замість нього буде використаний [\\_\\_serialize()](language.oop5.magic.md#object.serialize)\n\nПредполагаемое использование[\\_\\_serialize()](language.oop5.magic.md#object.serialize) полягає у визначенні зручного для серіалізації довільного уявлення об'єкта. Елементи масиву можуть відповідати властивостям об'єкта, але це необов'язково.\n\nИ наоборот,[unserialize()](function.unserialize.md) перевіряє наявність магічної функції [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize). Якщо функція присутня, їй буде передано відновлений масив, який було повернено з [\\_\\_serialize()](language.oop5.magic.md#object.serialize). Потім він може відновити властивості об'єкта цього масиву відповідним чином.\n\n> **Зауваження** :\n> \n> Якщо і [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize) і [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) визначено в одному і тому ж об'єкті, буде викликано лише метод [\\_\\_unserialize()](language.oop5.magic.md#object.unserialize). . [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) ігноруватиметься.\n\n> **Зауваження** :\n> \n> Функція доступна з PHP 7.4.0.\n\n**Приклад #2 Серіалізація та десеріалізація**\n\n```php\n<?php\nclass Connection\n{\n    protected $link;\n    private $dsn, $username, $password;\n\n    public function __construct($dsn, $username, $password)\n    {\n        $this->dsn = $dsn;\n        $this->username = $username;\n        $this->password = $password;\n        $this->connect();\n    }\n\n    private function connect()\n    {\n        $this->link = new PDO($this->dsn, $this->username, $this->password);\n    }\n\n    public function __serialize(): array\n    {\n        return [\n          'dsn' => $this->dsn,\n          'user' => $this->username,\n          'pass' => $this->password,\n        ];\n    }\n\n    public function __unserialize(array $data): void\n    {\n        $this->dsn = $data['dsn'];\n        $this->username = $data['user'];\n        $this->password = $data['pass'];\n\n        $this->connect();\n    }\n}?>\n```\n\n### [\\_\\_toString()](language.oop5.magic.md#object.tostring)\n\n```methodsynopsis\npublic __toString(): string\n```\n\nМетод[\\_\\_toString()](language.oop5.magic.md#object.tostring) дозволяє класу вирішувати, як він повинен реагувати при перетворенні на рядок. Наприклад, що вивести під час виконання `echo $obj;`\n\n**Увага**\n\nПочинаючи з PHP 8.0.0, значення, що повертається слід стандартній семантиці типу PHP, що означає, що воно буде перетворено в рядок (string), якщо можливо, і якщо [strict typing](language.types.declarations.md#language.types.declarations.strict) вимкнено.\n\nОб'єкт, що реалізує [Stringable](class.stringable.md) *не* буде прийматись оголошенням типу string, якщо включена [сувора типізація](language.types.declarations.md#language.types.declarations.strict). Якщо така поведінка необхідна, то оголошення типу має приймати інтерфейс. [Stringable](class.stringable.md) та рядок (string) за допомогою об'єднання типів.\n\nНачиная с PHP 8.0.0, любой класс, содержащий метод[\\_\\_toString()](language.oop5.magic.md#object.tostring), також неявно реалізовуватиме інтерфейс [Stringable](class.stringable.md) і, таким чином, проходитиме перевірку типу для цього інтерфейсу У будь-якому випадку рекомендується явно реалізувати інтерфейс.\n\nВ PHP 7.4 возвращаемое значение*ПОВИННО* бути рядком (string), інакше видається [Error](class.error.md)\n\nДо PHP 7.4.0 возвращаемое значение*повинно* бути рядком (string), інакше видається фатальна помилка \\*\\*`E_RECOVERABLE_ERROR`\\*\\*is emitted.\n\n**Увага**\n\nНе можна викинути виняток із методу [\\_\\_toString()](language.oop5.magic.md#object.tostring) до PHP 7.4.0. Це призведе до фатальної помилки.\n\n**Приклад #3 Простий приклад**\n\n```php\n<?php\n// Объявление простого класса\nclass TestClass\n{\n    public $foo;\n\n    public function __construct($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function __toString()\n    {\n        return $this->foo;\n    }\n}\n\n$class = new TestClass('Привет');\necho $class;\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nПривет\n```\n\n### [\\_\\_invoke()](language.oop5.magic.md#object.invoke)\n\n```methodsynopsis\n__invoke( ...$values): mixed\n```\n\nМетод[\\_\\_invoke()](language.oop5.magic.md#object.invoke) викликається, коли скрипт намагається виконати об'єкт як функцію.\n\n**Приклад #4 Использование[\\_\\_invoke()](language.oop5.magic.md#object.invoke)**\n\n```php\n<?php\nclass CallableClass\n{\n    public function __invoke($x)\n    {\n        var_dump($x);\n    }\n}\n$obj = new CallableClass;\n$obj(5);\nvar_dump(is_callable($obj));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(5)\nbool(true)\n```\n\n**Приклад #5 Приклад использования[\\_\\_invoke()](language.oop5.magic.md#object.invoke)**\n\n```php\n<?php\nclass Sort\n{\n    private $key;\n\n    public function __construct(string $key)\n    {\n        $this->key = $key;\n    }\n\n    public function __invoke(array $a, array $b): int\n    {\n        return $a[$this->key] <=> $b[$this->key];\n    }\n}\n\n$customers = [\n    ['id' => 1, 'first_name' => 'John', 'last_name' => 'Do'],\n    ['id' => 3, 'first_name' => 'Alice', 'last_name' => 'Gustav'],\n    ['id' => 2, 'first_name' => 'Bob', 'last_name' => 'Filipe']\n];\n\n// сортировка клиентов по имени\nusort($customers, new Sort('first_name'));\nprint_r($customers);\n\n// сортировка клиентов по фамилии\nusort($customers, new Sort('last_name'));\nprint_r($customers);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => Array\n        (\n            [id] => 3\n            [first_name] => Alice\n            [last_name] => Gustav\n        )\n\n    [1] => Array\n        (\n            [id] => 2\n            [first_name] => Bob\n            [last_name] => Filipe\n        )\n\n    [2] => Array\n        (\n            [id] => 1\n            [first_name] => John\n            [last_name] => Do\n        )\n\n)\nArray\n(\n    [0] => Array\n        (\n            [id] => 1\n            [first_name] => John\n            [last_name] => Do\n        )\n\n    [1] => Array\n        (\n            [id] => 2\n            [first_name] => Bob\n            [last_name] => Filipe\n        )\n\n    [2] => Array\n        (\n            [id] => 3\n            [first_name] => Alice\n            [last_name] => Gustav\n        )\n\n)\n```\n\n### [\\_\\_set\\_state()](language.oop5.magic.md#object.set-state)\n\n```methodsynopsis\nstatic __set_state(array $properties): object\n```\n\nЦей [статичний](language.oop5.static.md) метод викликається тим класів, які експортуються функцією [var\\_export()](function.var-export.md)\n\nЄдиним параметром цього методу є масив, що містить властивості, що експортуються у вигляді `['property' => value, ...]`\n\n**Приклад #6 Использование[\\_\\_set\\_state()](language.oop5.magic.md#object.set-state)**\n\n```php\n<?php\n\nclass A\n{\n    public $var1;\n    public $var2;\n\n    public static function __set_state($an_array)\n    {\n        $obj = new A;\n        $obj->var1 = $an_array['var1'];\n        $obj->var2 = $an_array['var2'];\n        return $obj;\n    }\n}\n\n$a = new A;\n$a->var1 = 5;\n$a->var2 = 'foo';\n\n$b = var_export($a, true);\nvar_dump($b);\neval('$c = ' . $b . ';');\nvar_dump($c);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(60) \"A::__set_state(array(\n   'var1' => 5,\n   'var2' => 'foo',\n))\"\nobject(A)#2 (2) {\n  [\"var1\"]=>\n  int(5)\n  [\"var2\"]=>\n  string(3) \"foo\"\n}\n```\n\n> **Зауваження**: Під час експорту об'єкту [var\\_export()](function.var-export.md) не перевіряє, чи реалізує клас об'єкта метод [\\_\\_set\\_state()](language.oop5.magic.md#object.set-state)тому повторний імпорт об'єктів призведе до виключення [Error](class.error.md), якщо метод \\_\\_set\\_state() не реалізовано. Зокрема, це стосується деяких внутрішніх класів. Необхідність перевірки, чи реалізує імпортований клас метод \\_\\_set\\_state(), повністю лежить на розробнику.\n\n### [\\_\\_debugInfo()](language.oop5.magic.md#object.debuginfo)\n\n```methodsynopsis\n__debugInfo(): array\n```\n\nЦей метод викликається функцією [var\\_dump()](function.var-dump.md), коли потрібно вивести список властивостей об'єкта. Якщо цей метод не визначений, тоді будуть виведені всі властивості об'єкта з модифікаторами public, protected та private.\n\n**Приклад #7 Использование[\\_\\_debugInfo()](language.oop5.magic.md#object.debuginfo)**\n\n```php\n<?php\nclass C {\n    private $prop;\n\n    public function __construct($val) {\n        $this->prop = $val;\n    }\n\n    public function __debugInfo() {\n        return [\n            'propSquared' => $this->prop ** 2,\n        ];\n    }\n}\n\nvar_dump(new C(42));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nobject(C)#1 (1) {\n  [\"propSquared\"]=>\n  int(1764)\n}\n```\n","title":"Магические методы","contentType":2,"navigation":[{"language.oop5.iterations.md":"« Ітератори об'єктів"},{"language.oop5.final.md":"Ключове слово final »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}