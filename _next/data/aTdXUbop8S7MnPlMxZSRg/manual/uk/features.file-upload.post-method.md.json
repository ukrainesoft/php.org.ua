{"pageProps":{"page":{"slug":"features.file-upload.post-method.md","content":"## Завантаження файлів методом POST\n\nЦя можливість дозволяє завантажувати як текстові, так і бінарні файли. За допомогою PHP-функцій автентифікації та роботи з файлами ви маєте повний контроль над тим, кому дозволено завантажувати файли та що робити з файлом після завантаження.\n\nPHP здатний отримувати завантажені файли будь-якого браузера, сумісного зі стандартом RFC-1867.\n\n> **Зауваження** **Суміжні зауваження щодо конфігурації**\n> \n> Також ознайомтеся з описом директив [file\\_uploads](ini.core.md#ini.file-uploads) [upload\\_max\\_filesize](ini.core.md#ini.upload-max-filesize) [upload\\_tmp\\_dir](ini.core.md#ini.upload-tmp-dir) [post\\_max\\_size](ini.core.md#ini.post-max-size) і [max\\_input\\_time](info.configuration.md#ini.max-input-time)конфигурационного файла php.ini\n\nТакож слід зауважити, що PHP підтримує завантаження файлів методом PUT, який використовується у клієнтах Netscape Composer та W3C Amaya. Для отримання більш детальної документації зверніться до розділу [підтримка методу PUT](features.file-upload.put-method.md)\n\n**Приклад #1 Форма для завантаження файлів**\n\nСторінка для завантаження файлів може бути реалізована за допомогою спеціальної форми, яка виглядає приблизно так:\n\nНадіслати цей файл:\n\nУ наведеному вище прикладі `__URL__` потрібно замінити посиланням на PHP-скрипт.\n\nПриховане поле `MAX_FILE_SIZE` (значення необхідно вказувати в байтах) має передувати полю для вибору файлу, і його значення є максимально допустимим розміром файлу, що приймається в PHP. Рекомендується завжди використовувати цю змінну, оскільки вона запобігає тривожному очікуванню користувачів при передачі величезних файлів, тільки для того, щоб дізнатися, що файл занадто великий і передача фактично не відбулася. Майте на увазі, що обійти це обмеження на стороні браузера досить просто, тому ви не повинні покладатися на те, що всі файли більшого розміру будуть блоковані за допомогою цієї можливості. Це здебільшого зручна можливість для користувачів клієнтської частини вашої програми. Однак налаштування PHP (на сервері) щодо максимального розміру оминути неможливо.\n\n> **Зауваження** :\n> \n> Также следует убедиться, что форма загрузки имеет атрибут`enctype=\"multipart/form-data\"`, інакше завантаження файлів на сервер не відбудеться.\n\nГлобальний масив [$\\_FILES](reserved.variables.files.md) містить всю інформацію про завантажені файли. Його вміст для нашого прикладу наведено нижче. Зверніть увагу, що тут передбачається використання імені *userfile* для поля вибору файлу, як і у наведеному вище прикладі. Насправді ім'я поля може бути будь-яким.\n\n[$\\_FILES\\['userfile'\\]\\['name'\\]](reserved.variables.files.md)\n\nОригінальна назва файлу на комп'ютері клієнта.\n\n[$\\_FILES\\['userfile'\\]\\['type'\\]](reserved.variables.files.md)\n\nMime-тип файлу, якщо браузер надав таку інформацію. Як приклад можна навести `\"image/gif\"`. Цей mime-тип не перевіряється на стороні PHP, тому не покладайтеся на його значення без перевірки.\n\n[$\\_FILES\\['userfile'\\]\\['size'\\]](reserved.variables.files.md)\n\nРозмір у байтах прийнятого файлу.\n\n[$\\_FILES\\['userfile'\\]\\['tmp\\_name'\\]](reserved.variables.files.md)\n\nТимчасове ім'я, з яким файл було збережено на сервері.\n\n[$\\_FILES\\['userfile'\\]\\['error'\\]](reserved.variables.files.md)\n\n[Код помилки](features.file-upload.errors.md), яка може виникнути під час завантаження файлу.\n\n[$\\_FILES\\['userfile'\\]\\['full\\_path'\\]](reserved.variables.files.md)\n\nПовний шлях представлений браузером. Це значення не завжди містить реальну структуру каталогів, і йому не можна довіряти. Доступно з PHP 8.1.0.\n\nЗа промовчанням прийняті файли зберігаються на сервері у стандартній тимчасовій папці доти, доки не буде задана інша директорія за допомогою директиви [upload\\_tmp\\_dir](ini.core.md#ini.upload-tmp-dir) конфігураційний файл php.ini. Директорію сервера за промовчанням можна змінити, встановивши змінну TMPDIR для оточення, в якому виконується PHP. Встановлення цієї змінної за допомогою функції [putenv()](function.putenv.md) всередині PHP-скрипту не працюватиме. Ця змінна оточення також може бути використана для того, щоб переконатися, що інші операції також працюють з прийнятими файлами.\n\n**Приклад #2 Перевірка файлів, що завантажуються на сервер**\n\nДля отримання більш детальної інформації ви можете ознайомитись з описом функцій [is\\_uploaded\\_file()](function.is-uploaded-file.md) і [move\\_uploaded\\_file()](function.move-uploaded-file.md). Наступний приклад приймає та обробляє завантажений за допомогою форми файл.\n\n```php\n<?php\n$uploaddir = '/var/www/uploads/';\n$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);\n\necho '<pre>';\nif (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {\n    echo \"Файл корректен и был успешно загружен.\\n\";\n} else {\n    echo \"Возможная атака с помощью файловой загрузки!\\n\";\n}\n\necho 'Некоторая отладочная информация:';\nprint_r($_FILES);\n\nprint \"</pre>\";\n\n?>\n```\n\nPHP-скрипт, який приймає завантажений файл, повинен реалізовувати логіку, необхідну визначення подальших дій над прийнятим файлом. Наприклад, ви можете перевірити змінну [$\\_FILES\\['userfile'\\]\\['size'\\]](reserved.variables.files.md), щоб відсікти занадто великі або занадто маленькі файли. Також ви можете використовувати змінну [$\\_FILES\\['userfile'\\]\\['type'\\]](reserved.variables.files.md) для виключення файлів, які не задовольняють критерію щодо типу файлу, проте, беріть до уваги, що це поле повністю контролюється клієнтом, використовуйте його лише як першу серію перевірок. Також ви можете використовувати [$\\_FILES\\['userfile'\\]\\['error'\\]](reserved.variables.files.md) і [коди помилок](features.file-upload.errors.md) під час реалізації вашої логіки. Незалежно від того, яку модель поведінки ви вибрали, потрібно видалити файл з тимчасової папки або перемістити його в іншу директорію.\n\nУ разі, якщо при відправленні форми файл обраний не був, PHP встановить змінну [$\\_FILES\\['userfile'\\]\\['size'\\]](reserved.variables.files.md)значением 0, а переменную[$\\_FILES\\['userfile'\\]\\['tmp\\_name'\\]](reserved.variables.files.md) \\- none.\n\nПісля завершення роботи скрипта, якщо завантажений файл не був перейменований або переміщений, він буде автоматично видалено з тимчасової папки.\n\n**Приклад #3 Завантаження масиву файлів**\n\nPHP підтримує [можливість передачі масиву з HTML](faq.md.md#faq.md.arrays) у тому числі і з файлами.\n\nИзображения:\n\n```php\n<?php\nforeach ($_FILES[\"pictures\"][\"error\"] as $key => $error) {\n    if ($error == UPLOAD_ERR_OK) {\n        $tmp_name = $_FILES[\"pictures\"][\"tmp_name\"][$key];\n        // basename() может спасти от атак на файловую систему;\n        // может понадобиться дополнительная проверка/очистка имени файла\n        $name = basename($_FILES[\"pictures\"][\"name\"][$key]);\n        move_uploaded_file($tmp_name, \"data/$name\");\n    }\n}\n?>\n```\n\nСмуга прогресу завантаження файлів може бути реалізована за допомогою \"[відстеження прогресу завантаження файлів за допомогою сесій](session.upload-progress.md)\".\n","title":"Завантаження файлів методом POST","contentType":2,"navigation":[{"features.file-upload.md":"« Завантаження файлів на сервер"},{"features.file-upload.errors.md":"Пояснення повідомлень про помилки »"},{"index.md":"PHP Manual"},{"features.file-upload.md":"Завантаження файлів на сервер"}]}},"__N_SSG":true}