{"pageProps":{"page":{"slug":"function.array-udiff-uassoc.md","content":"# array\\_udiff\\_uassoc\n\n(PHP 5, PHP 7, PHP 8)\n\narray\\_udiff\\_uassoc - Обчислює розбіжність у масивах з додатковою перевіркою індексів, використовуючи для порівняння значень та індексів callback-функцію\n\n### Опис\n\n```methodsynopsis\narray_udiff_uassoc(    array $array,    array ...$arrays,    callable $value_compare_func,    callable $key_compare_func): array\n```\n\nОбчислює розбіжність у масивах з додатковою перевіркою індексів, використовуючи для порівняння значень та індексів callback-функцію.\n\nОбратите внимание, что в отличие от функций[array\\_diff()](function.array-diff.md) і [array\\_udiff()](function.array-udiff.md) при порівнянні значень порівнюються і ключі.\n\n### Список параметрів\n\n`array`\n\nПерший масив.\n\n`arrays`\n\nМасиви для порівняння.\n\n`value_compare_func`\n\nФункція порівняння повинна повертати ціле, яке менше, дорівнює чи більше нуля, якщо перший аргумент є відповідно меншим, рівним чи більшим, ніж другий.\n\n```methodsynopsis\ncallback(mixed $a, mixed $b): int\n```\n\n**Застереження**\n\nВозвращение*нецілих* значень з функції порівняння, таких як число з плаваючою точкою (float), призведе до внутрішнього приведення значення callback-функції, що повертається, до цілого числа (int). Таким чином, значення `0.99`и`0.1` будуть приведені до цілого значення що дозволить порівняти ці значення як рівні.\n\n**Застереження**\n\nCallback-функція сортування повинна обробляти будь-яке значення з будь-якого масиву у будь-якому порядку, незалежно від того, в якому порядку вони були надані спочатку. Причина цього у тому, кожен окремий масив спочатку сортується перед порівнянням коїться з іншими масивами. Наприклад:\n\n```php\n<?php\n\n$arrayA = [\"string\", 1];\n$arrayB = [[\"value\" => 1]];\n// $item1 and $item2 can be any of \"string\", 1 or [\"value\" => 1]\n$compareFunc = static function ($item1, $item2) {\n    $value1 = is_string($item1) ? strlen($item1) : (is_array($item1) ? $item1[\"value\"] : $item1);\n    $value2 = is_string($item2) ? strlen($item2) : (is_array($item2) ? $item2[\"value\"] : $item2);\n    return $value1 <=> $value2;\n};\n\n?>\n```\n\n`key_compare_func`\n\nПорівняння ключів (індексів) виконується також callback-функцією `key_compare_func`. Ця поведінка відрізняється від поведінки функції [array\\_udiff\\_assoc()](function.array-udiff-assoc.md)яка порівнює індекси через внутрішню функцію.\n\n### Значення, що повертаються\n\nПовертає масив (array), що містить елементи аргументу `array`, яких немає в жодному іншому аргументі.\n\n### Приклади\n\n**Приклад #1 Приклад використання функції** array\\_udiff\\_uassoc()\\*\\*\\*\\*\n\n```php\n<?php\n\nclass cr {\n    private $priv_member;\n    function __construct($val)\n    {\n        $this->priv_member = $val;\n    }\n\n    static function comp_func_cr($a, $b)\n    {\n        if ($a->priv_member === $b->priv_member) return 0;\n        return ($a->priv_member > $b->priv_member)? 1:-1;\n    }\n\n    static function comp_func_key($a, $b)\n    {\n        if ($a === $b) return 0;\n        return ($a > $b)? 1:-1;\n    }\n}\n$a = array(\"0.1\" => new cr(9), \"0.5\" => new cr(12), 0 => new cr(23), 1=> new cr(4), 2 => new cr(-15),);\n$b = array(\"0.2\" => new cr(9), \"0.5\" => new cr(22), 0 => new cr(3), 1=> new cr(4), 2 => new cr(-15),);\n\n$result = array_udiff_uassoc($a, $b, array(\"cr\", \"comp_func_cr\"), array(\"cr\", \"comp_func_key\"));\nprint_r($result);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0.1] => cr Object\n        (\n            [priv_member:private] => 9\n        )\n\n    [0.5] => cr Object\n        (\n            [priv_member:private] => 12\n        )\n\n    [0] => cr Object\n        (\n            [priv_member:private] => 23\n        )\n)\n```\n\nУ наведеному прикладі видно, що пара `\"1\" => new cr(4)` є в обох масивах, і тому її немає у висновку функції. Функція буде працювати лише тоді, коли їй надали дві функції зворотного дзвінка.\n\n### Примітки\n\n> **Зауваження**: Зверніть увагу, що функція обробляє лише перший рівень багатовимірного масиву. Значення на вкладених рівнях обробляють, наприклад, так: `array_udiff_uassoc($array1[0], $array2[0], \"data_compare_func\", \"key_compare_func\");`\n\n### Дивіться також\n\n-   [array\\_diff()](function.array-diff.md) \\- обчислює розбіжність масивів\n-   [array\\_diff\\_assoc()](function.array-diff-assoc.md) \\- обчислює розбіжність масивів з додатковою перевіркою індексу\n-   [array\\_udiff()](function.array-udiff.md) \\- обчислює розбіжність масивів, використовуючи для порівняння callback-функцію\n-   [array\\_udiff\\_assoc()](function.array-udiff-assoc.md) \\- обчислює розбіжність у масивах з додатковою перевіркою індексів, використовуючи порівняння значень callback-функцию\n-   [array\\_intersect()](function.array-intersect.md) \\- обчислює перетин масивів\n-   [array\\_intersect\\_assoc()](function.array-intersect-assoc.md) \\- обчислює перетин масивів з додатковою перевіркою індексу\n-   [array\\_uintersect()](function.array-uintersect.md) \\- обчислює перетин масивів, використовуючи для порівняння значень callback-функцію\n-   [array\\_uintersect\\_assoc()](function.array-uintersect-assoc.md) \\- обчислює перетин масивів з додатковою перевіркою індексів, використовуючи для порівняння значень callback-функцію\n-   [array\\_uintersect\\_uassoc()](function.array-uintersect-uassoc.md) \\- обчислює перетин масивів з додатковою перевіркою індексу, використовуючи для порівняння індексів та значень окремі callback-функції\n","title":"array\\_udiff\\_uassoc","contentType":2,"navigation":[{"function.array-udiff-assoc.md":"« array\\_udiff\\_assoc"},{"function.array-udiff.md":"array\\_udiff »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}