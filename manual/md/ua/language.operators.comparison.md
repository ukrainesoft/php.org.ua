- [« Побітові оператори](language.operators.bitwise.md)
- [Оператор управління помилками
»](language.operators.errorcontrol.md)

- [PHP Manual](index.md)
- [Оператори](language.operators.md)
- Оператори порівняння

## Оператори порівняння

Оператори порівняння, як це видно з їхньої назви, дозволяють порівнювати
між собою два значення. Можливо вам буде цікаво також
ознайомитися з розділом [Порівняння типів](types.comparisons.md), в
якому наведено велику кількість відповідних прикладів.

| приклад | Назва | Результат |
|-------------|----------------------------------- -------------------------------------------------- -------------------------------------------------- ----|
| $a u003du003d $b | Рівне | **`true`** якщо `$a` дорівнює `$b` після перетворення типів. |
| $a u003du003du003d $b | Тотожно одно | **`true`** якщо `$a` дорівнює `$b` і має той самий тип. |
| $a!u003d$b | Не одно | **`true`** якщо `$a` не дорівнює `$b` після перетворення типів. |
| $a \<\> $b | Не одно | **`true`** якщо `$a` не дорівнює `$b` після перетворення типів. |
| $a !u003du003d $b | Тотожно не дорівнює | **`true`** якщо `$a` не дорівнює `$b`, або вони різних типів. |
| $a \< $b | Менш | **`true`** якщо `$a` строго менше `$b`. |
| $a \> $b | Більше | **`true`** якщо `$a` строго більше `$b`. |
| $a \<u003d $b | Менш чи одно | **`true`** якщо `$a` менше або дорівнює `$b`. |
| $a \>u003d $b | Більше чи одно | **`true`** якщо `$a` більше або дорівнює `$b`. |
| $a \<u003d\> $b | Космічний корабель (spaceship) Число типу int менше, більше або дорівнює нулю, коли $a відповідно менше, більше або дорівнює $b. |

**Оператори порівняння**

У випадку, якщо обидва операнди є [рядками, що містять
числа](language.types.numeric-strings.md) або один операнд є
числом, а інший - [рядком, що містить
числа](language.types.numeric-strings.md), то порівняння виконується
чисельно. Ці правила також застосовуються до оператора
[switch] (control-structures.switch.md). Перетворення типу не
відбувається при порівнянні `u003du003du003d` або `!u003du003d`, оскільки це включає
порівняння типу, і навіть значення.

**Увага**

До PHP 8.0.0, якщо рядок (string) порівнювався з числом або рядком,
містить число, то рядок (string) перетворювалося на число перед
виконанням порівняння. Це могло призвести до несподіваних результатів, що
можна побачити на наступному прикладі:

` <?phpvar_dump(0 u003du003d "a");var_dump("1" u003du003d "01");var_dump("10" u003du003d "1e1");var_dump(100 u003du003d "1e2");switch (" a") {case 0:   echo "0"; break; case "a":   echo "a"; break;}?> `

Результат виконання цього прикладу в PHP 7:

bool(true)
bool(true)
bool(true)
bool(true)
    0

Результат виконання цього прикладу в PHP 8:

bool(false)
bool(true)
bool(true)
bool(true)
a

`<?php// Цілі числаecho 1 <u003d> 1; // 0echo 1 <u003d> 2; // -1echo 2 <u003d> 1; // 1// Числа з плаваючою точкоюecho 1.5 <u003d> 1.5; // 0echo 1.5 <u003d> 2.5; // -1echo 2.5 <u003d> 1.5; // 1//Рядокecho "a" <u003d> "a"; // 0echo "a" <u003d> "b"; // -1echo "b" <u003d> "a"; // 1echo "a" <u003d> "aa"; // -1echo "zz" <u003d> "aa"; // 1// Массивиecho [] <u003d> []; // 0echo [1, 2, 3] <u003d> [1, 2, 3]; // 0echo [1, 2, 3] <u003d> []; // 1echo [1, 2, 3] <u003d> [1, 2, 1]; // 1echo [1, 2, 3] <u003d> [1, 2, 4]; // -1// Об'єкти$a u003d (object) ["a" u003d> "b"];$b u003d (object) ["a" u003d> "b"];echo $a <u003d> $b; // 0$a u003d (object) ["a" u003d> "b"];$b u003d (object) ["a" u003d> "c"];echo $a <u003d> $b; // -1$a u003d (object) ["a" u003d> "c"];$b u003d (object) ["a" u003d> "b"];echo $a <u003d> $b; // 1// порівнюються не тільки значення; ключі також мають збігатися$a u003d (object) ["a" u003d> "b"];$b u003d (object) ["b" u003d> "b"];echo $a <u003d> $b; // 1?> `

Для різних типів порівняння відбувається відповідно до наступної
таблицею (по порядку).

| Тип операнди 1 | Тип операнди 2 | Результат |
|---------------------------------|--------------- ------------------|------------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -----------------------------------|
| null чи string | string | **`null`** перетворюється на "", числове чи лексичне порівняння |
| bool чи null | будь-що | Перетворюється на тип bool, **`false`** \< **`true`** |
| об'єкт | об'єкт | Вбудовані класи можуть визначати власні правила порівняння, об'єкти різних класів не порівнюються, для порівняння об'єктів одного класу дивіться [Порівняння об'єкта](language.oop5.object-comparison.md) |
| string, resource, int чи float | string, resource, int чи float | Рядки та ресурси переводяться в числа, звичайна математика |
| array | array | Масиви з меншим числом елементів вважаються меншими, якщо ключ з першого операнда не знайдений у другому операнді - масиви не можуть порівнюватися, інакше йде порівняння відповідних значень (див. приклад нижче) |
| array | будь-що | тип array завжди більше |
| об'єкт | будь-що | тип object завжди більший |

**Порівняння різних типів**

**Приклад #1 Порівняння boolean/null**

`<?php// Логічні значення і null завжди порівнюються як логічніvar_dump(1 u003du003d TRUE); // TRUE - то що, що і (bool)1 u003du003d TRUEvar_dump(0 u003du003d FALSE); // TRUE - то що, що і (bool)0 u003du003d FALSEvar_dump(100 < TRUE); // FALSE - то що, що і (bool)100 < TRUEvar_dump(-10 < FALSE); , 100)); // NULL - (bool)NULL < (bool)-100 це FALSE < TRUE?> `

**Приклад #2 Алгоритм порівняння звичайних масивів**

` <?php// Массивы сравниваются таким образом с помощью стандартных операторов сравнения, а также оператора spaceship.function standard_array_compare($op1, $op2){    if (count($op1) < count($op2)) {        return -1; // $op1 < $op2    } elseif (count($op1) > count($op2)) {        return 1; // $op1 > $op2    }   foreach ($op1 as $key u003d> $val) {       if (!array_key_exists($key, $          } elseif ($val < $op2[$key]) {            return -1; } elseif ($val > $op2[$key]) {            return 1; }    }   return 0; // $op1 u003du003d $op2}?> `

**Увага**

# Порівняння чисел з плаваючою точкою

Через особливе внутрішнє уявлення типу float, не потрібно перевіряти
на рівність два числа з плаваючою точкою (float).

Для більш детальної інформації дивіться документацію типу float.

> **Примітка**: Пам'ятайте, що жонглювання типами в PHP не завжди
> очевидно при порівнянні значень різних типів, особливо у порівнянні
> цілих чисел (int) з логічними значеннями (bool) чи цілих чисел
> (int) зі рядками (string). Тому в більшості випадків
> рекомендується використовувати порівняння `u003du003du003d` та `!u003du003d`, а не `u003du003d` та `!u003d`.

### Незрівнянне значення

У той час як порівняння тотожності (`u003du003du003d` та `!u003du003d`) можна застосовувати до
довільним значенням, інші оператори порівняння слід застосовувати
тільки до порівнянних значень. Результат порівняння незрівнянних значень
не визначений і не слід покладатися.

### Дивіться також

- [strcasecmp()](function.strcasecmp.md)
- [strcmp()](function.strcmp.md)
- [Оператори з масивами](language.operators.array.md)
- [Типи](language.types.md)

### Тернарний оператор

Ще одним умовним оператором є тернарний оператор "?:".

**Приклад #3 Призначення за промовчанням**

` <?php// Приклад використання тернарного оператора$action u003d (empty($_POST['action'])) ? 'default' : $$POST['action']; u003d $_POST['action'];}?> `

Вираз `(expr1)? (expr2) : (expr3)` інтерпретується як expr2, якщо
expr1 має значення **`true`**, або як expr3, якщо expr1 має
значення **`false`**.

Також стало можливим не писати середню частину тернарного оператора.
Вираз `expr1?: expr3` оцінюється як результат expr1, якщо
результат виразу expr1 оцінюється як **`true`** та expr3 у протилежному
випадку. Вираз expr1 у разі оцінюється лише один раз.

> **Примітка**: Зверніть увагу, що тернарний оператор є
> виразом і трактується не як змінна, бо як результат висловлювання.
> Це важливо знати, якщо потрібно повернути змінну за посиланням.
> Вираз `return $var u003du003d 42? $a : $b;` не працюватиме у функції,
> повертає значення за посиланням, а в пізніших версіях PHP також
> буде видано попередження.

> **Примітка**:
>
> Рекомендується уникати "нагромадження" тернарних виразів. Поведінка
> PHP неочевидно при використанні більш ніж одного тернарного оператора
> без дужок щодо одного вираженні проти іншими мовами.
> Дійсно, до PHP 8.0.0 троїчні вирази оцінювалися
> ліво-асоціативними, а чи не право-асоціативними, як у більшості
> Інші мови програмування. Використання ліво-асоціативності
> застаріло у PHP 7.4.0. Починаючи з PHP 8.0.0, тернарний оператор
> неасоціативний.
>
> **Приклад #4 Неочевидна поведінка тернарного оператора**
>
> `<?php// на перший погляд, наступний код повинен вивести 'true'echo (true ? 'true' : false ? 't' : 'f');//одно, ' ' ' 0// это потому, что тернарные выражения левоассоциативны// это намного более очевидная версия вышеприведённого кодаecho ((true ? 'true' : false) ? 't' : 'f');// здесь видно, что первое выражение вычисляется в ' true', що// в свою чергу обчислюється в (bool)true, таким образом повертаючи істинну гілка// другого тернарного вираження.?> `

> **Примітка**:
>
> Ланцюжок коротких тернарних операторів (`?:`) стабільний і поводиться
> розумно. Вона оцінюватиме перший аргумент, який оцінюється як
> не хибне значення. Зверніть увагу, що невизначені значення всі
> і викликають попередження.
>
> **Приклад #5 Ланцюжок коротких тернарних операторів**
>
> `<?phpecho 0 ?: 1 ?: 2 ?: 3, PHP_EOL; //1echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; //2echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; //3?> `

### Оператор об'єднання з null

Іншим корисним скороченим оператором є оператор "??" (null
coalescing).

**Приклад #6 Призначення за промовчанням**

` <?php// Приклад використання оператора$action u003d $_POST['action'] ?? 'default';// Приклад вище аналогічний наступному кодуif (isset($_POST['action'])) {    $action u003d $_POST['action'];} else { f'' $a''

Вираз `(expr1) ?? (expr2)` обчислюється так: expr2, якщо expr1 дорівнює
**`null`** і expr1 в іншому випадку.

На практиці цей оператор не викликає попередження або помилки, якщо
лівий операнд немає, як і [isset()](function.isset.md). Це
дуже корисно для ключів масиву.

> **Примітка**: Будь ласка, пам'ятайте, що цей оператор є
> виразом, і він прирівнюється до виразу, а чи не значення змінної.
> Це може бути важливим, якщо потрібно повернути значення за посиланням.
> Вираз `return $foo ?? $bar;` у функції повертає посилання буде
> не працювати, а виводити попередження.

> **Примітка**:
>
> У оператора null coalescing низький пріоритет. Це означає, що при
> змішування його з іншими операторами (такими як конкатенація рядків
> або арифметичні оператори), швидше за все, знадобляться круглі
> дужки.
>
> `<?php// Викликає попередження про том, що $name не визначено.print 'Mr. ' . $name ?? 'Anonymous';// Виведе "Mr. Anonymous"print 'Mr. ' . ($name ?? 'Anonymous');?> `

> **Примітка**:
>
> Зверніть увагу, що цей оператор дозволяє використовувати просту
> вкладеність:
>
> **Приклад #7 Вкладений оператор null coalescing**
>
> ` <?php$foo u003d null;$bar u003d null;$baz u003d 1;$qux u003d 2;echo $foo ?? $bar??? $baz??? $qux; // виведе 1?> `
