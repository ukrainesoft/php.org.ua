- [«
DateTimeImmutable::\_\_construct](datetimeimmutable.construct.md)
- [DateTimeImmutable::createFromInterface
»](datetimeimmutable.createfrominterface.md)

- [PHP Manual](index.md)
- [DateTimeImmutable](class.datetimeimmutable.md)
- Розбирає рядок з датою згідно з вказаним форматом

# DateTimeImmutable::createFromFormat

# date_create_immutable_from_format

(PHP 5 \>u003d 5.5.0, PHP 7, PHP 8)

DateTimeImmutable::createFromFormat -- date_create_immutable_from_format
— Розбирає рядок із датою згідно з вказаним форматом

### Опис

Об'єктно-орієнтований стиль

public static **DateTimeImmutable::createFromFormat**(string `$format`,
string `$datetime`, ?[DateTimeZone](class.datetimezone.md) `$timezone`
u003d **`null`**): [DateTimeImmutable](class.datetimeimmutable.md)\|false

Процедурний стиль

[date_create_immutable_from_format](function.date-create-immutable-from-format.md)(string
`$format`, string `$datetime`, ?[DateTimeZone](class.datetimezone.md)
`$timezone` u003d **`null`**):
[DateTimeImmutable](class.datetimeimmutable.md)\|false

Повертає новий об'єкт DateTimeImmutable, що представляє дату та час,
вказані рядком у параметрі `datetime`, які були відформатовані в
заданому форматі `format`.

### Список параметрів

`format`
Формат дати та часу у вигляді рядка (string), якому відповідає
значення другого аргументу функції. Список варіантів форматування
представлений нижче. Найчастіше, при форматуванні використовуються
ті ж символи, що і функції [date()](function.date.md).

Формат розбирається зліва направо, це означає, що деякі
ситуаціях порядок присутності символів формату впливає на результат. В
у разі `z` (день року) потрібно, щоб рік уже був розібраний, наприклад,
за допомогою символів `Y` або `y`.

Символи, які використовуються для розбирання чисел, допускають широкий діапазон
значень, що виходить за межі логічного діапазону Наприклад, `d`
(День місяця) приймає значення в діапазоні від `00` до `99`.
Єдиним обмеженням є кількість цифр. Механізм
переповнення парсера дати/часу використовується, коли задаються значення,
що виходять за межі діапазону. Наведені нижче приклади демонструють
деякі особливості такої поведінки.

| Символ у рядку `format` | Опис | Можливі значення |
|:-----------------------------------------:|----- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ---|---------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -----------------|
| *День* | --- | --- |
| `d` та `j` | День місяця, 2 цифри з нулем на початку чи без нього | Від `01` до `31` або від `1` до `31`. (Допускається використання двозначних чисел, що перевищують кількість днів на місяці, у цьому випадку різниця переноситься на наступний місяць. Наприклад, використання числа 33 з січнем означає 2 лютого) |
| `D` та `l` | Текстова вистава дня тижня | Від `Mon` до `Sun` або від `Sunday` до `Saturday`. Якщо задане ім'я дня відрізняється від імені дня, що належить розібраній даті (або за замовчуванням), то відбувається переповнення до *наступної* дати із заданим ім'ям дня. Дивіться приклади нижче, щоб пояснити. |
| `S` | Суфікс для числа у англійській нумерації, 2 літери. Ці літери будуть пропущені при розборі рядка. | `st`, `nd`, `rd` або `th`. |
| `z` | Номер дня початку року (починаючи з 0); має передувати `Y` або `y`. | C `0` по `365`. (Допускаються тризначні числа, що перевищують числа на рік, у разі різниця переноситься наступного року. Наприклад, використання числа 366 з 2022 роком означає 2 січня 2023 року) |
| *Місяць* | --- | --- |
| `F` та `M` | Текстове подання місяця, наприклад, January або Sept | З `January` по `December` або з `Jan` по `Dec` |
| `m` та `n` | Числове уявлення місяця з першим нулем чи без нього | З `01` по `12` або з `1` по `12`. (Допускаються двоцифрові числа більше 12, у цьому випадку різниця переноситься на наступний рік. Наприклад, використання числа 13 означає січень наступного року) |
| *Рік* | --- | --- |
| 'Y' | Повне числове уявлення року, до 4 цифр. | Приклади: `0055`, `787`, `1999`, `2003`. |
| `y` | 2 цифри у виставі року (в діапазоні 1970-2069 включно) | Приклади: `99` або `03` (буде розшифровано як `1999` та `2003` відповідно) |
| * Час * | --- | --- |
| `a` та `A` | До полудня та Після полудня | `am` або `pm` |
| `g` та `h` | 12-ти годинний формат часу з першим нулем чи без нього | З `1` по `12` або з `01` по `12`. (допускається використання двозначних чисел більше 12, у разі різниця переноситься наступного дня. Наприклад, використання числа `14` означає `02` у наступному періоді AM/PM) |
| `G` та `H` | 24-годинний формат часу з нулем на початку або без нього | З `0` по `23` або з `00` по `23` (допускаються двоцифрові числа більше 24, у цьому випадку різниця переноситься на наступний день. Наприклад, використання `26` означає `02:00` наступного дня) |
| `i` | Хвилини з нулем на початку З `00` по `59`. (допускається використання двозначних чисел більше 59, у цьому випадку різниця переноситься на наступну годину. Наприклад, використання числа `66` означає `:06` наступної години) |
| `s` | Секунди з нулем на початку Від `00` до `59`. (Допускаються двозначні числа більше 59, у цьому випадку різниця переноситься на наступну хвилину. Наприклад, використання числа `90` означає `:30` наступної хвилини) |
| `v` | Дроб у мілісекундах (до 3 цифр) | Приклади: `12` (`0.12` секунд), `345` (`0.345` секунд) |
| `u` | Дроб у мікросекундах (до 6 цифр) | Приклади: `45` (`0.45` секунд), `654321` (`0.654321` секунд) |
| *Годинний пояс* | --- | --- |
| `e`, `O`, `P` та `T` | Ідентифікатор часового поясу, або різниця в годинах щодо UTC, або різниця щодо UTC з двокрапкою між годинами та хвилинами, або абревіатура часового поясу | Приклади: `UTC`, `GMT`, `Atlantic/Azores` або `+0200` або `+02:00` або `EST`, `MDT` |
| *Дата/Час повністю* | --- | --- |
| `U` | Кількість секунд від початку Епохи Unix (January 1 1970 00:00:00 GMT) | Приклад: `1292177455` |
| *Пробіл та Розділювачі* | --- | --- |
| `` (пробіл) | Один пропуск або один відступ табуляції | Приклад: `` |
| `#` | Один із наступних символів: `;`, `:`, `/`, `.`, `,`, `-`, `(` або `)` | Приклад: `/` |
| `;`, `:`, `/`, `.`, `,`, `-`, `(` або `)` | Символ роздільника. | Приклад: `-` |
| `?` | Один випадковий (будь-який) символ | Приклад: `^` (Будьте уважні: в UTF-8 кодуванні вам може знадобитися більше одного `?`, тому що там один символ може займати більше одного байта. У таких випадках може допомогти використання `*`.
| `*` | Будь-яка кількість будь-яких символів до наступного роздільника | Приклад: `*` в `Y-*-d` для рядка `2009-aWord-08` відповідатиме `aWord` |
| `!` Скидає всі поля (рік, місяць, день, година, хвилина, секунда та часовий пояс) до нульових значень (`0` для години, хвилини, секунди, `1` для місяця та дня, `1970` для року та `UTC` для інформації про часовий пояс). | Без `!` всі поля відповідатимуть поточному часу. |
| `|` | Скидає значення незаданих полів (рік, місяць, день, година, хвилина, секунда, часовий пояс) до нульових значень. | `Y-m-d|` встановить рік, місяць та день відповідно до даних у рядку, а години, хвилини та секунди встановить у 0. |
| `+` | Якщо заданий цей специфікатор, дані, що завершують рядок (нуль байт, наприклад) не викликатимуть помилку, тільки попередження | Використовуйте [DateTime::getLastErrors()](datetime.getlasterrors.md) для визначення, чи були у рядку завершальні символи. |

**Список можливих символів для складання рядка `format`**

Наявність у рядку формату нерозпізнаних символів, відсутніх у
списку вище, призведе до помилки розбору рядка. У цьому випадку повідомлення
про помилку буде додано до структури, що повертається. Отримати це
повідомлення можна за допомогою функції
[DateTime::getLastErrors()](datetime.getlasterrors.md).

Для вставки в `format` буквеного символу, ви повинні екранувати його з
допомогою зворотного слєша(`\`).

Якщо `format` не містить символ `!`, то значення полів, не заданих у
рядку формату, будуть встановлені відповідно до поточного часу.

Якщо `format` містить символ `!`, то значення полів, не заданих у
рядку формату (як і значення полів ліворуч від `!`) будуть
встановлені відповідно до значень полів початку Епохи Unix.

Якщо будь-який символ часу розібраний, всі інші поля, пов'язані з
часом встановлюються в "0", якщо вони також не розібрані.

Початок епохи Unix 1970-01-01 00:00:00 UTC.

`datetime`
Рядок, що представляє час.

`timezone`
Об'єкт класу [DateTimeZone](class.datetimezone.md), що представляє
очікуваний часовий пояс.

Якщо `timezone` не вказано або **`null`** та `datetime` не містить
часовий пояс, то буде використано поточний часовий пояс.

> **Примітка**:
>
> Параметр `timezone` та поточний часовий пояс будуть проігноровані, якщо
> параметр `datetime` також містить мітку часу UNIX (тобто
> timestamp виду `946684800`) або зазначений часовий пояс (тобто
> `2010-01-28T15:00:00+02:00`).

### Значення, що повертаються

Повертає новий екземпляр DateTimeImmutable або **`false`** у разі
виникнення помилки.

### Список змін

| Версія | Опис |
|--------|---------------------------------------- -------|
| 7.3.0 | Доданий специфікатор `v` параметру `format`. |

### Приклади

**Приклад #1 Приклад використання
**DateTimeImmutable::createFromFormat()****

Об'єктно-орієнтований стиль

` <?php$date u003d DateTimeImmutable::createFromFormat('j-M-Y', '15-Feb-2009');echo $date->format('Y-m-d');?> `

**Приклад #2 Тонкості **DateTimeImmutable::createFromFormat()****

`<?phpecho 'Поточний час: ' . date('Y-m-d H:i:s') . "
";$format u003d 'Y-m-d';$date u003d DateTimeImmutable::createFromFormat($format, '2009-02-15');echo "Формат: $format; " . $date->format('Y-m-d H:i:s') . "
";$format u003d 'Y-m-d H:i:s';$date u003d DateTimeImmutable::createFromFormat($format, '2009-02-15 15:16:17');echo "Формат: $format; " . $date->format('Y-m-d H:i:s') . "
";$format u003d 'Y-m-!d H:i:s';$date u003d DateTimeImmutable::createFromFormat($format, '2009-02-15 15:16:17');echo "Формат: $format; " . $date->format('Y-m-d H:i:s') . "
";$format u003d '!d';$date u003d DateTimeImmutable::createFromFormat($format, '15');echo "Формат: $format; " . $date->format('Y-m-d H:i:s') . "
";$format u003d 'i';$date u003d DateTimeImmutable::createFromFormat($format, '15');echo "Формат: $format; " . $date->format('Y-m-d H:i:s') . "
";?> `

Результатом виконання цього прикладу буде щось подібне:

Поточний час: 2022-06-02 15:50:46
Формат: Y-m-d; 2009-02-15 15:50:46
Формат: Y-m-d H: i: s; 2009-02-15 15:16:17
Формат: Y-m-!d H:i:s; 1970-01-15 15:16:17
Формат: ! d; 1970-01-15 00:00:00
Формат: i; 2022-06-02 00:15:00

**Приклад #3 Форматування рядка за допомогою літеральних символів**

` <?phpecho DateTimeImmutable::createFromFormat('H\h i\m s\s','23h 15m 03s')->format('H:i:s');?> `

Результатом виконання цього прикладу буде щось подібне:

23:15:03

**Приклад #4 Поведінка при переповненні**

` <?phpecho DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2021-17-35 16:60:97')->format(DateTimeImmutable::RFC2822);?> `

Результатом виконання цього прикладу буде щось подібне:

Sat, 04 Jun 2022 17:01:37 +0000

Хоча результат виглядає дивно, він правильний, тому що трапляються
наступні переповнення:

1. `97` секунд перевалюють за `1` хвилину, залишаючи `37` секунд.
2. `61` хвилин перевалює за `1` годину, залишаючи `1` хвилину.
3. `35` днів перевалюють за `1` місяць, залишаючи `4` дня. Кількість
решти днів залежить від місяця, тому що не в кожному місяці
однакову кількість днів.
4. `18` місяців перевалюють за `1` рік, залишаючи `6` місяців.

**Приклад #5 Поведінка імені переповненого дня**

` <?php$d u003d DateTime::createFromFormat(DateTimeInterface::RFC1123, 'Mon, 3 Aug 2020 25:00:00 +0000');echo $d->format(DateTime::RFC12
";?> `

Результатом виконання цього прикладу буде щось подібне:

Mon, 10 Aug 2020 01:00:00 +0000

Хоча результат виглядає дивно, він правильний, тому що трапляються
наступні переповнення:

1. `3 Aug 2020 25:00:00` перевалює за
`(Tue) 4 Aug 2020 1:00`.
2. Застосовується `Mon`, що переводить дату на
`Mon, 10 Aug 2020 1:00:00`. Пояснення щодо ключових слів,
таких як `Mon`, описано в розділі
формати](datetime.formats.relative.md).

Для виявлення переповнень у датах можна використовувати метод
[DateTimeImmutable::getLastErrors()](datetimeimmutable.getlasterrors.md),
який включатиме попередження, якщо відбулося переповнення.

**Приклад #6 Виявлення переповнення дат**

` <?php$d u003d DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2021-17-35 16:60:97');echo $d->format(DateTimeImmutable::RFC2822), 

";var_dump(DateTimeImmutable::GetLastErrors());?> `

Результатом виконання цього прикладу буде щось подібне:

Sat, 04 Jun 2022 17:01:37 +0000

array(4) {
'warning_count' u003d>
int(2)
'warnings' u003d>
array(1) {
[19] u003d>
string(27) "The parsed date was invalid"
}
'error_count' u003d>
int(0)
'errors' u003d>
array(0) {
}
}

### Дивіться також

- [DateTimeImmutable::\_\_construct()](datetimeimmutable.construct.md) -
Повертає новий об'єкт DateTimeImmutable
- [DateTimeImmutable::getLastErrors()](datetimeimmutable.getlasterrors.md) -
Повертає попередження та помилки
- [checkdate()](function.checkdate.md) - Перевіряє правильність дати
за григоріанським календарем
- [strptime()](function.strptime.md) - Розбирає рядок
дати/часу, згенеровану функцією strftime
