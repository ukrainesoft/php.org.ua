{"pageProps":{"page":{"slug":"philosophy.parallel.md","content":"# Філософія\n\nРозділ містить основні принципи, важливі для написання паралельного коду та деякі подробиці про внутрішню реалізацію parallel.\n\n### Не спілкуйтесь, поділяючи пам'ять; замість цього поділіться пам'яттю за допомогою спілкування.\n\nЦя філософія, якої дотримується parallel, бере свій початок з Go, однієї з найпопулярніших із платформ для написання паралельного коду в даний час. Програмісти на Go повинні наполегливо працювати, щоб відповідати цьому ідеалу: PHP і паралельний інтерфейс роблять всю важку роботу за програміста, причому за замовчуванням.\n\nУ традиційних моделях потокової передачі, що зустрічаються в інших мовах, потоки зазвичай обмінюються даними один з одним тільки завдяки тому факту, що вони працюють в тому самому адресному просторі. Програміст повинен використовувати взаємний виняток, змінні умови та інші низькорівневі примітиви потокової передачі або синхронізації, щоб забезпечити належну передачу стану та узгодженість.\n\nКоли звичайна модель інвертована, це означає, що потоки спільно використовують пам'ять тільки в результаті обміну даними (наприклад, змінна передається каналом).\n\nКоли parallel передає змінну з одного потоку до іншого будь-яким способом - аргументами завдання, поверненням через Future і каналами - вона передається за значенням. У всіх випадках, крім небуферизованих каналів, змінна також буферизується, тому вона не може змінитися (або бути знищена) до того, як вона буде використана в будь-якому потоці, який передається змінна. Небуферизоване читання каналом - єдиний випадок, коли потік безпосередньо читає пам'ять, виділену іншим потоком, це можна зробити безпечно, тому що потік, який володіє пам'яттю, очікує завершення читання, перш ніж він зможе продовжити керувати ним, і потік, якому не належить пам'ять, читає за значенням. Коли обидва потоки продовжують роботу, вони більше не поділяють пам'ять.\n\nЦе значно спрощує написання паралельного коду та міркування про нього порівняно з традиційною моделлю багатопоточності. Це означає, що програмісту не потрібно враховувати, що потоки можуть одночасно керувати даними, тому що це неможливо.\n\nЦе також робить PHP ідеальною платформою для реалізації API паралельного коду на основі CSP (передача повідомлень каналами), оскільки сам PHP нічого не поділяє - потоки PHP за замовчуванням працюють у власному віртуальному адресному просторі і тому можуть спільно використовувати пам'ять тільки шляхом обміну даними.\n\n### У даних має бути остаточний єдиний власник\n\nНаближаючись до моделі CSP вперше, програміст, який розуміється на традиційній моделі потокової передачі, може виявити, що шукає паралельні структури даних, оскільки це те, що вони теж використовують: вони передають загальні об'єкти управління.\n\nКоли справа доходить до моделі CSP, немає необхідності в тому, щоб структури даних спільно використовувалися багатьма завданнями і дійсно це простіше, якщо це не так. Дані повинні належати до одного завдання, зміни (або операції) у цій структурі даних повинні передаватися каналами і виконуватися власником даних, успішне виконання, помилка або результат (стан) зміни (або операції) передається назад.\n\nЗнову ж таки, природа PHP нічого не поділяє і природа паралельного копіювання за значенням допомагають програмісту досягти цієї мети, ніякі дані не будуть передані випадково, тільки в результаті обміну даними.\n","title":"Філософія","contentType":2,"navigation":[{"parallel.setup.md":"« Встановлення"},{"functional.parallel.md":"Функціональний API »"},{"index.md":"PHP Manual"},{"book.parallel.md":"parallel"}]}},"__N_SSG":true}