{"pageProps":{"page":{"slug":"evtimer.construct.md","content":"# EvTimer::\\_\\_construct\n\n(PECL ev >= 0.2.0)\n\nEvTimer::\\_\\_construct - Конструктор об'єкта спостерігача EvTimer\n\n### Опис\n\npublic **EvTimer::\\_\\_construct**  \nfloat`$after`  \nfloat`$repeat`  \n[callable](language.types.callable.md) `$callback`  \n[mixed](language.types.declarations.md#language.types.declarations.mixed) `$data` = **`null`**  \nint`$priority` =  \n) .\n\nКонструктор об'єкта спостерігача EvTimer.\n\n### Список параметрів\n\n`after`\n\nНалаштовує таймер для запуску через `after`секунд.\n\n`repeat`\n\nЯкщо час повтору дорівнює **`0.0`**, то він буде автоматично зупинено після закінчення часу очікування. Якщо позитивне, таймер буде автоматично налаштований на повторний запуск кожні повторювані секунди, доки не буде зупинено вручну.\n\n`callback`\n\nСмотрите[Спостерігачі callback-функцій](ev.watcher-callbacks.md)\n\n`data`\n\nЦі дані, пов'язані зі спостерігачем.\n\n`priority`\n\n[Пріоритет спостерігача](class.ev.md#ev.constants.watcher-pri)\n\n### Приклади\n\n**Приклад #1 Прості таймери**\n\n```php\n<?php\n// Создаёт и запускает таймер через 2 секунды\n$w1 = new EvTimer(2, 0, function () {\n    echo \"2 секунды прошло\\n\";\n});\n\n// Создаёт и запускает таймер через 2 секунды, повторяя каждую секунду\n// пока мы не остановим его вручную\n$w2 = new EvTimer(2, 1, function ($w) {\n    echo \"вызывается каждую секунду, запускается через 2 секунды\\n\";\n    echo \"итерация = \", Ev::iteration(), PHP_EOL;\n\n    // Останавливаем наблюдателя после 5 итераций\n    Ev::iteration() == 5 and $w->stop();\n    // Останавливаем наблюдателя, если дальнейшие вызовы вызовут более 10 итераций\n    Ev::iteration() >= 10 and $w->stop();\n});\n\n// Создаём остановленный таймер. Он будет неактивным, пока мы не запустим его сами\n$w_stopped = EvTimer::createStopped(10, 5, function($w) {\n    echo \"Callback-функция таймера, созданного как остановленный\\n\";\n\n    // Останавливаем наблюдателя после 2 итераций\n    Ev::iteration() >= 2 and $w->stop();\n});\n\n// Цикл до вызова Ev::stop() или остановки всех наблюдателей\nEv::run();\n\n// Запускаем и смотрим, работает ли он\n$w_stopped->start();\necho \"Запустили одну итерацию\\n\";\nEv::run(Ev::RUN_ONCE);\n\necho \"Перезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем\\n\";\n$w2->again();\nEv::run(Ev::RUN_NOWAIT);\n\n$w = new EvTimer(10, 0, function() {});\necho \"Запуск заблокированного цикла\\n\";\nEv::run();\necho \"END\\n\";\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n2 секунды прошло\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 1\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 2\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 3\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 4\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 5\nЗапустили одну итерацию\nCallback-функция таймера, созданного как остановленный\nПерезапустили второй наблюдатель и пробуем обработать те же события, но не блокируем\nЗапуск заблокированного цикла\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 8\nвызывается каждую секунду, запускается через 2 секунды\nитерация = 9\nитерация каждую секунду, запускается через 2 секунды\nитерация = 10\nEND\n```\n\n### Дивіться також\n\n-   [EvTimer::createStopped()](evtimer.createstopped.md) \\- створює зупинений спостерігач EvTimer\n-   [EvPeriodic](class.evperiodic.md)\n-   [» ev\\_timer - відносний і необов'язково повторюваний час очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_timer_code_relative_and_opti)\n-   [» Будьте обережні з часом очікування](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts)\n","title":"EvTimer::\\_\\_construct","contentType":2,"navigation":[{"evtimer.again.md":"« EvTimer::again"},{"evtimer.createstopped.md":"EvTimer::createStopped »"},{"index.md":"PHP Manual"},{"class.evtimer.md":"EvTimer"}]}},"__N_SSG":true}