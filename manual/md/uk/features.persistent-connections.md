- [« Робота зі з'єднаннями](features.connection-handling.md)
- [Використання PHP у командному рядку »](features.commandline.md)

- [PHP Manual](index.md)
- [Відмінні риси](features.md)
- Постійні з'єднання з базами даних

# Постійні з'єднання з базами даних

Постійні з'єднання є зв'язками з базами даних, які
не закриваються після завершення скрипта. При отриманні запиту на
постійне з'єднання PHP спочатку перевіряє, чи є ідентичне
постійне з'єднання (яке було відкрито за попередніх звернень)
і, якщо таке було знайдено, використовує його. У разі, якщо ідентичного
з'єднання немає, PHP створює нове. Під "ідентичним" мається на увазі
з'єднання, відкрите на тому ж хості з таким же ім'ям користувача та
паролем (якщо вони вказані).

Та частина розробників, яка не має точного уявлення про те,
як працює веб-сервер та як розподіляється навантаження, можуть отримати
помилкове уявлення про те, чим насправді є постійні
з'єднання. Зокрема, постійні з'єднання *не* надають
можливість відкривати "користувацькі сесії" в тому ж самому
з'єднанні, вони *не * дають можливість організовувати більше
ефективні транзакції, також вони не надають безліч інших
корисні можливості. Фактично, постійні з'єднання не
надають *ніякої* функціональності, яка була б неможлива в
непостійних аналогічних сполук.

Чому?

Це залежить від того, як відбувається взаємодія з веб-сервером.
Існує три основні способи використання PHP сервером для генерації
веб-сторінок.

Перший спосіб полягає в тому, щоб використовувати PHP як CGI-обертку.
При цьому PHP-інтерпретатор створюється та знищується при кожному зверненні
до сторінки (PHP-скрипту). Оскільки інтерпретатор знищується після
кожного запиту до сервера, всі використовувані ним ресурси (зокрема і
з'єднання з базою даних) закриваються. Отже, у цьому випадку ви
не отримайте нічого від використання постійних з'єднань - їх просто
ні.

Другий, і найбільш популярний спосіб - використовувати PHP як модуль
сервер, який використовує кілька процесів. Серед таких серверів
зараз входить лише Apache. У такому разі можна виділити один процес
(батьківський), який координує роботу всіх інших процесів
(дочірніх), які фактично та виконують роботу з обслуговування
веб-сторінок. При кожному зверненні клієнта до сервера запит
перенаправляється одному з дочірніх процесів, який на даний момент
не зайнятий обслуговуванням іншого клієнта. Це означає, що коли той самий
самий клієнт виконує повторний запит до сервера, він може бути
оброблений іншим дочірнім процесом, відмінним від того, що був при
першому зверненні. Після відкриття постійного з'єднання кожна
наступна сторінка, що вимагає з'єднання з базою даних, може
використовувати вже встановлене раніше з'єднання із SQL-сервером.

Третій спосіб - використовувати PHP як плагін у багатопоточному
веб-сервер. В даний час у PHP реалізована підтримка ISAPI, WSAPI,
та NSAPI (для Windows-платформ), які дозволяють підключати PHP до таких
багатопотокових серверів, як Netscape FastTrack (iPlanet), Microsoft's
Internet Information Server (IIS) та O'Reilly WebSite Pro. В цьому випадку
поведінка PHP повністю аналогічно розглянутій раніше моделі з
використанням кількох процесів.

Якщо постійні з'єднання не надають жодної додаткової
функціональності, чим вони тоді такі хороші?

Відповідь полягає у підвищенні ефективності. Постійні з'єднання
корисні в тому випадку, якщо при відкритті великої кількості
SQL-з'єднань виникає відчутне навантаження на сервер. Те, наскільки
велике це навантаження, залежить від багатьох факторів. Наприклад, від того,
яка саме база даних використовується, чи вона на тому ж
комп'ютері, що і ваш веб-сервер, наскільки завантажена машина, на якій
встановлений SQL-сервер, і таке інше. У випадку, якщо витрати на встановлення
з'єднання великі, постійні з'єднання можуть суттєво допомогти.
Вони дозволяють дочірньому процесу протягом усього життєвого циклу
використовувати те саме з'єднання замість того, щоб створювати його
при обробці кожної сторінки, яка взаємодіє із SQL-сервером.
Це означає, що кожен дочірній процес, який відкрив постійне
з'єднання, матиме власне з'єднання з сервером.
Наприклад, якщо у вас запущено 20 дочірніх процесів, які виконали
скрипт, який використовує постійне з'єднання з SQL-сервером, ви отримаєте
20 різних з'єднань із SQL-сервером, по одному на кожен дочірній
процес.

Слід зазначити, що цей підхід має деякі недоліки: якщо ви
використовуєте базу даних з обмеженою кількістю можливих
підключень, воно може бути перевищено кількістю запитуваних
дочірніми процесами постійних з'єднань. Наприклад, якщо ваша база
даних дозволяє 16 одночасних з'єднань, і під час навантаження на
сервер 17 дочірніх процесів спробують відкрити з'єднання, одна з
спроб зазнає невдачі. Якщо у вашому коді містяться помилки, не
що дозволяють закривати з'єднання (наприклад, нескінченні цикли), база
даних з 32 одночасними підключеннями незабаром може виявитися
заблокованою. Інформацію про те, як обробляти відкриті та
з'єднання, що не використовуються, ви можете знайти в документації до вашої бази
даних.

**Увага**

Є ще дві додаткові застереження, які слід пам'ятати при
роботи з постійними з'єднаннями. Якщо скрипт блокує
таблицю і з яких-небудь причин не може її звільнити, якщо
використання постійного з'єднання всі наступні скрипти, які
використовують це з'єднання будуть блоковані нескінченно довго і можуть
вимагати рестарту веб-сервера або сервера баз даних. Друге
застереження полягає в тому, що відкриті транзакції, якщо вони не
були закриті до завершення роботи скрипта, будуть продовжені в наступному
скрипт, що використовує це ж постійне з'єднання. Виходячи з цього, ви
Ви можете використовувати функцію
[register_shutdown_function()](function.register-shutdown-function.md)
для вказівки простої функції, яка знімає блокування таблиць або
відкату ваших транзакцій. Ще краще уникнути цих проблем повністю,
використовуючи постійні з'єднання у скриптах, які використовують
блокування таблиць або транзакції (при цьому ви все ще можете
використовувати їх десь у іншому місці).

Важливе резюме. Постійні з'єднання були створені для точного
відображення звичайних з'єднань. Це означає, що у вас завжди
є можливість замінити всі постійні з'єднання непостійними, і це
не позначиться на поведінці скрипта. Така заміна може вплинути
(і, мабуть, вплине) на ефективність роботи скрипта, але ніяк не на
його поведінка.

Дивіться також [ibase_pconnect()](function.ibase-pconnect.md),
[ociplogon()](function.ociplogon.md),
[odbc_pconnect()](function.odbc-pconnect.md),
[oci_pconnect()](function.oci-pconnect.md),
[pfsockopen()](function.pfsockopen.md) та
[pg_pconnect()](function.pg-pconnect.md).
