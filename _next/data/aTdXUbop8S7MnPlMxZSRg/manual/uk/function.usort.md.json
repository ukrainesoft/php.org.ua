{"pageProps":{"page":{"slug":"function.usort.md","content":"# usort\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nusort — Сортує масив за значеннями використовуючи функцію користувача для порівняння елементів\n\n### Опис\n\n```methodsynopsis\nusort(array &$array, callable $callback): true\n```\n\nСортує `array`по значениям, используя предоставленную пользователем функцию сравнения для определения порядка.\n\n> **Зауваження** :\n> \n> Якщо обидва порівнювані значення еквівалентні, вони зберігають свій початковий порядок. До PHP 8.0.0 їх відносний порядок у відсортованому масиві не було визначено.\n\n> **Зауваження**: Ця функція надає нові ключі елементам `array`. Вона видалить усі існуючі ключі, а не просто переупорядкує їх.\n\n### Список параметрів\n\n`array`\n\nВхідний масив\n\n`callback`\n\nФункція порівняння повинна повертати ціле, яке менше, дорівнює чи більше нуля, якщо перший аргумент є відповідно меншим, рівним чи більшим, ніж другий.\n\n```methodsynopsis\ncallback(mixed $a, mixed $b): int\n```\n\n**Застереження**\n\nВозвращение*нецілих* значень з функції порівняння, таких як число з плаваючою точкою (float), призведе до внутрішнього приведення значення callback-функції, що повертається, до цілого числа (int). Таким чином, значення `0.99`и`0.1` будуть приведені до цілого значення що дозволить порівняти ці значення як рівні.\n\n### Значення, що повертаються\n\nФункція завжди повертає **`true`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.2.0 | Тип значення, що повертається тепер **`true`**; раніше було bool. |\n| 8.0.0 | Тепер функція видасть помилку рівня **`E_WARNING`**, якщо параметр callback-функції, переданої у параметр `callback`, очікує на передачу значення за посиланням. |\n\n### Приклади\n\n**Приклад #1 Приклад використання** usort()\\*\\*\\*\\*\n\n```php\n<?php\nfunction cmp($a, $b)\n{\n    if ($a == $b) {\n        return 0;\n    }\n    return ($a < $b) ? -1 : 1;\n}\n\n$a = array(3, 2, 5, 6, 1);\n\nusort($a, \"cmp\");\n\nforeach ($a as $key => $value) {\n    echo \"$key: $value\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n0: 1\n1: 2\n2: 3\n3: 5\n4: 6\n```\n\nДля більшого спрощення внутрішнього порівняння можна використовувати оператор spaceship (космічний корабель).\n\n```php\n<?php\nfunction cmp($a, $b)\n{\n    return $a <=> $b;\n}\n\n$a = array(3, 2, 5, 6, 1);\n\nusort($a, \"cmp\");\n\nforeach ($a as $key => $value) {\n    echo \"$key: $value\\n\";\n}\n?>\n```\n\n> **Зауваження** :\n> \n> Очевидно, що для цього тривіального випадку більш підходить функція [sort()](function.sort.md)\n\n**Приклад #2 Приклад використання функції** usort()\\*\\* з багатовимірними масивами\\*\\*\n\n```php\n<?php\nfunction cmp($a, $b)\n{\n    return strcmp($a[\"fruit\"], $b[\"fruit\"]);\n}\n\n$fruits[0][\"fruit\"] = \"lemons\";\n$fruits[1][\"fruit\"] = \"apples\";\n$fruits[2][\"fruit\"] = \"grapes\";\n\nusort($fruits, \"cmp\");\n\nforeach ($fruits as $key => $value) {\n    echo \"\\$fruits[$key]: \" . $value[\"fruit\"] . \"\\n\";\n}\n?>\n```\n\nПри сортуванні багатовимірного масиву змінні $a і $b містять посилання перші два індексу масиву.\n\nРезультат виконання наведеного прикладу:\n\n```\n$fruits[0]: apples\n$fruits[1]: grapes\n$fruits[2]: lemons\n```\n\n**Приклад #3 Приклад використання** usort()**с методом класса**\n\n```php\n<?php\nclass TestObj {\n    private string $name;\n\n    function __construct($name)\n    {\n        $this->name = $name;\n    }\n\n    /* This is the static comparing function: */\n    static function cmp_obj($a, $b)\n    {\n        return strtolower($a->name) <=> strtolower($b->name);\n    }\n}\n\n$a[] = new TestObj(\"c\");\n$a[] = new TestObj(\"b\");\n$a[] = new TestObj(\"d\");\n\nusort($a, [TestObj::class, \"cmp_obj\"]);\n\nforeach ($a as $item) {\n    echo $item->name . \"\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nb\nc\nd\n```\n\n**Приклад #4 Приклад використання функції** usort()**с применением[анонімної функції](functions.anonymous.md) для сортування багатовимірного масиву**\n\n```php\n<?php\n$array[0] = array('key_a' => 'z', 'key_b' => 'c');\n$array[1] = array('key_a' => 'x', 'key_b' => 'b');\n$array[2] = array('key_a' => 'y', 'key_b' => 'a');\n\nfunction build_sorter($key) {\n    return function ($a, $b) use ($key) {\n        return strnatcmp($a[$key], $b[$key]);\n    };\n}\n\nusort($array, build_sorter('key_b'));\n\nforeach ($array as $item) {\n    echo $item['key_a'] . ', ' . $item['key_b'] . \"\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\ny, a\nx, b\nz, c\n```\n\n**Приклад #5 Приклад використання** usort()\\*\\* з оператором spaceship (космічний корабель)\\*\\*\n\nОператор spaceship (космічний корабель) дозволяє прямолінійно порівнювати складові значення кількох осях. У наступному прикладі `$people` сортується на прізвище, а потім на ім'я, якщо прізвище збігається.\n\n```php\n<?php\n$people[0] = ['first' => 'Adam', 'last' => 'West'];\n$people[1] = ['first' => 'Alec', 'last' => 'Baldwin'];\n$people[2] = ['first' => 'Adam', 'last' => 'Baldwin'];\n\nfunction sorter(array $a, array $b) {\n    return [$a['last'], $a['first']] <=> [$b['last'], $b['first']];\n}\n\nusort($people, 'sorter');\n\nforeach ($people as $person) {\n    print $person['last'] . ', ' . $person['first'] . PHP_EOL;\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nBaldwin, Adam\nBaldwin, Alec\nWest, Adam\n```\n\n### Дивіться також\n\n-   [uasort()](function.uasort.md) \\- Сортує масив користувальницькою функцією порівняння, зберігаючи асоціацію індексів\n-   [uksort()](function.uksort.md) \\- Сортує масив за ключами користувальницькою функцією порівняння\n-   [Порівняння функцій сортування масивів](array.sorting.md)\n","title":"usort","contentType":2,"navigation":[{"function.uksort.md":"« uksort"},{"book.classobj.md":"Класи та об'єкти »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}