- [« Відмінні риси](features.md)
- [Cookies »](features.cookies.md)

- [PHP Manual](index.md)
- [Відмінні риси](features.md)
- HTTP-автентифікація в PHP

# HTTP-автентифікація в PHP

Можливо використовувати функцію [header()](function.header.md) для
надсилання повідомлення ``Authentication Required'` браузеру, змусивши його
показати віконце для введення логіну та паролю. Як тільки користувач
заповнить логін і пароль, посилання, що містить PHP-скрипт, буде викликано ще
разів з [передбаченими змінними](reserved.variables.md)
`PHP_AUTH_USER`, `PHP_AUTH_PW` та `AUTH_TYPE`, встановленими в логін,
пароль та тип аутентифікації відповідно. Ці зумовлені
змінні зберігаються у масиві `$_SERVER`. Підтримуються *лише*:
"Basic" та "Digest". Докладніше дивіться функцію
[header()](function.header.md).

Приклад фрагмента скрипта, який змушує клієнта авторизуватися для
перегляду сторінки:

**Приклад #1 Приклад Basic HTTP-автентифікації**

` <?phpif (!isset($_SERVER['PHP_AUTH_USER']))) {    header('WWW-Authenticate: Basic realmu003d"My Realm"'); header('HTTP/1.0 401 Unauthorized'); echo 'Текст, надсилається в том випадку,    якщо користувач натиснув кнопку Cancel'; exit;} else {    echo "<p>Hello {$_SERVER['PHP_AUTH_USER']}.</p>"; echo "<p>Ви ввели пароль {$_SERVER['PHP_AUTH_PW']}.</p>";}?> `

**Приклад #2 Приклад Digest HTTP-автентифікації**

Це приклад реалізації простого скрипту Digest HTTP аутентифікації. За
подробиці звертайтесь до [» RFC
2617](http://www.faqs.org/rfcs/rfc2617).

` <?php$realm u003d 'Заборонена зона';//user u003d> password$users u003d array('admin' u003d> 'mypass', 'guest' u003d> 'guest');if (empty($_SERVER[') PHP_AUTH_DIGEST'])) {   header('HTTP/1.1 401 Unauthorized'); header('WWW-Authenticate: Digest realmu003d"'.$realm.           '",qopu003d"auth",nonceu003d"'.uniqid().'",opaqueu003d"'.md5($realm).'" '); die('Текст, надсилається в том випадку, якщо користувач натиснувкнопку Cancel');}// аналізуємо змінну PHP_AUTH_DIGESTif (!($data u003d http_digest_parse($||||| data['username']]))   die('Неправильні дані!');// генеруємо коректну відповідь$A1 u003d md5($data['username'] . ':' . $realm . ':' . $ $data['username']]);$A2u003du003dmd5($_SERVER['REQUEST_METHOD'].':'.$data['uri']);$valid_response u003d md5($A1.':'.$data ['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.$A2); if ($data['response'] !u003d $valid_response)   die('Неправильні дані!');// все добре, логін і пароль вірніecho 'Ви увійшли як: ' . $data['username'];// функція розбору заголовка http authfunction http_digest_parse($txt){     // захист від відсутніх даних     $needed_parts '' >1, 'qop'u003d>1, 'username'u003d>1, 'uri'u003d>1, 'response'u003d>1); $datau003du003darray(); $keys u003d implode('|', array_keys($needed_parts)); preg_match_all('@(' . $keys . ')u003d(?:([\'"])([^ ]+?) |([^\s,]+))@', $txt, $ matches,PREG_SET_ORDER);  foreach ($matches as $m) {        $data[$m[1]] u003d $m[3] ? $m[3] :$$  1]]);    }    return $needed_parts ? false : $data;}?> `

> **Примітка**: **Примітка щодо сумісності**
>
> Будьте особливо уважні під час вказівки HTTP-заголовків. Для того,
> щоб гарантувати максимальну сумісність із найбільшим
> кількістю різних клієнтів, слово "Basic" має бути написане з
> великої літери "B", регіон (realm) має бути взятий у подвійні (не
> одинарні!) лапки, і рівно один пробіл повинен передувати коду
> *401* у заголовку *HTTP/1.0 401*. Параметри аутентифікації повинні
> розділятися комами, як це було показано в прикладі Digest
> аутентифікації вище.

Замість простого відображення на екрані змінних `PHP_AUTH_USER` та
`PHP_AUTH_PW`, вам, можливо, знадобиться перевірити їхню коректність.
Використовуйте для цього запит до бази даних або пошук користувача
dbm-файл.

Ви можете переглянути особливості роботи браузера Internet Explorer. Він
дуже вимогливий до параметра заголовків, що передаються. Трюк із зазначенням
заголовка *WWW-Authenticate* перед відправкою статусу `HTTP/1.0 401` поки
що працює для нього.

> **Примітка**: **Примітка щодо конфігурації**
>
> PHP використовує вказівку директиви `AuthType` для вказівки того,
> використовується зовнішня автентифікація чи ні.

Слід зазначити, що все сказане вище не запобігає викраденню
паролів до сторінок, що вимагають авторизації, будь-ким, хто контролює
сторінки без авторизації, розташовані на тому самому сервері.

І Netscape Navigator та Internet Explorer очищають кеш аутентифікації
поточного вікна для заданого регіону (realm) при отриманні від сервера
статусу 401. Це може використовуватися для реалізації примусового
виходу користувача та повторного відображення діалогового вікна для введення
імені користувача та пароля. Деякі розробники використовують це для
обмеження авторизації за часом або для надання кнопки
"Вихід".

**Приклад #3 Приклад HTTP-автентифікації з примусовим введенням нової
пари логін/пароль**

`<?phpfunction authenticate() {    header('WWW-Authenticate: Basic realmu003d"Test Authentication System"'); header('HTTP/1.0 401 Unauthorized'); echo "Ви повинні ввести коректний логін і пароль для отримання доступу к ресурсу
";   exit;}if(!isset($_SERVER['PHP_AUTH_USER']) ||    ($_POST['SeenBefore'] u003du003d 1 && $_POST['OldAuth']_u003du003d $__ER {                                                            ']);    echo "<form actionu003d'' methodu003d'post'>
";   echo "<input typeu003d'hidden' nameu003d'SeenBefore' valueu003d'1' />
";   echo "<input typeu003d'hidden' nameu003d'OldAuth' valueu003d\""" . htmlspecialchars($_SERVER['PHP_AUTH_USER']) . "\" />
";   echo "<input typeu003d'submit' valueu003d'Авторизовуватися повторно' />
";   echo "</form></p>
";}?> `

Ця поведінка не регламентується стандартами
`HTTP Basic`-автентифікації, отже, ви не повинні залежати від
цього. Тестування браузера `Lynx` показало, що `Lynx` не очищає кеш
авторизації при отриманні від сервера статусу 401, та, натиснувши
послідовно "Back", а потім "Forward" можна відкрити таку
сторінку, за умови, що потрібні атрибути авторизації не змінилися.
Однак, користувач може натиснути клавішу ``_'` для очищення кешу
автентифікації.

Щоб домогтися коректної роботи HTTP-аутентифікації в IIS
сервері з CGI версією PHP, ви повинні відредагувати конфігураційну
налаштування IIS під назвою "Directory Security". Клацніть на написи
"`Edit`" та встановіть опцію "`Anonymous Access`", всі інші поля
повинні залишитись невідзначеними.

> **Примітка**: **Примітка щодо IIS:**
> Для того, щоб HTTP-автентифікація коректно працювала в IIS,
> конфігурації PHP-опція
> [cgi.rfc2616_headers](ini.core.md#ini.cgi.rfc2616-headers) має
> бути встановлена значенням `0` (значення за замовчуванням).
