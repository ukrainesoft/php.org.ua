{"pageProps":{"page":{"slug":"function.oci-close.md","content":"# oci\\_close\n\n(PHP 5, PHP 7, PHP 8, PECL OCI8 >= 1.1.0)\n\noci\\_close — Закриває з'єднання із сервером Oracle\n\n### Опис\n\n```methodsynopsis\noci_close(resource $connection): ?bool\n```\n\nЗвільняє `connection`. Відповідне йому з'єднання з базою даних буде закрито за відсутності ресурсів, що його використовують, і якщо воно було отримано з функції [oci\\_connect()](function.oci-connect.md) або [oci\\_new\\_connect()](function.oci-new-connect.md)\n\nРекомендується закривати більше не використовувані з'єднання, т.к. це звільняє ресурси бази даних іншим користувачам.\n\n### Список параметрів\n\n`connection`\n\nІдентифікатор з'єднання Oracle, отриманий із функцій [oci\\_connect()](function.oci-connect.md) [oci\\_pconnect()](function.oci-pconnect.md) або [oci\\_new\\_connect()](function.oci-new-connect.md)\n\n### Значення, що повертаються\n\nПовертає **`null`** якщо [oci8.old\\_oci\\_close\\_semantics](oci8.configuration.md#ini.oci8.old-oci-close-semantics) включений або **`true`** в іншому випадку.\n\n### Приклади\n\n**Приклад #1 Закриття з'єднання**\n\nСупутні з'єднання ресурси мають бути закриті для забезпечення коректного завершення з'єднання з базою даних та звільнення її ресурсів.\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT * FROM departments');\n$r = oci_execute($stid);\noci_fetch_all($stid, $res);\nvar_dump($res);\n\n// Освобождаем идентификатор выражения при закрытии соединения\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #2 З'єднання бази даних не закривається доти, доки не будуть закриті всі посилання на нього**\n\nВнутрішній лічильник посилань (refcount) ідентифікатора з'єднання повинен дорівнювати нулю перед безпосереднім закриттям з'єднання до бази даних.\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT * FROM departments');  // это увеличивает refcount на $conn\noci_execute($stid);\noci_fetch_all($stid, $res);\nvar_dump($res);\n\noci_close($conn);\n\n// $conn больше не может использоваться в данном скрипте, но реальное\n// соединение с базой данных будет открыто, пока не будет освобождена $stid.\nvar_dump($conn);  // выводит NULL\n\n// Пока PHP спит, запрос к виду Oracle V$SESSION в окне терминала\n// покажет, что пользователь базы данных всё ещё подключён.\nsleep(10);\n\n// Как только $stid освобождается, соединение к базе данных физически закрывается\noci_free_statement($stid);\n\n// Пока PHP спит, запрос к виду Oracle V$SESSION в окне терминала\n// покажет, что пользователь базы данных уже отключился.\nsleep(10);\n\n?>\n```\n\n**Приклад #3 Закриття з'єднання, відкритого кілька разів**\n\nПри повторному використанні облікових даних користувача обидві з'єднання повинні бути закриті перед безпосереднім закриттям з'єднання до бази даних.\n\n```php\n<?php\n\n$conn1 = oci_connect('hr', 'welcome', 'localhost/XE');\n\n// Использование тех же учётных данных повторно использует одно и то же\n// соединение с базой данных. Любые незафиксированные изменения в\n// $conn1 будут видны в $conn2\n$conn2 = oci_connect('hr', 'welcome', 'localhost/XE');\n\n// Пока PHP спит, запрос к виду Oracle V$SESSION в окне терминала\n// покажет, что подключён только один пользователь базы данных.\nsleep(10);\n\noci_close($conn1); // не закрывает реальное соединение с базой данных\nvar_dump($conn1);  // выводит NULL, т.к. $conn1 теперь бесполезна\nvar_dump($conn2);  // показывает, что $conn2 всё ещё является корректным ресурсом соединения\n\n?>\n```\n\n**Приклад #4 З'єднання закривається при відході змінних в області видимості**\n\nКоли всі змінні, що посилаються на з'єднання, йдуть з області видимості та звільняються PHP, відбувається відкат транзакції (якщо необхідно) і з'єднання з базою закривається.\n\n```php\n<?php\n\nfunction myfunc() {\n    $conn = oci_connect('hr', 'hrpwd', 'localhost/XE');\n    if (!$conn) {\n        $e = oci_error();\n        trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n    }\n\n    $stid = oci_parse($conn, 'UPDATE mytab SET id = 100');\n    oci_execute($stid, OCI_NO_AUTO_COMMIT);\n    return \"Закончили!\";\n}\n\n$r = myfunc();\n// В этой точке происходит откат транзакции и закрывается соответствующее\n// соединение с базой данных\n\nprint $r;  // отображает возвращённое функцией значение \"Закончили!\"\n\n?>\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Змінні, залежні від ідентифікатора з'єднань, такі як ідентифікатори виразів, отримані з [oci\\_parse()](function.oci-parse.md), повинні бути звільнені до закриття з'єднання з базою даних.\n\n> **Зауваження** :\n> \n> Функция**oci\\_close()** не закриває з'єднання з базою даних, створеними функцією [oci\\_pconnect()](function.oci-pconnect.md)\n\n### Дивіться також\n\n-   [oci\\_connect()](function.oci-connect.md) \\- Встановлює з'єднання з базою даних Oracle\n-   [oci\\_free\\_statement()](function.oci-free-statement.md) \\- Звільняє ресурси, які займає курсор або SQL-вираз.\n","title":"oci\\_close","contentType":2,"navigation":[{"function.oci-client-version.md":"« oci\\_client\\_version"},{"function.oci-commit.md":"oci\\_commit »"},{"index.md":"PHP Manual"},{"ref.oci8.md":"OCI8 Функції"}]}},"__N_SSG":true}