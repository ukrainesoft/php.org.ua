{"pageProps":{"page":{"slug":"language.variables.external.md","content":"## Змінні ззовні PHP\n\n### HTML-форми (GET та POST)\n\nКоли надсилається дані форми PHP-скрипту, інформація з цієї форми автоматично стає доступною йому. Існує кілька способів отримання цієї інформації, наприклад:\n\n**Приклад #1 Проста HTML-форма**\n\nИмя:  \nEmail:\n\nЄ лише два способи отримати доступ до даних форм HTML. Наявні способи наведені нижче:\n\n**Приклад #2 Доступ до даних із простої HTML-форми, надісланої через POST**\n\n```php\n<?php\necho $_POST['username'];\necho $_REQUEST['username'];\n?>\n```\n\nGET-форма використовується аналогічно, за винятком того, що замість POST, вам потрібно буде використовувати відповідну певну змінну GET. GET відноситься також до `QUERY_STRING` (Інформація в URL після '?'). Так наприклад, `http://www.example.com/test.php?id=3` містить GET-дані, доступні як [$\\_GET\\['id'\\]](reserved.variables.get.md)Смотрите также[$\\_REQUEST](reserved.variables.request.md)\n\n> **Зауваження** :\n> \n> Точки та прогалини в іменах змінних перетворюється на символи підкреслення. Наприклад, `<input name=\"a.b\" />`станет`$_REQUEST[\"a_b\"]`\n\nPHP також розуміє масиви в контексті змінних форм (див. [відповідні ЧАВО](faq.md.md)). Наприклад, ви можете згрупувати пов'язані змінні разом або використовувати цю можливість для отримання значень списку множинного вибору select. Наприклад, давайте відправимо форму самої собі, а після відправки відобразимо дані:\n\n**Приклад #3 Складніші змінні форми**\n\n```php\n<?php\nif ($_POST) {\n    echo '<pre>';\n    echo htmlspecialchars(print_r($_POST, true));\n    echo '</pre>';\n}\n?>\n<form action=\"\" method=\"post\">\n    Имя:  <input type=\"text\" name=\"personal[name]\" /><br />\n    Email: <input type=\"text\" name=\"personal[email]\" /><br />\n    Пиво: <br />\n    <select multiple name=\"beer[]\">\n        <option value=\"warthog\">Warthog</option>\n        <option value=\"guinness\">Guinness</option>\n        <option value=\"stuttgarter\">Stuttgarter Schwabenbräu</option>\n    </select><br />\n    <input type=\"submit\" value=\"Отправь меня!\" />\n</form>\n```\n\n> **Зауваження**: Якщо зовнішнє ім'я змінної починається з коректного синтаксису масиву, символи, що завершують, мовчки ігноруються. Наприклад, `<input name=\"foo[bar]baz\">`станет`$_REQUEST['foo']['bar']`\n\n#### Імена змінних кнопки-зображення\n\nПри надсиланні форми замість стандартної кнопки можна використовувати зображення за допомогою тега такого вигляду:\n\nКоли користувач клацне десь на зображенні, відповідна форма буде передана на сервер із двома додатковими змінними - sub\\_x та sub\\_y. Вони містять координати натискання користувача на зображення. Досвідчені програмісти можуть помітити, що насправді імена змінних, відправлених браузером, містять точку, а не підкреслення, але PHP автоматично перетворює точку на підкреслення.\n\n### HTTP Cookies\n\nPHP прозоро підтримує HTTP cookies як визначено в [» RFC 6265](http://www.faqs.org/rfcs/rfc6265). Cookies — це механізм для зберігання даних у віддаленому браузері і, таким чином, відстеження та ідентифікації користувачів, що повернулися. Ви можете встановити cookies за допомогою функції [setcookie()](function.setcookie.md). Cookies є частиною HTTP-заголовка, тому функція SetCookie повинна викликатися до того, як браузеру буде відправлено будь-який висновок. Це те ж обмеження, що й для функції [header()](function.header.md). Дані, що зберігаються в cookie, доступні у відповідних масивах даних cookie, таких як [$\\_COOKIE](reserved.variables.cookies.md) і [$\\_REQUEST](reserved.variables.request.md). Подробиці та приклади дивіться у довідковій сторінці [setcookie()](function.setcookie.md)\n\n> **Зауваження**: Починаючи з PHP 7.2.34, 7.3.23 та 7.4.11, відповідно, *імена* вхідні cookie більше не декодуються з URL-закодованого рядка з міркувань безпеки.\n\nЯкщо ви бажаєте присвоїти безліч значень однієї змінної cookie, ви можете присвоїти їх як масив. Наприклад:\n\n```php\n<?php\n  setcookie(\"MyCookie[foo]\", 'Testing 1', time()+3600);\n  setcookie(\"MyCookie[bar]\", 'Testing 2', time()+3600);\n?>\n```\n\nЦе створить дві різні cookie, хоч у вашому скрипті MyCookie буде тепер одним масивом. Якщо ви бажаєте встановити саме одну cookie з безліччю значень, спочатку розгляньте можливість використання до значень таких функцій, як [serialize()](function.serialize.md) або [explode()](function.explode.md)\n\nЗверніть увагу, що cookie замінить попередню cookie з тим самим ім'ям у вашому браузері, якщо тільки шлях або домен не відрізняються. Так, для застосування кошика покупок ви, можливо, захочете зберегти лічильник. Тобто:\n\n**Приклад #4 Приклад использования[setcookie()](function.setcookie.md)**\n\n```php\n<?php\nif (isset($_COOKIE['count'])) {\n    $count = $_COOKIE['count'] + 1;\n} else {\n    $count = 1;\n}\nsetcookie('count', $count, time()+3600);\nsetcookie(\"Cart[$count]\", $item, time()+3600);\n?>\n```\n\n### Крапки в іменах змінних, що приходять\n\nЯк правило, PHP не змінює переданих скрипту імен змінних. Однак слід зазначити, що точка не є коректним символом імені змінної PHP. Тому розглянемо такий запис:\n\n```php\n<?php\n$varname.ext;  /* неверное имя переменной */\n?>\n```\n\nВ даному випадку інтерпретатор бачить змінну $varname, після якої йде оператор конкатенації, а потім голий рядок (тобто не укладений у лапки рядок, що не відповідає жодному з ключових або зарезервованих слів) 'ext'. Очевидно, що це не дасть очікуваного результату.\n\nЗ цієї причини важливо відзначити, що PHP автоматично замінюватиме будь-які точки в іменах, що приходять змінних на символи підкреслення.\n\n### Визначення типів змінних\n\nОскільки PHP визначає типи змінних і перетворює їх (як правило) у міру необхідності, не завжди очевидно, який тип має змінна в будь-який момент часу. PHP містить кілька функцій, що дозволяють визначити тип змінної, таких як: [gettype()](function.gettype.md) [is\\_array()](function.is-array.md) [is\\_float()](function.is-float.md) [is\\_int()](function.is-int.md) [is\\_object()](function.is-object.md) і [is\\_string()](function.is-string.md)Смотрите также раздел [Типи](language.types.md)\n\nHTTP є текстовим протоколом, і більшість, якщо не все, вміст, що надходить в [суперглобальні масиви](language.variables.superglobals.md), наПриклад,[$\\_POST](reserved.variables.post.md) і [$\\_GET](reserved.variables.get.md)залишиться у вигляді рядків. PHP не перетворюватиме значення на певний тип. У наведеному нижче прикладі [$\\_GET\\[\"var1\"\\]](reserved.variables.get.md) міститиме рядок \"null\", а [$\\_GET\\[\"var2\"\\]](reserved.variables.get.md) - Рядок \"123\".\n\n```\n/index.php?var1=null&var2=123\n```\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.2.34, 7.3.23, 7.4.11 | *імена* вхідні cookie більше не декодуються з URL-закодованого рядка з міркувань безпеки. |\n","title":"Змінні ззовні PHP","contentType":2,"navigation":[{"language.variables.variable.md":"« Змінні змінні"},{"language.constants.md":"Константи »"},{"index.md":"PHP Manual"},{"language.variables.md":"Змінні"}]}},"__N_SSG":true}