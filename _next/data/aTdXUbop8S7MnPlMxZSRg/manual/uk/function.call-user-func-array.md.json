{"pageProps":{"page":{"slug":"function.call-user-func-array.md","content":"# call\\_user\\_func\\_array\n\n(PHP 4 >= 4.0.4, PHP 5, PHP 7, PHP 8)\n\ncall\\_user\\_func\\_array - Викликає callback-функцію з масивом параметрів\n\n### Опис\n\n```methodsynopsis\ncall_user_func_array(callable $callback, array $args): mixed\n```\n\nВикликає callback-функцію `callback`, з параметрами з масиву `args`\n\n### Список параметрів\n\n`callback`\n\nФункція типу, що викликається [callable](language.types.callable.md)\n\n`args`\n\nПараметри, що передаються в функцію, у вигляді масиву.\n\nЯкщо всі ключі `args` є числовими, ключі ігноруються і кожен елемент буде передано до параметра `callback` як позиційний аргумент по порядку.\n\nЯкщо якісь ключі `args` є рядками, ці елементи будуть передані до параметра `callback` як іменовані аргументи з ім'ям, заданим ключем.\n\nВідбудеться непоправна помилка, якщо числовий ключ у `args` з'являється після рядкового ключа або якщо рядковий ключ не збігається з ім'ям будь-якого параметра `callback`\n\n### Значення, що повертаються\n\nПовертає результат функції або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.0.0 | Ключі параметра `args` тепер інтерпретуються як імена параметрів, а чи не ігноруються. |\n\n### Приклади\n\n**Приклад #1 Приклад використання функції** call\\_user\\_func\\_array()\\*\\*\\*\\*\n\n```php\n<?php\nfunction foobar($arg, $arg2) {\n    echo __FUNCTION__, \" got $arg and $arg2\\n\";\n}\nclass foo {\n    function bar($arg, $arg2) {\n        echo __METHOD__, \" got $arg and $arg2\\n\";\n    }\n}\n\n\n// Вызываем функцию foobar() с 2 аргументами\ncall_user_func_array(\"foobar\", array(\"one\", \"two\"));\n\n// Вызываем метод $foo->bar() с 2 аргументами\n$foo = new foo;\ncall_user_func_array(array($foo, \"bar\"), array(\"three\", \"four\"));\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nfoobar got one and two\nfoo::bar got three and four\n```\n\n**Приклад #2 Приклад використання** call\\_user\\_func\\_array()\\*\\* з ім'ям простору імен\\*\\*\n\n```php\n<?php\n\nnamespace Foobar;\n\nclass Foo {\n    static public function test($name) {\n        print \"Hello {$name}!\\n\";\n    }\n}\n\ncall_user_func_array(__NAMESPACE__ .'\\Foo::test', array('Hannes'));\n\ncall_user_func_array(array(__NAMESPACE__ .'\\Foo', 'test'), array('Philip'));\n\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nHello Hannes!\nHello Philip!\n```\n\n**Приклад #3 Використання лямбда-функції**\n\n```php\n<?php\n\n$func = function($arg1, $arg2) {\n    return $arg1 * $arg2;\n};\n\nvar_dump(call_user_func_array($func, array(2, 4)));\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(8)\n```\n\n**Приклад #4 Передача значень за посиланням**\n\n```php\n<?php\n\nfunction mega(&$a){\n    $a = 55;\n    echo \"function mega \\$a=$a\\n\";\n}\n$bar = 77;\ncall_user_func_array('mega',array(&$bar));\necho \"global \\$bar=$bar\\n\";\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nfunction mega $a=55\nglobal $bar=55\n```\n\n**Приклад #5 Приклад використання** call\\_user\\_func\\_array()\\*\\* з іменованими аргументами\\*\\*\n\n```php\n<?php\nfunction foobar($first, $second) {\n    echo __FUNCTION__, \" получает $first и $second\\n\";\n}\n\n// Вызов функции foobar() с именованными аргументами в непозиционном порядке\ncall_user_func_array(\"foobar\", array(\"second\" => \"two\", \"first\" => \"one\"));\n\n// Вызов функции foobar() с одним именованным аргументом\ncall_user_func_array(\"foobar\", array(\"foo\", \"second\" => \"bar\"));\n\n// Неисправимая ошибка: Невозможно использовать позиционный аргумент после именованного аргумента\ncall_user_func_array(\"foobar\", array(\"first\" => \"one\", \"bar\"));\n\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nfoobar получает one и two\nfoobar получает foo и bar\n\nFatal error: Uncaught Error: Cannot use positional argument after named argument\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Callback-функції, зареєстровані такими функціями як [call\\_user\\_func()](function.call-user-func.md)и**call\\_user\\_func\\_array()**, не будуть викликані за наявності не спійманого виключення, кинутого у попередній callback-функції.\n\n### Дивіться також\n\n-   [call\\_user\\_func()](function.call-user-func.md) \\- Викликає callback-функцію, задану у першому параметрі\n-   [ReflectionFunction::invokeArgs()](reflectionfunction.invokeargs.md) \\- Виклик функції із передачею аргументів\n-   [ReflectionMethod::invokeArgs()](reflectionmethod.invokeargs.md) \\- виклик методу з передачею аргументів масивом\n","title":"call\\_user\\_func\\_array","contentType":2,"navigation":[{"ref.funchand.md":"« Функції керування функціями"},{"function.call-user-func.md":"call\\_user\\_func »"},{"index.md":"PHP Manual"},{"ref.funchand.md":"Функції керування функціями"}]}},"__N_SSG":true}