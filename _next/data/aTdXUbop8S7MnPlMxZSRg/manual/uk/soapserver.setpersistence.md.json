{"pageProps":{"page":{"slug":"soapserver.setpersistence.md","content":"# SoapServer::setPersistence\n\n(PHP 5, PHP 7, PHP 8)\n\nSoapServer::setPersistence — Встановлює режим збереження SoapServer\n\n### Опис\n\n```methodsynopsis\npublic SoapServer::setPersistence(int $mode): void\n```\n\nЦя функція дозволяє змінювати режим збереження об'єкта SoapServer між запитами. Ця функція дозволяє зберігати дані між запитами, використовуючи механізм сесій PHP. Цей метод впливає лише на SoapServer після експорту функцій, використовуючи [SoapServer::setClass()](soapserver.setclass.md)\n\n> **Зауваження** :\n> \n> Сохранение\\*\\*`SOAP_PERSISTENCE_SESSION`\\*\\* гарантує збереження лише об'єктів заданого класу, але з статичні дані класу. У цьому випадку використовуйте $this->bar замість self::$bar.\n\n> **Зауваження** :\n> \n> **`SOAP_PERSISTENCE_SESSION`** серіалізує дані об'єкта класу та зберігає їх між запитами. Для коректної роботи з ресурсами (наприклад, [PDO](class.pdo.md)), слід використовувати магічні методи [\\_\\_wakeup()](language.oop5.magic.md#object.wakeup) і [\\_\\_sleep()](language.oop5.magic.md#object.sleep)\n\n### Список параметрів\n\n`mode`\n\nОдна из констант`SOAP_PERSISTENCE_XXX`\n\n**`SOAP_PERSISTENCE_REQUEST`** - дані SoapServer не зберігаються між запитами. Ця поведінка **за замовчуванням** будь-якого об'єкта SoapServer після виклику setClass.\n\n**`SOAP_PERSISTENCE_SESSION`** - Дані SoapServer зберігаються між запитами. Це досягається шляхом серіалізації об'єкта SoapServer в [$\\_SESSION\\['\\_bogus\\_session\\_name'\\]](reserved.variables.session.md), отже необхідно викликати [session\\_start()](function.session-start.md) перед увімкненням цього режиму.\n\n### Значення, що повертаються\n\nФункція не повертає значення після виконання.\n\n### Приклади\n\n**Приклад #1 Приклад використання** SoapServer::setPersistence()\\*\\*\\*\\*\n\n```php\n<?php\n class MyFirstPersistentSoapServer {\n     private $resource; // (Такие как PDO, mysqli и т.д.)\n     public $myvar1;\n     public $myvar2;\n\n     public function __construct() {\n         $this->__wakeup(); // Вызываем __wakeup для пересоздания $resource\n     }\n\n     public function __wakeup() {\n         $this->resource = CodeToStartOurResourceUp();\n     }\n\n     public function __sleep() {\n         // Не сохраняем $resource здесь.\n         // Ошибка в этом методе приведёт к тому, что при последующей десериализации\n         // мы не сможем восстановить состояние объекта.\n         return array('myvar1','myvar2');\n     }\n }\n\n try {\n     session_start();\n     $server = new SoapServer(null, array('uri' => $_SERVER['REQUEST_URI']));\n     $server->setClass('MyFirstPersistentSoapServer');\n     // setPersistence НЕОБХОДИМО вызвать после setClass, поскольку setClass\n     // принудительно устанавливает SESSION_PERSISTENCE_REQUEST.\n     $server->setPersistence(SOAP_PERSISTENCE_SESSION);\n     $server->handle();\n } catch(SoapFault $e) {\n     error_log(\"ОШИБКА SOAP: \". $e->getMessage());\n }\n?>\n```\n\n### Дивіться також\n\n-   [SoapServer::setClass()](soapserver.setclass.md) \\- Встановлює клас, який обробляє SOAP-запити\n","title":"SoapServer::setPersistence","contentType":2,"navigation":[{"soapserver.setobject.md":"« SoapServer::setObject"},{"class.soapfault.md":"SoapFault »"},{"index.md":"PHP Manual"},{"class.soapserver.md":"SoapServer"}]}},"__N_SSG":true}