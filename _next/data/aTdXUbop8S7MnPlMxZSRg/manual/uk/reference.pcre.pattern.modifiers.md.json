{"pageProps":{"page":{"slug":"reference.pcre.pattern.modifiers.md","content":"# Модифікатори шаблонів\n\nНижче наведено всі доступні на сьогоднішній день модифікатори. Ім'я, взяте в круглі дужки, вказує на внутрішнє PCRE-ім'я для даного модифікатора. Пробіли та переклади рядків у модифікаторах ігноруються, інші символи викликають помилки.\n\n> *i* `PCRE_CASELESS`) .\n> \n> Якщо цей модифікатор використовується, символи шаблону відповідають символам як верхнього, так і нижнього регістра.\n> \n> *m* `PCRE_MULTILINE`) .\n> \n> За замовчуванням PCRE обробляє дані як рядковий символьний рядок (навіть якщо він містить кілька роздільників рядків). Метасимвол початку рядка '^' відповідає тільки початку тексту, що обробляється, в той час як метасимвол \"кінець рядка\" '$' відповідає кінцю тексту, або позиції перед завершальним текстом перекладом рядка (у разі, якщо модифікатор *D* не встановлений). У Perl ситуація повністю аналогічна. Якщо цей модифікатор використовується, метасимволи \"початок рядка\" і \"кінець рядка\" також відповідають позиціям перед довільним символом перекладу та рядки і, відповідно, як і на самому початку і в самому кінці рядка. Це відповідає Perl-модифікатору /m. У випадку, якщо текст, що обробляється, не містить символів перекладу рядка, або шаблон не містить метасимволів '^' або '$', даний модифікатор не має жодного ефекту.\n> \n> *s* `PCRE_DOTALL`) .\n> \n> Якщо цей модифікатор використовується, метасимвол \"точка\" у шаблоні відповідає всім символам, включаючи переклад рядків. Без нього – всі символи, окрім перекладів рядків. Цей модифікатор еквівалентний запису /s Perl. Клас символів, побудований на запереченні, наприклад \\[^a\\]завжди відповідає перекладу рядка, незалежно від наявності цього модифікатора.\n> \n> *x* `PCRE_EXTENDED`) .\n> \n> Якщо використовується модифікатор, неекрановані пробіли, символи табуляції та порожнього рядка будуть проігноровані в шаблоні, якщо вони не є частиною символьного класу. Також ігноруються всі символи між неекранованим символом '#' (якщо не є частиною символьного класу) і символом перекладу рядка (включаючи самі символи '#'\\\\n' та '#'). Це еквівалентно Perl-модифікатору /x і дозволяє розміщувати коментар у складних шаблонах. Примітка: це стосується лише символьних даних. Пробільні символи не фігурують у службових символьних послідовностях, наприклад, у послідовності '(?('), що відкриває умовну підмаску.\n> \n> *A* `PCRE_ANCHORED`) .\n> \n> Якщо використовується даний модифікатор, відповідність шаблону буде досягатися тільки в тому випадку, якщо він \"заякорений\", тобто відповідає початку рядка, в якому проводиться пошук. Того ж ефекту можна досягти відповідної конструкцією з вкладеним шаблоном, яка є єдиним способом реалізації цієї поведінки в Perl.\n> \n> *D* `PCRE_DOLLAR_ENDONLY`) .\n> \n> Якщо використовується цей модифікатор, метасимвол $ у шаблоні відповідає лише закінченню даних, що обробляються. Без цього модифікатора метасимвол $ відповідає також позиції перед останнім символом у разі, якщо ним є переклад рядка (але не поширюється на будь-які інші переклади рядків). Цей модифікатор ігнорується, якщо використовується модифікатор *m*. У мові Perl аналогічний модифікатор відсутній.\n> \n> *S*\n> \n> Якщо планується багаторазово використовувати шаблон, має сенс витратити трохи більше часу на його аналіз, щоб зменшити час його виконання. Якщо цей модифікатор використовується, проводиться додатковий аналіз шаблону. В даний час це має сенс тільки для \"незакорінних\" шаблонів, що не починаються з певного символу.\n> \n> *U* `PCRE_UNGREEDY`) .\n> \n> Цей модифікатор інвертує жадібність квантіфікаторів, таким чином вони за замовчуванням не жадібні. Але стають жадібними, якщо за ними слідує символ `?` . Така можливість не сумісна з Perl. Його також можна встановити за допомогою (`?U` [установки модифікатора всередині шаблону](regexp.reference.internal-options.md)или добавив знак вопроса после квантификатора (наПриклад,`.*?`\n> \n> > **Зауваження** :\n> > \n> > У нежадібному режимі зазвичай неможливий збіг символів, що перевищують [pcre.backtrack\\_limit](pcre.configuration.md#ini.pcre.backtrack-limit)\n> \n> *X* `PCRE_EXTRA`) .\n> \n> Цей модифікатор включає додаткову функціональність PCRE, яка не сумісна з Perl: будь-який зворотний сліш у шаблоні, за яким слідує символ, що не має спеціального значення, призводять до помилки. Це пов'язано з тим, що такі комбінації зарезервовані задля її подальшого розвитку. За замовчуванням, як і в Perl, зліш із наступним за ним символом без спеціального значення трактується як помилка. На сьогоднішній день це всі можливості, які керуються цим модифікатором\n> \n> *J* `PCRE_INFO_JCHANGED`) .\n> \n> Модифікатор (?J) змінює значення локальної опції `PCRE_DUPNAMES` - Підшаблони можуть мати однакові імена. Модифікатор `J` підтримується із версії PHP 7.2.0.\n> \n> *u* `PCRE_UTF8`) .\n> \n> Цей модифікатор включає додаткову функціональність PCRE, яка не сумісна з Perl: шаблон та цільовий рядок обробляються як рядок UTF-8. Неприпустимий цільовий рядок призводить до того, що функції preg\\_\\* нічого не знаходять, а неправильний шаблон призводить до помилки рівня E\\_WARNING. П'ятий та шостий октети UTF-8 послідовності розглядаються неприпустимими.\n> \n> *n* `PCRE_NO_AUTO_CAPTURE`) .\n> \n> Модифікатор робить прості групи `(xyz)` не захоплюваними. Перехоплюються лише іменовані подібні групи `(?<name>xyz)`. Це впливає тільки на те, які групи перехоплюються, як і раніше, можна використовувати нумеровані посилання на підшаблони і масив збігів, як і раніше, буде містити нумеровані результати.\n","title":"Модифікатори шаблонів","contentType":2,"navigation":[{"regexp.reference.performance.md":"« Продуктивність"},{"reference.pcre.pattern.differences.md":"Відмінності від Perl »"},{"index.md":"PHP Manual"},{"pcre.pattern.md":"Регулярні вирази PCRE"}]}},"__N_SSG":true}