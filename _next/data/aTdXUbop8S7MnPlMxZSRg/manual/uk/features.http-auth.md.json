{"pageProps":{"page":{"slug":"features.http-auth.md","content":"# HTTP-автентифікація в PHP\n\nМожливо використовувати функцію [header()](function.header.md)для отправки сообщения`\"Authentication Required\"` браузеру, змусивши його показати віконце для введення логіну та пароля. Як тільки користувач заповнить логін і пароль, посилання, що містить PHP-скрипт, буде викликане ще раз з [зумовленими змінними](reserved.variables.md)PHP\\_AUTH\\_USER, PHP\\_AUTH\\_PW та AUTH\\_TYPE, встановленими в логін, пароль та тип аутентифікації відповідно. Ці зумовлені змінні зберігаються у масиві [$\\_SERVER](reserved.variables.server.md). Підтримуються *тільки*: \"Basic\" та \"Digest\". Докладніше дивіться функцію [header()](function.header.md)\n\nПриклад фрагмента скрипта, який змушує клієнта авторизуватись для перегляду сторінки:\n\n**Приклад #1 Приклад Basic HTTP-автентифікації**\n\n```php\n<?php\nif (!isset($_SERVER['PHP_AUTH_USER'])) {\n    header('WWW-Authenticate: Basic realm=\"My Realm\"');\n    header('HTTP/1.0 401 Unauthorized');\n    echo 'Текст, отправляемый в том случае,\n    если пользователь нажал кнопку Cancel';\n    exit;\n} else {\n    echo \"<p>Hello {$_SERVER['PHP_AUTH_USER']}.</p>\";\n    echo \"<p>Вы ввели пароль {$_SERVER['PHP_AUTH_PW']}.</p>\";\n}\n?>\n```\n\n**Приклад #2 Приклад Digest HTTP-автентифікації**\n\nЦе приклад реалізації простого скрипту Digest HTTP аутентифікації. За подробицями звертайтесь до [» RFC 2617](http://www.faqs.org/rfcs/rfc2617)\n\n```php\n<?php\n$realm = 'Запретная зона';\n\n//user => password\n$users = array('admin' => 'mypass', 'guest' => 'guest');\n\n\nif (empty($_SERVER['PHP_AUTH_DIGEST'])) {\n    header('HTTP/1.1 401 Unauthorized');\n    header('WWW-Authenticate: Digest realm=\"'.$realm.\n           '\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.md5($realm).'\"');\n\n    die('Текст, отправляемый в том случае, если пользователь нажал кнопку Cancel');\n}\n\n\n// анализируем переменную PHP_AUTH_DIGEST\nif (!($data = http_digest_parse($_SERVER['PHP_AUTH_DIGEST'])) ||\n    !isset($users[$data['username']]))\n    die('Неправильные данные!');\n\n\n// генерируем корректный ответ\n$A1 = md5($data['username'] . ':' . $realm . ':' . $users[$data['username']]);\n$A2 = md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']);\n$valid_response = md5($A1.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.$A2);\n\nif ($data['response'] != $valid_response)\n    die('Неправильные данные!');\n\n// все хорошо, логин и пароль верны\necho 'Вы вошли как: ' . $data['username'];\n\n\n// функция разбора заголовка http auth\nfunction http_digest_parse($txt)\n{\n    // защита от отсутствующих данных\n    $needed_parts = array('nonce'=>1, 'nc'=>1, 'cnonce'=>1, 'qop'=>1, 'username'=>1, 'uri'=>1, 'response'=>1);\n    $data = array();\n    $keys = implode('|', array_keys($needed_parts));\n\n    preg_match_all('@(' . $keys . ')=(?:([\\'\"])([^\\2]+?)\\2|([^\\s,]+))@', $txt, $matches, PREG_SET_ORDER);\n\n    foreach ($matches as $m) {\n        $data[$m[1]] = $m[3] ? $m[3] : $m[4];\n        unset($needed_parts[$m[1]]);\n    }\n\n    return $needed_parts ? false : $data;\n}\n?>\n```\n\n> **Зауваження** **Зауваження щодо сумісності**\n> \n> Будьте особливо уважні під час вказівки HTTP-заголовків. Для того, щоб гарантувати максимальну сумісність з найбільшою кількістю різних клієнтів, слово \"Basic\" має бути написане з великої літери \"B\", регіон (realm) повинен бути взятий у подвійні (не одинарні!) лапки, і рівно одна прогалина повинна передувати коду *401* у заголовку *HTTP/1.0 401*. Параметри автентифікації повинні розділятися комами, як це було показано у прикладі Digest автентифікації вище.\n\nЗамість простого відображення на екрані змінних PHP\\_AUTH\\_USER та PHP\\_AUTH\\_PW, вам, можливо, знадобиться перевірити їхню коректність. Використовуйте для цього запит до бази даних або пошук користувача в файлі dbm.\n\nВи можете переглянути особливості роботи браузера Internet Explorer. Він дуже вимогливий до параметра заголовків, що передаються. Трюк із зазначенням заголовка *WWW-Authenticate*перед отправкой статуса`HTTP/1.0 401` поки що працює для нього.\n\n> **Зауваження** **Примітка щодо конфігурації**\n> \n> PHP використовує вказівку директиви `AuthType` для вказівки того, використовується зовнішня автентифікація чи ні.\n\nСлід зазначити, що все сказане вище не запобігає викрадання паролів до сторінок, що вимагають авторизацію, будь-ким, хто контролює сторінки без авторизації, розташовані на тому ж сервері.\n\nІ Netscape Navigator та Internet Explorer очищають кеш аутентифікації поточного вікна для заданого регіону (realm) при отриманні від сервера статусу 401. Це може використовуватися для реалізації примусового виходу користувача та повторного відображення діалогового вікна для введення імені користувача та пароля. Деякі розробники використовують це для обмеження авторизації за часом або надання кнопки \"Вихід\".\n\n**Приклад #3 Приклад HTTP-автентифікації з введенням нової пари логін/пароль**\n\n```php\n<?php\nfunction authenticate() {\n    header('WWW-Authenticate: Basic realm=\"Test Authentication System\"');\n    header('HTTP/1.0 401 Unauthorized');\n    echo \"Вы должны ввести корректный логин и пароль для получения доступа к ресурсу \\n\";\n    exit;\n}\n\nif (!isset($_SERVER['PHP_AUTH_USER']) ||\n    ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {\n    authenticate();\n} else {\n    echo \"<p>Добро пожаловать: \" . htmlspecialchars($_SERVER['PHP_AUTH_USER']) . \"<br />\";\n    echo \"Предыдущий логин: \" . htmlspecialchars($_REQUEST['OldAuth']);\n    echo \"<form action='' method='post'>\\n\";\n    echo \"<input type='hidden' name='SeenBefore' value='1' />\\n\";\n    echo \"<input type='hidden' name='OldAuth' value=\\\"\" . htmlspecialchars($_SERVER['PHP_AUTH_USER']) . \"\\\" />\\n\";\n    echo \"<input type='submit' value='Авторизоваться повторно' />\\n\";\n    echo \"</form></p>\\n\";\n}\n?>\n```\n\nЦя поведінка не регламентується стандартами `HTTP Basic`\\-аутентифікації, отже, ви не повинні залежати від цього. Тестування браузера `Lynx` показало, що `Lynx` не очищає кеш авторизації при отриманні від сервера статусу 401, і, натиснувши послідовно \"Back\", а потім \"Forward\" можна відкрити таку сторінку, за умови, що необхідні атрибути авторизації не змінилися. Однак користувач може натиснути клавішу `'_'` для очищення кешу автентифікації.\n\nДля того, щоб досягти коректної роботи HTTP-аутентифікації в IIS сервері з CGI версією PHP, ви повинні відредагувати конфігураційне налаштування IIS під назвою \"`Directory Security`\". Клацніть на написи\"`Edit`\" та встановіть опцію \"`Anonymous Access`\"Всі інші поля повинні залишитися невідзначеними.\n\n> **Зауваження** **Примітка щодо IIS:**  \n> Для того, щоб HTTP-автентифікація коректно працювала в IIS, у конфігурації PHP-опція [cgi.rfc2616\\_headers](ini.core.md#ini.cgi.rfc2616-headers) має бути встановлена ​​значенням (значение по умолчанию).\n","title":"HTTP-автентифікація в PHP","contentType":2,"navigation":[{"features.md":"\" Особливості"},{"features.cookies.md":"Cookies »"},{"index.md":"PHP Manual"},{"features.md":"Особливості"}]}},"__N_SSG":true}