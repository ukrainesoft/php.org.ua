- [« Цілі числа](language.types.integer.md)
- [Рядки »](language.types.string.md)

- [PHP Manual](index.md)
- [Типи](language.types.md)
- Числа з плаваючою точкою

## Числа з плаваючою точкою

Числа з плаваючою точкою або числа з плаваючою комою (також відомі
як "float", "double" або "real") можуть бути визначені такими
синтаксисами:

` <?php$a u003d 1.234;$b u003d 1.2e3;$c u003d 7E-10;$d u003d 1_234.567; // починаючи с PHP 7.4.0?> `

Формально, починаючи з PHP 7.4.0 (раніше підкреслення не дозволялося):

LNUM [0-9]+(_[0-9]+)*
DNUM ([0-9]*(_[0-9]+)*[\.]{LNUM}) | ({LNUM}[\.][0-9]*(_[0-9]+)*)
EXPONENT_DNUM (({LNUM} | {DNUM}) [eE][+-]? {LNUM})

Розмір числа з плаваючою точкою залежить від платформи, хоча максимум як
правило, становить 1.8e308 з точністю близько 14 десяткових цифр
(64-бітний формат IEEE).

**Увага**

# Точність чисел з плаваючою точкою

Числа з плаваючою точкою мають обмежену точність. Хоча це залежить
від операційної системи, в PHP зазвичай використовується подвійний формат
точності IEEE 754, що дає максимальну відносну помилку заокруглення
порядку 1.11e-16. Неелементарні арифметичні операції можуть давати
великі помилки, і, зрозуміло, необхідно брати до уваги
поширення помилок при спільному використанні кількох операцій.

Крім того, раціональні числа, які можуть бути точно представлені в
вигляді чисел з плаваючою точкою з основою 10, наприклад, `0.1` або
`0.7`, не мають точного внутрішнього уявлення як чисел з
плаваючою точкою з основою 2, незалежно від розміру мантиси.
Тому вони і не можуть бути перетворені на їхню внутрішню двійкову форму
без невеликої втрати точності. Це може призвести до несподіваних
результатам: наприклад, `floor((0.1+0.7)*10)` швидше за все поверне `7`
замість очікуваного `8`, тому що результат внутрішньої вистави буде
чимось на зразок `7.999999999999991118...`.

Так що ніколи не довіряйте точності чисел з плаваючою точкою до
останньої цифри і не перевіряйте прямо їхню рівність. якщо вам
дійсно необхідна висока точність, використовуйте [математичні
функції довільної точності] (ref.bc.md) та
[gmp](ref.gmp.md)-функції.

"Просте" пояснення можна знайти в [» посібнику за числами з плаваючою
точкою](http://floating-point-gui.de/), яке також називається "Why
don’t my numbers add up?" ("Чому мої числа не складаються?")

### Перетворення в число з плаваючою точкою

#### З рядків

Якщо рядок [містить число](language.types.numeric-strings.md) або
провідну числову послідовність, тоді вона буде перетворена на
відповідне значення з плаваючою точкою, інакше вона
перетворюється на нуль (`0`).

#### З інших типів

Для значень інших типів перетворення виконується шляхом
перетворення значення спочатку в ціле число (int), а потім у число з
плаваючою точкою (float). Дивіться [Перетворення на ціле
число](language.types.integer.md#language.types.integer.casting) для
отримання додаткової інформації.

> **Примітка**:
>
> Оскільки певні типи мають невизначену поведінку при
> перетворенні на ціле число (int), те саме відбувається і при
> перетворенні на число з плаваючою точкою (float).

### Порівняння чисел з плаваючою точкою

Як зазначено вище, перевіряти числа з плаваючою точкою на рівність
проблематично через їхнє внутрішнього уявлення. Проте,
існують способи їх порівняння, які працюють попри все
ці обмеження.

Для порівняння чисел із плаваючою точкою використовується верхня межа
відносної помилки при заокругленні. Ця величина називається машинною
епсилон або одиницею округлення (unit roundoff) і є
найменшу допустиму різницю при розрахунках.

$a і $b рівні до 5-ти знаків після точки.

`<?php$a u003d 1.23456789;$b u003d 1.23456780;$epsilon u003d 0.00001;if (abs($a - $b) < $epsilon) {     

### NaN

Деякі числові операції можуть повертати значення, яке надається
константою **`NAN`**. Цей результат означає невизначене або
незрозуміле значення в операціях з плаваючою точкою. Будь-яке строге
або не суворе порівняння даного значення з іншим значенням, крім
**`true`**, включаючи його самого, поверне **`false`**.

Оскільки **`NAN`** є необмеженою кількістю різних
значень, то **`NAN`** не слід порівнювати з іншими значеннями,
включаючи її саму. Натомість, для визначення її наявності необхідно
використовувати функцію [is_nan()](function.is-nan.md).
