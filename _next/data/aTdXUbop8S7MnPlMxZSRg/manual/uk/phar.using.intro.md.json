{"pageProps":{"page":{"slug":"phar.using.intro.md","content":"## Використання Phar-архівів: Вступ\n\nКонцептуально Phar-архіви аналогічні JAR-архівам Java, але враховують потреби та гнучкість PHP-додатків. Phar-архів використовується для поширення закінченого PHP-програми або бібліотеки у вигляді одного файлу. Додаток, що має вигляд Phar-архіву, використовується в точності так само, як і будь-який інший PHP-додаток:\n\n```\nphp coolapplication.phar\n```\n\nВикористання бібліотеки, що має вигляд Phar-архіву, ідентичне використанню будь-якої іншої PHP-бібліотеки:\n\n```php\n<?php\ninclude 'coollibrary.phar';\n?>\n```\n\nОбгортка потоку `phar` є основою модуля phar, для її використання докладно написано [тут](phar.using.stream.md). Обгортка потоку `phar` надає доступ до файлів усередині phar-архіву з використанням стандартних файлових функцій PHP: [fopen()](function.fopen.md) [opendir()](function.opendir.md) та інших, які працюють із звичайними файлами. Обгортка потоку `phar` підтримує всі операції читання/запису як над файлами, і над каталогами.\n\n```php\n<?php\ninclude 'phar://coollibrary.phar/internal/file.php';\nheader('Content-type: image/jpeg');\n// доступ к phar-архивам может осуществляться по полному пути или с помощью псевдонима\necho file_get_contents('phar:///полный/путь/к/coollibrary.phar/images/wow.jpg');\n?>\n```\n\nКласс[Phar](class.phar.md) реалізує розширені можливості доступу до файлів і створення phar-архівів. Використання класу Phar докладно описано [тут](phar.using.object.md)\n\n```php\n<?php\ntry {\n    // открыть существующий phar-архив\n    $p = new Phar('coollibrary.phar', 0);\n    // Phar наследует SPL-класс DirectoryIterator\n    foreach (new RecursiveIteratorIterator($p) as $file) {\n        // $file является объектом класса PharFileInfo, который наследует SplFileInfo\n        echo $file->getFileName() . \"\\n\";\n        echo file_get_contents($file->getPathName()) . \"\\n\"; // отображает содержимое;\n    }\n    if (isset($p['internal/file.php'])) {\n        var_dump($p['internal/file.php']->getMetadata());\n    }\n\n    // создать новый phar-архив - параметр phar.readonly в php.ini должен быть 0\n    // phar.readonly включён по умолчанию из соображений безопасности.\n    // На работающих серверах phar-архивы никогда не должны создаваться,\n    // а только выполняться.\n    if (Phar::canWrite()) {\n        $p = new Phar('newphar.tar.phar', 0, 'newphar.tar.phar');\n        // создать phar-архив, основанный на tar, сжатый gzip-сжатием (.tar.gz)\n        $p = $p->convertToExecutable(Phar::TAR, Phar::GZ);\n\n        // создать транзакцию - в newphar.phar ничего не будет записано\n        // до тех пор, пока не будет вызван stopBuffering(), однако для этого требуется временное хранилище\n        $p->startBuffering();\n        // добавить все файлы в каталоге /путь/к/проекту/project, сохранение в phar-архив с префиксом \"project\"\n        $p->buildFromIterator(new RecursiveIteratorIterator(new RecursiveDirectoryIterator('/путь/к/проекту/project')), '/путь/к/проекту/');\n\n        // добавить новый файл используя ArrayAccess\n        $p['file1.txt'] = 'Информация';\n        $fp = fopen('hugefile.dat', 'rb');\n        // скопировать все данные из потока\n        $p['data/hugefile.dat'] = $fp;\n\n        if (Phar::canCompress(Phar::GZ)) {\n            $p['data/hugefile.dat']->compress(Phar::GZ);\n        }\n\n        $p['images/wow.jpg'] = file_get_contents('images/wow.jpg');\n        // любое значение может быть сохранено в качестве метаданных файла\n        $p['images/wow.jpg']->setMetadata(array('mime-type' => 'image/jpeg'));\n        $p['index.php'] = file_get_contents('index.php');\n        $p->setMetadata(array('bootstrap' => 'index.php'));\n\n        // сохранить phar-архив на диск\n        $p->stopBuffering();\n    }\n} catch (Exception $e) {\n    echo 'Невозможно открыть Phar: ', $e;\n}\n?>\n```\n\nКрім того, перевірка вмісту phar-файлу може бути здійснена за допомогою будь-якого з підтримуваних симетричних алгоритмів хешування (MD5, SHA1, SHA256 та SHA512, якщо ext/hash включений), а також за допомогою підписування асиметричними відкритим/закритим ключами, використовуючи OpenSSL. Для того щоб використовувати підписування OpenSSL, вам необхідно згенерувати пару з відкритого та закритого ключів та встановити закритий ключ для підписування, використовуючи [Phar::setSignatureAlgorithm()](phar.setsignaturealgorithm.md). Крім того, відкритий ключ, витягнутий за допомогою цього коду:\n\n```php\n<?php\n$public = openssl_get_publickey(file_get_contents('private.pem'));\n$pkey = '';\nopenssl_pkey_export($public, $pkey);\n?>\n```\n\nповинен бути збережений поруч із phar-архівом, для перевірки якого він використовується. Якщо phar-архів збережений як `/шлях/до/моєму/архіву/my.phar`, то відкритий ключ повинен бути збережений як `/шлях/до/моєму/архіву/my.phar.pubkey`, інакше phar не зможе перевірити справжність підпису OpenSSL.\n\nКласс[Phar](class.phar.md) також надає 3 статичні методи: [Phar::webPhar()](phar.webphar.md) [Phar::mungServer()](phar.mungserver.md) і [Phar::interceptFileFuncs()](phar.interceptfilefuncs.md), які мають вирішальне значення для упаковки PHP-додатків, призначених для використання на звичайних файлових системах та для веб-додатків . [Phar::webPhar()](phar.webphar.md) реалізує фронтальний контролер, який направляє HTTP-дзвінки у правильне місце всередині phar-архіву . [Phar::mungServer()](phar.mungserver.md) використовується для зміни значень масиву [$\\_SERVER](reserved.variables.server.md)що дозволяє обдурити додатки, що обробляють ці значення . [Phar::interceptFileFuncs()](phar.interceptfilefuncs.md) інструктує Phar про необхідність перехоплення дзвінків [fopen()](function.fopen.md) [file\\_get\\_contents()](function.file-get-contents.md) [opendir()](function.opendir.md) та інших функцій, заснованих на stat ([file\\_exists()](function.file-exists.md) [is\\_readable()](function.is-readable.md) і так далі) і перенаправлення всіх відносних шляхів усередину phar-архіву.\n\nНаприклад, для упаковки випуску популярної програми phpMyAdmin для його використання як phar-архів, потрібен тільки цей простий скрипт, а `phpMyAdmin.phar.tar.php` буде доступний як звичайний файл на вашому веб-сервері після зміни значень user/password:\n\n```php\n<?php\n@unlink('phpMyAdmin.phar.tar.php');\ncopy('phpMyAdmin-2.11.3-english.tar.gz', 'phpMyAdmin.phar.tar.php');\n$a = new Phar('phpMyAdmin.phar.tar.php');\n$a->startBuffering();\n$a[\"phpMyAdmin-2.11.3-english/config.inc.php\"] = '<?php\n/* Конфигурация сервера */\n$i = 0;\n\n/* Сервер localhost (config:root) [1] */\n$i++;\n$cfg[\\'Servers\\'][$i][\\'host\\'] = \\'localhost\\';\n$cfg[\\'Servers\\'][$i][\\'extension\\'] = \\'mysqli\\';\n$cfg[\\'Servers\\'][$i][\\'connect_type\\'] = \\'tcp\\';\n$cfg[\\'Servers\\'][$i][\\'compress\\'] = false;\n$cfg[\\'Servers\\'][$i][\\'auth_type\\'] = \\'config\\';\n$cfg[\\'Servers\\'][$i][\\'user\\'] = \\'root\\';\n$cfg[\\'Servers\\'][$i][\\'password\\'] = \\'\\';\n\n\n/* Конец конфигурации сервера */\nif (strpos(PHP_OS, \\'WIN\\') !== false) {\n    $cfg[\\'UploadDir\\'] = getcwd();\n} else {\n    $cfg[\\'UploadDir\\'] = \\'/tmp/pharphpmyadmin\\';\n    @mkdir(\\'/tmp/pharphpmyadmin\\');\n    @chmod(\\'/tmp/pharphpmyadmin\\', 0777);\n}';\n$a->setStub('<?php\nPhar::interceptFileFuncs();\nPhar::webPhar(\"phpMyAdmin.phar\", \"phpMyAdmin-2.11.3-english/index.php\");\necho \"phpMyAdmin предназначен для выполнения в веб-браузере\\n\";\nexit -1;\n__HALT_COMPILER();\n');\n$a->stopBuffering();\n?>\n```\n","title":"Використання Phar-архівів: Вступ","contentType":2,"navigation":[{"phar.using.md":"« Використання Phar-архівів"},{"phar.using.stream.md":"Використання Phar-архівів: обгортка потоку phar »"},{"index.md":"PHP Manual"},{"phar.using.md":"Використання Phar-архівів"}]}},"__N_SSG":true}