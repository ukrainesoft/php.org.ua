{"pageProps":{"page":{"slug":"function.oci-bind-array-by-name.md","content":"# oci\\_bind\\_array\\_by\\_name\n\n(PHP 5 >= 5.1.2, PHP 7, PHP 8, PECL OCI8 >= 1.2.0)\n\noci\\_bind\\_array\\_by\\_name - Зв'язує PHP масив з масивом Oracle PL/SQL\n\n### Опис\n\n```methodsynopsis\noci_bind_array_by_name(    resource $statement,    string $param,    array &$var,    int $max_array_length,    int $max_item_length = -1,    int $type = SQLT_AFC): bool\n```\n\nПов'язує PHP масив `var` з вказівником Oracle `param` на масив Oracle PL/SQL. Напрямок, введення або висновок, для якого використовуватиметься масив, буде визначатися під час виконання.\n\n### Список параметрів\n\n`statement`\n\nІдентифікатор допустимого виразу OCI.\n\n`param`\n\nВказівник на масив Oracle.\n\n`var`\n\nМасив.\n\n`max_array_length`\n\nЗадає максимальний розмір для вихідного та результуючого масивів.\n\n`max_item_length`\n\nВизначає максимальний розмір значень масиву. Якщо не встановлено або дорівнює -1, **oci\\_bind\\_array\\_by\\_name()** знайде найбільший елемент у вихідному масиві і використовує його розмір як цю настройку.\n\n`type`\n\nВикористовується для визначення типу значень PL/SQL масиву. Дивіться список нижче:\n\n-   \\*\\*`SQLT_NUM`\\*\\*- для масивів із елементами типу NUMBER.\n    \n-   \\*\\*`SQLT_INT`**\\- для масивів з елементами типу INTEGER (Примітка: INTEGER - синонім типу NUMBER(38), проте тип**`SQLT_NUM`\\*\\*у цьому випадку не працюватиме, навіть незважаючи на те, що вони синонімічні).\n    \n-   \\*\\*`SQLT_FLT`\\*\\*- для масивів із елементами типу FLOAT.\n    \n-   \\*\\*`SQLT_AFC`\\*\\*- для масивів із елементами типу CHAR.\n    \n-   \\*\\*`SQLT_CHR`\\*\\*- для масивів із елементами типу VARCHAR2.\n    \n-   \\*\\*`SQLT_VCS`\\*\\*- для масивів із елементами типу VARCHAR.\n    \n-   \\*\\*`SQLT_AVC`\\*\\*- для масивів із елементами типу CHARZ.\n    \n-   \\*\\*`SQLT_STR`\\*\\*- для масивів із елементами типу STRING.\n    \n-   \\*\\*`SQLT_LVC`\\*\\*- для масивів із елементами типу LONG VARCHAR.\n    \n-   \\*\\*`SQLT_ODT`\\*\\*- для масивів із елементами типу DATE.\n    \n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** oci\\_bind\\_array\\_by\\_name()\\*\\*\\*\\*\n\n```php\n<?php\n\n$conn = oci_connect(\"hr\", \"hrpwd\", \"localhost/XE\");\nif (!$conn) {\n    $m = oci_error();\n    trigger_error(htmlentities($m['message']), E_USER_ERROR);\n}\n\n$create = \"CREATE TABLE bind_example(name VARCHAR(20))\";\n$stid = oci_parse($conn, $create);\noci_execute($stid);\n\n$create_pkg = \"\nCREATE OR REPLACE PACKAGE ARRAYBINDPKG1 AS\n  TYPE ARRTYPE IS TABLE OF VARCHAR(20) INDEX BY BINARY_INTEGER;\n  PROCEDURE iobind(c1 IN OUT ARRTYPE);\nEND ARRAYBINDPKG1;\";\n$stid = oci_parse($conn, $create_pkg);\noci_execute($stid);\n\n$create_pkg_body = \"\nCREATE OR REPLACE PACKAGE BODY ARRAYBINDPKG1 AS\n  CURSOR CUR IS SELECT name FROM bind_example;\n  PROCEDURE iobind(c1 IN OUT ARRTYPE) IS\n    BEGIN\n    -- Bulk Insert\n    FORALL i IN INDICES OF c1\n      INSERT INTO bind_example VALUES (c1(i));\n\n    -- Fetch and reverse\n    IF NOT CUR%ISOPEN THEN\n      OPEN CUR;\n    END IF;\n    FOR i IN REVERSE 1..5 LOOP\n      FETCH CUR INTO c1(i);\n      IF CUR%NOTFOUND THEN\n        CLOSE CUR;\n        EXIT;\n      END IF;\n    END LOOP;\n  END iobind;\nEND ARRAYBINDPKG1;\";\n$stid = oci_parse($conn, $create_pkg_body);\noci_execute($stid);\n\n$stid = oci_parse($conn, \"BEGIN arraybindpkg1.iobind(:c1); END;\");\n$array = array(\"one\", \"two\", \"three\", \"four\", \"five\");\noci_bind_array_by_name($stid, \":c1\", $array, 5, -1, SQLT_CHR);\noci_execute($stid);\n\nvar_dump($array);\n\n?>\n```\n","title":"oci\\_bind\\_array\\_by\\_name","contentType":2,"navigation":[{"ref.oci8.md":"« OCI8 Функції"},{"function.oci-bind-by-name.md":"oci\\_bind\\_by\\_name »"},{"index.md":"PHP Manual"},{"ref.oci8.md":"OCI8 Функції"}]}},"__N_SSG":true}