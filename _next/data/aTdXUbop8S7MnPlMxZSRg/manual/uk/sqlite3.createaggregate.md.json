{"pageProps":{"page":{"slug":"sqlite3.createaggregate.md","content":"# SQLite3::createAggregate\n\n(PHP 5 >= 5.3.0, PHP 7, PHP 8)\n\nSQLite3::createAggregate — Зареєструвати функцію PHP як агрегуючу функцію SQL\n\n### Опис\n\n```methodsynopsis\npublic SQLite3::createAggregate(    string $name,    callable $stepCallback,    callable $finalCallback,    int $argCount = -1): bool\n```\n\nРеєструє функцію PHP або функцію користувача як агрегуючу функцію SQL для використання в запитах.\n\n### Список параметрів\n\n`name`\n\nІм'я агрегуючої функції SQL, яка має бути створена або перевизначена.\n\n`stepCallback`\n\nФункція зворотного дзвінка, яка буде викликана для кожного рядка результуючого набору. Ваша PHP-функція повинна акумулювати результат та зберігати його у контексті агрегації.\n\nЦя функція має бути визначена так:\n\n```methodsynopsis\nstep(    mixed $context,    int $rownumber,    mixed $value,    mixed ...$values): mixed\n```\n\n`context`\n\nДля першого рядка має дорівнювати **`null`**; Для всіх наступних рядків його значення має дорівнювати значенням, повернутим на попередньому кроці; Ви повинні використовувати його, щоб зберегти стан агрегації.\n\n`rownumber`\n\nНомер поточного рядка.\n\n`value`\n\nПерший аргумент передано агрегатору.\n\n`values`\n\nПодальші аргументи.\n\nЗначення функції, що повертається, буде використано як параметр `context` при наступному запуску функції, або як значення, що передається фіналізуючої функції.\n\n`finalCallback`\n\nФункція зворотного дзвінка для обчислення підсумкового агрегованого значення. Вона буде викликана як тільки всі рядки результуючого набору будуть оброблені, їй буде переданий контекст, що агрегує, і вона поверне фінальне значення. Ця функція має повернути значення типу зрозумілого SQLite (тобто . [скалярний тип](language.types.intro.md)\n\nЦя функція має бути визначена так:\n\n```methodsynopsis\nfini(mixed $context, int $rownumber): mixed\n```\n\n`context`\n\nМістить результат останнього виклику функції, що агрегує.\n\n`rownumber`\n\nЗавжди\n\nЗначення цієї функції буде використане як значення, що повертається всього агрегатора.\n\n`argCount`\n\nКількість аргументів, які приймає функція агрегування SQL. Якщо значення є негативним, то функція може використовувати будь-яку кількість аргументів.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад агрегуючої функції max\\_length**\n\n```php\n<?php\n$data = array(\n   'one',\n   'two',\n   'three',\n   'four',\n   'five',\n   'six',\n   'seven',\n   'eight',\n   'nine',\n   'ten',\n   );\n$db = new SQLite3(':memory:');\n$db->exec(\"CREATE TABLE strings(a)\");\n$insert = $db->prepare('INSERT INTO strings VALUES (?)');\nforeach ($data as $str) {\n    $insert->bindValue(1, $str);\n    $insert->execute();\n}\n$insert = null;\n\nfunction max_len_step($context, $rownumber, $string)\n{\n    if (strlen($string) > $context) {\n        $context = strlen($string);\n    }\n    return $context;\n}\n\nfunction max_len_finalize($context, $rownumber)\n{\n    return $context === null ? 0 : $context;\n}\n\n$db->createAggregate('max_len', 'max_len_step', 'max_len_finalize');\n\nvar_dump($db->querySingle('SELECT max_len(a) from strings'));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(5)\n```\n\nУ цьому прикладі ми написали функцію, що агрегує, яка обчислює найдовшого рядка в одній колонці таблиці. Для кожного рядка викликається функція `max_len_step` і їй передається параметр `$context`. Цей параметр нічим не відрізняється від звичайної змінної PHP і може спокійно містити масив або об'єкт. У цьому прикладі ми використовуємо її для збереження максимальної знайденої довжини рядка. Якщо `$string` буде мати довжину більше, ніж поточна збережена, значення контексту буде оновлено.\n\nПісля того, як усі рядки оброблені, SQLite викличе функцію `max_len_finalize`для остаточної підготовки результату. Тут ми можемо зробити необхідні розрахунки на основі даних з `$context`. У нашому простому прикладі ніяка постобробка не потрібна і ми просто повертаємо отримане значення.\n\n**Підказка**\n\nНЕ рекомендується зберігати копію значень у контексті, а обробку проводити у фінальній функції, оскільки це може призвести до великого споживання пам'яті під час обробки запиту. Просто уявіть, скільки пам'яті вам знадобиться для зберігання мільйона рядків, по 32 байти кожен, у пам'яті.\n\n**Підказка**\n\nДля перевизначення вбудованих в SQLite функцій, що агрегують, ви можете використовувати **SQLite3::createAggregate()**\n","title":"SQLite3::createAggregate","contentType":2,"navigation":[{"sqlite3.construct.md":"« SQLite3::\\_\\_construct"},{"sqlite3.createcollation.md":"SQLite3::createCollation »"},{"index.md":"PHP Manual"},{"class.sqlite3.md":"SQLite3"}]}},"__N_SSG":true}