- [« Основи підрахунку посилань](features.gc.refcounting-basics.md)
- [Питання продуктивності
»](features.gc.performance-considerations.md)

- [PHP Manual](index.md)
- [Складання сміття](features.gc.md)
- Збір циклічних посилань

## Збір циклічних посилань

Зазвичай механізми підрахунку посилань у пам'яті, наприклад, використовуваний PHP
раніше, не вирішують проблему витоку пам'яті через циклічні посилання.
Починаючи з версії 5.3.0, в PHP реалізований синхронний механізм
дослідження "[» Concurrent Cycle Collection in Reference Counted
Systems](http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf)",
у якому розглядається це питання.

Повний опис роботи алгоритму виходить за межі даного розділу,
тому наведено лише основи. Насамперед ми повинні задати кілька
Основні правила. Якщо лічильник посилань збільшується, то контейнер все ще
використовується та не є сміттям. Якщо лічильник зменшується до нуля, то
zval може бути вилучено. Виходячи з цих правил витоку пам'яті з
циклічними посиланнями можуть вийти тільки при зменшенні лічильника
посилань до ненульового значення. Потім, у виділених контейнерах можна
знайти сміття перевіривши можливість зменшення всіх лічильників посилань на
одиницю та визначивши ті контейнери, у яких лічильник стане рівним нулю.

![Алгоритм складання
сміття](images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png)

Для уникнення постійної перевірки на сміття з циклічними посиланнями при
кожному зменшенні лічильника посилань, алгоритм додає всі можливі
коріння (zval контейнери) в "кореневий буфер" (позначаючи їх як
"фіолетові"). Це також гарантує попадання будь-якого кореня в буфер.
тільки один раз. Механізм складання сміття стартує лише тоді, коли
наповнюється буфер (дивіться крок A на малюнку вище).

На кроці B алгоритм здійснює пошук у глибину за всіма можливими коріннями
для одноразового зменшення лічильника посилань на одиницю у всіх
контейнерів (позначаючи їх як "сірі"). На кроці C алгоритм знову
проводить пошук у глибину для перевірки лічильників посилань. Якщо він
знаходить лічильник з нульовим значенням, контейнер позначається як "білий"
(на малюнку відображено синім). Якщо ж лічильник більший за нуль, то
відбувається пошук у глибину від цього контейнера зі зворотним збільшенням
лічильників на одиницю і повторною позначкою як "чорний" на них
контейнери. На останньому кроці D алгоритм проходить по кореневому буферу
видаляє з нього коріння контейнерів, заразом перевіряючи які контейнери
позначені як "білі". Ці контейнери буде звільнено з пам'яті.

Тепер, коли ви маєте уявлення про роботу алгоритму, розглянемо його
інтеграцію до PHP. За замовчуванням збирач сміття завжди увімкнений. Для
зміни цієї опції використовується параметр
[zend.enable_gc](info.configuration.md#ini.zend.enable-gc) у
`php.ini`.

Якщо збирач сміття включений, алгоритм пошуку циклічних посилань
виконується щоразу, коли кореневий буфер наповнюється 10,000 корінням
(ви можете змінити це значення, змінивши константу
`GC_ROOT_BUFFER_MAX_ENTRIES` у файлі `Zend/zend_gc.c` у вихідному коді
PHP і перебравши PHP). Якщо збирач сміття вимкнено, алгоритм ніколи не
буде запущено. Тим не менш, буфер завжди заповнюється корінням.

Якщо буфер заповнився при вимкненому механізмі збирання сміття, то інші
коріння нічого очікувати в нього записані. Таким чином, якщо вони виявляться сміттям
з циклічними посиланнями, то ніколи не будуть очищені та створять витік
пам'яті.

Причиною постійного запису коріння в буфер навіть при вимкненому механізмі
складання сміття є те, що це набагато швидше, ніж постійно
перевіряти чи включений механізм складання сміття чи ні. Проте, саме складання
сміття та алгоритм її аналізу можуть займати значний час.

Крім зміни параметра
[zend.enable_gc](info.configuration.md#ini.zend.enable-gc), механізм
складання сміття також можна запустити і зупинити викликавши функції
[gc_enable()](function.gc-enable.md) та
[gc_disable()](function.gc-disable.md) відповідно. Виклик цих
функцій має той же ефект, що і включення/вимкнення механізму
налаштування конфігурації. Крім того, можна запустити складання
сміття, навіть якщо кореневий буфер ще заповнений. Для цього ви можете
викликати функцію [gc_collect_cycles()](function.gc-collect-cycles.md),
яка також повертає кількість циклічних посилань зібраних
алгоритмом.

Причиною включення та вимикання механізму складання, а також його ручного
запуску, може стати те, що деякі частини вашої програми можуть
бути вимогливими до часу. У цих випадках ви, можливо, не
захочете стороннього втручання збирача сміття. Зрозуміло,
виключаючи збирач сміття у певних місцях вашої програми ви
ризикуєте отримати витік пам'яті, т.к. потенційно деякі коріння можуть
не поміститися в обмежений кореневий буфер. Більш доцільно буде
викликати [gc_collect_cycles()](function.gc-collect-cycles.md)
безпосередньо перед викликом [gc_disable()](function.gc-disable.md)
для звільнення пам'яті та вже записаних коренів у буфері. Це очистить
буфер і дозволить використовувати більше місця для зберігання коренів, поки
механізм буде вимкнено.
