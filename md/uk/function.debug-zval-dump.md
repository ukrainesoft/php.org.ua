- [«boolval](function.boolval.md)
- [doubleval »](function.doubleval.md)

- [PHP Manual](index.md)
- [Функції для роботи зі змінними](ref.var.md)
- Виводить рядкову виставу внутрішньої структури zval

#debug_zval_dump

(PHP 4 \>u003d 4.2.0, PHP 5, PHP 7, PHP 8)

debug_zval_dump — Виводить строкове уявлення внутрішньої структури
zval

### Опис

**debug_zval_dump**([mixed](language.types.declarations.md#language.types.declarations.mixed)
$value,
[mixed](language.types.declarations.md#language.types.declarations.mixed)
`...$values`): void

Виводить на висновок рядкове уявлення внутрішньої структури zval
(Значення Zend). Це в основному корисно для розуміння чи налагодження
деталей реалізації Zend Engine чи модулів PHP.

### Список параметрів

`value`
Оброблювана змінна.

`values`
Наступні змінні або значення обробки.

### Значення, що повертаються

Функція не повертає значення після виконання.

### Приклади

**Приклад #1 Приклад використання **debug_zval_dump()****

` <?php$var1 u003d 'Hello';$var1 .u003d ' World';$var2 u003d $var1;debug_zval_dump($var1);?> `

Результат виконання цього прикладу:

string(11) "Hello World" refcount(3)

> **Примітка**: **Розуміння `refcount`**
>
> Значення `refcount`, яке показується цією функцією, може бути
> несподіваним без детального розуміння реалізації двигуна.
>
> Zend Engine використовує підрахунок посилань для двох різних цілей:
>
> - Оптимізація використання пам'яті за допомогою методу, званого
> "копіювання під час запису", коли кілька змінних, що містять
> те саме значення, вказують на ту саму копію в пам'яті.
> Коли будь-яка змінна змінюється, вона вказує на нову копію.
> у пам'яті, а лічильник посилань на оригінал зменшується на 1.
> - Відстеження змінних, які були призначені або передані через
> посилання (дивіться [Пояснення посилань](language.references.md)).
> Цей лічильник посилань зберігається в окремому посиланні zval, що вказує
> на zval для поточного значення. Цей додатковий zval у
> зараз не відображається в **debug_zval_dump()**.
>
> Оскільки **debug_zval_dump()** приймає свої вхідні дані як
> звичайні параметри, передані за значенням, їх передачі буде
> використовувати метод копіювання під час запису: замість копіювання даних
> лічильник посилань буде збільшено на одиницю на час існування виклику
> Функції. Якщо функція змінила параметр після отримання, буде
> Зроблено копію; оскільки це не так, покаже лічильник посилань на один
> вище, ніж у зухвалої області.
>
> Передача параметрів також запобігає відображенню змінних
> **debug_zval_dump()**, призначені за посиланням. Для
> ілюстрації розглянемо трохи змінену версію наведеного вище
> прикладу:
>
> ` <?php$var1 u003d 'Hello';$var1 .u003d ' World';// Вкажіть три змінні як посилання на одно і те ж значення$var2 u003d& $var1;$var3 u003d& var1);?> `
>
> Результат виконання цього прикладу:
>
> string(11) "Hello World" refcount(2)
>
> Хоча `$var1`, `$var2`, і `$var3` пов'язані як посилання, тільки *value*
> передається до **debug_zval_dump()**. Це значення використовується один раз
> набором посилань та один раз всередині функції **debug_zval_dump()**,
> тому лічильник посилань дорівнює 2.
>
> Подальші складнощі виникають через оптимізацію, зроблену в двигуні
> для різних типів даних. Деякі типи, такі як цілі числа, не
> використовують "копіювання під час запису", тому не показують лічильник
> Посилань взагалі. В інших випадках refcount показує додаткові
> копії, що використовуються всередині, наприклад, коли літерний рядок або
> масив зберігається як інструкції коду.

### Дивіться також

- [var_dump()](function.var-dump.md) - Виводить інформацію про
змінної
- [debug_backtrace()](function.debug-backtrace.md) - Виводить стек
викликів функцій у масив
- "[Посилання. Роз'яснення](language.references.md)"
- "[» Посилання. Роз'яснення (від Derick
Rethans)](http://derickrethans.nl/php_references_article.php)"
