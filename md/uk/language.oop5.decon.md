- [« Автоматичне завантаження класів](language.oop5.autoload.md)
- [Область видимості »](language.oop5.visibility.md)

- [PHP Manual](index.md)
- [Класи та об'єкти](language.oop5.md)
- Конструктори та деструктори

## Конструктори та деструктори

### Конструктор

**\_\_construct**([mixed](language.types.declarations.md#language.types.declarations.mixed)
`...$values` u003d ""): void

PHP дозволяє оголошувати методи-конструктори. Класи, в яких оголошено
метод-конструктор, викликатиме цей метод при кожному створенні нового
об'єкта, так що це може виявитися корисним, наприклад, для
ініціалізації будь-якого стану об'єкта перед його використанням.

> **Примітка**: Конструктори, визначені в класах-батьках, не
> викликаються автоматично, якщо дочірній клас визначає власний
> Конструктор. Щоб викликати конструктор, оголошений у батьківському
> класі, потрібно викликати **parent::\_\_construct()** всередині
> конструктора дочірнього класу. Якщо у дочірньому класі не визначено
> конструктор, він може бути успадкований від батьківського класу як
> простий спосіб (якщо він був визначений як приватний).

**Приклад #1 Конструктори при наслідуванні**

` <?phpclass BaseClass {   function __construct() {       print'"Конструктор класу BaseClass
";   }}class SubClass extends BaseClass {   function __construct() {        parent::__construct();        print "Конструктор класу Sub
";  }}class|OtherSubClass extends BaseClass {     //| BaseClass$obj u003d new OtherSubClass();?> `

На відміну від інших методів,
[\_\_construct()](language.oop5.decon.md#object.construct)
звільняється від звичайних [правил сумісності
сигнатури](language.oop5.basic.md#language.oop.lsp) при успадкування.

Конструктори - це звичайні методи, які викликаються при
інстанціюванні відповідних об'єктів. Отже, вони можуть
мати довільну кількість аргументів, які можуть бути
обов'язковими, можуть бути типізованими і можуть мати значення по
замовчуванням. Аргументи конструктора вказуються в круглих дужках після
імені класу

**Приклад #2 Використання аргументів у конструкторах**

`<?phpclass Point {   protected int $x; protected int $y; public function __construct(int $x, int $y u003d 0) {        $this->x u003d $x; $this->y u003d $y; }}// Передаєм обидва параметра.$p1 u003d new Point(4, 5);// Передаєм тільки обов'язкові параметри. Для $y використовується значення за мовчанням 0.$p2 u003d new Point(4);// Викликаємо з іменованими параметрами (починаючи с PHP 8.0):$p3 u003d ne

Якщо клас не має конструктора, або його конструктор не має
обов'язкових параметрів, дужки після імені класу можна писати.

#### Конструктори у старому стилі

До PHP 8.0.0, класи у глобальному просторі імен будуть
інтерпретувати метод, названий так само, як клас, як конструктор
старий стиль. Цей синтаксис вважається застарілим і викликатиме
помилку рівня **`E_DEPRECATED`**, але все одно ці методи будуть
викликатися як конструктор. Якщо в класі присутні і
[\_\_construct()](language.oop5.decon.md#object.construct), і метод з
ім'ям класу, то як конструктор буде викликаний
[\_\_construct()](language.oop5.decon.md#object.construct).

Для класів, що у власному просторі імен і для всіх
класів, починаючи з PHP 8.0.0, метод, названий на ім'я класу, буде
ігноруватися.

У новому коді завжди використовуйте
[\_\_construct()](language.oop5.decon.md#object.construct).

#### Визначення властивостей об'єкта в конструкторі

Починаючи з PHP 8.0.0, параметри конструктора можна використовувати для
завдання відповідних властивостей об'єкта. Це досить поширена
практика - надавати властивостям об'єкта параметри, передані в
конструктор, не роблячи жодних додаткових перетворень.
Визначення властивостей класу у конструкторі дозволяє значно
скоротити кількість шаблонного коду для цього випадку. Приклад вище
можна буде переписати так:

**Приклад #3 Використання визначення властивостей у конструкторі**

` <?phpclass Point {    public function __construct(protected int $x, protected int $y u003d 0) {    }} `

Якщо декларація аргументу конструктора включає модифікатор видимості,
PHP інтерпретує його одночасно як аргумент конструктора, і як
властивість об'єкта і автоматично надасть властивості значення, передане
у конструктор. При цьому, якщо не передбачається будь-якої
Додаткову логіку, тіло конструктора можна залишити порожнім. Код
конструктора виконається після того, як усі аргументи нададуться всім
відповідним властивостям.

Не всі аргументи, що передаються в конструктор, повинні бути властивостями
об'єкт. У конструкторі можна ставити як звичайні, так і ті, що є
властивостями об'єкта аргументи у порядку. Аргументи-властивості ніяк
не впливають на код, який виконується в конструкторі.

> **Примітка**:
>
> Властивості об'єктів не можуть бути типу
> [callable](language.types.callable.md) у зв'язку з неоднозначністю
> яку вони представляють для движка PHP. Відповідно та властивості
> обумовлені в конструкторі також можуть бути типу
> [callable](language.types.callable.md). Будь-які інші [декларації
> типи](language.types.declarations.md) допустимі.

> **Примітка**:
>
> [Атрибути](language.attributes.md), задані для таких аргументів,
> будуть застосовані як їм самих, так відповідних властивостей.

#### New в ініціалізації класу

Починаючи з PHP 8.1.0, об'єкти можна використовувати як значення
параметрів за умовчанням, статичних змінних та глобальних констант, а
також у аргументах атрибутів. Об'єкти також тепер можна передавати в
[define()](function.define.md).

> **Примітка**:
>
> Використання динамічного чи не рядкового імені класу або
> анонімного класу заборонена. Використання розпакування аргументів
> Не допускається. Використання непідтримуваних виразів як
> аргументів заборонено.

**Приклад #4 Приклад використання new в ініціалізації класу**

`<?php// Все допустимо:static $x u003d new Foo;const C u003d new Foo;function test($param u003d new Foo) {}#[AnAttribute(new Foo)      prop u003d new Foo,    ) {}}// Всё не допустимо (ошибка во времени компиляции):function test(    $a u003d new (CLASS_NAME_CONSTANT)(), // динамическое имя класса    $b u003d new class {}, // анонимный клас   $c u003d new A(...[]), // розпакування аргументів    $d u003d new B($abc), // непідтримуване постійне вираз) {}?

#### Статичні методи створення об'єкта

PHP підтримує лише один конструктор для класу. Однак у деяких
випадках є необхідність створювати об'єкт різними шляхами залежно
від різних вхідних даних. Рекомендований спосіб - використовувати
статичні методи як обгортки над конструктором.

**Приклад #5 Використання статичних методів для створення об'єктів**

`<?phpclass Product {    private ?int $id; private ?string $name; private function __construct(?int $id u003d null, ?string $name u003d null) {        $this->id u003d $id; $this->name u003d $name; }    public|static| return $new; }    public static function fromJson(string $json): static {       $data u003d json_decode($json); return new static($data['id'], $data['name']); }    public|static| $datau003dconvert_xml_to_array($xml); $new u003d new static(); $new->id u003d $data['id']; $new->name u003d $data['name']; return $new; }}$p1 u003d Product::fromBasicData(5, 'Widget');$p2 u003d Product::fromJson($some_json_string);$p3 u003d Product::fromXml($some_xml_string); `

Конструктор можна зробити прихованим або захищеним для запобігання його
прямого дзвінка. У такому разі об'єкт класу можна буде створити лише
з допомогою статичних методів. Так як це методи того ж класу, вони
мають доступ до всіх його прихованих методів, навіть якщо вони відносяться до
різним екземплярам класу. Прихований конструктор опціональний і може
бути присутніми або відсутніми за потребою.

У прикладі вище три публічні статичні методи демонструють різні
способи створення екземпляра об'єкта

- `fromBasicData()` приймає явні параметри, створює екземпляр
класу через конструктор та повертає об'єкт.
- `fromJson()` приймає JSON рядок, виробляє над нею деякі
перетворення, витягує дані необхідні створення об'єкта і,
так само як і попередній метод, викликає конструктор та повертає
створений об'єкт.
- `fromXml()` приймає XML рядок, витягує потрібні дані і, оскільки
у конструкторі немає обов'язкових параметрів, що викликає його без них.
Після цього, оскільки йому доступні приховані властивості, він надає
їм значення прямо. Після цього повертає готовий об'єкт.

У всіх трьох випадках, ключове слово 'static' транслюється в ім'я
класу, де цей код викликається. У нашому випадку `Product`.

### Деструктори

**\_\_destruct**(): void

PHP надає концепцію деструктора, аналогічну до тієї, яка
застосовується в інших ГО-мовах, таких як C++. Деструктор буде викликаний
при звільненні всіх посилань на певний об'єкт або при завершенні
скрипта (порядок виконання деструкторів не гарантується).

**Приклад #6 Приклад використання деструктора**

`<?phpclass MyDestructableClass{"  function __construct() {       print"
";   }   function __destruct() {        print "Знищується " . __CLASS__  . "
";  }}$obj u003d new MyDestructableClass(); `

Як і у випадку з конструкторами, деструктори, оголошені в батьківському
класі, не будуть викликатися автоматично. Для виклику деструктора
батьківського класу, потрібно викликати **parent::\_\_destruct()**
тіло деструктора дочірнього класу. Подібно до конструкторів, дочірній клас
може успадкувати деструктор із батьківського класу, якщо він не
визначений у ньому.

Деструктор буде викликатись навіть у тому випадку, якщо скрипт був
зупинено за допомогою функції [exit()](function.exit.md). Виклик
[exit()](function.exit.md) у деструкторі запобігає запуску всіх
наступних функцій завершення.

> **Примітка**:
>
> Деструктори, викликані після завершення скрипта, викликаються після
> надсилання HTTP-заголовків. Робоча директорія під час фази завершення
> скрипт може відрізнятися в деяких SAPI (наприклад, в Apache).

> **Примітка**:
>
> Спроба викинути виняток з деструктора (що викликається під час
> завершення скрипта) викликає фатальну помилку.
