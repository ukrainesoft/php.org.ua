{"pageProps":{"page":{"slug":"function.header.md","content":"# header\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nheader — Надсилає необроблений (сирий) HTTP-заголовок\n\n### Опис\n\n```methodsynopsis\nheader(string $header, bool $replace = true, int $response_code = 0): void\n```\n\nФункцию**header()** викликають для надсилання HTTP-заголовка. У [» специфікації HTTP/1.1](http://www.faqs.org/rfcs/rfc2616) докладно описані HTTP-заголовки.\n\nПомните, функцию**header()** дозволено викликати тільки якщо клієнту ще не були передані дані. Тобто вона повинна йти першою у висновку, перед її викликом не повинно бути HTML-тегів, порожніх рядків тощо. Іноді виникає помилка, коли при читанні коду файловими функціями на кшталт [include](function.include.md) або [require](function.require.md) у коді трапляються пробіли або порожні рядки, які виводяться до виклику функції **header()**. Ті самі проблеми можуть виникати, коли в одному файлі записані PHP-код та HTML-розмітка.\n\n```php\n<html>\n<?php\n\n/* Этот Приклад приведёт к ошибке. Обратите внимание\n * на тег вверху, который будет выведен до вызова функции header() */\nheader('Location: http://www.example.com/');\nexit;\n\n?>\n```\n\n### Список параметрів\n\n`header`\n\nРядок заголовка.\n\nІснує два виклики заголовка, які відрізняються від інших. Перший - заголовок, який починається з рядка`HTTP/`»(Регістр не важливий). Цей заголовок визначає код стану HTTP для відповіді. Наприклад, якщо веб-сервер Apache через директиву `ErrorDocument` налаштований на обробку запитів до неіснуючих файлів PHP-скриптом, то розробник, ймовірно, захоче переконатися, що скрипт генерує правильний код стану.\n\n```php\n<?php\n\n// Приклад иллюстрирует передачу заголовка \"HTTP/\".\n// Из альтернативных способов в типичных случаях выбирают этот:\n// 1. header($_SERVER[\"SERVER_PROTOCOL\"] . \" 404 Not Found\");\n//    (чтобы переопределить сообщения о состоянии HTTP для клиентов, которые все еще работают по протоколу HTTP/1.0)\n// 2. http_response_code(404); (для определить сообщение по умолчанию)\nheader(\"HTTP/1.1 404 Not Found\");\n\n?>\n```\n\nІнший відмінний вид заголовка - \"Location:\". Він відправляє заголовок назад у браузер, а також повертає браузеру код стану `REDIRECT` (302), якщо тільки код стану `201`или`3xx` не було встановлено.\n\n```php\n<?php\n\nheader(\"Location: http://www.example.com/\"); /* Перенаправление браузера */\n\n/* Убедиться, что код ниже не будет выполнен после перенаправления .*/\nexit;\n\n?>\n```\n\n`replace`\n\nНеобов'язковий параметр `replace` визначає, чи повинен заголовок замінити попередній аналогічний заголовок або додати друге заголовок того ж типу. За умовчанням він замінить заголовок, але якщо передати **`false`**, Як другий аргумент, можна примусово задати кілька однотипних заголовків. Наприклад:\n\n```php\n<?php\n\nheader('WWW-Authenticate: Negotiate');\nheader('WWW-Authenticate: NTLM', false);\n\n?>\n```\n\n`response_code`\n\nПримусово вказує код відповіді HTTP. Зверніть увагу, що цей параметр працює тільки тоді, коли рядок `header`не пуста.\n\n### Значення, що повертаються\n\nФункція не повертає значення після виконання.\n\n### Помилки\n\nЯкщо не вдалося запланувати надсилання заголовка, функція **header()** видає помилку рівня **`E_WARNING`**\n\n### Приклади\n\n**Приклад #1 Діалог завантаження**\n\nЯкщо потрібно запропонувати користувачеві зберегти дані, що пересилаються, наприклад згенерований PDF-файл, вказують заголовок [» Content-Disposition](http://www.faqs.org/rfcs/rfc2183), який підставляє ім'я файлу, що рекомендується, і змушує браузер показати діалог збереження.\n\n```php\n<?php\n\n// Будем передавать PDF\nheader('Content-Type: application/pdf');\n\n// Он будет называться downloaded.pdf\nheader('Content-Disposition: attachment; filename=\"downloaded.pdf\"');\n\n// Исходный PDF-файл original.pdf\nreadfile('original.pdf');\n\n?>\n```\n\n**Приклад #2 Директиви для роботи з кешем**\n\nPHP-скрипти часто генерують динамічний зміст, який не повинен кешувати браузер клієнта або проміжний кеш між сервером та клієнтським браузером. Проксі-сервери та браузери можуть примусово відключити кешування, передавши заголовки:\n\n```php\n<?php\n\nheader(\"Cache-Control: no-cache, must-revalidate\"); // HTTP/1.1\nheader(\"Expires: Sat, 26 Jul 1997 05:00:00 GMT\"); // Дата в прошлом\n\n?>\n```\n\n> **Зауваження** :\n> \n> Бувають ситуації, в яких браузер не кешуватиме сторінки, навіть якщо наведені заголовки не були передані. Користувачам доступні установки браузера, які змінюють поведінку кешування за замовчуванням. Надсилаючи наведені заголовки, розробник повинен перевизначити будь-які налаштування, які в інших випадках призводять до кешування виведення скрипту.\n> \n> Крім того, через функцію [session\\_cache\\_limiter()](function.session-cache-limiter.md) та директиву `session.cache_limiter` можна автоматично створювати правильні заголовки, пов'язані з кешуванням під час роботи з сесіями.\n\n**Приклад #3 Налаштування cookie**\n\nфункцією [setcookie()](function.setcookie.md) зручно встановлювати cookies. Щоб встановити cookie з атрибутами, які не підтримують функцію [setcookie()](function.setcookie.md), викликають функцію **header()**\n\nНаприклад, наступний код встановлює cookie з атрибутом `Partitioned`\n\n```php\n<?php\n\nheader('Set-Cookie: name=value; Secure; Path=/; SameSite=None; Partitioned;');\n\n?>\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Доступ до заголовків та їх висновок здійснюватиметься лише у випадку, якщо у SAPI є їх підтримка.\n\n> **Зауваження** :\n> \n> Щоб уникнути цієї проблеми, можна буферизувати висновок скрипта. Тоді всі дані, що виводяться, буферизуватимуться на сервері, поки не буде дана явна команда на пересилання даних. Керувати буферизацією можна вручну - функціями [ob\\_start()](function.ob-start.md) і [ob\\_end\\_flush()](function.ob-end-flush.md), або поставивши директиву `output_buffering` у конфігураційному файлі php.ini, або налаштувавши конфігурацію сервера належним чином.\n\n> **Зауваження** :\n> \n> Рядок заголовка HTTP-стану буде відправлений клієнту першим, незалежно від того, чи викликана функція **header()** першою чи ні. Статус можна перевизначити у будь-який час викликом функції **header()** з новим рядком стану, якщо HTTP-заголовки ще не були надіслані.\n\n> **Зауваження** :\n> \n> Специфікація HTTP/1.1 вимагає, щоб як аргумент заголовка [» Location:](http://tools.ietf.org/html/rfc7231#section-7.1.2) був вказаний абсолютний URI, який би включав схему, ім'я хоста та абсолютний шлях, хоча іноді клієнти можуть приймати і відносні URI. Абсолютний URI можна побудувати самому через елементи [$\\_SERVER\\['HTTP\\_HOST'\\]](reserved.variables.server.md) [$\\_SERVER\\['PHP\\_SELF'\\]](reserved.variables.server.md) або функцією [dirname()](function.dirname.md) :\n> \n> ```php\n> <?php\n> \n> /* Перенаправлення браузера на іншу сторінку в тій же директорії, яка\n> була запитана */\n> $host = $_SERVER['HTTP_HOST'];\n> $uri = rtrim(dirname($_SERVER['PHP_SELF']), '/\\\\');\n> $extra = 'mypage.php';\n> header(\"Location: http://$host$uri/$extra\");\n> exit;\n> \n> ?>\n> ```\n\n> **Зауваження** :\n> \n> Ідентифікатор сесії не буде передаватися разом із заголовком Location, навіть якщо увімкнено налаштування [session.use\\_trans\\_sid](session.configuration.md#ini.session.use-trans-sid). Його потрібно передавати вручну, використовуючи константу **`SID`**\n\n### Дивіться також\n\n-   [headers\\_sent()](function.headers-sent.md) \\- Перевіряє, чи були надіслані заголовки\n-   [setcookie()](function.setcookie.md) \\- Надсилає cookie\n-   [http\\_response\\_code()](function.http-response-code.md) \\- Отримує або встановлює код відповіді HTTP\n-   [header\\_remove()](function.header-remove.md) \\- Видаляє раніше встановлені заголовки\n-   [headers\\_list()](function.headers-list.md) \\- Повертає список переданих заголовків (або готових до відправлення)\n-   Розділ документації[HTTP-автентифікації](features.http-auth.md)\n","title":"header","contentType":2,"navigation":[{"function.header-remove.md":"« header\\_remove"},{"function.headers-list.md":"headers\\_list »"},{"index.md":"PHP Manual"},{"ref.network.md":"Мережеві функції"}]}},"__N_SSG":true}