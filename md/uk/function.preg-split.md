- [«preg_replace](function.preg-replace.md)
- [ssdeep »](book.ssdeep.md)

- [PHP Manual](index.md)
- [Функції PCRE](ref.pcre.md)
- Розбиває рядок за регулярним виразом

# preg_split

(PHP 4, PHP 5, PHP 7, PHP 8)

preg_split — Розбиває рядок за регулярним виразом

### Опис

**preg_split**(
string `$pattern`,
string `$subject`,
int `$limit` u003d -1,
int `$flags` u003d 0
): array\|false

Розбиває рядок за регулярним виразом.

### Список параметрів

`pattern`
Рядок містить шаблон пошуку.

`subject`
Вхідний рядок.

`limit`
Якщо вказано, функція повертає не більше, ніж `limit` підрядок.
Частина рядка, що залишилася, буде повернута в останній підрядці.
Спеціальне значення `limit`, що дорівнює -1 або 0, має на увазі відсутність
обмеження.

`flags`
`flags` може бути будь-якою комбінацією наступних прапорів (об'єднаних з
допомогою побітового оператора `|`):

**`PREG_SPLIT_NO_EMPTY`**
Якщо вказано цей прапор, функція **preg_split()** поверне лише непусті
підрядки.

**`PREG_SPLIT_DELIM_CAPTURE`**
Якщо зазначений цей прапор, вираз, укладений у круглі дужки в
розділяючий шаблон, також витягується із заданого рядка і повертається
функцією.

**`PREG_SPLIT_OFFSET_CAPTURE`**
Якщо зазначений цей прапор, для кожного знайденого підрядку буде вказано його
позиція у вихідному рядку. Необхідно пам'ятати, що цей прапор змінює
формат масиву, що повертається: кожен елемент буде містити масив,
що містить в індексі з номером `0` знайдену підрядку, а зміщення цієї
підстроки в параметрі `subject` - в індексі `1`.

### Значення, що повертаються

Повертає масив, що складається з підрядків заданого рядка `subject`,
яка розбита за межами, що відповідають шаблону `pattern` або
**`false`** у разі виникнення помилки.

### Помилки

Якщо переданий шаблон регулярного виразу не компілюється
допустиме регулярне вираження, видається помилка рівня **`E_WARNING`**.

### Приклади

**Приклад #1 **preg_split()** приклад: Отримання підрядок із заданого
тексту**

`<?php// розбиваємо рядок по|довільному числу кома і пробельних символів,// які включають в себе  "" ",,  ,
і  $keywords u003d preg_split("/[\s,]+/", "hypertext language, programming");print_r($keywords);?> `

Результат виконання цього прикладу:

Array
(
[0] u003d> hypertext
[1] u003d> language
[2] u003d> programming
)

**Приклад #2 Розбиваємо рядок на складові символи**

` <?php$str u003d 'string';$chars u003d preg_split('//', $str, -1, PREG_SPLIT_NO_EMPTY);print_r($chars);?> `

Результат виконання цього прикладу:

Array
(
[0] u003d> s
[1] u003d> t
[2] u003d> r
[3] u003d> i
[4] u003d> n
[5] u003d> g
)

**Приклад #3 Розбиваємо рядок із зазначенням усунення для кожної з
знайдених підрядів**

` <?php$str u003d 'hypertext language programming';$chars u003d preg_split('/ /', $str, -1, PREG_SPLIT_OFFSET_CAPTURE);print_r($chars);?> `

Результат виконання цього прикладу:

Array
(
[0] u003d> Array
(
[0] u003d> hypertext
[1] u003d> 0
)

[1] u003d> Array
(
[0] u003d> language
[1] u003d> 10
)

[2] u003d> Array
(
[0] u003d> programming
[1] u003d> 19
)

)

### Примітки

**Підказка**

Якщо вам не потрібна потужність регулярних виразів, ви можете вибрати більше
швидкі (хоч і прості) альтернативи на кшталт
[explode()](function.explode.md) або
[str_split()](function.str-split.md).

**Підказка**

Якщо відповідностей не знайшлося, то повертається масив із єдиним
елементом рівним усьому рядку.

### Дивіться також

- "[Регулярні висловлювання PCRE](pcre.pattern.md)"
- [preg_quote()](function.preg-quote.md) - Екранує символи в
регулярних виразах
- [implode()](function.implode.md) - Об'єднує елементи масиву в
рядок
- [preg_match()](function.preg-match.md) - Виконує перевірку на
відповідність регулярному виразу
- [preg_match_all()](function.preg-match-all.md) - Виконує
глобальний пошук шаблону в рядку
- [preg_replace()](function.preg-replace.md) - Пошук та
заміну за регулярним виразом
- [preg_last_error()](function.preg-last-error.md) - Повертає код
помилки виконання останнього регулярного вираження PCRE
