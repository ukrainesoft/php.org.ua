{"pageProps":{"page":{"slug":"language.oop5.overloading.md","content":"## Перевантаження\n\nПеревантаження в PHP означає можливість динамічно створювати властивості та методи. Ці динамічні сутності обробляються за допомогою магічних методів, які можна створити у класі для різних видів дій.\n\nМетоди навантаження викликаються при взаємодії з властивостями або методами, які не були оголошені чи не [видно](language.oop5.visibility.md) у поточній області видимості. Далі в цьому розділі будуть використовуватися терміни недоступні властивості або недоступні методи позначення цієї комбінації оголошення і області видимості.\n\nУсі методи навантаження мають бути оголошені як `public`\n\n> **Зауваження** :\n> \n> Жоден з аргументів цих магічних методів може бути переданий [за посиланням](functions.arguments.md#functions.arguments.by-reference)\n\n> **Зауваження** :\n> \n> Інтерпретація перевантаження PHP відрізняється від більшості об'єктно-орієнтованих мов. Традиційно перевантаження означає можливість мати кілька однойменних методів із різною кількістю та типами аргументів.\n\n### Перевантаження властивостей\n\n```methodsynopsis\npublic __set(string $name, mixed $value): void\n```\n\n```methodsynopsis\npublic __get(string $name): mixed\n```\n\n```methodsynopsis\npublic __isset(string $name): bool\n```\n\n```methodsynopsis\npublic __unset(string $name): void\n```\n\nМетод[\\_\\_set()](language.oop5.overloading.md#object.set) буде виконано під час запису даних у недоступні (захищені та приватні) або неіснуючі властивості.\n\nМетод[\\_\\_get()](language.oop5.overloading.md#object.get) буде виконано під час читання даних із недоступних (захищених чи приватних) чи неіснуючих властивостей.\n\nМетод[\\_\\_isset()](language.oop5.overloading.md#object.isset) буде виконано при використанні [isset()](function.isset.md) або [empty()](function.empty.md) на недоступних (захищених чи приватних) чи неіснуючих властивостях.\n\nМетод[\\_\\_unset()](language.oop5.overloading.md#object.unset) буде виконано під час виклику [unset()](function.unset.md) на недоступній (захищеній або приватній) або неіснуючій властивості.\n\nАргумент $name являє собою ім'я властивості, що викликається. Метод [\\_\\_set()](language.oop5.overloading.md#object.set) містить аргумент $value, що є значенням, яке буде записано у властивість з ім'ям $name.\n\nПеревантаження властивостей працює лише у контексті об'єкта. Дані магічні методи не будуть викликані у статичному контексті. Тому ці методи не повинні оголошуватися [статичними](language.oop5.static.md). При оголошенні будь-якого магічного методу як `static` буде видано попередження.\n\n> **Зауваження** :\n> \n> Возвращаемое значение[\\_\\_set()](language.oop5.overloading.md#object.set)будет проигнорировано из-за способа обработки в PHP оператора присваивания. Аналогично,[\\_\\_get()](language.oop5.overloading.md#object.get) ніколи не викликається при об'єднанні присвоювань, наприклад, таким чином:\n> \n> ```\n> $a = $obj->b = 8;\n> ```\n\n> **Зауваження** :\n> \n> PHP не викликатиме перевантажений метод зсередини того ж перевантаженого методу. Це означає, що, наприклад, написання `return $this->foo`внутри[\\_\\_get()](language.oop5.overloading.md#object.get) поверне `null` та викличе помилку рівня **`E_WARNING`**, если не определено свойство`foo`замість того, щоб викликати метод [\\_\\_get()](language.oop5.overloading.md#object.get) вдруге. Однак методи перевантаження можуть неявно викликати інші методи навантаження (наприклад, метод [\\_\\_set()](language.oop5.overloading.md#object.set) викликає метод [\\_\\_get()](language.oop5.overloading.md#object.get)\n\n**Приклад #1 Перевантаження властивостей за допомогою методів [\\_\\_get()](language.oop5.overloading.md#object.get) [\\_\\_set()](language.oop5.overloading.md#object.set) [\\_\\_isset()](language.oop5.overloading.md#object.isset) і [\\_\\_unset()](language.oop5.overloading.md#object.unset)**\n\n```php\n<?php\nclass PropertyTest\n{\n    /**  Место хранения перегружаемых данных.  */\n    private $data = array();\n\n    /**  Перегрузка не применяется к объявленным свойствам.  */\n    public $declared = 1;\n\n    /**  Здесь перегрузка будет использована только при доступе вне класса.  */\n    private $hidden = 2;\n\n    public function __set($name, $value)\n    {\n        echo \"Установка '$name' в '$value'\\n\";\n        $this->data[$name] = $value;\n    }\n\n    public function __get($name)\n    {\n        echo \"Получение '$name'\\n\";\n        if (array_key_exists($name, $this->data)) {\n            return $this->data[$name];\n        }\n\n        $trace = debug_backtrace();\n        trigger_error(\n            'Неопределённое свойство в __get(): ' . $name .\n            ' в файле ' . $trace[0]['file'] .\n            ' на строке ' . $trace[0]['line'],\n            E_USER_NOTICE);\n        return null;\n    }\n\n    public function __isset($name)\n    {\n        echo \"Установлено ли '$name'?\\n\";\n        return isset($this->data[$name]);\n    }\n\n    public function __unset($name)\n    {\n        echo \"Уничтожение '$name'\\n\";\n        unset($this->data[$name]);\n    }\n\n    /**  Не магический метод, просто для Приклада. */\n    public function getHidden()\n    {\n        return $this->hidden;\n    }\n}\n\n\necho \"<pre>\\n\";\n\n$obj = new PropertyTest;\n\n$obj->a = 1;\necho $obj->a . \"\\n\\n\";\n\nvar_dump(isset($obj->a));\nunset($obj->a);\nvar_dump(isset($obj->a));\necho \"\\n\";\n\necho $obj->declared . \"\\n\\n\";\n\necho \"Давайте поэкспериментируем с закрытым свойством 'hidden':\\n\";\necho \"Закрытые свойства видны внутри класса, поэтому __get() не используется...\\n\";\necho $obj->getHidden() . \"\\n\";\necho \"Закрытые свойства не видны вне класса, поэтому __get() используется...\\n\";\necho $obj->hidden . \"\\n\";\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nУстановка 'a' в '1'\nПолучение 'a'\n1\n\nУстановлено ли 'a'?\nbool(true)\nУничтожение 'a'\nУстановлено ли 'a'?\nbool(false)\n\n1\n\nДавайте поэкспериментируем с закрытым свойством 'hidden':\nЗакрытые свойства видны внутри класса, поэтому __get() не используется...\n2\nЗакрытые свойства не видны вне класса, поэтому __get() используется...\nПолучение 'hidden'\n\n\nNotice: Неопределённое свойство в __get(): hidden в <file> on line 70 in <file> on line 29\n```\n\n### Перевантаження методів\n\n```methodsynopsis\npublic __call(string $name, array $arguments): mixed\n```\n\n```methodsynopsis\npublic static __callStatic(string $name, array $arguments): mixed\n```\n\n[\\_\\_call()](language.oop5.overloading.md#object.call) запускається під час виклику недоступних методів у контексті об'єкт.\n\n[\\_\\_callStatic()](language.oop5.overloading.md#object.callstatic) запускається під час виклику недоступних методів у статичному контексті.\n\nАргумент $name являє собою ім'я методу, що викликається. Аргумент $arguments є нумерованим масивом, що містить параметри, передані в метод $name, що викликається.\n\n**Приклад #2 Перевантаження методів за допомогою методів [\\_\\_call()](language.oop5.overloading.md#object.call) і [\\_\\_callStatic()](language.oop5.overloading.md#object.callstatic)**\n\n```php\n<?php\nclass MethodTest {\n    public function __call($name, $arguments) {\n        // Замечание: значение $name регистрозависимо.\n        echo \"Вызов метода '$name' \"\n             . implode(', ', $arguments). \"\\n\";\n    }\n\n    public static function __callStatic($name, $arguments) {\n        // Замечание: значение $name регистрозависимо.\n        echo \"Вызов статического метода '$name' \"\n             . implode(', ', $arguments). \"\\n\";\n    }\n}\n\n$obj = new MethodTest;\n$obj->runTest('в контексте объекта');\n\nMethodTest::runTest('в статическом контексте');\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nВызов метода 'runTest' в контексте объекта\nВызов статического метода 'runTest' в статическом контексте\n```\n","title":"Перевантаження","contentType":2,"navigation":[{"language.oop5.anonymous.md":"« Анонімні класи"},{"language.oop5.iterations.md":"Ітератори об'єктів »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}