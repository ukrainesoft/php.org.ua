{"pageProps":{"page":{"slug":"reflectionmethod.construct.md","content":"# ReflectionMethod::\\_\\_construct\n\n(PHP 5, PHP 7, PHP 8)\n\nReflectionMethod::\\_\\_construct - Конструктор класу ReflectionMethod\n\n### Опис\n\npublic **ReflectionMethod::\\_\\_construct**(object|string`$objectOrMethod`, string`$method`) .\n\nAlternative signature (not supported with named arguments):\n\npublic **ReflectionMethod::\\_\\_construct**(string`$classMethod`) .\n\nСтворює новий об'єкт класу [ReflectionMethod](class.reflectionmethod.md)\n\n### Список параметрів\n\n`objectOrMethod`\n\nІм'я класу або об'єкт (примірник класу), що містить метод.\n\n`method`\n\nІм'я методу.\n\n`classMethod`\n\nІмена класу та методу, розділені `::`\n\n### Помилки\n\nИсключение[ReflectionException](class.reflectionexception.md) викидається, якщо заданий метод немає.\n\n### Приклади\n\n**Приклад #1 Приклад використання** ReflectionMethod::\\_\\_construct()\\*\\*\\*\\*\n\n```php\n<?php\nclass Counter\n{\n    private static $c = 0;\n\n    /**\n     * Счётчик\n     *\n     * @final\n     * @static\n     * @access  public\n     * @return  int\n     */\n    final public static function increment()\n    {\n        return ++self::$c;\n    }\n}\n\n// Создание экземпляра класса ReflectionMethod\n$method = new ReflectionMethod('Counter', 'increment');\n\n// Вывод основной информации\nprintf(\n    \"===> %s%s%s%s%s%s%s метод '%s' (%s)\\n\" .\n    \"     объявлен в %s\\n\" .\n    \"     строки с %d по %d\\n\" .\n    \"     имеет модификаторы %d[%s]\\n\",\n        $method->isInternal() ? 'внутренний' : 'определённый пользователем',\n        $method->isAbstract() ? ' абстрактный' : '',\n        $method->isFinal() ? ' окончательный' : '',\n        $method->isPublic() ? ' общедоступный' : '',\n        $method->isPrivate() ? ' закрытый' : '',\n        $method->isProtected() ? ' защищённый' : '',\n        $method->isStatic() ? ' статический' : '',\n        $method->getName(),\n        $method->isConstructor() ? 'конструктор' : 'обычный метод',\n        $method->getFileName(),\n        $method->getStartLine(),\n        $method->getEndline(),\n        $method->getModifiers(),\n        implode(' ', Reflection::getModifierNames($method->getModifiers()))\n);\n\n// Вывод doc-комментария\nprintf(\"---> Комментарий:\\n %s\\n\", var_export($method->getDocComment(), true));\n\n// Вывод статических переменных, если есть\nif ($statics= $method->getStaticVariables()) {\n    printf(\"---> Статические переменные: %s\\n\", var_export($statics, true));\n}\n\n// Вызов метода\nprintf(\"---> Результат вызова метода: \");\nvar_dump($method->invoke(NULL));\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n===> определённый пользователем окончательный общедоступный статический метод 'increment' (обычный метод)\n     объявлен в /Users/philip/cvs/phpdoc/test.php\n     строки с 14 по 17\n     имеет модификаторы 261[final public static]\n---> Комментарий:\n '/**\n     * Счётчик\n     *\n     * @final\n     * @static\n     * @access  public\n     * @return  int\n     */'\n---> Результат вызова метода: int(1)\n```\n\n### Дивіться також\n\n-   [ReflectionMethod::export()](reflectionmethod.export.md) \\- Експорт відбитого методу\n-   [Конструктори](language.oop5.decon.md#language.oop5.decon.constructor)\n","title":"ReflectionMethod::\\_\\_construct","contentType":2,"navigation":[{"class.reflectionmethod.md":"« ReflectionMethod"},{"reflectionmethod.createfrommethodname.md":"ReflectionMethod::createFromMethodName »"},{"index.md":"PHP Manual"},{"class.reflectionmethod.md":"ReflectionMethod"}]}},"__N_SSG":true}