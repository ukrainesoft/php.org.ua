{"pageProps":{"page":{"slug":"intlcalendar.clear.md","content":"# IntlCalendar::clear\n\n(PHP 5 >= 5.5.0, PHP 7, PHP 8, PECL >= 3.0.0a1)\n\nIntlCalendar::clear — Очищає поле чи всі поля\n\n### Опис\n\nОб'єктно-орієнтований стиль\n\n```methodsynopsis\npublic IntlCalendar::clear(?int $field = null): true\n```\n\nПроцедурний стиль\n\n```methodsynopsis\nintlcal_clear(IntlCalendar $calendar, ?int $field = null): true\n```\n\nОчищає всі поля, або певне поле. Очищене поле позначається як не задане, що дає йому найнижчий пріоритет щодо перевизначальних полів або навіть за замовчуванням при обчисленні часу. Крім того, його значення встановлено на , хоча, враховуючи низький пріоритет поля, його значення могло бути внутрішньо встановлено інше значення на момент завершення запиту поля.\n\n### Список параметрів\n\n`calendar`\n\nЕкземпляр [IntlCalendar](class.intlcalendar.md)\n\n`field`\n\nОдна з представлених у класі [IntlCalendar](class.intlcalendar.md) [констант](class.intlcalendar.md#intlcalendar.constants)полей типа дата/время. Целое число от до\\*\\*`IntlCalendar::FIELD_COUNT`\\*\\*\n\n### Значення, що повертаються\n\nФункція завжди повертає **`true`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.2.0 | Тип значення, що повертається тепер **`true`**; раніше було bool. |\n\n### Приклади\n\n**Приклад #1 Приклад використання** IntlCalendar::clear()\\*\\*\\*\\*\n\n```php\n<?php\nini_set('intl.default_locale', 'es_ES');\nini_set('date.timezone', 'UTC');\n\n$fields = array(\n    'FIELD_ERA'                  => 0,\n    'FIELD_YEAR'                 => 1,\n    'FIELD_MONTH'                => 2,\n    'FIELD_WEEK_OF_YEAR'         => 3,\n    'FIELD_WEEK_OF_MONTH'        => 4,\n    'FIELD_DATE'                 => 5,\n    'FIELD_DAY_OF_YEAR'          => 6,\n    'FIELD_DAY_OF_WEEK'          => 7,\n    'FIELD_DAY_OF_WEEK_IN_MONTH' => 8,\n    'FIELD_AM_PM'                => 9,\n    'FIELD_HOUR'                 => 10,\n    'FIELD_HOUR_OF_DAY'          => 11,\n    'FIELD_MINUTE'               => 12,\n    'FIELD_SECOND'               => 13,\n    'FIELD_MILLISECOND'          => 14,\n    'FIELD_ZONE_OFFSET'          => 15,\n    'FIELD_DST_OFFSET'           => 16,\n    'FIELD_YEAR_WOY'             => 17,\n    'FIELD_DOW_LOCAL'            => 18,\n    'FIELD_EXTENDED_YEAR'        => 19,\n    'FIELD_JULIAN_DAY'           => 20,\n    'FIELD_MILLISECONDS_IN_DAY'  => 21,\n    'FIELD_IS_LEAP_MONTH'        => 22,\n    'FIELD_FIELD_COUNT'          => 23,\n);\nfunction getSetFields(IntlCalendar $cal) {\n    global $fields;\n    $ret = array();\n    foreach ($fields as $name => $value) {\n        if ($cal->isSet($value)) {\n            $ret[] = $name;\n        }\n    }\n    return $ret;\n}\n\n$cal = new IntlGregorianCalendar(2013, 2 /* Март */, 15);\necho \"После создания григорианского календаря\\n\";\nprint_r(getSetFields($cal));\necho \"\\n\";\n\necho IntlDateFormatter::formatObject($cal), \"\\n\";\necho \"После того, как средство форматирования запросило поле EXTENDED_YEAR\\n\";\nprint_r(getSetFields($cal));\necho \"\\n\";\n\n$cal->clear(IntlCalendar::FIELD_YEAR);\necho \"После того, как год будет очищен, дата останется прежней\\n\";\necho IntlDateFormatter::formatObject($cal), \"\\n\";\necho \"Потому что FIELD_EXTENDED_YEAR все ещё установлен\\n\";\nprint_r(getSetFields($cal));\necho \"\\n\";\n\nvar_dump($cal->clear(IntlCalendar::FIELD_EXTENDED_YEAR));\necho \"После того, как поле EXTENDED_YEAR было очищено\\n\";\nprint_r(getSetFields($cal));\necho IntlDateFormatter::formatObject($cal), \"\\n\";\necho \"\\n\";\n\necho \"После пересчёта полей,\\n\"\n        . \" снова установлено поле EXTENDED_YEAR (до 1970 г.)\\n\";\nprint_r(getSetFields($cal));\necho \"\\n\";\n\n$cal->clear();\necho \"После вызова варианта без аргументов\\n\";\nprint_r(getSetFields($cal));\necho IntlDateFormatter::formatObject($cal), \"\\n\";\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nПосле создания григорианского календаря\nArray\n(\n    [0] => FIELD_ERA\n    [1] => FIELD_YEAR\n    [2] => FIELD_MONTH\n    [3] => FIELD_DATE\n)\n\n15/03/2013 00:00:00\nПосле того, как средство форматирования запросило поле EXTENDED_YEAR\nArray\n(\n    [0] => FIELD_ERA\n    [1] => FIELD_YEAR\n    [2] => FIELD_MONTH\n    [3] => FIELD_DATE\n    [4] => FIELD_EXTENDED_YEAR\n)\n\nПосле того, как год будет очищен, дата останется прежней\n15/03/2013 00:00:00\nПотому что FIELD_EXTENDED_YEAR все ещё установлен\nArray\n(\n    [0] => FIELD_ERA\n    [1] => FIELD_MONTH\n    [2] => FIELD_DATE\n    [3] => FIELD_EXTENDED_YEAR\n)\n\nbool(true)\nПосле того, как поле EXTENDED_YEAR было очищено\nArray\n(\n    [0] => FIELD_ERA\n    [1] => FIELD_MONTH\n    [2] => FIELD_DATE\n)\n15/03/1970 00:00:00\n\nПосле пересчёта полей,\n снова установлено поле EXTENDED_YEAR (до 1970 г.)\nArray\n(\n    [0] => FIELD_ERA\n    [1] => FIELD_MONTH\n    [2] => FIELD_DATE\n    [3] => FIELD_EXTENDED_YEAR\n)\n\nПосле вызова варианта без аргументов\nArray\n(\n)\n01/01/1970 00:00:00\n```\n","title":"IntlCalendar::clear","contentType":2,"navigation":[{"intlcalendar.before.md":"« IntlCalendar::before"},{"intlcalendar.construct.md":"IntlCalendar::\\_\\_construct »"},{"index.md":"PHP Manual"},{"class.intlcalendar.md":"IntlCalendar"}]}},"__N_SSG":true}