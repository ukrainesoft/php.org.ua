{"pageProps":{"page":{"slug":"language.exceptions.md","content":"# Винятки\n\n## Зміст\n\n-   [Спадкування винятків](language.exceptions.extending.md)\n\nУ PHP реалізовано модель винятків, аналогічну тим, що використовуються в інших мовах програмування. Виняток у PHP може бути викинуто ([`throw`](language.exceptions.md)) і спіймано (`catch`). Код може бути укладений у блок [`try`](language.exceptions.md), щоб полегшити обробку потенційних винятків. У кожного блоку [`try`](language.exceptions.md) має бути як мінімум один відповідний блок `catch`или`finally`\n\nЯкщо викинутий виняток, а в поточній області видимості функції немає блоку `catch`, виняток буде \"підніматися\" по стеку викликів до зухвалої функції, доки не знайде відповідний блок `catch`. Усі блоки `finally`, які зустрінуться на цьому шляху, будуть виконані. Якщо стек викликів розгортається до глобальної області видимості, не зустрічаючи відповідного блоку `catch`, програма завершується з невиправною помилкою, якщо не було встановлено глобальний обробник винятків.\n\nВикинутий об'єкт повинен наслідувати ([`instanceof`](language.operators.type.md)) інтерфейс [Throwable](class.throwable.md). Спроба викинути об'єкт, який не є таким, призведе до непоправної помилки PHP.\n\nПочинаючи з PHP 8.0.0, ключове слово [`throw`](language.exceptions.md) є виразом і може бути використаний у будь-якому контексті виразу. У попередніх версіях воно було твердженням і мало розташовуватися в окремому рядку.\n\n## `catch`\n\nБлок`catch` визначає, як реагувати на викинутий виняток. Блок `catch` визначає один або декілька типів винятків або помилок, які він може обробити, і, за бажанням, змінну, якій можна привласнити виняток (вказівка ​​змінної була обов'язковою до версії PHP 8.0.0). Перший блок `catch`, з яким зіткнеться викинутий виняток чи помилка і відповідає типу викинутого об'єкта, обробить об'єкт.\n\nДекілька блоків `catch` можуть бути використані для перехоплення різних класів винятків. Нормальне виконання (коли виняток не викинуто у блоці [`try`](language.exceptions.md)) будет продолжаться после последнего блока`catch`, Визначеного в послідовності. Винятки можуть бути викинуті ([`throw`](language.exceptions.md)) (або повторно викинуті) усередині блоку `catch`. В іншому випадку виконання буде продовжено після блоку `catch`, який був викликаний.\n\nПри виникненні виключення, код, який слідує за твердженням, не буде виконаний, а PHP спробує знайти перший відповідний блок `catch`. . Якщо виняток не спіймано, буде видана помилка PHP з повідомленням \"`Uncaught Exception ...`\", якщо обробник не був визначений за допомогою функції [set\\_exception\\_handler()](function.set-exception-handler.md)\n\nПочинаючи з версії PHP 7.1.0, у блоці `catch` можна вказувати кілька винятків, використовуючи символ . Це корисно, коли різні винятки із різних ієрархій класів обробляються однаково.\n\nПочинаючи з версії PHP 8.0.0, ім'я змінної для упійманого виключення є необов'язковим. Якщо воно не вказано, блок `catch` буде виконано, але не матиме доступу до викинутого об'єкта.\n\n## `finally`\n\nБлок`finally` також може бути вказаний після або замість блоків `catch`. Код у блоці `finally` завжди виконуватиметься після блоків [`try`](language.exceptions.md)и`catch`незалежно від того, чи було викинуто виняток і до відновлення нормального виконання.\n\nОдна з помітних взаємодій відбувається між блоком `finally` та оператором [`return`](function.return.md). Якщо оператор [`return`](function.return.md) зустрічається усередині блоків [`try`](language.exceptions.md)или`catch`, блок`finally` все одно буде виконано. Більше того, оператор [`return`](function.return.md) виконається, коли зустрінеться, але результат буде повернутий після виконання блоку `finally`. Крім того, якщо блок `finally` також містить оператор [`return`](function.return.md), возвращается значение из блока`finally`\n\n## Глобальний обробник винятків\n\nЯкщо виключення дозволено поширюватися на глобальну область видимості, це може бути перехоплено глобальним обробником винятків, якщо він встановлено. Функція [set\\_exception\\_handler()](function.set-exception-handler.md) може встановити функцію, яка буде викликана замість блоку `catch`, якщо не буде викликано жодного іншого блоку. Ефект по суті такий самий, як якби вся програма була обгорнута в блок [`try`](language.exceptions.md)\\-`catch` з цією функцією як `catch`\n\n## Примітки\n\n> **Зауваження** :\n> \n> Внутрішні функції PHP переважно використовують [звіт про помилки](errorfunc.configuration.md#ini.error-reporting), тільки сучасні [об'єктно-орієнтовані](language.oop5.md) модулі використовують винятки. Однак помилки можна легко перевести у винятки за допомогою класу [ErrorException](class.errorexception.md). Однак ця техніка працює тільки з помилками, що виправляються.\n> \n> **Приклад #1 Перетворення звітів про помилки на виключення**\n> \n> ```php\n> <?php\n> function exceptions_error_handler($severity, $message, $filename, $lineno) {\n>     throw new ErrorException($message, 0, $severity, $filename, $lineno);\n> }\n> \n> set_error_handler('exceptions_error_handler');\n> ?>\n> ```\n\n**Підказка**\n\nБиблиотека[Стандартна бібліотека PHP (SPL)](intro.spl.md) надає велику кількість [вбудованих винятків](spl.exceptions.md)\n\n## Приклади\n\n**Приклад #2 Викидання винятку**\n\n```php\n<?php\nfunction inverse($x) {\n    if (!$x) {\n        throw new Exception('Деление на ноль.');\n    }\n    return 1/$x;\n}\n\ntry {\n    echo inverse(5) . \"\\n\";\n    echo inverse(0) . \"\\n\";\n} catch (Exception $e) {\n    echo 'Выброшено исключение: ',  $e->getMessage(), \"\\n\";\n}\n\n// Продолжение выполнения\necho \"Привет, мир\\n\";\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n0.2\nВыброшено исключение: Деление на ноль.\nПривет, мир\n```\n\n**Приклад #3 Обработка исключений с помощью блока`finally`**\n\n```php\n<?php\nfunction inverse($x) {\n    if (!$x) {\n        throw new Exception('Деление на ноль.');\n    }\n    return 1/$x;\n}\n\ntry {\n    echo inverse(5) . \"\\n\";\n} catch (Exception $e) {\n    echo 'Поймано исключение: ',  $e->getMessage(), \"\\n\";\n} finally {\n    echo \"Первый блок finally.\\n\";\n}\n\ntry {\n    echo inverse(0) . \"\\n\";\n} catch (Exception $e) {\n    echo 'Поймано исключение: ',  $e->getMessage(), \"\\n\";\n} finally {\n    echo \"Второй блок finally.\\n\";\n}\n\n// Продолжение нормального выполнения\necho \"Привет, мир\\n\";\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n0.2\nПервый блок finally.\nПоймано исключение: Деление на ноль.\nВторой блок finally.\nПривет, мир\n```\n\n**Приклад #4 Взаємодія між блоками `finally`и[`return`](function.return.md)**\n\n```php\n<?php\n\nfunction test() {\n    try {\n        throw new Exception('foo');\n    } catch (Exception $e) {\n        return 'catch';\n    } finally {\n        return 'finally';\n    }\n}\n\necho test();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nfinally\n```\n\n**Приклад #5 Вкладені винятки**\n\n```php\n<?php\n\nclass MyException extends Exception { }\n\nclass Test {\n    public function testing() {\n        try {\n            try {\n                throw new MyException('foo!');\n            } catch (MyException $e) {\n                // повторный выброс исключения\n                throw $e;\n            }\n        } catch (Exception $e) {\n            var_dump($e->getMessage());\n        }\n    }\n}\n\n$foo = new Test;\n$foo->testing();\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(4) \"foo!\"\n```\n\n**Приклад #6 Обробка кількох винятків в одному блоці catch**\n\n```php\n<?php\n\nclass MyException extends Exception { }\n\nclass MyOtherException extends Exception { }\n\nclass Test {\n    public function testing() {\n        try {\n            throw new MyException();\n        } catch (MyException | MyOtherException $e) {\n            var_dump(get_class($e));\n        }\n    }\n}\n\n$foo = new Test;\n$foo->testing();\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(11) \"MyException\"\n```\n\n**Приклад #7 Приклад блока`catch` без вказівки змінної**\n\nДопустимо починаючи з PHP 8.0.0\n\n```php\n<?php\n\nclass SpecificException extends Exception {}\n\nfunction test() {\n    throw new SpecificException('Ой!');\n}\n\ntry {\n    test();\n} catch (SpecificException) {\n    print \"Было поймано исключение SpecificException, но нам безразлично, что у него внутри.\";\n}\n?>\n```\n\n**Приклад #8 Throw як вираз**\n\nДопустимо починаючи з PHP 8.0.0\n\n```php\n<?php\n\nfunction test() {\n    do_something_risky() or throw new Exception('Всё сломалось');\n}\n\ntry {\n    test();\n} catch (Exception $e) {\n    print $e->getMessage();\n}\n?>\n```\n","title":"Винятки","contentType":2,"navigation":[{"language.errors.php7.md":"« Помилки в PHP 7"},{"language.exceptions.extending.md":"Спадкування винятків »"},{"index.md":"PHP Manual"},{"langref.md":"Довідник мови"}]}},"__N_SSG":true}