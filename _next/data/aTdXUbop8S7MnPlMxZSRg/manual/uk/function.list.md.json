{"pageProps":{"page":{"slug":"function.list.md","content":"# list\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nlist - Надає змінним значення схожим на масиви синтаксисом\n\n### Опис\n\n```methodsynopsis\nlist(mixed $var, mixed ...$vars = ?): array\n```\n\nЯк і конструкція [array()](function.array.md), це функція, а мовна конструкція. Конструкцією **list()** користуються, щоб надавати списку змінних значення за одну операцію. Рядки не можна розпакувати, а вирази **list()** не можна викликати без аргументів.\n\n> **Зауваження** :\n> \n> До PHP 7.1.0 конструкция**list()** працювала тільки з індексованими масивами та приймала числові індекси починаючи з 0.\n\n### Список параметрів\n\n`var`\n\nЗмінна.\n\n`vars`\n\nДодаткові змінні.\n\n### Значення, що повертаються\n\nПовертає привласнений масив.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.3.0 | Додано підтримку присвоєння за посиланнями при деструктуруванні масиву. |\n| 7.1.0 | Тепер у конструкції **list()** можна задавати ключі. Це дозволяє розіменовувати асоціативні масиви та масиви з індексами не по порядку. |\n\n### Приклади\n\n**Приклад #1 Приклад використання конструкції **list()****\n\n```php\n<?php\n\n$info = array('кофе', 'коричневый', 'кофеин');\n\n// Составить список всех переменных\nlist($drink, $color, $power) = $info;\necho \"$drink - $color, а $power делает его особенным.\\n\";\n\n// Составить список только некоторых из них\nlist($drink, , $power) = $info;\necho \"В $drink есть $power.\\n\";\n\n// Или пропустить все, кроме третьей\nlist( , , $power) = $info;\necho \"Мне нужен $power!\\n\";\n\n// Конструкция list() не работает со строками\nlist($bar) = \"abcde\";\nvar_dump($bar); // NULL\n?>\n```\n\n**Приклад #2 Приклад використання конструкції **list()****\n\n```php\n<?php\n\n$result = $pdo->query(\"SELECT id, name FROM employees\");\nwhile (list($id, $name) = $result->fetch(PDO::FETCH_NUM)) {\n    echo \"id: $id, name: $name\\n\";\n}\n?>\n```\n\n**Приклад #3 Использование**list()\\*\\* з індексами масивів\\*\\*\n\n```php\n<?php\n\nlist($a, list($b, $c)) = array(1, array(2, 3));\n\nvar_dump($a, $b, $c);\n\n?>\n```\n\n```\nint(1)\nint(2)\nint(3)\n```\n\n**Приклад #4 Конструкция**list()\\*\\* та порядок вказівки індексів\\*\\*\n\nПорядок визначення індексів у масиві, з яким працюватиме конструкція **list()**, не важливий.\n\n```php\n<?php\n\n$foo = array(2 => 'a', 'foo' => 'b', 0 => 'c');\n$foo[1] = 'd';\nlist($x, $y, $z) = $foo;\nvar_dump($foo, $x, $y, $z);\n```\n\nДає такий висновок (зверніть увагу на порядок, в якому елементи порівнювалися, і в якому порядку записані елементи в синтаксисі **list()**):\n\n```\narray(4) {\n  [2]=>\n  string(1) \"a\"\n  [\"foo\"]=>\n  string(1) \"b\"\n  [0]=>\n  string(1) \"c\"\n  [1]=>\n  string(1) \"d\"\n}\nstring(1) \"c\"\nstring(1) \"d\"\nstring(1) \"a\"\n```\n\n**Приклад #5**list()\\*\\* з ключами\\*\\*\n\nПочинаючи з PHP 7.1.0 конструкції **list()** можна містити явні ключі, які вказують як довільні вирази. Допустимо змішувати рядкові та цілочислові ключі; однак елементи з ключами і без ключів не можна змішувати.\n\n```php\n<?php\n\n$data = [\n    [\"id\" => 1, \"name\" => 'Tom'],\n    [\"id\" => 2, \"name\" => 'Fred'],\n];\nforeach ($data as [\"id\" => $id, \"name\" => $name]) {\n    echo \"id: $id, name: $name\\n\";\n}\necho PHP_EOL;\nlist(1 => $second, 3 => $fourth) = [1, 2, 3, 4];\necho \"$second, $fourth\\n\";\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid: 1, name: Tom\nid: 2, name: Fred\n\n2, 4\n```\n\n### Дивіться також\n\n-   [each()](function.each.md) \\- Повертає поточну пару ключ/значення з масиву та зміщує його покажчик\n-   [array()](function.array.md) \\- створює масив\n-   [extract()](function.extract.md) \\- Імпортує змінні масиву до поточної таблиці символів\n","title":"list","contentType":2,"navigation":[{"function.ksort.md":"« ksort"},{"function.natcasesort.md":"natcasesort »"},{"index.md":"PHP Manual"},{"ref.array.md":"Функції для роботи з масивами"}]}},"__N_SSG":true}