{"pageProps":{"page":{"slug":"language.types.declarations.md","content":"## Оголошення типів\n\nОголошення типів дозволено додавати до аргументів функції, значенням, що повертаються, і властивостям класу (останнє починаючи з PHP 7.4.0). Оголошені типи гарантують, що під час виклику значення належить тому типу, який для нього вказано, інакше буде викинуто виняток [TypeError](class.typeerror.md)\n\nКожен тип, який підтримує PHP, за винятком ресурсів (resource), дозволено вказувати при об'явленні користувача типу. На цій сторінці наведено журнал змін доступності окремих типів та документацію про те, як їх застосовувати в оголошеннях типів.\n\n> **Зауваження** :\n> \n> Коли клас реалізує метод інтерфейсу або перевизначає метод, який вже був визначений батьківським класом, метод, що знову визначається, повинен бути сумісний з визначенням, яке було зроблено раніше. Метод сумісний, якщо він дотримується [правила варіантності](language.oop5.variance.md)\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.3.0 | Додано підтримку типізації констант класів, інтерфейсів, трейтів та перерахувань. |\n| 8.2.0 | Додано підтримку типів DNF. |\n| 8.2.0 | Додано підтримку типу true. |\n| 8.2.0 | Типи null та false тепер можна використовувати автономно. |\n| 8.1.0 | Додано підтримку перетинів типів. |\n| 8.1.0 | Повернення за посиланням з функції з типом значення, що повертається void застарів. |\n| 8.1.0 | Додано підтримку типу повертаного значення never. |\n| 8.0.0 | Додана підтримка типу значення, що повертається [mixed](language.types.declarations.md#language.types.declarations.mixed) |\n| 8.0.0 | Додано підтримку типу повертаного значення static. |\n| 8.0.0 | Додано підтримку об'єднання типів. |\n| 7.4.0 | Додано підтримку типізації властивостей класів. |\n| 7.2.0 | Додана підтримка типу значення object, що повертається. |\n| 7.1.0 | Додана підтримка типу значення, що повертається [iterable](language.types.iterable.md) |\n| 7.1.0 | Додано підтримку типу повертаного значення void. |\n| 7.1.0 | Додана підтримка типу значення nullable. |\n\n### Примітка щодо використання атомарних типів\n\nАтомарні типи мають прямолінійну поведінку з незначними застереженнями, які описані в цьому розділі.\n\n#### Скалярні типи\n\n**Увага**\n\nПсевдоніми імен для скалярних типів (bool, int, float, string) не підтримуються. Натомість вони розглядаються як імена класів або інтерфейсів. Наример, коли в якості типу вказано `boolean`очікується, що значення виконує умова [`instanceof`](language.operators.type.md) щодо класу чи інтерфейсу `boolean`, а не значення типу bool:\n\n```php\n<?php\n    function test(boolean $param) {}\n    test(true);\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nWarning: \"boolean\" will be interpreted as a class name. Did you mean \"bool\"? Write \"\\boolean\" to suppress this warning in /in/9YrUX on line 2\n\nFatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2\nStack trace:\n#0 -(3): test(true)\n#1 {main}\n  thrown in - on line 2\n```\n\n#### void\n\n> **Зауваження** :\n> \n> Повернення за посиланням з void-функції застарілий починаючи з PHP 8.1.0, оскільки така функція суперечлива. Раніше під час її виклику видавалася помилка рівня **`E_NOTICE`**: Тільки посилання на змінні повинні повертатися за посиланням\n> \n> ```php\n> <?php\n> function &test(): void {}\n> ?>\n> ```\n\n#### Тип Callable\n\nЦей тип не можна оголошувати як тип якості класу.\n\n> **Зауваження**: Цей тип неможливо вказати як назву функції.\n\n#### Оголошення типів у параметрах передачі за посиланнями\n\nЯкщо у параметрі, що передається за посиланням, оголошується тип значення, що повертається, тип змінної перевіряється *тільки* при вході в функцію, на початку дзвінка, але не при поверненні функції. Тобто функція може змінити тип посилання змінну.\n\n**Приклад #1 Типизовані параметри, що передаються за посиланням**\n\n```php\n<?php\n\nfunction array_baz(array &$param)\n{\n    $param = 1;\n}\n$var = [];\narray_baz($var);\nvar_dump($var);\narray_baz($var);\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nint(1)\n\nFatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2\nStack trace:\n#0 -(9): array_baz(1)\n#1 {main}\n  thrown in - on line 2\n```\n\n### Примітка щодо складових типів\n\nНа оголошення складових типів поширюється низка обмежень і під час компіляції PHP виконає перевірку оголошених типів на надмірність, щоб запобігти простим помилкам.\n\n**Застереження**\n\nДо PHP 8.2.0 та появи DNF-типів, було неможливо комбінувати пересічені та об'єднані типи.\n\n#### Об'єднання типів\n\n**Увага**\n\nНеможливо поєднувати два типи значень false та true. Натомість вказують bool.\n\n**Застереження**\n\nОскільки до PHP 8.2.0 не можна було визначати false і null як окремі типи, об'єднання типів, що складалося лише з цих типів, було неприпустимим. Сюди входять типи: false, `false|null`и`?false`\n\n##### Синтаксичний цукор типу Nullable\n\nОголошення одного базового типу може бути позначене як nullable шляхом додавання до типу префікса у вигляді знака питання (`?` ). Тому `?T`и`T|null` ідентичні.\n\n> **Зауваження**: Цей синтаксис підтримується з PHP 7.1.0 та передує підтримці об'єднання типів.\n\n> **Зауваження** :\n> \n> Ще один спосіб досягти nullable-аргументів - вказати `null` значенням за промовчанням. Такий спосіб не рекомендований, оскільки якщо значення за замовчуванням буде змінено в дочірньому класі, виникне порушення сумісності типів, так як в оголошення типу потрібно буде додати тип null.\n> \n> **Приклад #2 Старий спосіб вказівки nullable-аргументів**\n> \n> ```php\n> <?php\n> \n> class C {}\n> \n> function f(C $c = null) {\n>     var_dump($c);\n> }\n> \n> f(new C);\n> f(null);\n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> object(C)#1 (0) {\n> }\n> NULL\n> ```\n\n#### Повторювані та надлишкові типи\n\nНадлишкові типи, які можна знайти без виконання завантаження класу, призведуть до помилки під час компіляції, щоб відловити неточності в оголошеннях складових типів. У них включено:\n\n-   Кожне ім'я після дозволу внутрішніми засобами мови може зустрічатися лише один раз. Наприклад, типи`int|string|INT`или`Countable&Traversable&COUNTABLE`приведуть до помилки.\n-   Вказівка ​​типу[mixed](language.types.declarations.md#language.types.declarations.mixed)(з іншими типами) призведе до помилки.\n-   Для об'єднаних типів:\n    -   Якщо вказано тип bool, то false чи true не може бути вказано додатково.\n    -   Якщо вказано тип об'єкта, типи класів не можна вказувати додатково.\n    -   Якщо вказано тип[iterable](language.types.iterable.md), то array і[Traversable](class.traversable.md)не можна вказувати додатково.\n-   Для перетятих типів:\n    -   Вказівка ​​типу, що не відноситься до типу класу, призведе до помилки.\n    -   Вказівка ​​self, parent або static призведе до помилки.\n-   Для DNF-типів:\n    -   Якщо вказано більш загальний тип, то суворіший тип буде надлишковим.\n    -   Дублювання членів у пересічених типах.\n\n> **Зауваження**: Це не гарантує, що тип мінімальний, оскільки для цього довелося б завантажити всі зазначені типи класів.\n\nНаприклад, якщо `A`и`B` - це псевдоніми класів, то `A|B` залишається коректним об'єднанням типів, навіть якщо його можна звести або до `A`, либо к`B`. Аналогічно, якщо клас `B extends A {}`, то`A|B` також є коректним поєднанням типів, навіть якщо його можна звести до просто `A`\n\n```php\n<?php\n\nfunction foo(): int|INT {} // Запрещено\nfunction foo(): bool|false {} // Запрещено\nfunction foo(): int&Traversable {} // Запрещено\nfunction foo(): self&Traversable {} // Запрещено\n\nuse A as B;\nfunction foo(): A|B {} // Запрещено («use» — часть разрешения имён)\nfunction foo(): A&B {} // Запрещено («use» — часть разрешения имён)\n\nclass_alias('X', 'Y');\nfunction foo(): X|Y {} // Разрешено (избыточность известна только во время выполнения)\nfunction foo(): X&Y {} // Разрешено (избыточность известна только во время выполнения)\n?>\n```\n\n### Приклади\n\n**Приклад #3 Приклад оголошення типу класу**\n\n```php\n<?php\n\nclass C {}\nclass D extends C {}\n\n// Не наследует C.\nclass E {}\n\nfunction f(C $c) {\n    echo get_class($c).\"\\n\";\n}\n\nf(new C);\nf(new D);\nf(new E);\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nC\nD\n\nFatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8\nStack trace:\n#0 -(14): f(Object(E))\n#1 {main}\n  thrown in - on line 8\n```\n\n**Приклад #4 Приклад оголошення типу інтерфейсу**\n\n```php\n<?php\n\ninterface I { public function f(); }\nclass C implements I { public function f() {} }\n\n// Не реализует I.\nclass E {}\n\nfunction f(I $i) {\n    echo get_class($i).\"\\n\";\n}\n\nf(new C);\nf(new E);\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nC\n\nFatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8\nStack trace:\n#0 -(13): f(Object(E))\n#1 {main}\n  thrown in - on line 8\n```\n\n**Приклад #5 Приклад оголошення типу значення, що повертається**\n\n```php\n<?php\n\nfunction sum($a, $b): float {\n    return $a + $b;\n}\n\n// Обратите внимание, что будет возвращено значение float.\nvar_dump(sum(1, 2));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nfloat(3)\n```\n\n**Приклад #6 Повернення об'єкта**\n\n```php\n<?php\n\nclass C {}\n\nfunction getC(): C {\n    return new C;\n}\n\nvar_dump(getC());\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nobject(C)#1 (0) {\n}\n```\n\n**Приклад #7 Оголошення аргументу типу Nullable**\n\n```php\n<?php\n\nclass C {}\n\nfunction f(?C $c) {\n    var_dump($c);\n}\n\nf(new C);\nf(null);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nobject(C)#1 (0) {\n}\nNULL\n```\n\n**Приклад #8 Оголошення типу значення, що повертається Nullable**\n\n```php\n<?php\n\nfunction get_item(): ?string {\n    if (isset($_GET['item'])) {\n        return $_GET['item'];\n    } else {\n        return null;\n    }\n}\n?>\n```\n\n**Приклад #9 Оголошення типу якості класу**\n\n```php\n<?php\n\nclass User {\n    public static string $foo = 'foo';\n\n    public int $id;\n    public string $username;\n\n    public function __construct(int $id, string $username) {\n        $this->id = $id;\n        $this->username = $username;\n    }\n}\n?>\n```\n\n### Сувора типізація\n\nЗа промовчанням PHP перетворюватиме значення неправильного типу на очікувані. Наприклад, якщо рядковий (string) параметр функції передати ціле число (int), воно перетворюється на рядок (string).\n\nМожна увімкнути режим суворої типізації на рівні файлу. У цьому режимі тип значення повинен суворо відповідати оголошеному, інакше буде викинуто виняток [TypeError](class.typeerror.md). Єдиний виняток із цього правила — передача цілого значення (int) туди, де очікується число з плаваючою точкою (float).\n\n**Увага**\n\nНа дзвінки з внутрішніх функцій дія `strict_types` не розповсюджується.\n\nДля включення суворої типізації вказують оператор [`declare`](control-structures.declare.md) з оголошенням `strict_types` :\n\n> **Зауваження** :\n> \n> Сувора типізація поширюється на виклики функцій, зроблених *зсередини* файла з увімкненою строгою типізацією, а не до функцій, оголошених у цьому файлі. Якщо з файлу без увімкненої суворої типізації викликається функція, яка була визначена у файлі зі суворою типізацією, то будуть використані установки по типізації зухвалої сторони - тобто правила суворої типізації будуть проігноровані і для значень застосовуватиметься приведення типів.\n\n> **Зауваження** :\n> \n> Сувора типізація визначається лише для оголошень скалярних типів.\n\n**Приклад #10 Сувора типізація для значень аргументів**\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nfunction sum(int $a, int $b) {\n    return $a + $b;\n}\n\nvar_dump(sum(1, 2));\nvar_dump(sum(1.5, 2.5));\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nint(3)\n\nFatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4\nStack trace:\n#0 -(9): sum(1.5, 2.5)\n#1 {main}\n  thrown in - on line 4\n```\n\n**Приклад #11 Приведення типів для значень аргументів**\n\n```php\n<?php\n\nfunction sum(int $a, int $b) {\n    return $a + $b;\n}\n\nvar_dump(sum(1, 2));\n\n// Переданные значения будут приведены к целым числам: обратите внимание на вывод ниже!\nvar_dump(sum(1.5, 2.5));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(3)\nint(3)\n```\n\n**Приклад #12 Сувора типізація для значень, що повертаються**\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nfunction sum($a, $b): int {\n    return $a + $b;\n}\n\nvar_dump(sum(1, 2));\nvar_dump(sum(1, 2.5));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(3)\n\nFatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5\nStack trace:\n#0 -(9): sum(1, 2.5)\n#1 {main}\n  thrown in - on line 5\n```\n","title":"Оголошення типів","contentType":2,"navigation":[{"language.types.iterable.md":"« Ітеровані"},{"language.types.type-juggling.md":"Маніпуляції з типами »"},{"index.md":"PHP Manual"},{"language.types.md":"Типи"}]}},"__N_SSG":true}