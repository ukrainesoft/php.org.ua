{"pageProps":{"page":{"slug":"eventbufferevent.connect.md","content":"# EventBufferEvent::connect\n\n(PECL event >= 1.2.6-beta)\n\nEventBufferEvent::connect — Підключає файловий дескриптор події буфера до вказаної адреси або сокету UNIX\n\n### Опис\n\n```methodsynopsis\npublic\n   EventBufferEvent::connect(\n    string\n     $addr\n   ): bool\n```\n\nПідключає файловий дескриптор події буфера до вказаної адреси (опційно з портом) або UNIX-сокету.\n\nЯкщо сокет не призначений для події буфера, функція виділяє новий сокет і робить його внутрішнім неблокуючим.\n\nЩоб дозволити DNS-імена (асинхронно), використовуйте метод [EventBufferEvent::connectHost()](eventbufferevent.connecthost.md)\n\n### Список параметрів\n\n`addr`\n\nПовинна містити IP-адресу з необов'язковим номером порту або шлях до сокету домену UNIX. Допустимі формати:\n\n\\[IPv6Address\\]:port\\[IPv6Address\\]IPv6Address IPv4Address:port IPv4Address unix:path\n\nИмейте в виду, что префикс`'unix:'`в настоящее время не чувствителен к регистру.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** EventBufferEvent::connect()\\*\\*\\*\\*\n\n```php\n<?php\n/*\n * 1. Подключение к 127.0.0.1 и порту 80\n * by means of EventBufferEvent::connect().\n *\n * 2. Запрос /index.cphp с помощью HTTP/1.0\n * используя выходной буфер.\n *\n * 3. Асинхронно прочитайте ответ и распечатайте его стандартным выводом.\n */\n\n/* Чтение callback-функции */\nfunction readcb($bev, $base) {\n    $input = $bev->getInput();\n\n    while (($n = $input->remove($buf, 1024)) > 0) {\n        echo $buf;\n    }\n}\n\n/* Событие callback-функции */\nfunction eventcb($bev, $events, $base) {\n    if ($events & EventBufferEvent::CONNECTED) {\n        echo \"Подключено.\\n\";\n    } elseif ($events & (EventBufferEvent::ERROR | EventBufferEvent::EOF)) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"DNS ошибка: \", $bev->getDnsErrorString(), PHP_EOL;\n        }\n\n        echo \"Закрытие\\n\";\n        $base->exit();\n        exit(\"Завершено\\n\");\n    }\n}\n\n$base = new EventBase();\n\necho \"шаг 1\\n\";\n$bev = new EventBufferEvent($base, /* используйте внутренний сокет */ NULL,\n    EventBufferEvent::OPT_CLOSE_ON_FREE | EventBufferEvent::OPT_DEFER_CALLBACKS);\nif (!$bev) {\n    exit(\"Не удалось создать сокет bufferevent\\n\");\n}\n\necho \"шаг 2\\n\";\n$bev->setCallbacks(\"readcb\", /* writecb */ NULL, \"eventcb\", $base);\n$bev->enable(Event::READ | Event::WRITE);\n\necho \"шаг 3\\n\";\n/* Послать запрос */\n$output = $bev->getOutput();\nif (!$output->add(\n    \"GET /index.cphp HTTP/1.0\\r\\n\".\n    \"Connection: Close\\r\\n\\r\\n\"\n)) {\n    exit(\"Не удалось добавить запрос в выходной буфер\\n\");\n}\n\n/* Подключение к хосту синхронно.\n * Мы знаем IP, и нам не нужно разрешать DNS. */\nif (!$bev->connect(\"127.0.0.1:80\")) {\n    exit(\"Не удаётся подключиться к хосту\\n\");\n}\n\n/* Отправка ожидающих событий */\n$base->dispatch();\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nstep 1\nstep 2\nstep 3\nConnected.\nHTTP/1.1 200 OK\nServer: nginx/1.2.6\nDate: Sat, 09 Mar 2013 10:06:58 GMT\nContent-Type: text/html; charset=utf-8\nConnection: close\nX-Powered-By: PHP/5.4.11--pl2-gentoo\n\nsdfsdfsf\nClosing\nDone\n```\n\n**Приклад #2 Підключіться до сокету домену UNIX, який імовірно обслуговується сервером, прочитайте відповідь сервера та виведіть його на консоль**\n\n```php\n<?php\nclass MyUnixSocketClient {\n    private $base, $bev;\n\n    function __construct($base, $sock_path) {\n        $this->base = $base;\n        $this->bev = new EventBufferEvent($base, NULL, EventBufferEvent::OPT_CLOSE_ON_FREE,\n            array ($this, \"read_cb\"), NULL, array ($this, \"event_cb\"));\n\n        if (!$this->bev->connect(\"unix:$sock_path\")) {\n            trigger_error(\"Failed to connect to socket `$sock_path'\", E_USER_ERROR);\n        }\n\n        $this->bev->enable(Event::READ);\n    }\n\n    function __destruct() {\n        if ($this->bev) {\n            $this->bev->free();\n            $this->bev = NULL;\n        }\n    }\n\n    function dispatch() {\n        $this->base->dispatch();\n    }\n\n    function read_cb($bev, $unused) {\n        $in = $bev->input;\n\n        printf(\"Получено %ld байтов\\n\", $in->length);\n        printf(\"----- данные ----\\n\");\n        printf(\"%ld:\\t%s\\n\", (int) $in->length, $in->pullup(-1));\n\n        $this->bev->free();\n        $this->bev = NULL;\n        $this->base->exit(NULL);\n    }\n\n    function event_cb($bev, $events, $unused) {\n        if ($events & EventBufferEvent::ERROR) {\n            echo \"Ошибка bufferevent\\n\";\n        }\n\n        if ($events & (EventBufferEvent::EOF | EventBufferEvent::ERROR)) {\n            $bev->free();\n            $bev = NULL;\n        } elseif ($events & EventBufferEvent::CONNECTED) {\n            $bev->output->add(\"test\\n\");\n        }\n    }\n}\n\nif ($argc <= 1) {\n    exit(\"Путь к сокету не указан\\n\");\n}\n$sock_path = $argv[1];\n\n$base = new EventBase();\n$cl = new MyUnixSocketClient($base, $sock_path);\n$cl->dispatch();\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nПолучено 5 байтов\n----- данные ----\n5:  test\n```\n\n### Дивіться також\n\n-   [EventBufferEvent::connectHost()](eventbufferevent.connecthost.md) \\- Підключається на ім'я хоста з можливістю асинхронного дозволу DNS\n","title":"EventBufferEvent::connect","contentType":2,"navigation":[{"eventbufferevent.close.md":"« EventBufferEvent::close"},{"eventbufferevent.connecthost.md":"EventBufferEvent::connectHost »"},{"index.md":"PHP Manual"},{"class.eventbufferevent.md":"EventBufferEvent"}]}},"__N_SSG":true}