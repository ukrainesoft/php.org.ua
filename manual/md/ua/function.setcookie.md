- [« pfsockopen](function.pfsockopen.md)
- [setrawcookie»] (function.setrawcookie.md)

- [PHP Manual](index.md)
- [Мережні функції](ref.network.md)
- Надсилає cookie

# setcookie

(PHP 4, PHP 5, PHP 7, PHP 8)

setcookie — Надсилає cookie

### Опис

**setcookie**(
string `$name`,
string `$value` u003d "",
int `$expires_or_options` u003d 0,
string `$path` u003d "",
string `$domain` u003d "",
bool `$secure` u003d **`false`**,
bool `$httponly` u003d **`false`**
): bool

Альтернативна сигнатура доступна з PHP 7.3.0 (іменовані параметри не
підтримуються):

**setcookie**(string `$name`, string `$value` u003d "", array `$options` u003d
\[\]): bool

**setcookie()** задає cookie, яке буде передано клієнту разом з
іншими HTTP-заголовками. Як і будь-який інший заголовок, cookie повинні
передаватися до того, як будуть виведені будь-які інші дані
скрипта (це обмеження протоколу). Це означає, що у скрипті виклики
цієї функції повинні розташовуватися до іншого висновку, включаючи висновок
тегів `<html>` і `<head>`, а також порожні рядки та пробельні
символи.

Після передачі клієнту cookie будуть доступні через масив `$_COOKIE`
під час наступного завантаження сторінки. Значення cookie також є в
`$_REQUEST`.

### Список параметрів

[» RFC 6265](http://www.faqs.org/rfcs/rfc6265) дає конкретні вказівки,
як потрібно інтерпретувати кожен із параметрів **setcookie()**.

`name`
Назву cookie.

`value`
Значення cookie. Це значення буде збережено на клієнтському комп'ютері;
не записуйте секретні дані в cookie. Значення, присвоєне cookie c
іменем `name`, припустимо, ``cookiename'`, буде доступно через
`$_COOKIE['cookiename']`.

`expires_or_options`
Час, коли термін дії cookie закінчується. Це мітка часу Unix, то
є кількість секунд від початку епохи. Іншими словами, бажано
задавати цей час за допомогою функції [time()](function.time.md),
додаючи час у секундах, через який термін дії cookie повинен
закінчитися. Або можна скористатися функцією
[mktime()](function.mktime.md). `time()+60*60*24*30` встановить термін
дії cookie 30 днів. Якщо задати 0 або пропустити цей аргумент,
термін дії cookie закінчиться із закінченням сесії (при закритті
браузера).

> **Примітка**:
>
> Можна помітити, що `expires_or_options` приймає як значення
> мітку часу Unix, а зберігає його у форматі
> `Wdy, DD-Mon-YYYY HH:MM:SS GMT`. PHP робить це перетворення
> автоматично.

`path`
Дорога до директорії на сервері, з якої будуть доступні cookie. Якщо
задати ``/'`, cookie будуть доступні у всьому домені `domain`. Якщо поставити
``/foo/'`, cookie будуть доступні тільки з директорії `/foo/` та всіх її
піддиректорій (наприклад, `/foo/bar/`) домену `domain`. За замовчуванням
значенням є поточна директорія, у якій cookie встановлюється.

`domain`
(Під)домен, якому доступні cookie. Завдання піддомену (наприклад,
``www.example.com'`) зробить cookie доступними в ньому та у всіх його
піддоменах (наприклад, w2.www.example.com). Для того, щоб зробити
cookie доступними для всього домену (включно з піддоменами), потрібно просто
вказати ім'я домену (тобто ``example.com'`).

Старі браузери, що йдуть застарілому документу [» RFC
2109](http://www.faqs.org/rfcs/rfc2109), можуть вимагати `.` перед
доменом, щоб включалися всі піддомени.

`secure`
Вказує на те, що значення cookie має передаватися від клієнта за
захищеному з'єднанню HTTPS. Якщо задано **`true`**, cookie від клієнта
буде передано на сервер, лише якщо встановлено захищене з'єднання.
Під час передачі cookie від сервера клієнту програміст веб-сервера повинен
стежити за тим, щоб cookie цього типу передавалися по захищеному
каналу (варто звернути увагу на `$_SERVER["HTTPS"]`).

`httponly`
Якщо задано **`true`**, cookie будуть доступні лише через
HTTP-протокол. Тобто cookie у цьому випадку не будуть доступні скриптовим
мов, на зразок JavaScript. Ця можливість була запропонована як
заходи, що ефективно знижує кількість крадіжок особистих даних за допомогою
XSS-атак (попри те, що підтримується не всіма браузерами). Стоїть
однак відзначити, що навколо цієї можливості часто виникають суперечки щодо її
ефективності та доцільності. Може набувати значень **`true`**
або **`false`**.

`options`
Асоціативний масив (array), який може мати будь-який із ключів:
`expires`, `path`, `domain`, `secure`, `httponly` та `samesite`. При
наявності будь-якого іншого ключа виникне помилка рівня **`E_WARNING`**.
Значення мають той самий сенс, як описано у параметрах з відповідним
ім'ям. Значення елемента `samesite` має бути або `None`, або
`Lax`, або `Strict`. Якщо якась із допустимих опцій не вказана, її
значення за замовчуванням збігаються зі значеннями за промовчанням для явних
параметрів. Якщо елемент samesite не вказано, cookie-атрибут SameSite
не встановлений.

### Значення, що повертаються

Якщо перед викликом функції клієнту вже передавався будь-який висновок
(теги, порожні рядки, пробіли, текст тощо), **setcookie()** потерпить
невдачу і поверне **`false`**. Якщо **setcookie()** успішно відпрацює,
то поверне **`true`**. Це, однак, не означає, що клієнтське
програма (браузер) правильно прийняла та обробила cookie.

### Список змін

| Версія | Опис |
|--------|---------------------------------------- -------------------------------------------------- -------------------------------------------------- -|
| 7.3.0 | Доданий альтернативний підпис, що підтримує масив опцій `options`. Цей підпис також підтримує налаштування cookie-атрибута SameSite. |

### Приклади

Нижче наведено кілька прикладів, як надсилати cookie:

**Приклад #1 Приклад використання **setcookie()****

` <?php$value u003d 'щось звідки-то';setcookie("TestCookie", $value);setcookie("TestCookie", $value, time()+3600); /* термін дії 1 година */setcookie("TestCookie", $value, time()+3600, "/~rasmus/", "example.com", 1);?> `

Варто зазначити, що значення cookie перед надсиланням клієнту піддається
URL-кодування. При зворотному отриманні значення cookie декодується та
міститься в змінну, з тим самим ім'ям, що й ім'я cookie. Якщо ви не
хочете, щоб значення кодувалися, використовуйте функцію
[setrawcookie()](function.setrawcookie.md). Переглянути вміст
наших тестових cookie можна, запустивши один із таких прикладів:

`<?php// Вивести одно конкретне значення cookieecho $_COOKIE["TestCookie"];

**Приклад #2 Приклад видалення cookie за допомогою **setcookie()****

Щоб видалити cookie, достатньо як термін дії вказати
якийсь час у минулому. Це запустить механізм браузера, що видаляє
закінчилися cookie. У прикладах нижче показано, як видалити cookie, задані
у попередніх прикладах:

` <?php// установка дати запливу строку дії на годину назадsetcookie("TestCookie", "", time() - 3600);setcookie("TestCookie", "", time() , "example.com", 1);?> `

**Приклад #3 **setcookie()** та масиви**

Можна поміщати в cookie масиви. Для цього кожному cookie
Необхідно дати ім'я відповідно до правил іменування масивів. Така
можливість дозволяє помістити стільки значень, скільки є
елементів у масиві. При зворотному отриманні всі ці значення будуть
поміщені в масив з ім'ям цього cookie:

` <?php// відправка cookiesetcookie("cookie[three]", "cookiethree");setcookie("cookie[two]", "cookietwo");setcookie("cookie[one]", "cookieone");/ / після перезавантаження сторінки, виведемо cookieif (isset($_COOKIE['cookie'])) {    foreach ($_COOKIE['cookie'] as $name u003d> $value)    $valueu003du003dhtmlspecialchars($value); echo "$name : $value <br />
";    }}?> `

Результат виконання цього прикладу:

three : cookiethree
two : cookietwo
one : cookieone

> **Примітка**: Використання розділових символів, таких як `[` та
> `]` як частина імені файлу cookie, не відповідає RFC 6265, розділ 4,
> але передбачається, що воно підтримується користувачами агентами
> відповідно до RFC 6265, розділ 5.

### Примітки

> **Примітка**:
>
> Щоб мати можливість надсилати виведення скрипту до виклику цієї
> функції можна скористатися буферизацією. У цьому випадку весь висновок
> скрипта міститься в буфер на сервері і залишається там, поки ви явно не
> надішліть його браузеру. Управління буферизацією здійснюється
> функціями [ob_start()](function.ob-start.md) та
> [ob_end_flush()](function.ob-end-flush.md) у скрипті, або можна
> встановити директиву `output_buffering` у файлі `php.ini` або
> конфігураційних файлів сервера.

Загальні зауваження:

- Cookie стануть видимими лише після перезавантаження сторінки, для
якої вони мають бути видні. Для перевірки, чи правильно cookie
встановилися, перевірте їх при наступному завантаженні сторінки до
закінчення терміну їхньої дії. Термін дії cookie задається в
параметрі `expires_or_options`. Зручно перевіряти існування
cookie простим викликом `print_r($_COOKIE);`.
- При видаленні cookie повинні бути задані ті самі параметри, що й
встановлення. Якщо значення задати порожній рядок, а
інші параметри задати відповідно до попереднього виклику,
що встановив cookie, тоді cookie з заданим ім'ям буде видалено з
клієнтської машини. Внутрішньо це виглядає так: cookie надається
значення "deleted", а термін дії переноситься на рік у минуле.
- Оскільки встановлення значення **`false`** призведе до видалення cookie,
не слід задавати cookie значення булевого типу. Замість цього
можна використовувати *0* для **`false`** та *1* для **`true`**.
- Cookie можна назвати як масиви, і вони будуть доступні в
PHP-скрипт, як масиви, але на користувальницькій машині вони будуть
зберігатися як окремих записів. Для завдання cookie з безліччю
імен та значень бажано використовувати функцію
[explode()](function.explode.md). Не рекомендується для цих цілей
використовувати функцію [serialize()](function.serialize.md), оскільки
це негативно позначається на безпеці скрипта.

При багаторазових викликах **setcookie()** функції виконуються в тому
порядку, у якому викликалися.

### Дивіться також

- [header()](function.header.md) - Надсилання HTTP-заголовка
- [setrawcookie()](function.setrawcookie.md) - Надсилає cookie без
URL-кодування значення
- [розділ cookies](features.cookies.md)
- [»RFC 6265](http://www.faqs.org/rfcs/rfc6265)
- [» RFC 2109](http://www.faqs.org/rfcs/rfc2109)
