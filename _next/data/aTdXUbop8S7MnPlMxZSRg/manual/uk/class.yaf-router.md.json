{"pageProps":{"page":{"slug":"class.yaf-router.md","content":"# Клас Yaf\\_Router\n\n(Yaf >=1.0.0)\n\n## Вступ\n\n**Yaf\\_Router** – це стандартний каркасний маршрутизатор. Маршрутизація - це процес отримання кінцевої точки URI (тої частини URI, яка йде після базового URI: дивіться [Yaf\\_Request\\_Abstract::setBaseUri()](yaf-request-abstract.setbaseuri.md)) та розкладання її на параметри, щоб визначити, який модуль, контролер та дія повинні отримати запит. Ці значення модуля, контролера, дії та інших параметрів упаковані в об'єкт [Yaf\\_Request\\_Abstract](class.yaf-request-abstract.md), який потім обробляється [Yaf\\_Dispatcher](class.yaf-dispatcher.md). Маршрутизація відбувається лише один раз: при початковому отриманні запиту та до відправлення першого контролера . **Yaf\\_Router** призначений для забезпечення функціональності, подібної до mod\\_rewrite, з використанням чистих структур PHP. Він заснований на маршрутизації Ruby on Rails і не вимагає будь-яких попередніх знань про перезапис URL веб-сервера. Він призначений для роботи з одним правилом Apache mod\\_rewrite (одним з):\n\n**Приклад #1 Правило перезапису Apache**\n\nRewriteEngine on RewriteRule !\\\\.(js|ico|gif|jpg|png|css|html)$ index.php\n\nабо (переважно):\n\n**Приклад #2 Правило перезапису Apache**\n\nRewriteEngine On RewriteCond %{REQUEST\\_FILENAME} -s\\[OR\\]RewriteCond %{REQUEST\\_FILENAME} -l\\[OR\\]RewriteCond %{REQUEST\\_FILENAME} -d RewriteRule ^.\\* \\[NC,L\\]RewriteRule ^.\\*$ index.php\\[NC,L\\]\n\nУ разі використання Lighttpd використовуйте таке правило перезапису:\n\n**Приклад #3 Правило перезапису для Lighttpd**\n\nurl.rewrite-once = ( \".\\*\\\\?(.\\*)$\" => \"/index.php?$1\", \".\\*\\\\.(js|ico|gif|jpg|png|css|html)$\" => \"$0\", \"\" => \"/index.php\" )\n\nПід час використання Nginx використовуйте таке правило перезапису:\n\n**Приклад #4 Правило перезапису Nginx**\n\nserver { listen\\*\\*\\*\\*; server\\_name yourdomain.com; root document\\_root; index index.php index.md;\n\nif (!-e $request\\_filename) { rewrite ^/(.\\*) /index.php/$1 last; } }\n\n## Маршрут за замовчуванням\n\n**Yaf\\_Router** поставляється з попередньо налаштованим маршрутом за умовчанням [Yaf\\_Route\\_Static](class.yaf-route-static.md), який буде відповідати URI у формі контролера/дії. Крім того, ім'я модуля може бути зазначено як перший елемент шляху, що дозволяє використовувати URI форми модуля/контролера/дії. Нарешті, він також буде відповідати будь-яким додатковим параметрам, які додаються до URI за замовчуванням - controller /action/var1/value1/var2/value2.\n\n> **Зауваження** :\n> \n> Ім'я модуля має бути визначено у конфігурації з урахуванням application.module=\"Index,Foo,Bar\", у цьому випадку тільки index, foo та bar можуть розглядатися як ім'я модуля. Якщо не налаштовано, є лише один модуль під назвою \"Index\".\n\nДеякі приклади відповідності таких маршрутів:\n\n**Приклад #5 Приклад использования[Yaf\\_Route\\_Static](class.yaf-route-static.md)(маршрут за замовчуванням)**\n\n// Припускаючи наступне налаштування: $conf = array( \"application\" => array( \"modules\" => \"Index,Blog\", ), );\n\nТільки контролер:[http://example/news](http://example/news)controller == news Тільки дія (якщо визначено yaf.action\\_prefer=1 в php.ini) action == news\n\nНевірний модуль відображається на ім'я контролера:[http://example/foo](http://example/foo)controller == foo\n\nМодуль + контролер:[http://example/blog/archive](http://example/blog/archive)module == blog controller == archive\n\nМодуль + контролер + дія:[http://example/blog/archive/list](http://example/blog/archive/list)module == blog controller == archive action == list\n\nМодуль + контролер + дія + параметри:[http://example/blog/archive/list/sort/alpha/date/desc](http://example/blog/archive/list/sort/alpha/date/desc)module == blog controller == archive action == list sort == alpha date == desc\n\n## Огляд класів\n\n```classsynopsis\n\n\n\n    \n     \n      class Yaf_Router\n     \n     {\n\n    /* Свойства */\n    \n     protected\n      $_routes;\n\n    protected\n      $_current;\n\n\n\n    /* Методы */\n    \n   public __construct()\n\n    public addConfig(Yaf_Config_Abstract $config): bool\npublic addRoute(string $name, Yaf_Route_Abstract $route): bool\npublic getCurrentRoute(): string\npublic getRoute(string $name): Yaf_Route_Interface\npublic getRoutes(): mixed\npublic route(Yaf_Request_Abstract $request): bool\n\n   }\n```\n\n## Властивості\n\n\\_routes\n\nстек зареєстрованих маршрутів\n\n\\_current\n\nпісля фази маршрутизації вказується назва, який маршрут використовується для маршрутизації поточного запиту. Ви можете отримати його ім'я за допомогою [Yaf\\_Router::getCurrentRoute()](yaf-router.getcurrentroute.md)\n\n## Зміст\n\n-   [Yaf\\_Router::addConfig](yaf-router.addconfig.md)— Додає настроєні маршрути до маршрутизатора\n-   [Yaf\\_Router::addRoute](yaf-router.addroute.md)— Додає новий маршрут до маршрутизатора\n-   [Yaf\\_Router::\\_\\_construct](yaf-router.construct.md) \\- Конструктор класу Yaf\\_Router\n-   [Yaf\\_Router::getCurrentRoute](yaf-router.getcurrentroute.md)— Отримує ім'я діючого маршруту\n-   [Yaf\\_Router::getRoute](yaf-router.getroute.md)— Отримує маршрут на ім'я\n-   [Yaf\\_Router::getRoutes](yaf-router.getroutes.md)— Отримує зареєстровані маршрути\n-   [Yaf\\_Router::route](yaf-router.route.md) \\- Призначення route\n","title":"Клас Yaf\\_Router","contentType":2,"navigation":[{"yaf-route-rewrite.route.md":"« Yaf\\_Route\\_Rewrite::route"},{"yaf-router.addconfig.md":"Yaf\\_Router::addConfig »"},{"index.md":"PHP Manual"},{"book.yaf.md":"Yaf"}]}},"__N_SSG":true}