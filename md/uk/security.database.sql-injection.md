- [«Шифрування сховища бази даних](security.database.storage.md)
- [Повідомлення про помилки »](security.errors.md)

- [PHP Manual](index.md)
- [Безпека баз даних](security.database.md)
- SQL-ін'єкції

## SQL-ін'єкції

Багато веб-розробників навіть не здогадуються, що SQL-запити можуть бути
підроблені і вважають, що SQL-запити завжди достовірні. Насправді
підроблені запити можуть обійти обмеження доступу, стандартну
перевірку авторизації, а деякі види запитів можуть дати можливість
виконувати команди операційної системи.

Пряме впровадження шкідливих інструкцій у SQL-запити - це методика,
якої зломщик створює або змінює поточні SQL-запити для
відображення прихованих даних, їх зміни або навіть виконання небезпечних
команд операційної системи на сервері бази даних Атака виконується на
базі програми, що будує SQL-запити з введення користувача і
статичних властивостей. Наступні приклади, на жаль, побудовані на
реальні факти.

Завдяки відсутності перевірки користувальницького введення та з'єднання з
базою даних під обліковим записом суперкористувача (або будь-якого іншого
користувача, наділеного відповідними привілеями), зломщик може
створити ще одного користувача БД із правами суперкористувача.

**Приклад #1 Посторінковий висновок результату... та створення
суперкористувача в PostgreSQL**

`<?php$offsetu003du003d$argv[0]; // увага, ні ні перевірки введених даних!$query u003d "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";$result u003d pg_query

Зазвичай користувачі клацають за посиланням 'вперед' і 'назад', внаслідок
чого значення змінної `$offset` заноситься до URL. Скрипт очікує, що
$offset - десяткове число. Проте, зломщик може спробувати зламати
систему, приєднавши до URL додатковий рядок, оброблений функцією
[urlencode()](function.urlencode.md):

`` sqlcode
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
select 'crack', usesysid, 't', 't', 'crack'
from pg_shadow where usenameu003d'postgres';
-
````

Якщо це станеться, скрипт надасть зломщику доступ до бази
правами суперкористувача. Зауважимо, що значення `0;` використане для
того, щоб задати правильне зміщення для першого запиту та коректно
його завершити.

> **Примітка**:
>
> Часто використовуваною технікою для ігнорування SQL-парсером
> Частини запиту є використання `--`, що означає коментар.

Ще один ймовірний спосіб отримати паролі облікових записів у БД - атака
сторінок, які надають пошук по базі. Зломщику потрібно лише перевірити,
чи використовується в запиті, що передається на сервер і необроблювана
належним чином змінна. Це може бути один з встановлюваних на
на попередній сторінці фільтрів, таких як `WHERE, ORDER BY, LIMIT` та
`OFFSET`, які використовуються при побудові запитів `SELECT`. У разі якщо
база даних, що використовується вами, підтримує конструкцію `UNION`, зломщик
може приєднати до оригінального запиту ще один додатковий
вилучення паролів користувача. Настійно рекомендуємо
використовувати лише зашифровані паролі.

**Приклад #2 Лістинг статей... та деяких паролів (для будь-якої бази
даних)**

` <?php$query  u003d "SELECT id, name, inserted, size FROM products           WHERE size u003d '$size'";$result u003d odbc_;

Статична частина запиту може комбінуватися з іншим
`SELECT`-запитом, який виведе всі паролі:

`` sqlcode
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
-
````

Якщо цей запит (що використовує ``` та `--`) приєднати до значення однієї
зі змінних, що використовуються для формування $query, то запит помітно
зміниться.

Команди UPDATE можуть також використовуватися для атаки. Знову ж таки, є
загроза поділу інструкції на кілька частин та приєднання
додатковий запит. Також зломщик може видозмінити вираз
`SET`. У цьому випадку потенційному зломщику необхідно мати
деякою додатковою інформацією про структуру бази даних для
успішного маніпулювання запитами. Цю інформацію можна отримати,
проаналізувавши імена змінних, що використовуються у формі, або просто
перебираючи всі найпоширеніші варіанти назви
відповідних полів (а їх не так вже й багато).

**Приклад #3 Від відновлення пароля... до отримання додаткових
привілеїв (для будь-якої бази даних)**

` <?php$query u003d "UPDATE usertable SET pwdu003d'$pwd' WHERE uidu003d'$uid';";?> `

Але зловмисник може ввести значення 'or uid like'%admin%'' для
змінною `$uid` для зміни пароля адміністратора або просто
присвоїти змінній `$pwd` значення `hehehe', trustedu003d100, adminu003d'yes`
для отримання додаткових привілеїв. Під час виконання запитів
переплітаються:

` <?php// $uid: ' or uid like '%admin%$query u003d "UPDATE usertable SET pwdu003d'...' WHERE uidu003d'' or uid like '%admin%';";// pwd: hehehe', trustedu003d100, adminu003d'yes$query u003d "UPDATE usertable SET pwdu003d'hehehe', trustedu003d100, adminu003d'yes' WHERE...;";?> `

Страхітливий приклад того, як на сервері баз даних можуть виконуватися
команди операційної системи.

**Приклад #4 Виконання команд операційної системи на сервері (для бази
MSSQL)**

` <?php$query  u003d "SELECT * FROM products WHERE id LIKE '%$prod%'";$result u003d mssql_query($query);?> `

Якщо зломщик введе значення
`a%' exec master..xp_cmdshell 'net user test testpass /ADD' --` для
змінною `$prod`, тоді запит `$query` виглядатиме так:

` <?php$query  u003d "SELECT * FROM products           WHERE id LIKE '%a%'           exec master..xp_cmdshell 'net user test testpass /ADD' --%'";$result u003d mssql_query($query);?> `

MSSQL сервер виконує SQL-команди в пакетному режимі, у тому числі
операції із закладу локальних облікових записів бази даних. В разі,
якщо програма працює з привілеями адміністратора `sa` та сервіс
MSSQL запущений з необхідними привілеями, то виконавши наведені вище
дії, зломщик отримає обліковий запис для доступу до сервера.

> **Примітка**:
>
> Деякі наведені у цьому розділі приклади стосуються конкретної бази
> даних. Це не означає, що аналогічні атаки на інші програмні
> Продукти неможливі. Працездатність вашої бази даних може бути
> порушена будь-яким іншим способом.

![Робочий приклад проблем, що викликаються
SQL-ін'єкцією](images/fa7c5b5f326e3c4a6cc9db19e7edbaf0-xkcd-bobby-tables.png)

Авторство зображення належить [»xkcd](http://xkcd.com/327)

### Способи захисту

Хоча, як і раніше, очевидно, що зломщик повинен мати принаймні
деякими знаннями про структуру бази даних, щоб провести успішну
атаку, отримати цю інформацію часто дуже просто. Наприклад, якщо
база даних є частиною open-source або іншого публічно доступного
програмного пакета з інсталяцією за замовчуванням, ця інформація є
повністю відкритої та доступної. Ці дані також можуть бути отримані з
закритого проекту, навіть якщо він закодований, ускладнений, або
скомпілюваний, і навіть з вашого особистого коду через відображення повідомлень
про помилки. До інших методів відноситься використання поширених
(легко вгадуваних) назв таблиць та стовпців. Наприклад, форма логіну,
яка використовує таблицю 'users' з назвами стовпців 'id',
'username' та 'password'.

Більшість успішних атак ґрунтується на коді, написаному без урахування
відповідних вимог безпеки. Не довіряйте жодним введеним
особливо якщо вони надходять з боку клієнта, навіть якщо це
списки у формі, приховані поля або куки. Перший наведений приклад
показують, як такі запити можуть призвести до катастрофи.

- Ніколи не з'єднуйтесь з базою даних, використовуючи обліковий запис
власника бази даних або суперкористувача. Завжди намагайтеся
використовувати спеціально створених користувачів з максимально
обмеженими правами.

- використовуйте підготовлені вирази із прив'язаними змінними.
Ця можливість надається модулями
[PDO](pdo.prepared-statements.md),
[MySQLi](mysqli.quickstart.prepared-statements.md) та іншими
бібліотеками.

- Завжди перевіряйте введені дані на відповідність очікуваного типу.
У PHP є безліч функцій для перевірки даних: починаючи від
найпростіших [функцій для роботи зі змінними](ref.var.md) та
[функцій визначення типу символів](ref.ctype.md) (таких як
[is_numeric()](function.is-numeric.md) та
[ctype_digit()](function.ctype-digit.md) відповідно) та
закінчуючи [Perl-сумісними регулярними
виразами] (ref.pcre.md).

- Якщо програма очікує цифрове введення, застосуйте функцію
[ctype_digit()](function.ctype-digit.md) для перевірки введених
даних, або примусово вкажіть їх тип за допомогою
[settype()](function.settype.md), або просто використовуйте числове
представлення за допомогою функції [sprintf()](function.sprintf.md).

**Приклад #5 Більш безпечна реалізація посторінкової навігації**

` <?phpsettype($offset, 'integer');$query u003d "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";// зверніть увагу на форм    query u003d sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",                 $set)

- Якщо на рівні бази даних не підтримуються прив'язані
змінні, то завжди екрануйте будь-які нечислові дані,
використовуваний у запитах до БД за допомогою спеціальних екрануючих
функцій, специфічних для вашої бази даних (наприклад,
[mysql_real_escape_string()](function.mysql-real-escape-string.md),
**sqlite_escape_string()** і т.д.). Загальні функції, такі як
[addslashes()](function.addslashes.md) корисні тільки в
певних випадках (наприклад MySQL в однобайтному кодуванні з
відключеним `NO_BACKSLASH_ESCAPES`), тому краще уникати їх
використання.

- У жодному разі не виводьте жодної інформації про БД, особливо про її
структуру. Також ознайомтесь із відповідними розділами
документації: "[Повідомлення про помилки](security.errors.md)" та
"[Функції обробки та логування помилок](ref.errorfunc.md)".

- Ви можете використовувати процедури, що зберігаються, і заздалегідь визначені
курсори для абстрагованої роботи з даними, не надаючи
користувачам прямого доступу до даних та уявлень, але це
Рішення має свої особливості.

Крім всього вищесказаного, ви можете логувати запити у вашому
скрипт або на рівні бази даних, якщо вона це підтримує. Очевидно,
що логування не може запобігти завданню шкоди, але може допомогти
при трасуванні зламаної програми. Лог-файл корисний не сам собою,
а інформацією, що міститься в ньому. Причому, здебільшого
корисно логувати усі можливі деталі.
