{"pageProps":{"page":{"slug":"sqlite3.setauthorizer.md","content":"# SQLite3::setAuthorizer\n\n(PHP 8)\n\nSQLite3::setAuthorizer — Встановлює callback-функцію, яка буде використовуватися як авторизатор для обмеження дій висловлювання\n\n### Опис\n\n```methodsynopsis\npublic SQLite3::setAuthorizer(?callable $callback): bool\n```\n\nВстановлює callback-функцію, яка буде викликатися SQLite щоразу під час виконання дії (читання, видалення, модифікація тощо.). Це використовується при підготовці SQL-виразів з ненадійного джерела, щоб гарантувати, що SQL-вирази не намагатимуться отримати доступ до даних, які їм не дозволено бачити, або щоб вони не намагалися виконати шкідливі вирази, що ушкоджують базу даних. Наприклад, програма може дозволити користувачеві вводити довільні SQL-запити для виконання у базі даних. Але програма не хоче, щоб користувач міг вносити довільні зміни до бази даних. Тоді можна встановити авторизатор, який забороняє використання будь-яких виразів, крім SELECT, поки готується введений користувачем SQL запит.\n\nCallback-авторизатор може бути викликаний кілька разів кожного висловлювання, підготовленого SQLite. Запити `SELECT`или`UPDATE` будуть викликати авторизатор для кожної колонки, що зчитується або модифікується.\n\nВиклик авторизатора може використовуватися до п'яти параметрів. Перший параметр передається завжди, його тип - ціле число (int) (код дії), що збігається з константою `SQLite3`. Інші параметри надсилаються лише для деяких дій. Ця таблиця описує другий і третій параметри відповідно до дії:\n\n**Список кодів дії та параметрів**\n\n| Действие | Второй параметр | Третий параметр |\n| --- | --- | --- |\n| **`SQLite3::CREATE_INDEX`** | Ім'я індексу | Ім'я таблиці |\n| **`SQLite3::CREATE_TABLE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::CREATE_TEMP_INDEX`** | Ім'я індексу | Ім'я таблиці |\n| **`SQLite3::CREATE_TEMP_TABLE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::CREATE_TEMP_TRIGGER`** | Ім'я тригера | Ім'я таблиці |\n| **`SQLite3::CREATE_TEMP_VIEW`** | Ім'я уявлення | **`null`** |\n| **`SQLite3::CREATE_TRIGGER`** | Ім'я тригера | Ім'я таблиці |\n| **`SQLite3::CREATE_VIEW`** | Ім'я уявлення | **`null`** |\n| **`SQLite3::DELETE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::DROP_INDEX`** | Ім'я індексу | Ім'я таблиці |\n| **`SQLite3::DROP_TABLE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::DROP_TEMP_INDEX`** | Ім'я індексу | Ім'я таблиці |\n| **`SQLite3::DROP_TEMP_TABLE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::DROP_TEMP_TRIGGER`** | Ім'я тригера | Ім'я таблиці |\n| **`SQLite3::DROP_TEMP_VIEW`** | Ім'я уявлення | **`null`** |\n| **`SQLite3::DROP_TRIGGER`** | Ім'я тригера | Ім'я таблиці |\n| **`SQLite3::DROP_VIEW`** | Ім'я уявлення | **`null`** |\n| **`SQLite3::INSERT`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::PRAGMA`** | Ім'я pragma | Перший аргумент, переданий pragma, або **`null`** |\n| **`SQLite3::READ`** | Ім'я таблиці | Ім'я колонки |\n| **`SQLite3::SELECT`** | **`null`** | **`null`** |\n| **`SQLite3::TRANSACTION`** | Операція | **`null`** |\n| **`SQLite3::UPDATE`** | Ім'я таблиці | Ім'я колонки |\n| **`SQLite3::ATTACH`** | ім'я файлу | **`null`** |\n| **`SQLite3::DETACH`** | Ім'я бази даних | **`null`** |\n| **`SQLite3::ALTER_TABLE`** | Ім'я бази даних | Ім'я таблиці |\n| **`SQLite3::REINDEX`** | Ім'я індексу | **`null`** |\n| **`SQLite3::ANALYZE`** | Ім'я таблиці | **`null`** |\n| **`SQLite3::CREATE_VTABLE`** | Ім'я таблиці | Ім'я модуля |\n| **`SQLite3::DROP_VTABLE`** | Ім'я таблиці | Ім'я модуля |\n| **`SQLite3::FUNCTION`** | **`null`** | Ім'я функції |\n| **`SQLite3::SAVEPOINT`** | Операція | Ім'я точки збереження |\n| **`SQLite3::RECURSIVE`** | **`null`** | **`null`** |\n\nЧетвертим параметром буде ім'я бази даних (`\"main\"` `\"temp\"` і т.д.), якщо потрібно.\n\nП'ятий параметр callback-авторизатора - ім'я самого внутрішнього тригера або подання, відповідального за спробу отримання доступу, або **`null`**, якщо ця спроба отримання доступу зроблена безпосередньо з коду SQL верхнього рівня.\n\nКоли callback-функція повертає \\*\\*`SQLite3::OK`\\*\\*Це означає, що запитана операція прийнята. Коли callback-функція повертає **`SQLite3::DENY`**, виклик, що запустив авторизатор, зазнає невдачі з повідомленням про помилку, що пояснює, що доступ заборонено.\n\nЯкщо код дії - **`SQLite3::READ`**, і callback-функція повертає **`SQLite3::IGNORE`**, то підготовлений вираз складається для заміни на **`null`** значення колонки таблиці, яке б зчитувалося, якби повернувся код **`SQLite3::OK`**Возврат**`SQLite3::IGNORE`** може використовуватися, щоб заборонити недовіреному користувачеві доступ до окремих колонок таблиці.\n\nКоли на таблицю посилаються через `SELECT`, але з неї не витягується жодного значення колонок, (наприклад, у запиті `\"SELECT count(*) FROM table\"`), то callback-авторизатор\\*\\*`SQLite3::READ`\\*\\* викликається один раз для цієї таблиці з ім'ям колонки, яке дорівнює порожньому рядку.\n\nЯкщо код дії - **`SQLite3::DELETE`**, і callback-функція повертає \\*\\*`SQLite3::IGNORE`\\*\\*тоді операція DELETE продовжує свою роботу, але з вимкненою оптимізацією видалення, і всі рядки видаляються окремо.\n\nУ поєднанні з базою даних одночасно може використовуватися лише один авторизатор. Кожен виклик **SQLite3::setAuthorizer()** перезаписує попередній. Вимкнути авторизатор можна, передавши **`null`** замість callback-функції. За замовчуванням авторизатор вимкнено.\n\nCallback-авторизатор не повинен робити нічого, що змінює підключення до бази даних, яке викликало callback-авторизатор.\n\nЗверніть увагу, що авторизатор викликається тільки тоді, коли вираз готується, а не тоді, коли воно виконується.\n\nБільш детальну інформацію можна знайти у [» Документації SQLite3](http://sqlite.org/c3ref/set_authorizer.md)\n\n### Список параметрів\n\n`callback`\n\nФункция[callable](language.types.callable.md) для дзвінка.\n\nЯкщо передано **`null`**, то поточний callback-авторизатор буде вимкнено.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Помилки\n\nЦей метод не викликає жодних помилок, але якщо авторизатор включений і повертає некоректне значення, то при підготовці виразу буде викликана помилка (або викинутий виняток, залежно від використання методу [SQLite3::enableExceptions()](sqlite3.enableexceptions.md)\n\n### Приклади\n\n**Приклад #1 Приклад використання** SQLite3::setAuthorizer()\\*\\*\\*\\*\n\nУ цьому прикладі дозволено доступ тільки для читання, і лише деякі з колонок таблиці `users` будуть повернуті. Інші колонки будуть замінені на **`null`**\n\n```php\n<?php\n$db = new SQLite3('data.sqlite');\n$db->exec('CREATE TABLE users (id, name, password);');\n$db->exec('INSERT INTO users VALUES (1, \\'Pauline\\', \\'Snails4eva\\');');\n\n$allowed_columns = ['id', 'name'];\n\n$db->setAuthorizer(function (int $action, ...$args) use ($allowed_columns) {\n    if ($action === SQLite3::READ) {\n        list($table, $column) = $args;\n\n        if ($table === 'users' && in_array($column, $allowed_columns) {\n            return SQLite3::OK;\n        }\n\n        return SQLite3::IGNORE;\n    }\n\n    return SQLite3::DENY;\n});\n\nprint_r($db->querySingle('SELECT * FROM users WHERE id = 1;'));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [id] => 1\n    [name] => Pauline\n    [password] =>\n)\n```\n","title":"SQLite3::setAuthorizer","contentType":2,"navigation":[{"sqlite3.querysingle.md":"« SQLite3::querySingle"},{"sqlite3.version.md":"SQLite3::version »"},{"index.md":"PHP Manual"},{"class.sqlite3.md":"SQLite3"}]}},"__N_SSG":true}