{"pageProps":{"page":{"slug":"language.namespaces.rules.md","content":"## Правила дозволу імен\n\n(PHP 5 >= 5.3.0, PHP 7, PHP 8)\n\nДля цілей цих правил дозволу наведемо важливі визначення:\n\n**Визначення імені простору імен**\n\nНеповне ім'я\n\nІдентифікатор без роздільника просторів імен, наприклад `Foo`\n\nПовне ім'я\n\nІдентифікатор з роздільником просторів імен, наприклад `Foo\\Bar`\n\nАбсолютне ім'я\n\nІдентифікатор з роздільником просторів імен, який починається з роздільника просторів імен, наприклад `\\Foo\\Bar`. Простір імен `\\Foo`— также абсолютное имя.\n\nВідносне ім'я\n\nІдентифікатор, який починається з ключового слова `namespace`, наПриклад`namespace\\Foo\\Bar`\n\nІмена дозволяються за такими правилами:\n\n1.  Абсолютні імена дозволяються без провідного роздільника простору імен. Наприклад,`\\A\\B`дозволяється в`A\\B`\n2.  Відносні імена дозволяються в ім'я із заміною ключового слова`namespace`поточним простором імен. Якщо ім'я зустрічається у глобальному просторі імен, префікс`namespace\\`видаляється. Наприклад,`namespace\\A`усередині простору імен`X\\Y`дозволяється в`X\\Y\\A`. Те ж ім'я в глобальному просторі імен дозволяється в`A`\n3.  У повних іменах перший сегмент імені перетворюється з урахуванням поточної таблиці імпорту класу чи простору імен. Наприклад, якщо простір імен`A\\B\\C`імпортовано як`C`, то ім'я`C\\D\\E`преобразуется в`A\\B\\C\\D\\E`\n4.  У повних іменах, якщо не застосовувалося правило імпорту, поточний простір імен додається до імені. Наприклад, ім'я`C\\D\\E`усередині простору імен`A\\B`вирішиться у`A\\B\\C\\D\\E`\n5.  Неповні імена перетворюються з урахуванням поточної таблиці імпорту та типу елемента. Тобто імена як класів перетворюються з урахуванням таблиці імпорту класів чи просторів імен, імена функцій — з урахуванням таблиці імпорту функцій, а константи — таблиці імпорту констант. Наприклад, під час запису`use A\\B\\C;`, виклик`new C()`дозволяється в`A\\B\\C()`. Аналогічно, під час запису`use function A\\B\\foo;` виклик `foo()`дозволяється в`A\\B\\foo`\n6.  На початок неповних імен, якщо не застосовувалося правило імпорту та ім'я відноситься до елемента з ім'ям як у класу, додається поточний простір імен. Наприклад, ім'я класу у виразі`new C()`усередині простору імен`A\\B`дозволиться в ім'я`A\\B\\C`\n7.  У неповних іменах, якщо не застосовувалося правило імпорту та ім'я відноситься до функції або константи, а код лежить за межами глобального простору імен, ім'я дозволяється під час виконання. Ось як дозволиться виклик функції`foo()`у коді у просторі імен`A\\B` :\n    1.  Виконується пошук функції з поточного простору імен:`A\\B\\foo()`\n    2.  PHP намагається знайти та викликати функцію`foo()`из*глобального простору імен*\n\n**Приклад #1 Приклади дозволу імен**\n\n```php\n<?php\n\nnamespace A;\nuse B\\D, C\\E as F;\n\n// вызовы функций\n\nfoo();      // сперва пытается вызвать функцию foo, определённую в пространстве имён A,\n            // затем вызывает глобальную функцию foo\n\n\\foo();     // вызывает функцию foo, определённую в глобальном пространстве\n\nmy\\foo();   // вызывает функцию foo, определённую в пространстве имён A\\my\n\nF();        // сперва пытается вызвать функцию F, определённую в пространстве имён A,\n            // затем вызывает глобальную функцию F\n\n// ссылки на классы\n\nnew B();    // создаёт объект класса B, определённого в пространстве имён A.\n            // если не найден, то пытается сделать автозагрузку класса A\\B\n\nnew D();    // используя правила импорта, создаёт объект класса D, определённого в пространстве имён B\n            // если не найден, то пытается сделать автозагрузку класса B\\D\n\nnew F();    // используя правила импорта, создаёт объект класса E, определённого в пространстве имён C\n            // если не найден, то пытается сделать автозагрузку класса C\\E\n\nnew \\B();   // создаёт объект класса B, определённого в глобальном пространстве,\n            // если не найден, то пытается сделать автозагрузку класса B\n\nnew \\D();   // создаёт объект класса D, определённого в глобальном пространстве,\n            // если не найден, то пытается сделать автозагрузку класса D\n\nnew \\F();   // создаёт объект класса F, определённого в глобальном пространстве,\n            // если не найден, то пытается сделать автозагрузку класса F\n\n// статические методы/функции пространства имён из другого пространства имён\n\nB\\foo();    // вызывает функцию foo из пространства имён A\\B\n\nB::foo();   // вызывает метод foo из класса B, определённого в пространстве имён A\n            // если класс A\\B не найден, то пытается сделать автозагрузку класса A\\B\n\nD::foo();   // используя правила импорта, вызывает метод foo класса D, определённого в пространстве имён B\n            // если класс B\\D не найден, то пытается сделать автозагрузку класса B\\D\n\n\\B\\foo();   // вызывает функцию foo из пространства имён B\n\n\\B::foo();  // вызывает метод foo класса B из глобального пространства\n            // если класс B не найден, то пытается сделать автозагрузку класса B\n\n// статические методы/функции пространства имён из текущего пространства имён\n\nA\\B::foo();   // вызывает метод foo класса B из пространства имён A\\A\n              // если класс A\\A\\B не найден, то пытается сделать автозагрузку класса A\\A\\B\n\n\\A\\B::foo();  // вызывает метод foo класса B из пространства имён A\n              // если класс A\\B не найден, то пытается сделать автозагрузку класса A\\B\n\n?>\n```\n","title":"Правила дозволу імен","contentType":2,"navigation":[{"language.namespaces.fallback.md":"« Повернення до глобального простору"},{"language.namespaces.faq.md":"FAQ »"},{"index.md":"PHP Manual"},{"language.namespaces.md":"Простори імен"}]}},"__N_SSG":true}