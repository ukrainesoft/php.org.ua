- [« Числа з плаваючою точкою](language.types.float.md)
- [Числові рядки »](language.types.numeric-strings.md)

- [PHP Manual](index.md)
- [Типи](language.types.md)
- Рядки

## Рядки

Рядок (тип string) - це набір символів, де символ - це те саме,
що й байт. Це означає, що PHP підтримує рівно 256 різних
символів, а також те, що у PHP немає вбудованої підтримки Unicode.
Дивіться також [подробиці реалізації строкового
типу](language.types.string.md#language.types.string.details).

> **Примітка**: У 32-бітних системах і ранніх версіях PHP,
> Рядки (string) не можуть бути більше 2 ГБ (2147483647 байт).

### Синтаксис

Рядок може бути визначений чотирма різними способами:

- [одинарними
лапками](language.types.string.md#language.types.string.syntax.single)
- [подвійними
лапками](language.types.string.md#language.types.string.syntax.double)
-
[heredoc-синтаксисом](language.types.string.md#language.types.string.syntax.heredoc)
-
[nowdoc-синтаксисом](language.types.string.md#language.types.string.syntax.nowdoc)

#### Одинарні лапки

Найпростіший спосіб визначити рядок - це укласти його в одинарні
лапки (символ ```).

Щоб використовувати одинарну лапку всередині рядка, проекрануйте її
зворотним слішем (`\`). Якщо необхідно написати сам зворотний сліш,
продублюйте його (`\`). Всі інші випадки застосування зворотного
слеша будуть інтерпретовані як звичайні символи: це означає, що якщо
ви спробуєте використовувати інші керуючі послідовності, такі
як `або
`, вони будуть виведені як є замість будь-якого
особливої поведінки.

> **Примітка**: На відміну від синтаксису [подвійних
> лапок](language.types.string.md#language.types.string.syntax.double)
> і
> [heredoc](language.types.string.md#language.types.string.syntax.heredoc),
> [змінні](language.variables.md) та керуючі послідовності
> для спеціальних символів, укладених у одинарні лапки, *не*
> обробляються.

`<?phpecho 'це простий рядок';echo 'Також ви можете вставляти в рядкисимвол нового рядки ось так,це нормально';// Виводить: Однажды Арноль \'ll be back"';// Виводить: Ви видалили C:\*.*?echo 'Ви видалили C:\*.*?';// Виводить: Ви удалили C:\*.*?echo ''Ви видалили C:\*.*?';// Виводить: Це не буде розгорнуто:
нова рядокecho 'Це не буде розгорнуто:
нова рядок';// Виводить: Змінні $expand також $either не розгортаютьсяecho 'Змінні $expand також $either не розвертаються';?> `

#### Подвійні лапки

Якщо рядок укладено в подвійні лапки ("), PHP розпізнає наступні
керуючі послідовності спеціальних символів:

| Послідовність | Значення |
|----------------------|-------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------------|
| `
`| новий рядок (LF або 0x0A (10) в ASCII) |
| ``| повернення каретки (CR або 0x0D (13) до ASCII) |
| `` | горизонтальна табуляція (HT або 0x09 (9) ASCII) |
| `` | вертикальна табуляція (VT або 0x0B (11) ASCII) |
| `` | escape-знак (ESC або 0x1B (27) ASCII) |
| `` | подання сторінки (FF або 0x0C (12) до ASCII) |
| '\' | зворотна коса межа |
| `\$` | знак долара
| `\"` | подвійна лапка |
| "[0-7] {1,3}" | послідовність символів, що відповідає регулярному виразу символу у восьмеричній системі числення, який мовчки переповнюється, щоб поміститися в байт (тобто "u003du003du003d") |
| `\x[0-9A-Fa-f]{1,2}` | послідовність символів, що відповідає регулярному виразу символу у шістнадцятковій системі числення |
| `\u{[0-9A-Fa-f]+}` | послідовність символів, що відповідає регулярному виразу символу Unicode, яка відображається в рядку у поданні UTF-8 |

**Управляючі послідовності**

Як і в рядку, укладеному в одинарні лапки, екранування будь-якого
іншого символу виведе також сам символ екранування.

Але найважливішою властивістю рядків у подвійних лапках є обробка
змінних. Дивіться докладніше [обробку
строк](language.types.string.md#language.types.string.parsing).

#### Heredoc

Третій спосіб визначення рядків - це використання heredoc-синтаксису:
`<<<`. Після цього оператора необхідно вказати ідентифікатор, потім
переклад рядка. Після цього йде сам рядок, а потім цей же
ідентифікатор закриває вставку.

Закриваючий ідентифікатор може мати відступ за допомогою пробілу або
табуляції, і в цьому випадку відступ буде видалено з усіх рядків у рядку
документа. До PHP 7.3.0 закриваючий ідентифікатор *повинен* був
перебувати на початку нового рядка.

Крім того, закриваючий ідентифікатор повинен відповідати тим же
правилам іменування, як і будь-яка інша мітка в PHP: він повинен містити
тільки буквено-цифрові символи та підкреслення і повинен починатися з
нецифрового символу або символу підкреслення.

**Приклад #1 Базовий приклад використання Heredoc у PHP 7.3.0**

`<?php// без відступовecho <<<END      a     b    c
END;// 4 відступуecho <<<END      a     b   c c   END; `

Результат виконання цього прикладу в PHP 7.3:

a
b
c

a
b
c

Якщо ідентифікатор, що закриває, зміщений далі, ніж будь-який рядок тіла,
буде викинуто [ParseError](class.parseerror.md):

**Приклад #2 Закриваючий ідентифікатор не повинен мати відступ більше, ніж
будь-який рядок тіла**

`<?phpecho <<<<END  a bc   END; `

Результат виконання цього прикладу в PHP 7.3:

PHP Parse error: Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4

Якщо закриває ідентифікатор є відступ, табуляції також можуть
використовуватися, однак табуляції та прогалини *не повинні* змішуватися в
відношення відступу закриває ідентифікатора та відступу тіла (аж до
закриває ідентифікатора). У будь-якому з цих випадків буде викинуто
[ParseError](class.parseerror.md). Ці обмеження на прогалини були
включені, тому що змішування табуляції та пробілів для відступів шкідливо
для розбору.

**Приклад #3 Інший відступ для ідентифікатора тіла, що закриває
(пробілів)**

` <?php// Весь следующий код не работает.// Другой отступ для закрывающего идентификатора (табов) тела (пробелов){    echo <<<END     a        END;}// смешивание пробелов и табуляции в теле{    echo <<<END a     END;}// змішування пробілів і табуляції в закриваючому ідентифікаторі{    echo <<<END          a      

Результат виконання цього прикладу в PHP 7.3:

PHP Parse error: Invalid indentation - tabs and spaces cannot be mixed in example.php line 8

За ідентифікатором основного рядка, що закриває, не обов'язково ставити
точку з комою або новий рядок. Наприклад, починаючи з PHP 7.3.0 дозволено
наступний код:

**Приклад #4 Продовження виразу після ідентифікатора**

` <?php$values u003d [<<<ENDa  b    cEND, 'd e f'];var_dump($values); `

Результат виконання цього прикладу в PHP 7.3:

array(2) {
[0] u003d>
string(11) "a
b
c"
[1] u003d>
string(5) "d e f"
}

**Увага**

Якщо ідентифікатор, що закриває, був знайдений на початку рядка, то незалежно
від того, чи був він частиною іншого слова, його можна розглядати як
закриває ідентифікатор та викинути
[ParseError](class.parseerror.md).

**Приклад #5 Закриваючий ідентифікатор у тілі тексту має тенденцію
викликати ParseError**

`<?php$values u003d [<<<ENDabEND INGEND, 'd e f']; `

Результат виконання цього прикладу в PHP 7.3:

PHP Parse error: syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6

Щоб уникнути цієї проблеми, ви можете безпечно слідувати простому
правилу: *не вибирайте закриває ідентифікатор, який з'являється в
тексту*.

**Увага**

До PHP 7.3.0 дуже важливо відзначити, що рядок із закриваючим
ідентифікатор не повинен містити інших символів, за винятком
крапки з комою (`;`). Це означає, що ідентифікатор *не повинен
вводитися з відступом* і що не може бути жодних прогалин чи знаків
табуляції до або після крапки з комою. Важливо також розуміти, що першим
символом перед ідентифікатором, що закриває, повинен бути символ нової
рядки, визначені у вашій операційній системі. Наприклад, у UNIX
системах, включаючи macOS, це `
`. Після закриття ідентифікатора
також відразу має починатися новий рядок.

Якщо це правило порушено та закриває ідентифікатор не є
"чистим" вважається, що закриваючий ідентифікатор відсутній і PHP
продовжить його пошук далі. Якщо в цьому випадку вірний закриває
ідентифікатор так і не буде знайдений, то це викличе помилку парсингу з
номер рядка в кінці скрипта.

**Приклад #6 Приклад неправильного синтаксису, до PHP 7.3.0**

` <?phpclass foo {    public $bar u003d <<<EOTbarEOT;// відступ перед закриваючим ідентифікатором недопустимо}?> `

**Приклад #7 Приклад правильного синтаксису, навіть до PHP 7.3.0**

` <?phpclass foo {    public $bar u003d <<<EOTbarEOT;}?> `

Heredoc, що містить змінні, не може використовуватися для
ініціалізації властивостей класу.

Heredoc-текст поводиться так само, як і рядок у подвійних лапках, при
цьому їх не маючи. Це означає, що вам не потрібно екранувати
лапки в heredoc, але ви все ще можете використовувати
вищеперелічені керуючі послідовності. Змінні
обробляються, але із застосуванням складних змінних усередині heredoc потрібно
бути також уважним, як і під час роботи з рядками.

**Приклад #8 Приклад визначення heredoc-рядка**

`<?php$str u003d <<<<<EODПриклад рядки,що охоплює кілька рядків,з використанням heredoc-синтаксису.EOD;/* Більш складний приклад з змінними. */class foo{    var $foo; var $bar; function __construct()   {         $this->foo u003d 'Foo'; $this->bar u003d array('Bar1', 'Bar2', 'Bar3'); }}$foo u003d new foo();$name u003d 'Імерек';echo <<<EOTМене звуть "$name". Я друкую $foo->foo.Тепер я виводжу {$foo->bar[1]}.

Результат виконання цього прикладу:

Мене звуть "Імерек". Я друкую Foo.
Тепер я виводжу Bar2.
Це має вивести велику літеру 'A': A

Також можна використовувати heredoc-синтаксис для передачі даних через
аргументи функції:

**Приклад #9 Приклад застосування heredoc в аргументах**

`<?phpvar_dump(array(<<<<EODfoobar!EOD));?> `

Можна ініціалізувати статичні змінні та властивості/константи
класу за допомогою синтаксису heredoc:

**Приклад #10 Використання heredoc для інціалізації статичних
змінних**

` <?php// Статичні змінніfunction foo(){   static $bar u003d <<<LABELТут...нічого немає...LABEL;}// Константи/властивості класуclass foo{                  ¦      ¦           echbate public $baz u003d <<<FOOBARПриклад використання поляFOOBAR;}?> `

Можна також оточувати ідентифікатор Heredoc подвійними лапками:

**Приклад #11 Використання подвійних лапок у heredoc**

`<?phpecho <<<""FOOBAR"Привіт, світ!FOOBAR;?> `

#### Nowdoc

Nowdoc - це те саме для рядків в одинарних лапках, що й heredoc
для рядків у подвійних лапках. Nowdoc схожий на heredoc, але всередині нього
*не здійснюється жодних підстановок*. Ця конструкція ідеальна для
впровадження PHP-коду або інших великих блоків тексту без необхідності
його екранування. У цьому він трохи схожий на SGML-конструкцію
`<![CDATA[ ]]>` тим, що оголошує блок тексту, не призначений для
обробки.

Nowdoc вказується тією ж послідовністю `<<<`, що використовується в
heredoc, але наступний за нею ідентифікатор полягає в одинарному
лапки, наприклад, `<<<'EOT'`. Усі умови, що діють для
ідентифікатори heredoc також дійсні і для nowdoc, особливо ті,
що відносяться до ідентифікатора, що закриває.

**Приклад #12 Приклад використання nowdoc**

` <?phpecho <<<<'EOD'Приклад тексту,що займає кілька рядків,з допомогою синтаксису nowdoc. Зворотні слідки завжди обробляються буквально, наприклад, і та '.EOD; `

Результат виконання цього прикладу:

Приклад тексту
займає кілька рядків,
за допомогою синтаксису nowdoc. Зворотні сліші завжди обробляються буквально,
наприклад, \ і \'.

**Приклад #13 Nowdoc приклад цитування рядка зі змінними**

`<?php/* Більш складний приклад з змінними. */class foo{    public $foo; public $bar; function __construct()   {         $this->foo u003d 'Foo'; $this->bar u003d array('Bar1', 'Bar2', 'Bar3'); }}$foo u003d new foo();$name u003d 'Імерек';echo <<<'EOT'Мене звуть "$name". Я друкую $foo->foo.Тепер я друкую {$foo->bar[1]}.

Результат виконання цього прикладу:

Мене звуть "$name". Я друкую $foo->foo.
Тепер я друкую {$foo->bar[1]}.
Це не повинно вивести 'A': \x41

**Приклад #14 Приклад використання статичних даних**

` <?phpclass foo {    public $bar u003d <<<'EOT'barEOT;}?> `

#### Обробка змінних

Якщо рядок вказується у подвійних лапках, або за допомогою heredoc,
[Змінні](language.variables.md) всередині неї обробляються.

Існує два типи синтаксису:
[простий](language.types.string.md#language.types.string.parsing.simple)
і
[складний](language.types.string.md#language.types.string.parsing.complex).
Простий синтаксис більш легкий та зручний. Він дає можливість обробки
змінної, значення масиву (array) або властивості об'єкта (object) з
мінімумом зусиль.

Складний синтаксис може бути визначений за фігурними дужками, що оточують
вираз.

##### Простий синтаксис

Якщо інтерпретатор зустрічає знак долара ($), він захоплює так
багато символів, скільки можливо, щоб сформувати правильне ім'я
змінної. Якщо ви хочете точно визначити кінець імені, укладайте ім'я
змінної у фігурні дужки.

` <?php$juice u003d "apple";echo "He drank some $juice juice.".PHP_EOL;// Некоректно. 's' - вірний символ для імені змінної, але змінна має ім'я$juice.echo "He drank some juice made of $juices.";// Коректно. Строго вказаний кінець імені змінною з допомогою дужок:echo "He drank some juice made of ${juice}s.";?> `

Результат виконання цього прикладу:

He drank some apple juice.
He drank some juice made of.
He drank some juice made of apples.

Аналогічно можуть бути оброблені елемент масиву (array) або властивість
об'єкта (object). В індексах масиву квадратна дужка, що закриває (`]`)
позначає кінець визначення індексу. Для властивостей об'єкта застосовуються ті
ж правила, що й для простих змінних.

**Приклад #15 Приклад простого синтаксису**

` <?phpdefine('KOOLAID', 'koolaid1');$juices u003d array("apple", "orange", "koolaid1" u003d> "purple");echo "He drank some $juices[0] .PHP_EOL;echo "He drank some $juices[1] juice.".PHP_EOL;echo "He drank some $juices[koolaid1] juice.".PHP_EOL;class people {   public $jane u003d "Jane Smith"; public $robert u003d "Robert Paulsen"; public $smith u003d "Smith";}$people u003d new people();echo "$people->john drank some $juices[0] juice.".PHP_EOL;echo "$people->john  ->jane.".PHP_EOL;echo"$people->john's wife greeted $people->robert.".PHP_EOL;echo "$people->robert greeted the two $people->smiths."; // Не спрацює?> `

Результат виконання цього прикладу:

He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank деякі apple juice.
John Smith є саїд hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two.

У PHP 7.1.0 додано підтримку *негативних* числових індексів.

**Приклад #16 Негативні числові індекси**

` <?php$string u003d 'string';echo "Символ з індексом -2 рівний $string[-2].", PHP_EOL;$string[-3] u003d 'o';echo "Зміна символу на позиції 'o' дає наступний рядок: $string.', PHP_EOL;?> `

Результат виконання цього прикладу:

Символ із індексом -2 дорівнює n.
Зміна символу на позиції -3 на 'o' дає наступний рядок: strong

Для чогось складнішого, використовуйте складний синтаксис.

##### Складний (фігурний) синтаксис

Він називається складним не тому, що важкий у розумінні, а тому що
дозволяє використовувати складні вирази.

Будь-яка скалярна змінна, елемент масиву або властивість об'єкта,
відображається в рядок, може бути представлена в рядку цим
синтаксисом. Вираз записується так само, як і поза рядком, а потім
полягає в `{` та `}`. Оскільки `{` не може бути екранований, цей
синтаксис буде розпізнаватись тільки коли `$` слід безпосередньо
за `{`. Використовуйте `{\$`, щоб надрукувати `{$`. Кілька тих, хто пояснює
прикладів:

` <?php// Показуємо все помилкиerror_reporting(E_ALL);$great u003d 'здорово';// Не працює, виводить: Це { здорово}echo "Це { $great}";//   {$great}";// Працюєecho "Цей квадрат шириною {$square->width}00 сантиметрів.";// Працює, ключи, в'язні в лапки, працюють тільки с key']}";// Працюєecho "Це працює: {$arr[4][3]}";// Це невірно за тією ж причиною, і і$foo[bar] поза// рядки. Іншими словами, це як і раніше працюватиме, / / але але, оскільки PHP спочатку шукає константу Foo, це викликає // помилка рівня E_NOTICE (не визначена) / Працює. При використанні багатомірних масивів внутрі// рядків завжди використовуйте фігурні дужкиecho "Це працює: {$arr['foo'][3]}";// Працює.echo ""   | $arr['foo'][3];echo "Це також працює: {$obj->values[3]->name}";echo "Це значення змінної за ім'ям $name: {${$name}}" ;echo "Це значення змінної за імені, що повертає функція getName(): {${getName()}}";echo "Це значення змінної по імені, objectu003d$повертає| ->getName()}}";// Не працює, виводить: Це то, повертає getName(): {getName()}echo "Це то, повертає getName(): {getName()}";/// Не працює, виводить: C: older\{fantastic}.txtecho "C: older\{$great}.txt"// Працює, виводить: C: older antastic.txtecho "C:\folder\{$great}.txt "?> `

За допомогою цього синтаксису також можливий доступ до властивостей об'єкту
усередині рядків.

` <?phpclass foo {   var $bar u003d 'I am bar.';}$foo u003d new foo();$bar u003d 'bar';$baz u003d array('foo', 'bar', 'ba 'quux');echo "{$foo->$bar}
";echo "{$foo->{$baz[1]}}
";?> `

Результат виконання цього прикладу:

I am bar.
I am bar.

> **Примітка**:
>
> Значення, до якого здійснюється доступ із функцій, дзвінків
> методів, статичних змінних класу та констант класу всередині `{$}`,
> буде інтерпретуватися як ім'я змінної області, у якій
> визначено рядок. Використання одинарних фігурних дужок (`{}`) не
> працюватиме для доступу до значень функцій, методів, констант
> класів чи статичних змінних класу.

` <?php// Показуємо все помилкиerror_reporting(E_ALL);class beers {    const softdrink u003d 'rootbeer'; public static $ale u003d 'ipa';}$rootbeer u003d 'A & W';$ipa u003d 'Alexander Keith\'s';// Це працює, виводить: Я би хотел A beers::softdrink}}
";// Це також працює, виводить: Я би хотів Alexander Keith'secho "Я би хотів {${beers::$ale}}
";?> `

#### Доступ до символу в рядку та його зміна

Символи в рядках можна використовувати та модифікувати, визначивши їх
зміщення щодо початку рядка, починаючи з нуля, у квадратних
дужках після рядка, наприклад, $str[42]. Думайте про рядок для цього
Цілі, як про масив символів. Якщо потрібно отримати або замінити більше ніж 1
символу, можна використовувати функції [substr()](function.substr.md) та
[substr_replace()](function.substr-replace.md).

> **Примітка**: Починаючи з PHP 7.1.0, підтримуються негативні
> значення усунення. Вони задають усунення з кінця рядка. Раніше
> негативні усунення викликали помилку рівня **`E_NOTICE`** при
> читанні (повертаючи порожній рядок) або **`E_WARNING`** під час запису
> (залишаючи рядок без змін).

> **Примітка**: До PHP 8.0.0 для доступу до символу в рядку (string)
> також можна було використовувати фігурні дужки, наприклад $str{42},
> для тієї ж мети. Синтаксис фігурних дужок застарів у PHP 7.4.0 та
> більше не підтримується у PHP 8.0.0.

**Увага**

Спроба запису у зсув за межами рядка доповнить рядок пробілами
до цього усунення. Нецілі типи буде перетворено на цілі. Невірний
тип зміщення викликає помилку рівня **`E_WARNING`**. Використовується тільки
перший символ рядка. Починаючи з PHP 7.1.0, присвоєння порожній
рядки викликає фатальну помилку. Раніше у такому разі присвоювався
нульовий байт (Null).

**Увага**

Рядки в PHP внутрішньо являють собою масиви байт. Як результат,
доступ або зміна рядка зі зміщення небезпечно з погляду
багатобайтного кодування, і має виконуватися тільки з рядками в
однобайтних кодуваннях, таких як, наприклад, ISO-8859-1.

> **Примітка**: Починаючи з PHP 7.1.0, використання порожнього індексу
> викликає фатальну помилку, раніше у разі рядок
> перетворювалася на масив без попередження.

**Приклад #17 Кілька прикладів рядків**

` <?php// Отримання Першого символу строки $ рядки$str u003d 'This is still a test.';$last u003d $str[strlen($str)-1];// Зміна останнього символу рядки$str u003d 'Look at the sea'$ str)-1] u003d 'e';?> `

Зміщення у рядку має задаватися або цілим числом, або рядком,
містить цифри, інакше видаватиметься попередження.

**Приклад #18 Приклад неприпустимого усунення рядка**

` <?php$stru003du003d'abc';var_dump($str['1']);var_dump(isset($str['1']));var_dump($str['1.0']);var_dump(isset ($str['1.0']));var_dump($str['x']);var_dump(isset($str['x']));var_dump($str['1x']);var_dump(isset ($str['1x']));?> `

Результат виконання цього прикладу:

string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' у /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' в /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)

> **Примітка**:
>
> Спроба доступу до змінних інших типів (за винятком масивів або
> об'єкти, що реалізують певні інтерфейси) за допомогою `[]` або `{}`
> мовчки поверне **`null`**.

> **Примітка**:
>
> Доступ до символів у рядкових літералах можна отримати за допомогою
> синтаксису `[]` або `{}`.

> **Примітка**:
>
> Доступ до символів у рядкових літералах за допомогою синтаксису
> `{}` оголошений застарілим у PHP 7.4. Функціонал вилучений у PHP 8.0.

### Корисні функції та оператори

Рядки можуть бути об'єднані за допомогою оператора '.' (крапка). Зверніть
увагу, оператор додавання '+' *тут не працює*. Додаткову
інформацію дивіться в розділі
оператори](language.operators.string.md).

Для модифікації рядків існує багато корисних функцій.

Основні функції описані в розділі
функцій](ref.strings.md), а для розширеного пошуку та заміни - функції
[Perl-сумісних регулярних виразів](ref.pcre.md).

Також існують [функції для роботи з URL](ref.url.md) та функції
шифрування/дешифрування рядків ([Sodium](ref.sodium.md) та
[Hash](ref.hash.md)).

Нарешті, дивіться [функції символьних типів](ref.ctype.md).

### Перетворення в рядок

Значення може бути перетворено на рядок за допомогою приведення
`(string)`, або функції [strval()](function.strval.md). У виразах,
де потрібен рядок, перетворення відбувається автоматично. Це
відбувається, коли ви використовуєте функції [echo](function.echo.md) або
[print](function.print.md), або коли значення змінної
порівнюється з рядком. Прочитання розділів керівництва
[Типи](language.types.md) та [Маніпуляції з
типами](language.types.type-juggling.md) зробить таке більше
зрозумілим. Також дивіться [settype()](function.settype.md).

Значення bool **`true`** перетворюється на рядок ``1'', а значення
**`false`** перетворюється на ````` (порожній рядок). Це дозволяє
перетворювати значення в обидві сторони - з бульова типу в рядковий і
навпаки.

Ціле (int) або число з плаваючою точкою (float) перетворюється на рядок,
представлену числом, що складається з його цифр (включаючи показник ступеня
для чисел із плаваючою точкою). Числа з плаваючою точкою можуть бути
перетворені за допомогою експонентного уявлення (`4.1E+6`).

> **Примітка**:
>
> Починаючи з PHP 8.0.0, символом десяткової точки завжди є `.`. До
> PHP 8.0.0 символ десяткової точки визначався у локалі скрипту
> (категорія LC_NUMERIC). Дивіться функцію
> [setlocale()](function.setlocale.md)

Масиви завжди перетворюються на рядок ``Array'`, так що ви не можете
відобразити вміст масиву (array), використовуючи
[echo](function.echo.md) або [print](function.print.md), щоб
дізнатися, що він містить. Щоб переглянути окремий елемент,
використовуйте щось на зразок `echo $arr['foo']`. Дивіться нижче поради про
Як відобразити/переглянути весь вміст.

Для перетворення змінної типу ``Object'` в тип string використовується
магічний метод [\_\_toString](language.oop5.magic.md).

Тип ресурс (resource) завжди перетворюється на рядок (string) виду
``Resource id #1'', де `1` є номером ресурсу прив'язаного до
resource під час виконання. І хоча не варто точно покладатися на цю
рядок, який може бути змінено в майбутньому, він завжди буде
унікальною для поточного запуску скрипта (тобто веб-запиту або
CLI-процесу) і не може використовуватись повторно для іншого ресурсу.
Якщо ви бажаєте отримати тип ресурсу, використовуйте
[get_resource_type()](function.get-resource-type.md).

Значення **`null`** завжди перетворюється на порожній рядок.

Як ви могли бачити вище, пряме перетворення на рядок масивів,
об'єктів чи ресурсів не дає жодної корисної інформації про самих
значеннях, крім їх типів. Більш сприятливий спосіб виведення значень для
налагодження - використовувати функції [print_r()](function.print-r.md) та
[var_dump()](function.var-dump.md).

Більшість значень у PHP може бути перетворено на рядок для
Постійне зберігання. Цей метод називається серіалізацією і може бути
виконаний за допомогою функції [serialize()](function.serialize.md).

### Подробиці реалізації рядкового типу

Рядковий тип (string) у PHP реалізований у вигляді масиву байт та цілого
числа, що містить довжину буфера Він не містить жодної інформації про
способі перетворення цих байт на символи, надаючи це завдання
програмісту. Немає жодних обмежень на вміст рядка, наприклад,
байт зі значенням `0` ("NUL"-байт) може розташовуватися будь-де
(проте, варто враховувати, що деякі функції, як сказано в цьому
керівництві, є " бинарно-безопасными " , тобто. вони можуть
передавати рядки бібліотекам, які ігнорують дані після
NUL-байт).

Дана природа рядкового типу пояснює чому в PHP немає окремого
типу "byte" - рядки відіграють цю роль. Функції, що повертають нетекстові
дані - наприклад, довільний потік даних, що зчитується з мережевого
сокету - проте повертають рядки.

Зважаючи на той факт, що PHP не диктує певного кодування
для рядків, можна поставити питання, як у такому разі кодуються рядкові
літерали. Наприклад, рядок 'á' еквівалентний 'xE1' (ISO-8859-1),
`\\xC3\xA1`` (UTF-8, форма нормалізації C), ``\x61\xCC\x81"' (UTF-8,
форма нормалізації D) або будь-якому іншому можливому уявленню?
Відповіддю є таке: рядок буде закодований таким чином,
яким вона записана у файлі скрипта. Таким чином, якщо скрипт записаний
у кодуванні ISO-8859-1, то й рядок буде закодовано в ISO-8859-1 та
і т.д. Однак це правило не застосовується при включеному режимі Zend
Multibyte: у цьому випадку скрипт може бути записаний у будь-якому кодуванні
(яка вказується ясно або визначається автоматично), а потім
конвертуються у певне внутрішнє кодування, яке і буде
згодом використана для рядкових літералів. Врахуйте, що на
кодування скрипта (або на внутрішнє кодування, якщо увімкнено режим Zend
Multibyte) накладаються деякі обмеження: практично завжди
дане кодування має бути надмножиною ASCII, наприклад, UTF-8 або
ISO-8859-1. Врахуйте також, що кодування, що залежать від стану, де
одні й самі значення байт можуть бути використані в початковому і не
початковому стані зсуву можуть викликати проблеми.

Зрозуміло, щоб приносити користь, рядкові функції мають зробити
деякі припущення про кодування рядка. На жаль, серед
PHP-функцій досить велика різноманітність підходів до цього питання:

- Деякі функції припускають, що рядок закодовано в
будь-яке однобайтове кодування, однак, для коректної роботи їм
не потрібно інтерпретувати байти як певні символи. Під
цю категорію потрапляють, наприклад, [substr()](function.substr.md),
[strpos()](function.strpos.md), [strlen()](function.strlen.md) та
[strcmp()](function.strcmp.md). Інший спосіб мислення про ці
функціях є оперування буферами пам'яті, тобто. вони
працюють безпосередньо з байтами та їх зсувами.
- Інші функції очікують на передачу кодування у вигляді параметра,
можливо, припускаючи деяке кодування за замовчуванням, якщо
параметр із кодуванням не було вказано. Такою функцією є
[htmlentities()](function.mdentities.md) та більшість функцій
із модуля [mbstring](book.mbstring.md).
- Інші функції використовують поточні установки локалі (дивіться
[setlocale()](function.setlocale.md)), але оперують побайтово). В
цю категорію попадають [strcasecmp()](function.strcasecmp.md),
[strtoupper()](function.strtoupper.md) та
[ucfirst()](function.ucfirst.md). Це означає, що вони можуть бути
використані тільки з однобайтовими кодуваннями, у тому випадку, коли
кодування збігається з локаллю. Наприклад, `strtoupper("á")` може
повернути ``Á'`, якщо локаль встановлена коректно та літера `á`
закодована як одного байта. Якщо вона закодована в UTF-8,
буде повернено некоректний результат, та, залежно від поточної
локалі, що результує рядок може бути (або не бути) зіпсована.
- Нарешті, є функції, які мають на увазі, що рядок використовує
певне кодування, зазвичай UTF-8. Сюди попадають більшість
функцій з модулів [intl](book.intl.md) та [PCRE](book.pcre.md)
(В останньому випадку, тільки при вказівці модифікатора `u`). Хоча це
і зроблено спеціально, функція
[utf8_decode()](function.utf8-decode.md) передбачає кодування
UTF-8, а [utf8_encode()](function.utf8-encode.md) - ISO-8859-1.

Зрештою, написання коректних програм, що працюють з Unicode,
означає обережне уникнення функцій, які не працюють з Unicode та,
швидше за все, зіпсують дані, та використання замість них коректних
функцій, зазвичай з модулів [intl](book.intl.md) та
[mbstring](book.mbstring.md). Однак, використання функцій, здатних
працювати з Unicode, є початком. Незалежно від тих
функцій, що надає мову, необхідно знати специфікацію
самого Unicode. Наприклад, якщо програма передбачає існування в
мові лише малих і великих букв, вона робить велику помилку.
