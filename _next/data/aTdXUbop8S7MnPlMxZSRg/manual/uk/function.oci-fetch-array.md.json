{"pageProps":{"page":{"slug":"function.oci-fetch-array.md","content":"# oci\\_fetch\\_array\n\n(PHP 5, PHP 7, PHP 8, PECL OCI8 >= 1.1.0)\n\noci\\_fetch\\_array — Повертає наступний рядок із результату запиту у вигляді асоціативного чи нумерованого масиву\n\n### Опис\n\n```methodsynopsis\noci_fetch_array(resource $statement, int $mode = OCI_BOTH | OCI_RETURN_NULLS): array|false\n```\n\nПовертає масив, що містить наступний рядок результату запиту. Кожен елемент масиву відповідає одному полю рядка. Ця функція зазвичай викликається в циклі, доки вона не поверне\\*\\*`false`\\*\\*що вказує на відсутність наступних рядків.\n\nЯкщо `statement`відповідає PL/SQL блоку, що повертається Oracle Database Implicit Result Sets, тоді буде послідовно вилучено ряди з усіх наборів. Якщо`statement`повертається з[oci\\_get\\_implicit\\_resultset()](function.oci-get-implicit-resultset.md)тоді повернеться лише частина рядів для одного дочірнього запиту.\n\nДля отримання детальнішої інформації щодо відображення типів даних модуля OCI8 зверніться до [типів даних, що підтримуються драйвером](oci8.datatypes.md)\n\n### Список параметрів\n\n`statement`\n\nКоректний ідентифікатор виразу OCI8, отриманий з [oci\\_parse()](function.oci-parse.md) та виконаний функцією [oci\\_execute()](function.oci-execute.md), або ідентифікатор виразу `REF CURSOR`\n\nТакож може бути ідентифікатором, що повертається функцією[oci\\_get\\_implicit\\_resultset()](function.oci-get-implicit-resultset.md)\n\n`mode`\n\nНеобов'язковий другий параметр може складатися з будь-якої комбінації наступних констант:\n\n\\*\\*\\*\\*oci\\_fetch\\_array()**Modes**\n\n| Константа | Опис |\n| --- | --- |\n| **`OCI_BOTH`** | Повертає масив як з асоціативними та числовими індексами. Ця константа те саме, що й **`OCI_ASSOC`** **`OCI_NUM`**, і вона використовується за замовчуванням. |\n| **`OCI_ASSOC`** | Повертає асоціативний масив. |\n| **`OCI_NUM`** | Повертає нумерований масив. |\n| **`OCI_RETURN_NULLS`** | Створює елементи для рівних полів **`null`**. . Значення елемента дорівнюватиме PHP **`null`** |\n| **`OCI_RETURN_LOBS`** | Повертає вміст полів типу LOB замість LOB покажчика. |\n\nПо умолчанию`mode`равен\\*\\*`OCI_BOTH`\\*\\*\n\nВикористовуйте оператор додавання \"+\", щоб вказати більше одного режиму.\n\n### Значення, що повертаються\n\nПовертає масив з асоціативними та/або числовими ключами. Якщо більше немає рядків у`statement`, то повертається **`false`**\n\nЗа замовчуванням поля`LOB`повертаються як покажчики LOB.\n\nПоля типу`DATE`повертаються у форматі рядків, що відповідає поточному формату дати. Формат за промовчанням може бути змінений за допомогою змінних оточення Oracle, таких як`NLS_LANG`, або попереднім виконанням команди`ALTER SESSION SET NLS_DATE_FORMAT`\n\nРегістронезалежні (за замовчуванням у Oracle) імена полів матимуть асоціативні індекси у верхньому регістрі в результуючому масиві. Регістрозалежні імена полів матимуть індекси з тими самими регістрами символів, як і саме поле. Використовуйте[var\\_dump()](function.var-dump.md)для результуючого масиву, щоб перевірити відповідність регістрів символів кожному за запиту.\n\nІм'я таблиці не входить до асоціативного індексу. Якщо ваш запит містить два різні поля з однаковим ім'ям, використовуйте\\*\\*`OCI_NUM`\\*\\*або додайте аліас для поля у запит, щоб імена стали унікальними (дивіться приклад #7). Інакше буде повернуто лише одне поле.\n\n### Приклади\n\n**Приклад #1**oci\\_fetch\\_array()**с**`OCI_BOTH`\\*\\*\\*\\*\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT department_id, department_name FROM departments');\noci_execute($stid);\n\nwhile (($row = oci_fetch_array($stid, OCI_BOTH))) {\n    // Используйте название полей в верхнем регистре для ассоциативных индексов\n    echo $row[0] . \" и \" . $row['DEPARTMENT_ID']   . \" идентичны<br>\\n\";\n    echo $row[1] . \" и \" . $row['DEPARTMENT_NAME'] . \" идентичны<br>\\n\";\n}\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #2**oci\\_fetch\\_array()**с**`OCI_NUM`\\*\\*\\*\\*\n\n```php\n<?php\n\n/*\n  Перед выполнением создайте таблицу:\n      CREATE TABLE mytab (id NUMBER, description CLOB);\n      INSERT INTO mytab (id, description) values (1, 'A very long string');\n      COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT id, description FROM mytab');\noci_execute($stid);\n\nwhile (($row = oci_fetch_array($stid, OCI_NUM)) != false) {\n    echo $row[0] . \"<br>\\n\";\n    echo $row[1]->read(11) . \"<br>\\n\"; // это выведет первые 11 байт DESCRIPTION\n}\n\n// Выведет:\n//    1\n//    A very long\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #3**oci\\_fetch\\_array()**с**`OCI_ASSOC`\\*\\*\\*\\*\n\n```php\n<?php\n\n/*\n  Перед выполнением создайте таблицу:\n      CREATE TABLE mytab (id NUMBER, description CLOB);\n      INSERT INTO mytab (id, description) values (1, 'A very long string');\n      COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT id, description FROM mytab');\noci_execute($stid);\n\nwhile (($row = oci_fetch_array($stid, OCI_ASSOC)) != false) {\n    echo $row['ID'] . \"<br>\\n\";\n    echo $row['DESCRIPTION']->read(11) . \"<br>\\n\"; // это выведет первые 11 байт DESCRIPTION\n}\n\n// Выведет:\n//    1\n//    A very long\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #4**oci\\_fetch\\_array()**с**`OCI_RETURN_NULLS`\\*\\*\\*\\*\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT 1, null FROM dual');\noci_execute($stid);\nwhile (($row = oci_fetch_array ($stid, OCI_ASSOC)) != false) { // Игнорирует NULL значения\n    var_dump($row);\n}\n\n/*\nВышеуказанный код выведет:\n  array(1) {\n    [1]=>\n    string(1) \"1\"\n  }\n*/\n\n$stid = oci_parse($conn, 'SELECT 1, null FROM dual');\noci_execute($stid);\nwhile (($row = oci_fetch_array ($stid, OCI_ASSOC+OCI_RETURN_NULLS)) != false) { // Получает NULL значения\n    var_dump($row);\n}\n\n/*\nВышеуказанный код выведет:\n  array(2) {\n    [1]=>\n    string(1) \"1\"\n    [\"NULL\"]=>\n    NULL\n  }\n*/\n\n?>\n```\n\n**Приклад #5**oci\\_fetch\\_array()**с**`OCI_RETURN_LOBS`\\*\\*\\*\\*\n\n```php\n<?php\n\n/*\n  Перед выполнением создайте таблицу:\n      CREATE TABLE mytab (id NUMBER, description CLOB);\n      INSERT INTO mytab (id, description) values (1, 'A very long string');\n      COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT id, description FROM mytab');\noci_execute($stid);\n\nwhile (($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_LOBS))) {\n    echo $row['ID'] . \"<br>\\n\";\n    echo $row['DESCRIPTION'] . \"<br>\\n\"; // содержит весь DESCRIPTION\n    // В цикле, очищение больших переменных перед повторным получением данных, уменьшает пиковое потребление памяти PHP\n    unset($row);\n}\n\n// Выведет:\n//    1\n//    A very long string\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #6**oci\\_fetch\\_array()**з реєстрозалежними назвами полів**\n\n```php\n<?php\n\n/*\n   Перед выполнением создайте таблицу:\n      CREATE TABLE mytab (\"Name\" VARCHAR2(20), city VARCHAR2(20));\n      INSERT INTO mytab (\"Name\", city) values ('Chris', 'Melbourne');\n      COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'select * from mytab');\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS);\n\n// Так как 'Name' было создан как регистрозависимое поле, то\n// те же регисты символов используются для индексов массива.\n// Тем не менее для 'CITY' должен использоваться индекс в верхнем регистре.\nprint $row['Name'] . \"<br>\\n\";   //  выведет Chris\nprint $row['CITY'] . \"<br>\\n\";   //  выведет Melbourne\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #7**oci\\_fetch\\_array()**з полями з однаковими назвами**\n\n```php\n<?php\n\n/*\n  Перед выполнением создайте таблицу:\n      CREATE TABLE mycity (id NUMBER, name VARCHAR2(20));\n      INSERT INTO mycity (id, name) values (1, 'Melbourne');\n      CREATE TABLE mycountry (id NUMBER, name VARCHAR2(20));\n      INSERT INTO mycountry (id, name) values (1, 'Australia');\n      COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$sql = 'SELECT mycity.name, mycountry.name\n        FROM mycity, mycountry\n        WHERE mycity.id = mycountry.id';\n$stid = oci_parse($conn, $sql);\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC);\nvar_dump($row);\n\n// Выведет только одну записаь \"NAME\":\n//    array(1) {\n//      [\"NAME\"]=>\n//      string(9) \"Australia\"\n//    }\n\n// Для получения полей с повторяющимся названием используйте SQL псевдонимы (alias) для полей. НаПриклад \"AS ctnm\":\n$sql = 'SELECT mycity.name AS ctnm, mycountry.name\n        FROM mycity, mycountry\n        WHERE mycity.id = mycountry.id';\n$stid = oci_parse($conn, $sql);\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC);\nvar_dump($row);\n\n// Выведет записи из обоих полей:\n//    array(2) {\n//      [\"CTNM\"]=>\n//      string(9) \"Melbourne\"\n//      [\"NAME\"]=>\n//      string(9) \"Australia\"\n//    }\n\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #8**oci\\_fetch\\_array()**з полями`DATE`**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n// Устанавливаем формат даты для данного соединения.\n// Для повышения производительности вместо этого\n// используйте изменение формата в триггере или переменной окружения.\n$stid = oci_parse($conn, \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD'\");\noci_execute($stid);\n\n$stid = oci_parse($conn, 'SELECT hire_date FROM employees WHERE employee_id = 188');\noci_execute($stid);\n$row = oci_fetch_array($stid, OCI_ASSOC);\necho $row['HIRE_DATE'] . \"<br>\\n\";  // выведет 1997-06-14\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #9**oci\\_fetch\\_array()**с`REF CURSOR`**\n\n```php\n<?php\n/*\n  Создайте PL/SQL хранимую процедуру:\n\n  CREATE OR REPLACE PROCEDURE myproc(p1 OUT SYS_REFCURSOR) AS\n  BEGIN\n    OPEN p1 FOR SELECT * FROM all_objects WHERE ROWNUM < 5000;\n  END;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'BEGIN myproc(:rc); END;');\n$refcur = oci_new_cursor($conn);\noci_bind_by_name($stid, ':rc', $refcur, -1, OCI_B_CURSOR);\noci_execute($stid);\n\n// Выполняет вовзращенный REF CURSOR и получает его в виде идентификатора выражения\noci_execute($refcur);\necho \"<table border='1'>\\n\";\nwhile (($row = oci_fetch_array($refcur, OCI_ASSOC+OCI_RETURN_NULLS)) != false) {\n    echo \"<tr>\\n\";\n    foreach ($row as $item) {\n        echo \"    <td>\".($item !== null ? htmlentities($item, ENT_QUOTES) : \"\").\"</td>\\n\";\n    }\n    echo \"</tr>\\n\";\n}\necho \"</table>\\n\";\n\noci_free_statement($refcur);\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #10 Посічний висновок за допомогою**oci\\_fetch\\_array()**використовуючи`LIMIT`\\-подібний запит**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n// Определяем версию базы данных\npreg_match('/Release ([0-9]+)\\./', oci_server_version($conn), $matches);\n$oracleversion = $matches[1];\n\n// Запрос, который необходимо сделать \"постраничным\"\n$sql = 'SELECT city, postal_code FROM locations ORDER BY city';\n\nif ($oracleversion >= 12) {\n    // Используем Oracle 12c OFFSET / FETCH NEXT синтаксис\n    $sql = $sql . ' OFFSET :offset ROWS FETCH NEXT :numrows ROWS ONLY';\n} else {\n    // Cтарые версии Oracle нуждаются в выборке с помощью подзапроса в $sql.\n    // Или, если SQL выражение известно на стадии разработки, то с помощью\n    // функции row_number(). Будьте осторожны и избегайте возможности\n    // SQL-инъекции при объединении строк в боевом окружении.\n    $sql = \"SELECT * FROM (SELECT a.*, ROWNUM AS my_rnum\n                           FROM ($sql) a\n                           WHERE ROWNUM <= :offset + :numrows)\n            WHERE my_rnum > :offset\";\n}\n\n$offset  = 0;  // skip this many rows\n$numrows = 5;  // return 5 rows\n$stid = oci_parse($conn, $sql);\noci_bind_by_name($stid, ':numrows', $numrows);\noci_bind_by_name($stid, ':offset', $offset);\noci_execute($stid);\n\nwhile (($row = oci_fetch_array($stid, OCI_ASSOC + OCI_RETURN_NULLS)) != false) {\n    echo $row['CITY'] . \" \" . $row['POSTAL_CODE'] . \"<br>\\n\";\n}\n\n// Выведет:\n//    Beijing 190518\n//    Bern 3095\n//    Bombay 490231\n//    Geneva 1730\n//    Hiroshima 6823\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #11**oci\\_fetch\\_array()**c Oracle Database Implicit Result Sets**\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/pdborcl');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n// Требует OCI8 2.0 (или новее) и Oracle Database 12c (или новее)\n// также смотрите oci_get_implicit_resultset()\n$sql = 'DECLARE\n           c1 SYS_REFCURSOR;\n        BEGIN\n           OPEN c1 FOR SELECT city, postal_code FROM locations WHERE ROWNUM < 4 ORDER BY city;\n           DBMS_SQL.RETURN_RESULT(c1);\n           OPEN c1 FOR SELECT country_id FROM locations WHERE ROWNUM < 4 ORDER BY city;\n           DBMS_SQL.RETURN_RESULT(c1);\n        END;';\n\n$stid = oci_parse($conn, $sql);\noci_execute($stid);\n\n// Обратите внимание: oci_fetch_all и oci_fetch() нельзя неприменимы здесь\necho \"<table>\\n\";\nwhile (($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) != false) {\n    echo \"<tr>\\n\";\n    foreach ($row as $item) {\n        echo \"  <td>\".($item!==null?htmlentities($item, ENT_QUOTES|ENT_SUBSTITUTE):\"\").\"</td>\\n\";\n    }\n    echo \"</tr>\\n\";\n}\necho \"</table>\\n\";\n\n// Выведет:\n//    Beijing 190518\n//    Bern    3095\n//    Bombay  490231\n//    CN\n//    CH\n//    IN\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Індекси асоціативного масиву необхідно наводити у верхній регістр для стандартних полів Oracle, створених із реєстронезалежними назвами.\n\n> **Зауваження** :\n> \n> Для запитів, що повертають велику кількість рядів, продуктивність може бути значно збільшена за допомогою збільшення значення опції [oci8.default\\_prefetch](oci8.configuration.md#ini.oci8.default-prefetch)или использования[oci\\_set\\_prefetch()](function.oci-set-prefetch.md)\n\n> **Зауваження** :\n> \n> Функция**oci\\_fetch\\_array()** *трохи*повільніше[oci\\_fetch\\_assoc()](function.oci-fetch-assoc.md) або [oci\\_fetch\\_row()](function.oci-fetch-row.md), але гнучкіша.\n\n### Дивіться також\n\n-   [oci\\_fetch()](function.oci-fetch.md) \\- Вибирає наступний рядок із результату в буфер\n-   [oci\\_fetch\\_all()](function.oci-fetch-all.md) \\- Вибирає всі рядки з результату запиту до двомірного масиву\n-   [oci\\_fetch\\_assoc()](function.oci-fetch-assoc.md) \\- Повертає наступний рядок із результату запиту у вигляді асоціативного масиву\n-   [oci\\_fetch\\_object()](function.oci-fetch-object.md) \\- Повертає наступний рядок із результату запиту у вигляді об'єкта\n-   [oci\\_fetch\\_row()](function.oci-fetch-row.md) \\- Повертає наступний рядок із результату запиту у вигляді нумерованого масиву\n-   [oci\\_set\\_prefetch()](function.oci-set-prefetch.md) \\- Встановлює кількість рядків, які будуть автоматично вибрані у буфер\n","title":"oci\\_fetch\\_array","contentType":2,"navigation":[{"function.oci-fetch-all.md":"« oci\\_fetch\\_all"},{"function.oci-fetch-assoc.md":"oci\\_fetch\\_assoc »"},{"index.md":"PHP Manual"},{"ref.oci8.md":"OCI8 Функції"}]}},"__N_SSG":true}