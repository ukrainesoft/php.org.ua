{"pageProps":{"page":{"slug":"language.oop5.basic.md","content":"## Основи\n\n### class\n\nКожне визначення класу починається з ключового слова `class`, Потім слідує ім'я класу, і далі пара фігурних дужок, які містять визначення властивостей і методів цього класу.\n\nІм'ям класу може бути будь-яке слово, за умови, що воно не входить до списку [зарезервованих слів](reserved.md) PHP починається з літери або символу підкреслення і за яким слідує будь-яка кількість букв, цифр або символів підкреслення. Якщо задати ці правила у вигляді регулярного виразу, то вийде таке вираз: `^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$`\n\nКлас може містити власні [константи](language.oop5.constants.md) [змінні](language.oop5.properties.md) (звані властивостями) та функції (звані методами).\n\n**Приклад #1 Просте визначення класу**\n\n```php\n<?php\nclass SimpleClass\n{\n    // объявление свойства\n    public $var = 'значение по умолчанию';\n\n    // объявление метода\n    public function displayVar() {\n        echo $this->var;\n    }\n}\n?>\n```\n\nПсевдозмінна $this доступна в тому випадку, якщо метод був викликаний у контексті об'єкта. $this - значення об'єкта, що викликає.\n\n**Увага**\n\nВиклик нестатичного методу статично викликає помилку [Error](class.error.md). До PHP 8.0.0 це призвело б до повідомлення про старіння, і $this не було б визначено.\n\n**Приклад #2 Деякі приклади псевдо-змінної $this**\n\n```php\n<?php\nclass A\n{\n    function foo()\n    {\n        if (isset($this)) {\n            echo '$this определена (';\n            echo get_class($this);\n            echo \")\\n\";\n        } else {\n            echo \"\\$this не определена.\\n\";\n        }\n    }\n}\n\nclass B\n{\n    function bar()\n    {\n        A::foo();\n    }\n}\n\n$a = new A();\n$a->foo();\n\nA::foo();\n\n$b = new B();\n$b->bar();\n\nB::bar();\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 7:\n\n```\n$this определена (A)\n\nDeprecated: Non-static method A::foo() should not be called statically in %s  on line 27\n$this не определена.\n\nDeprecated: Non-static method A::foo() should not be called statically in %s  on line 20\n$this не определена.\n\nDeprecated: Non-static method B::bar() should not be called statically in %s  on line 32\n\nDeprecated: Non-static method A::foo() should not be called statically in %s  on line 20\n$this не определена.\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\n$this определена (A)\n\nFatal error: Uncaught Error: Non-static method A::foo() cannot be called statically in %s :27\nStack trace:\n#0 {main}\n  thrown in %s  on line 27\n```\n\n#### Класи, доступні лише для читання\n\nПочинаючи з PHP 8.2.0, клас може бути позначений модифікатором readonly. Клас класу як readonly додасть [модифікатор readonly](language.oop5.properties.md#language.oop5.properties.readonly-properties) до кожної оголошеної властивості і запобігатиме створенню [динамічних властивостей](language.oop5.properties.md#language.oop5.properties.dynamic-properties). Більше того, неможливо додати їх підтримку за допомогою атрибуту [AllowDynamicProperties](class.allowdynamicproperties.md). Спроба зробити це призведе до помилки компіляції.\n\n```php\n<?php\n#[\\AllowDynamicProperties]\nreadonly class Foo {\n}\n\n// Fatal error: Cannot apply #[AllowDynamicProperties] to readonly class Foo\n?>\n```\n\nОскільки ні нетипізовані, ні статичні властивості не можуть бути позначені модифікатором `readonly`, класи, доступні тільки для читання також не можуть їх оголошувати:\n\n```php\n<?php\nreadonly class Foo\n{\n    public $bar;\n}\n\n// Fatal error: Readonly property Foo::$bar must have type\n?>\n```\n\n```php\n<?php\nreadonly class Foo\n{\n    public static int $bar;\n}\n\n// Fatal error: Readonly class Foo cannot declare static properties\n?>\n```\n\nКлас readonly може бути [розширено](language.oop5.basic.md#language.oop5.basic.extends) тоді і тільки тоді, коли дочірній клас також є класом readonly.\n\n### new\n\nДля створення екземпляра класу використовується директива `new`. Новий об'єкт завжди буде створений, за винятком випадків, коли він містить [конструктор](language.oop5.decon.md), в якому визначено виклик [винятки](language.exceptions.md) у разі виникнення помилки. Рекомендується визначати класи до створення екземплярів (у деяких випадках це обов'язково).\n\nЯкщо з директивою `new` використовується рядок (string), що містить ім'я класу, буде створено новий екземпляр цього класу. Якщо ім'я знаходиться у просторі імен, воно має бути задано повністю.\n\n> **Зауваження** :\n> \n> У разі відсутності аргументів у конструктор класу круглі дужки після назви класу можна опустити.\n\n**Приклад #3 Створення екземпляра класу**\n\n```php\n<?php\n$instance = new SimpleClass();\n\n// Это же можно сделать с помощью переменной:\n$className = 'SimpleClass';\n$instance = new $className(); // new SimpleClass()\n?>\n```\n\nПочинаючи з PHP 8.0.0, підтримується використання оператора `new` з довільними виразами. Це дозволяє створювати складніші екземпляри, якщо вираз представлений у вигляді рядка (string). Вирази мають бути поміщені у круглі дужки.\n\n**Приклад #4 Створення екземпляра з використанням довільного виразу**\n\nУ цьому прикладі ми показуємо кілька варіантів допустимих довільних виразів, які є ім'ям класу. Приклад виклику функції, конкатенації рядків та константи **`::class`**\n\n```php\n<?php\n\nclass ClassA extends \\stdClass {}\nclass ClassB extends \\stdClass {}\nclass ClassC extends ClassB {}\nclass ClassD extends ClassA {}\n\nfunction getSomeClass(): string\n{\n    return 'ClassA';\n}\n\nvar_dump(new (getSomeClass()));\nvar_dump(new ('Class' . 'B'));\nvar_dump(new ('Class' . 'C'));\nvar_dump(new (ClassD::class));\n?>\n```\n\nРезультат виконання наведеного прикладу в PHP 8:\n\n```\nobject(ClassA)#1 (0) {\n}\nobject(ClassB)#1 (0) {\n}\nobject(ClassC)#1 (0) {\n}\nobject(ClassD)#1 (0) {\n}\n```\n\nУ контексті класу можна створити новий об'єкт через `new self`и`new parent`\n\nКоли відбувається присвоєння вже існуючого екземпляра класу нової змінної, то ця змінна вказуватиме на цей самий екземпляр класу. Те саме відбувається і при передачі екземпляра класу в функцію. Копію вже створеного об'єкта можна створити через неї [клонування](language.oop5.cloning.md)\n\n**Приклад #5 Привласнення об'єкта**\n\n```php\n<?php\n\n$instance = new SimpleClass();\n\n$assigned   =  $instance;\n$reference  =& $instance;\n\n$instance->var = '$assigned будет иметь это значение';\n\n$instance = null; // $instance и $reference становятся null\n\nvar_dump($instance);\nvar_dump($reference);\nvar_dump($assigned);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNULL\nNULL\nobject(SimpleClass)#1 (1) {\n   [\"var\"]=>\n     string(30) \"$assigned будет иметь это значение\"\n}\n```\n\nСтворювати екземпляри об'єкта можна двома способами:\n\n**Приклад #6 Створення нових об'єктів**\n\n```php\n<?php\nclass Test\n{\n    static public function getNew()\n    {\n        return new static;\n    }\n}\n\nclass Child extends Test\n{}\n\n$obj1 = new Test();\n$obj2 = new $obj1;\nvar_dump($obj1 !== $obj2);\n\n$obj3 = Test::getNew();\nvar_dump($obj3 instanceof Test);\n\n$obj4 = Child::getNew();\nvar_dump($obj4 instanceof Child);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nbool(true)\nbool(true)\nbool(true)\n```\n\nЗвернутися до властивості або методу щойно створеного об'єкта можна за допомогою одного виразу:\n\n**Приклад #7 Доступ до властивостей/методів щойно створеного об'єкта**\n\n```php\n<?php\necho (new DateTime())->format('Y');\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n2016\n```\n\n> **Зауваження**: До PHP 7.1 аргументи не мали значення, якщо не визначено функцію конструктора.\n\n### Властивості та методи\n\nВластивості та методи класу живуть у розділених \"просторах імен\", так що можливо мати властивість та метод з одним і тим же ім'ям. Посилання як на властивості, так і на методи мають однакову нотацію, і виходить, що отримаєте ви доступ до властивості або викличе метод - визначається контекстом використання.\n\n**Приклад #8 Доступ до якості vs. виклик методу**\n\n```php\n<?php\nclass Foo\n{\n    public $bar = 'свойство';\n\n    public function bar() {\n        return 'метод';\n    }\n}\n\n$obj = new Foo();\necho $obj->bar, PHP_EOL, $obj->bar(), PHP_EOL;\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nсвойство\nметод\n```\n\nЦе означає, що викликати [анонімну функцію](functions.anonymous.md), Присвоєну змінною, безпосередньо не вийде. Натомість властивість має бути призначена, наприклад, змінною. Можна викликати таку властивість безпосередньо, уклавши її в дужки.\n\n**Приклад #9 Виклик анонімної функції, що міститься у властивості**\n\n```php\n<?php\nclass Foo\n{\n    public $bar;\n\n    public function __construct() {\n        $this->bar = function() {\n            return 42;\n        };\n    }\n}\n\n$obj = new Foo();\n\necho ($obj->bar)(), PHP_EOL;\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n42\n```\n\n### extends\n\nКлас може успадковувати константи, методи та властивості іншого класу, використовуючи ключове слово `extends` у його оголошенні. Неможливо успадковувати кілька класів, один клас може успадковувати лише один базовий клас.\n\nНаслідувані константи, методи та властивості можуть бути перевизначені (за винятком випадків, коли метод або константа класу оголошені як [final](language.oop5.final.md)) шляхом оголошення їх із тими самими іменами, як й у батьківському класі. Існує можливість доступу до перевизначених методів або статичних властивостей шляхом звернення до них через [parent::](language.oop5.paamayim-nekudotayim.md)\n\n> **Зауваження**: Починаючи з PHP 8.1.0, константи можна оголошувати остаточними (final).\n\n**Приклад #10 Просте спадкування класів**\n\n```php\n<?php\nclass ExtendClass extends SimpleClass\n{\n    // Переопределение метода родителя\n    function displayVar()\n    {\n        echo \"Расширенный класс\\n\";\n        parent::displayVar();\n    }\n}\n\n$extended = new ExtendClass();\n$extended->displayVar();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nРасширенный класс\nзначение по умолчанию\n```\n\n#### Правила сумісності сигнатури\n\nПри перевизначенні методу його сигнатура має бути сумісною з батьківським методом. В іншому випадку видається фатальна помилка або, до PHP 8.0.0, генерується помилка рівня **`E_WARNING`**. Сигнатура є сумісною, якщо вона відповідає правилам [контраваріантності](language.oop5.variance.md), робить обов'язковий параметр необов'язковим, додає лише необов'язкові нові параметри та не обмежує, а лише послаблює видимість. Це відомо як принцип підстановки Барбари Лисків або скорочено LSP. Правила сумісності не поширюються на [конструктор](language.oop5.decon.md#language.oop5.decon.constructor)и сигнатуру`private` методів, вони не будуть видавати фатальну помилку у разі невідповідності сигнатури.\n\n**Приклад #11 Сумісність дочірніх методів**\n\n```php\n<?php\n\nclass Base\n{\n    public function foo(int $a) {\n        echo \"Допустимо\\n\";\n    }\n}\n\nclass Extend1 extends Base\n{\n    function foo(int $a = 5)\n    {\n        parent::foo($a);\n    }\n}\n\nclass Extend2 extends Base\n{\n    function foo(int $a, $b = 5)\n    {\n        parent::foo($a);\n    }\n}\n\n$extended1 = new Extend1();\n$extended1->foo();\n$extended2 = new Extend2();\n$extended2->foo(1);\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nДопустимо\nДопустимо\n```\n\nНаступні приклади демонструють, що дочірній метод, який видаляє параметр або робить необов'язковий параметр, несумісний з батьківським методом.\n\n**Приклад #12 Фатальна помилка, коли дочірній метод видаляє параметр**\n\n```php\n<?php\n\nclass Base\n{\n    public function foo(int $a = 5) {\n        echo \"Допустимо\\n\";\n    }\n}\n\nclass Extend extends Base\n{\n    function foo()\n    {\n        parent::foo(1);\n    }\n}\n```\n\nРезультат виконання наведеного прикладу PHP 8 аналогічний:\n\n```\nFatal error: Declaration of Extend::foo() must be compatible with Base::foo(int $a = 5) in /in/evtlq on line 13\n```\n\n**Приклад #13 Фатальна помилка, коли дочірній метод робить необов'язковим параметром.**\n\n```php\n<?php\n\nclass Base\n{\n    public function foo(int $a = 5) {\n        echo \"Допустимо\\n\";\n    }\n}\n\nclass Extend extends Base\n{\n    function foo(int $a)\n    {\n        parent::foo($a);\n    }\n}\n```\n\nРезультат виконання наведеного прикладу PHP 8 аналогічний:\n\n```\nFatal error: Declaration of Extend::foo(int $a) must be compatible with Base::foo(int $a = 5) in /in/qJXVC on line 13\n```\n\n**Увага**\n\nПерейменування параметра методу дочірньому класі перестав бути несумісністю сигнатури. Однак це не рекомендується, оскільки призведе до [Error](class.error.md) під час виконання, якщо використовуються [іменовані аргументи](functions.arguments.md#functions.named-arguments)\n\n**Приклад #14 Помилка використання іменованих аргументів і параметрів, перейменованих у дочірньому класі**\n\n```php\n<?php\n\nclass A {\n    public function test($foo, $bar) {}\n}\n\nclass B extends A {\n    public function test($a, $b) {}\n}\n\n$obj = new B;\n\n// Передача параметров согласно контракту A::test()\n$obj->test(foo: \"foo\", bar: \"bar\"); // ОШИБКА!\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nFatal error: Uncaught Error: Unknown named parameter $foo in /in/XaaeN:14\nStack trace:\n#0 {main}\n  thrown in /in/XaaeN on line 14\n```\n\n### ::class\n\nКлючевое слово`class` використовується для дозволу імені класу. Щоб отримати повне ім'я класу `ClassName`, используйте`ClassName::class`. Зазвичай це досить корисно під час роботи з класами, які використовують [простору імен](language.namespaces.md)\n\n**Приклад #15 Дозвіл імені класу**\n\n```php\n<?php\nnamespace NS {\n    class ClassName {\n    }\n\n    echo ClassName::class;\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNS\\ClassName\n```\n\n> **Зауваження** :\n> \n> Дозвіл імен класу з використанням `::class` відбувається на етапі компіляції. Це означає, що на момент створення рядка з ім'ям класу автозавантаження не відбувається. Як наслідок, імена класів розкриваються навіть якщо клас не існує. Помилка у разі не видається.\n> \n> **Приклад #16 Відсутня роздільна здатність імені класу**\n> \n> ```php\n> <?php\n> print Does\\Not\\Exist::class;\n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> Does\\Not\\Exist\n> ```\n\nНачиная с PHP 8.0.0, константа`::class` також може використовуватись для об'єктів. Цей дозвіл відбувається під час виконання, а чи не під час компіляції. Те саме, що і при виклику [get\\_class()](function.get-class.md) для об'єкту.\n\n**Приклад #17 Роздільна здатність імені об'єкта**\n\n```php\n<?php\nnamespace NS {\n    class ClassName {\n    }\n}\n$c = new ClassName();\nprint $c::class;\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNS\\ClassName\n```\n\n### Методи та властивості Nullsafe\n\nПочинаючи з PHP 8.0.0, до властивостей та методів можна також звертатися за допомогою оператора \"nullsafe\": `?->`. Оператор nullsafe працює так само, як доступ до властивості або методу, як зазначено вище, за винятком того, що якщо розйменування об'єкта видає **`null`**, то буде повернутий **`null`**, а не викинуто виняток. Якщо розіменування є частиною ланцюжка, решта ланцюжка пропускається.\n\nАналогічно висновку кожного звернення до [is\\_null()](function.is-null.md), але компактніший.\n\n**Приклад #18 Оператор Nullsafe**\n\n```php\n<?php\n\n// Начиная с PHP 8.0.0, эта строка:\n$result = $repository?->getUser(5)?->name;\n\n// Эквивалентна следующему блоку кода:\nif (is_null($repository)) {\n    $result = null;\n} else {\n    $user = $repository->getUser(5);\n    if (is_null($user)) {\n        $result = null;\n    } else {\n        $result = $user->name;\n    }\n}\n?>\n```\n\n> **Зауваження** :\n> \n> Оператор nullsafe найкраще використовувати, коли null вважається допустимим і очікуваним значенням для властивості або методу, що повертається. Для індикації помилки краще викидати виняток.\n","title":"Основи","contentType":2,"navigation":[{"oop5.intro.md":"\" Вступ"},{"language.oop5.properties.md":"Властивості »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}