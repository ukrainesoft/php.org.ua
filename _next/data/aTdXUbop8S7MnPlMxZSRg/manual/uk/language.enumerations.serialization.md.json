{"pageProps":{"page":{"slug":"language.enumerations.serialization.md","content":"## Серіалізація\n\nПерерахування серіалізуються інакше, ніж об'єкти. Зокрема, у перерахувань є новий код серіалізації. `«E»`, Що вказує ім'я варіанта перерахування. Потім цей ідентифікатор буде доступний процедурі десеріалізації, щоб встановити змінну існуюче одноелементне значення. Це гарантує, що:\n\n```php\n<?php\n\nSuit::Hearts === unserialize(serialize(Suit::Hearts));\n\nprint serialize(Suit::Hearts);\n// E:11:\"Suit:Hearts\";\n?>\n```\n\nЯкщо при десеріалізації перерахування та варіант не будуть знайдені для порівняння серіалізованому значенню, буде видано попередження та повернуто **`false`**\n\nЯкщо чистий перелік серіалізується в JSON, буде видано помилку. Якщо типізований перелік серіалізується в JSON, він буде представлений лише його скалярним значенням типу, заданого у перерахуванні. Щоб перевизначити поведінку цих способів, реалізують інтерфейс [JsonSerializable](class.jsonserializable.md)\n\nДля функції [print\\_r()](function.print-r.md) висновок варіанта перерахування трохи відрізняється від об'єктів, щоб зменшити плутанину.\n\n```php\n<?php\n\nenum Foo {\n    case Bar;\n}\n\nenum Baz: int {\n    case Beep = 5;\n}\n\nprint_r(Foo::Bar);\nprint_r(Baz::Beep);\n\n/* Выводит\n\nFoo Enum (\n    [name] => Bar\n)\nBaz Enum:int {\n    [name] => Beep\n    [value] => 5\n}\n*/\n?>\n```\n","title":"Серіалізація","contentType":2,"navigation":[{"language.enumerations.listing.md":"« Список значень"},{"language.enumerations.object-differences.inheritance.md":"Чому перерахування не розширюються »"},{"index.md":"PHP Manual"},{"language.enumerations.md":"Перерахування"}]}},"__N_SSG":true}