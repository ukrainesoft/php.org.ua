{"pageProps":{"page":{"slug":"functions.first_class_callable_syntax.md","content":"## Callback-функції як об'єкти першого класу\n\nCallback-функції як об'єкти першого класу представлені в PHP 8.1.0 як спосіб створення [анонімних функцій](functions.anonymous.md)из[callback-функцій](language.types.callable.md). Синтаксис замінює існуючий синтаксис виклику з використанням рядків та масивів. Перевага синтаксису полягає в тому, що він доступний для статичного аналізу та використовує область видимості у точці, де отримана callback-функція.\n\nСинтаксис`CallableExpr(...)` використовується для створення об'єкта [Closure](class.closure.md)из callback-функции`CallableExpr` приймає будь-який вираз, який може бути викликаний безпосередньо в граматиці PHP:\n\n**Приклад #1 Простий приклад callback функції як об'єкти першого класу**\n\n```php\n<?php\nclass Foo {\n   public function method() {}\n   public static function staticmethod() {}\n   public function __invoke() {}\n}\n$obj = new Foo();\n$classStr = 'Foo';\n$methodStr = 'method';\n$staticmethodStr = 'staticmethod';\n$f1 = strlen(...);\n$f2 = $obj(...);  // вызываемый объект\n$f3 = $obj->method(...);\n$f4 = $obj->$methodStr(...);\n$f5 = Foo::staticmethod(...);\n$f6 = $classStr::$staticmethodStr(...);\n// традиционная callback-функция с использованием строки, массива\n$f7 = 'strlen'(...);\n$f8 = [$obj, 'method'](...);\n$f9 = [Foo::class, 'staticmethod'](...);\n?>\n```\n\n> **Зауваження** :\n> \n> `...`является частью синтаксиса, а не пропуском.\n\nУ`CallableExpr(...)` та ж семантика, що й у [Closure::fromCallable()](closure.fromcallable.md). Тобто, на відміну від callback-функції з використанням рядків та масивів, `CallableExpr(...)` враховує область видимості у точці, де вона створюється:\n\n**Приклад #2 Сравнение области действия`CallableExpr(...)` та традиційної callback-функції**\n\n```php\n<?php\nclass Foo {\n    public function getPrivateMethod() {\n        return [$this, 'privateMethod'];\n    }\n    private function privateMethod() {\n        echo __METHOD__, \"\\n\";\n    }\n}\n$foo = new Foo;\n$privateMethod = $foo->getPrivateMethod();\n$privateMethod();\n// Fatal error: Call to private method Foo::privateMethod() from global scope\n// Это потому, что вызов выполняется вне Foo, и с этого момента будет проверяться видимость.\nclass Foo1 {\n    public function getPrivateMethod() {\n        // Использует область, в которой получена callback-функция.\n        return $this->privateMethod(...); // идентично Closure::fromCallable([$this, 'privateMethod']);\n    }\n    private function privateMethod() {\n        echo __METHOD__, \"\\n\";\n    }\n}\n$foo1 = new Foo1;\n$privateMethod = $foo1->getPrivateMethod();\n$privateMethod();  // Foo1::privateMethod\n?>\n```\n\n> **Зауваження** :\n> \n> Створення об'єкта за допомогою цього синтаксису (наприклад, `new Foo(...)`) не підтримується, оскільки синтаксис `new Foo()` не вважається callback-функцією.\n\n> **Зауваження** :\n> \n> Callback-функції як об'єкти першого класу не можна комбінувати з [оператором Nullsafe](language.oop5.basic.md#language.oop5.basic.nullsafe)Оба следующих результата приводят к ошибке времени компиляции:\n> \n> ```php\n> <?php\n> $obj?->method(...);\n> $obj?->prop->method(...);\n> ?>\n> ```\n","title":"Callback-функції як об'єкти першого класу","contentType":2,"navigation":[{"functions.arrow.md":"« Стрілкові функції"},{"language.oop5.md":"Класи та об'єкти »"},{"index.md":"PHP Manual"},{"language.functions.md":"Функції"}]}},"__N_SSG":true}