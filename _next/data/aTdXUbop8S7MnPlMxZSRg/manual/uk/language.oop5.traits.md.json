{"pageProps":{"page":{"slug":"language.oop5.traits.md","content":"## Трейти\n\nPHP реалізує спосіб перевикористання коду, званий трейтами (Traits).\n\nТрейт - це механізм перевикористання коду в мовах з підтримкою поодинокого успадкування, до яких належить PHP. Завдання трейту - зменшити обмеження одиночного успадкування, дозволяючи розробнику легко перевикористовувати набори методів у кількох незалежних класах, що у різних ієрархіях класів. Семантика комбінації трейтів та класів визначена так, щоб знизити рівень складності, а також уникнути типових проблем, властивих множинному спадкуванню та домішкам (Mixins).\n\nТрейт дуже схожий на клас, але розрахований лише на угруповання функціональності тонко контрольованим та узгодженим чином. Не можна створити окремий примірник трейту. Трейт — це доповнення до звичайного успадкування та інструмент побудови горизонтальної композиції поведінки, тобто роботи з членами класу (трейту) без вимоги успадкування.\n\n**Приклад #1 Приклад використання трейту**\n\n```php\n<?php\ntrait ezcReflectionReturnInfo {\n    function getReturnType() { /*1*/ }\n    function getReturnDescription() { /*2*/ }\n}\n\nclass ezcReflectionMethod extends ReflectionMethod {\n    use ezcReflectionReturnInfo;\n    /* ... */\n}\n\nclass ezcReflectionFunction extends ReflectionFunction {\n    use ezcReflectionReturnInfo;\n    /* ... */\n}\n?>\n```\n\n### Пріоритет\n\nЧлен, успадкований із базового класу, перевизначається членом, введеним трейтом. Порядок пріоритету наступний: члени поточного класу перевизначають методи трейту, які зі свого боку перевизначають успадковані методи.\n\n**Приклад #2 Приклад пріоритету старшинства**\n\nСпадкований від базового класу метод перевизначається методом, доданим у клас MyHelloWorld із трейту SayWorld. Поведінка методів трейту повторює поведінку методів класу MyHelloWorld. Порядок пріоритету такий: методи поточного класу перевизначають методи трейту, які зі свого боку перевизначають методи базового класу.\n\n```php\n<?php\nclass Base {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n\ntrait SayWorld {\n    public function sayHello() {\n        parent::sayHello();\n        echo 'World!';\n    }\n}\n\nclass MyHelloWorld extends Base {\n    use SayWorld;\n}\n\n$o = new MyHelloWorld();\n$o->sayHello();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHello World!\n```\n\n**Приклад #3 Приклад альтернативного порядку пріоритету**\n\n```php\n<?php\ntrait HelloWorld {\n    public function sayHello() {\n        echo 'Hello World!';\n    }\n}\n\nclass TheWorldIsNotEnough {\n    use HelloWorld;\n    public function sayHello() {\n        echo 'Hello Universe!';\n    }\n}\n\n$o = new TheWorldIsNotEnough();\n$o->sayHello();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHello Universe!\n```\n\n### Декілька трейтів\n\nДо класу можна додати кілька трейтів, перерахувавши їх у директиві `use`через запятую.\n\n**Приклад #4 Приклад використання кількох трейтів**\n\n```php\n<?php\ntrait Hello {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n\ntrait World {\n    public function sayWorld() {\n        echo 'World';\n    }\n}\n\nclass MyHelloWorld {\n    use Hello, World;\n    public function sayExclamationMark() {\n        echo '!';\n    }\n}\n\n$o = new MyHelloWorld();\n$o->sayHello();\n$o->sayWorld();\n$o->sayExclamationMark();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHello World!\n```\n\n### Вирішення конфліктів\n\nЯкщо два трейти додають метод з тим самим ім'ям, буде викликана фатальна помилка, якщо конфлікт явно не вирішений.\n\nДля вирішення конфліктів іменування між трейтами, включеними в той самий клас, викликають оператор `insteadof`, щоб точно вибрати один із конфліктуючих методів.\n\nОскільки попередній оператор тільки виключає методи, оператор `as` може включити один із конфліктуючих методів під іншим ім'ям. Зверніть увагу, що оператор `as` не перейменовує метод, а також не впливає на будь-який інший метод.\n\n**Приклад #5 Приклад вирішення конфліктів**\n\nУ цьому прикладі клас Talker включені трейти A і B. Оскільки в трейтах A і B є конфліктуючі методи, клас використовує варіант методу smallTalk з трейту B, а варіант методу bigTalk — з трейту A.\n\nКлас Aliased\\_Talker застосовує оператор `as`, щоб використати реалізацію методу bigTalk із класу B під додатковим псевдонімом `talk`\n\n```php\n<?php\ntrait A {\n    public function smallTalk() {\n        echo 'a';\n    }\n    public function bigTalk() {\n        echo 'A';\n    }\n}\n\ntrait B {\n    public function smallTalk() {\n        echo 'b';\n    }\n    public function bigTalk() {\n        echo 'B';\n    }\n}\n\nclass Talker {\n    use A, B {\n        B::smallTalk insteadof A;\n        A::bigTalk insteadof B;\n    }\n}\n\nclass Aliased_Talker {\n    use A, B {\n        B::smallTalk insteadof A;\n        A::bigTalk insteadof B;\n        B::bigTalk as talk;\n    }\n}\n?>\n```\n\n### Зміна видимості методу\n\nПрименяя оператор`as`, можна також змінити видимість методу у класі, до якого включено трейт.\n\n**Приклад #6 Приклад зміни видимості методу**\n\n```php\n<?php\ntrait HelloWorld {\n    public function sayHello() {\n        echo 'Hello World!';\n    }\n}\n\n// Изменение видимости метода sayHello\nclass MyClass1 {\n    use HelloWorld { sayHello as protected; }\n}\n\n// Создание псевдонима метода с изменённой видимостью\n// видимость sayHello не изменилась\nclass MyClass2 {\n    use HelloWorld { sayHello as private myPrivateHello; }\n}\n?>\n```\n\n### Трейти, що складаються з трейтів\n\nТрейти можна включати і до класів, і до інших трейтів. Трейт може бути повністю або частково складений із членів, описаних в інших трейтах, один або кілька з яких включені до визначення трейту.\n\n**Приклад #7 Приклад трейтів, що складаються з трейтів**\n\n```php\n<?php\ntrait Hello {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n\ntrait World {\n    public function sayWorld() {\n        echo 'World!';\n    }\n}\n\ntrait HelloWorld {\n    use Hello, World;\n}\n\nclass MyHelloWorld {\n    use HelloWorld;\n}\n\n$o = new MyHelloWorld();\n$o->sayHello();\n$o->sayWorld();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHello World!\n```\n\n### Абстрактні члени трейтів\n\nТрейти підтримують абстрактні методи, щоб встановити вимоги до класу, до якого буде включено трейт. Підтримуються загальнодоступні, захищені та закриті методи. До PHP 8.0.0 підтримувалися лише загальнодоступні та захищені абстрактні методи.\n\n**Застереження**\n\nНачиная с PHP 8.0.0 сигнатура конкретного метода должна следовать[правилам сумісності сигнатур](language.oop5.basic.md#language.oop.lsp)Ранее сигнатура метода могла несовпадать.\n\n**Приклад #8 Вимоги трейту за допомогою абстрактних методів**\n\n```php\n<?php\ntrait Hello {\n    public function sayHelloWorld() {\n        echo 'Hello'.$this->getWorld();\n    }\n    abstract public function getWorld();\n}\n\nclass MyHelloWorld {\n    private $world;\n    use Hello;\n    public function getWorld() {\n        return $this->world;\n    }\n    public function setWorld($val) {\n        $this->world = $val;\n    }\n}\n?>\n```\n\n### Статичні члени трейту\n\nУ трейтах можна визначати статичні змінні, статичні методи та статичні властивості.\n\n> **Зауваження** :\n> \n> Починаючи з PHP 8.1.0 прямий виклик статичного методу або прямий доступ до статичної властивості у трейті застарілий. До статичних методів і властивостей потрібно звертатися лише у класі, до якого включено трейт.\n\n**Приклад #9 Статичні змінні**\n\n```php\n<?php\ntrait Counter {\n    public function inc() {\n        static $c = 0;\n        $c = $c + 1;\n        echo \"$c\\n\";\n    }\n}\n\nclass C1 {\n    use Counter;\n}\n\nclass C2 {\n    use Counter;\n}\n\n$o = new C1(); $o->inc(); // echo 1\n$p = new C2(); $p->inc(); // echo 1\n?>\n```\n\n**Приклад #10 Статичні методи**\n\n```php\n<?php\ntrait StaticExample {\n    public static function doSomething() {\n        echo 'Что-либо делаем';\n    }\n}\n\nclass Example {\n    use StaticExample;\n}\n\nExample::doSomething();\n?>\n```\n\n**Приклад #11 Статичні властивості**\n\n```php\n<?php\ntrait StaticExample {\n    public static $static = 'foo';\n}\nclass Example {\n    use StaticExample;\n}\necho Example::$static;\n?>\n```\n\n### Властивості\n\nТрейти також можуть визначати властивості.\n\n**Приклад #12 Визначення властивостей**\n\n```php\n<?php\ntrait PropertiesTrait {\n    public $x = 1;\n}\n\nclass PropertiesExample {\n    use PropertiesTrait;\n}\n\n$example = new PropertiesExample;\n$example->x;\n?>\n```\n\nЯкщо трейт визначає властивість, то клас не може визначити властивість з таким самим ім'ям, крім випадків повного збігу (та сама область видимості і тип, модифікатор readonly і початкове значення), інакше буде викинуто фатальну помилку.\n\n**Приклад #13 Вирішення конфліктів**\n\n```php\n<?php\ntrait PropertiesTrait {\n    public $same = true;\n    public $different1 = false;\n    public bool $different2;\n    public bool $different3;\n}\n\nclass PropertiesExample {\n    use PropertiesTrait;\n    public $same = true;\n    public $different1 = true; // Фатальная ошибка\n    public string $different2; // Фатальная ошибка\n    readonly protected bool $different3; // Фатальная ошибка\n}\n?>\n```\n\n### Константи\n\nПочинаючи з версії PHP 8.2.0, трейти можуть також визначати константи.\n\n**Приклад #14 Визначення констант**\n\n```php\n<?php\ntrait ConstantsTrait {\n    public const FLAG_MUTABLE = 1;\n    final public const FLAG_IMMUTABLE = 5;\n}\n\nclass ConstantsExample {\n    use ConstantsTrait;\n}\n\n$example = new ConstantsExample;\necho $example::FLAG_MUTABLE; // 1\n?>\n```\n\nЯкщо трейт визначає константу, то клас не може визначити константу з таким же ім'ям, якщо вони не сумісні (однакова область видимості, початкове значення і модифікатор final), інакше викидається фатальна помилка.\n\n**Приклад #15 Вирішення конфліктів**\n\n```php\n<?php\ntrait ConstantsTrait {\n    public const FLAG_MUTABLE = 1;\n    final public const FLAG_IMMUTABLE = 5;\n}\n\nclass ConstantsExample {\n    use ConstantsTrait;\n    public const FLAG_IMMUTABLE = 5; // Фатальная ошибка\n}\n?>\n```\n","title":"Трейти","contentType":2,"navigation":[{"language.oop5.interfaces.md":"« Інтерфейси об'єктів"},{"language.oop5.anonymous.md":"Анонімні класи »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}