{"pageProps":{"page":{"slug":"language.types.type-juggling.md","content":"## Маніпуляції з типами\n\nPHP не вимагає явного визначення типу при оголошенні змінної. Якщо тип змінної не вказано, він буде визначений значенням, яке вона зберігає. Тобто, якщо змінною $var присвоюється значення типу рядок (string), $var змінить тип на рядок (string). Якщо після цього змінної $var буде присвоєно значення типу ціле число (int), вона змінить тип на ціле число (int).\n\nУ ряді контекстів PHP може спробувати автоматично перетворити тип значення на інший. Існуючі контексти:\n\n-   Числовий\n-   Рядковий\n-   Логічний\n-   Контекст цілих чисел та рядків\n-   Порівняльний\n-   Контекст функцій\n\n> **Зауваження**: Коли значення потрібно інтерпретувати як інший тип, саме значення *не*меняет тип.\n\nПро те, як примусово встановити тип змінної, розказано у розділі «[Приведення типу](language.types.type-juggling.md#language.types.typecasting)». Про те, як змінити тип змінної, описано в описі функції [settype()](function.settype.md)\n\n### Числовий контекст\n\nЧисловий контекст виникає під час роботи з [арифметичними операторами](language.operators.arithmetic.md)\n\nУ цьому контексті, якщо один з операндів - число з плаваючою точкою (float) (або не інтерпретується як ціле число (int)), обидва операнда інтерпретуються як число з плаваючою точкою (float) і результатом буде число з плаваючою точкою (float). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результатом також буде ціле число (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, викидається виняток [TypeError](class.typeerror.md)\n\n### Рядковий контекст\n\nРядковий контекст виникає під час роботи з мовними конструкціями [echo](function.echo.md) [print](function.print.md), при[інтерполяції рядків](language.types.string.md#language.types.string.parsing)или строковом[оператора конкатенації](language.operators.string.md)\n\nУ цьому контексті значення інтерпретуватиметься як рядок (string). Якщо значення не може бути інтерпретовано, викидається виняток [TypeError](class.typeerror.md). До версії PHP 7.4.0 видавалася помилка рівня **`E_RECOVERABLE_ERROR`**\n\n### Логічний контекст\n\nЛогічний контекст виникає під час роботи з умовними операторами, [тернарним оператором](language.operators.comparison.md#language.operators.comparison.ternary) або [логічним оператором](language.operators.logical.md)\n\nУ цьому контексті значення інтерпретуватиметься як логічне значення (bool).\n\n### Контекст цілих чисел та рядків\n\nКонтекст цілих чисел і рядків виникає під час роботи з [побітовими операторами](language.operators.bitwise.md)\n\nУ цьому контексті, якщо у всіх операндів є тип рядка (string), результат також буде рядком (string). В іншому випадку операнди будуть інтерпретовані як ціле число (int) і результат також буде цілим числом (int). Починаючи з PHP 8.0.0, якщо один із операндів не може бути інтерпретований, то буде викинуто виняток [TypeError](class.typeerror.md)\n\n### Порівняльний контекст\n\nПорівняльний контекст виникає при роботі з [операторами порівняння](language.operators.comparison.md)\n\nПеретворення типів, що відбуваються в цьому контексті, пояснено у [таблиці порівняння типів](language.operators.comparison.md#language.operators.comparison.types) розділу \"Оператори порівняння\".\n\n### Контекст функцій\n\nКонтекст функцій виникає, коли значення передається типізованим параметром, властивістю або повертається з функції, в якій оголошено тип значення, що повертається.\n\nУ цьому контексті значення має бути значенням типу. Є два винятки, перше: якщо тип значення - ціле число (int), а оголошений тип - число з плаваючою точкою (float), то ціле число перетворюється на число з плаваючою точкою. Другий: якщо оголошений тип – це *скалярний* тип, значення перетворюється на скалярний тип і режим суворої типізації активний (за замовчуванням), значення може бути перетворено на допустиме скалярне значення. Опис такої поведінки наведено нижче.\n\n**Увага**\n\n[Вбудовані функції](functions.internal.md) автоматично підставляють **`null`** до скалярних типів, це поведінка *ЗАСТАРІЛО*с PHP 8.1.0.\n\n#### Примусова типізація із простим оголошенням типів\n\n-   Оголошення типу bool: значення інтерпретується як логічне значення (bool).\n-   Оголошення типу int: значення інтерпретується як ціле число (int), якщо перетворення надійно визначене. Наприклад, коли рядок[числовий рядок](language.types.numeric-strings.md)\n-   Оголошення типу float: значення інтерпретується як число з плаваючою точкою (float), якщо перетворення надійно визначене. Наприклад, коли рядок[числовий рядок](language.types.numeric-strings.md)\n-   Оголошення типу string: значення інтерпретується як рядок (string).\n\n#### Примусова типізація з поєднанням типів\n\nКогда директива`strict_types` не ввімкнено, оголошення скалярних типів підлягають обмеженому неявному наведенню типів. Якщо точний тип значення – не частина об'єднання, то цільовий тип вибраний зі списку в порядку зменшення пріоритету:\n\n1.  int\n2.  float\n3.  string\n4.  bool\n\nЯкщо тип і існує в об'єднанні та значення може бути приведено до цього типу відповідно до існуючої семантики перевірки типів PHP, то PHP вибирає цей тип. В іншому випадку буде вибрано наступний тип.\n\n**Застереження**\n\nЯк виняток, якщо значення — рядок, а ціле число (int) і число з точкою (float) — це частина об'єднання, переважний тип буде визначений існуючою семантикою [числового рядка](language.types.numeric-strings.md)НаПриклад, для`«42»` PHP вибирає ціле число (int), а для `«42.0»` - Число з плаваючою точкою (float).\n\n> **Зауваження** :\n> \n> Типи, які не входять до списку переваг, не стануть метою для неявного приведення. Говорячи конкретніше, ніякого неявного приведення до типів null, false і true не буде.\n\n**Приклад #1 Приклад примусового включення типів до об'єднання**\n\n```php\n<?php\n\n// int|string\n42    --> 42          // точный тип\n\"42\"  --> \"42\"        // точный тип\nnew ObjectWithToString --> \"Результат __toString()\"\n                      // объект не совместим с int, переход к string\n42.0  --> 42          // float совместимый с int\n42.1  --> 42          // float совместимый с int\n1e100 --> \"1.0E+100\"  // float слишком велик для типа int, переход к string\nINF   --> \"INF\"       // float слишком велик для типа int, переход к string\ntrue  --> 1           // bool совместимый с int\n[]    --> TypeError   // массив не совместим с int или string\n\n// int|float|bool\n\"45\"    --> 45        // int числовая строка\n\"45.0\"  --> 45.0      // float числовая строка\n\n\"45X\"   --> true      // не числовая строка, переход к bool\n\"\"      --> false     // не числовая строка, переход к bool\n\"X\"     --> true      // не числовая строка, переход к bool\n[]      --> TypeError // массив не совместимый с int, float или bool\n?>\n```\n\n### Приведення типів\n\nПриведення типу перетворює значення до вибраного типу, записуючи тип у круглих дужках перед значенням, що перетворюється.\n\n```php\n<?php\n\n$foo = 10;   // $foo — это целое число\n$bar = (bool) $foo;   // $bar — это логическое значение\n?>\n```\n\nДозволено такі типи:\n\n-   `(int)`\\- Приведення типу до цілого числа (int)\n-   `(bool)`\\- Приведення типу до логічного значення (bool)\n-   `(float)`— приведення типу до плаваючої точки (float)\n-   `(string)`\\- Приведення типу до рядка (string)\n-   `(array)`\\- Приведення типу до масиву (array)\n-   `(object)`\\- Приведення типу до об'єкта (object)\n-   `(unset)`\\- Приведення типу до NULL\n\n> **Зауваження** :\n> \n> `(integer)`— псевдоним приведения типа`(int)`. . `(boolean)`— псевдоним приведения типа`(bool)`. . `(binary)`— псевдоним приведения типа`(string)`. . `(double)`и`(real)` - псевдоніми приведення типу `(float)`. Ці наведення не використовують канонічне ім'я типу і не рекомендуються.\n\n**Увага**\n\nПсевдоним приведения типа`(real)`устарел с PHP 8.0.0.\n\n**Увага**\n\nПриведение типа`(unset)`устарело с версии PHP 7.2.0. Обратите внимание, что приведение`(unset)` рівносильно присвоєння змінної або виклику значення NULL. Приведення `(unset)`удалено в PHP 8.0.0.\n\n**Застереження**\n\nПриведение типа`(binary)`и префикс`b` є для прямої підтримки. Типи `(binary)`и`(string)` ідентичні, однак, це може змінитись, не потрібно на це покладатися.\n\n> **Зауваження** :\n> \n> PHP ігнорує прогалини у круглих дужках при наведенні типу. Тому такі два приведення типів еквівалентні:\n> \n> ```php\n> <?php\n> \n> $foo = (int) $bar;\n> $foo = ( int ) $bar;\n> ?>\n> ```\n\nПриведення рядків (string) та змінних до бінарних рядків (string):\n\n```php\n<?php\n\n$binary = (binary) $string;\n$binary = b\"binary string\";\n?>\n```\n\n> **Зауваження**: Замість приведення змінної до типу рядок (string) можна також укласти змінну подвійні лапки.\n> \n> ```php\n> <?php\n> \n> $ foo = 10; // $foo - ціле число\n> $str = \"$foo\"; // $str - рядок\n> $fst = (string) $foo; // $fst теж рядок\n> \n> // Виводить, що «вони однакові»\n> if ($fst === $str) {\n>     echo \"вони однакові\";\n> }\n> ?>\n> ```\n\nМожливо, очевидно, що станеться при перетворенні між різними типами. Отримати додаткову інформацію можна у розділах:\n\n-   [Перетворення типу до логічного значення (boolean)](language.types.boolean.md#language.types.boolean.casting)\n-   [Перетворення типу до цілого числа (integer)](language.types.integer.md#language.types.integer.casting)\n-   [Перетворення типу до плаваючої точки (float)](language.types.float.md#language.types.float.casting)\n-   [Перетворення типу до рядка (string)](language.types.string.md#language.types.string.casting)\n-   [Перетворення типу до масиву (array)](language.types.array.md#language.types.array.casting)\n-   [Перетворення типу на об'єкт (object)](language.types.object.md#language.types.object.casting)\n-   [Перетворення типу ресурсу (resource)](language.types.resource.md#language.types.resource.casting)\n-   [Перетворення типу на NULL](language.types.null.md#language.types.null.casting)\n-   [Таблиці порівняння типів](types.comparisons.md)\n\n> **Зауваження**: Оскільки PHP підтримує індексацію в рядках (string) через усунення, використовуючи той же синтаксис, що і індексація в масивах (array), наступний приклад справедливий для всіх версій PHP:\n> \n> ```php\n> <?php\n> \n> $a = 'car'; // $a - рядок\n> $a[0] = 'b'; // $a, як і раніше, рядок\n> echo $a; // bar\n> ?>\n> ```\n> \n> Додаткову інформацію можна знайти в розділі «[Доступ до символу в рядку та його зміна](language.types.string.md#language.types.string.substr)».\n","title":"Маніпуляції з типами","contentType":2,"navigation":[{"language.types.declarations.md":"« Оголошення типів"},{"language.variables.md":"Змінні »"},{"index.md":"PHP Manual"},{"language.types.md":"Типи"}]}},"__N_SSG":true}