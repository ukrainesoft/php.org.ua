{"pageProps":{"page":{"slug":"function.pcntl-signal.md","content":"# pcntl\\_signal\n\n(PHP 4 >= 4.1.0, PHP 5, PHP 7, PHP 8)\n\npcntl\\_signal — Встановлення обробника сигналу\n\n### Опис\n\n```methodsynopsis\npcntl_signal(int $signal, callable|int $handler, bool $restart_syscalls = true): bool\n```\n\nФункция**pcntl\\_signal()** встановлює новий оброблювач сигналу або замінює поточний оброблювач сигналу, вказаний у аргументі `signal`\n\n### Список параметрів\n\n`signal`\n\nНомер сигналу.\n\n`handler`\n\nОброблювач сигналу. Це може бути або [callable](language.types.callable.md), покажчик на функцію, яка буде запущена для обробки сигналу, або значення однієї з глобальних констант: **`SIG_IGN`** або **`SIG_DFL`**, які, відповідно, або призведуть до ігнорування сигналу або відновлення оброблювача за замовчуванням.\n\nЕсли передан тип[callable](language.types.callable.md), він повинен мати таку сигнатуру:\n\n```methodsynopsis\nhandler(int $signo, mixed $siginfo): void\n```\n\n`signal`\n\nНомер сигналу, що обробляється.\n\n`siginfo`\n\nЯкщо операційна система підтримує структури siginfo\\_t, можна передати масив з інформацією про сигнал відповідної структури.\n\n> **Зауваження** :\n> \n> Зверніть увагу, що коли ви задаєте як обробник метод об'єкта, лічильник посилань на цей об'єкт буде збільшений на одиницю, що збереже його в пам'яті доти, поки ви або не зміните обробник на щось інше, або до тих пір, поки скрипт повністю не завершить своєї роботи.\n\n`restart_syscalls`\n\nВизначає, чи потрібно використовувати перезапуск системного виклику під час надходження сигналу.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.1.0 | Починаючи з PHP 7.1.0 обробнику callback-функції передається другий аргумент, що містить структуру siginfo певного сигналу. Ці дані будуть передані лише в тому випадку, якщо операційна система підтримує структури siginfo\\_t. Якщо в операційній системі не реалізовано підтримку структури siginfo\\_t, то як другий аргумент буде переданий NULL. |\n\n### Приклади\n\n**Приклад #1 Приклад використання** pcntl\\_signal()\\*\\*\\*\\*\n\n```php\n<?php\n// Обязательно\ndeclare(ticks = 1);\n\n// функция обработки сигнала\nfunction sig_handler($signo)\n{\n\n     switch ($signo) {\n         case SIGTERM:\n             // Обработка задач остановки\n             exit;\n             break;\n         case SIGHUP:\n             // обработка задач перезапуска\n             break;\n         case SIGUSR1:\n             echo \"Получен сигнал SIGUSR1...\\n\";\n             break;\n         default:\n             // Обработка других сигналов\n     }\n\n}\n\necho \"Установка обработчиков сигналов...\\n\";\n\n// Установка обработчиков сигналов\npcntl_signal(SIGTERM, \"sig_handler\");\npcntl_signal(SIGHUP,  \"sig_handler\");\npcntl_signal(SIGUSR1, \"sig_handler\");\n\n// или можете использовать объект\n// pcntl_signal(SIGUSR1, array($obj, \"do_something\"));\n\necho \"Отправка сигнала SIGUSR1 себе...\\n\";\n\n// Отправка SIGUSR1 процессу с текущим id (т.е. себе)\n// для использования функций posix_* требуется модуль posix\nposix_kill(posix_getpid(), SIGUSR1);\n\necho \"Завершено\\n\";\n\n?>\n```\n\n### Примітки\n\n**pcntl\\_signal()** не збирає обробники сигналів у стек, а замінює їх.\n\n### Дивіться також\n\n-   [pcntl\\_fork()](function.pcntl-fork.md) \\- Розгалужити (fork) поточний запущений процес\n-   [pcntl\\_waitpid()](function.pcntl-waitpid.md) \\- Очікує чи повертає статус породженого дочірнього процесу\n","title":"pcntl\\_signal","contentType":2,"navigation":[{"function.pcntl-signal-get-handler.md":"« pcntl\\_signal\\_get\\_handler"},{"function.pcntl-sigprocmask.md":"pcntl\\_sigprocmask »"},{"index.md":"PHP Manual"},{"ref.pcntl.md":"Функції PCNTL"}]}},"__N_SSG":true}