- [« Функції зворотного виклику
(callback-функції)] (language.types.callable.md)
- [Маніпуляції з типами »](language.types.type-juggling.md)

- [PHP Manual](index.md)
- [Типи](language.types.md)
- Оголошення типів

## Оголошення типів

Оголошення типів можуть бути використані для аргументів функцій,
значень, що повертаються і, починаючи з PHP 7.4.0, для властивостей класу. Вони
використовуються під час виконання для перевірки, що значення має точно
той тип, який їм вказаний. Інакше буде викинуто
виняток [TypeError](class.typeerror.md).

> **Примітка**:
>
> При перевизначенні батьківського методу, тип значення, що повертається
> дочірнього методу повинен відповідати будь-якому оголошення
> типу, що повертається батьківського. Якщо у батьківському методі тип
> повертається значення не оголошено, це можна зробити в дочірньому.

### Одиночні типи

| Тип | Опис | Версія |
|------------------------------------------------- ----------------------------|--------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -----------|-----------|
| Ім'я класу/інтерфейсу Значення має бути ['instanceof`](language.operators.type.md) заданого класу або інтерфейсу. | |
| self | Значення має бути ['instanceof`](language.operators.type.md) того ж класу, в якому використовується оголошення типу. Може використовуватись лише у класах. | |
| parent | Значення має бути ['instanceof`](language.operators.type.md) батьківського класу, в якому використовується оголошення типу. Може використовуватись лише у класах. | |
| array | Значення має бути типу array. | |
| [callable](language.types.callable.md) | Значення має бути коректним [callable](language.types.callable.md). Не можна використовувати як оголошення для властивостей класу. | |
| bool | Значення має бути логічного типу. | |
| float | Значення має бути числом із плаваючою точкою. | |
| int | Значення має бути цілим числом. | |
| string | Значення має бути рядком (тип string). | |
| [iterable](language.types.iterable.md) | Значення може бути або масивом (тип array), або є ['instanceof`](language.operators.type.md) [Traversable](class.traversable.md). | PHP 7.1.0
| об'єкт | Значення має бути об'єктом (тип об'єкта). | PHP 7.2.0
| [mixed](language.types.declarations.md#language.types.declarations.mixed) | Значення може мати будь-який тип. | PHP 8.0.0

**Увага**

Псевдоніми для зазначених вище скалярних типів не підтримуються. В
У разі використання вони будуть вважатися за ім'я класу або інтерфейсу. До
наприклад, при використанні в якості типу `boolean`, він буде очікувати,
що значення є
[`instanceof`](language.operators.type.md) класу або інтерфейсу
`boolean`, а не значення типу bool:

`<?php     function test(boolean $param) {}    test(true);?> `

Результат виконання цього прикладу в PHP 8:

Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write " oolean " до цього warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) повинен бути типом boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
thrown in - on line 2

#### mixed

[mixed](language.types.declarations.md#language.types.declarations.mixed)
еквівалентний [об'єднання
типів](language.types.declarations.md#language.types.declarations.composite.union)
object\|resource\|array\|string\|int\|float\|bool\|null. Доступно з PHP
8.0.0.

#### Приклади

**Приклад #1 Оголошення типу класу**

` <?phpclass C {}class D extends C {}// Не є спадкоємцем C.class E {}function f(C $c) {    echo get_class($c)."
";}f(new C);f(new D);f(new E);?> `

Результат виконання цього прикладу в PHP 8:

C
D

Error error: Uncaught TypeError: f(): Argument #1 ($c) мусить бути з типу C, E given, названий / in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
thrown in - on line 8

**Приклад #2 Оголошення типу інтерфейсу**

`<?phpinterface I { public function f(); }class C implements I { public function f() {} }// Не реалізує інтерфейс I.class E {}function f(I $i) {   echo get_class($i)."
";}f(new C);f(new E);?> `

Результат виконання цього прикладу в PHP 8:

C

Error error: Uncaught TypeError: f(): Argument #1 ($i) повинен бути типом I, E given, названий - онлайн 13 і defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
thrown in - on line 8

**Приклад #3 Оголошення типу значення, що повертається**

`<?phpfunction sum($a, $b): float {   return $a + $b;}//Зверніть увагу, що буде повернено число(?d), 2;

Результат виконання цього прикладу:

float(3)

**Приклад #4 Повернення об'єкта**

` <?phpclass C {}function getC(): C {   return new C;}var_dump(getC());?> `

Результат виконання цього прикладу:

object(C)#1 (0) {
}

### Обнулювані типи

Оголошення типів можуть бути позначені як обнулювані, шляхом додавання
префікса як знака питання(`?`). Це означає, що значення може
бути як оголошеного типу, і бути рівним **`null`**.

**Приклад #5 Оголошення типів обнулювання**

` <?phpclass C {}function f(?C $c) {   var_dump($c);}f(new C);f(null);?> `

Результат виконання цього прикладу:

object(C)#1 (0) {
}
NULL

**Приклад #6 Типи, що обнулюються, для повертаного значення**

`<?phpfunction get_item(): ?string {    if (isset($_GET['item'])) {        return $_GET['item']; } else {        return null; }}?> `

> **Примітка**:
>
> До PHP 7.1.0, можна було задавати обнулювані типи аргументів
> функцій шляхом завдання значення за промовчанням рівного `null`. Так робити
> не рекомендується, оскільки це може поламати спадкування.
>
> **Приклад #7 Старий спосіб задавати обнулювані типи аргументів**
>
> ` <?phpclass C {}function f(C $c u003d null) {    var_dump($c);}f(new C);f(null);?> `
>
> Результат виконання цього прикладу:
>
> object(C)#1 (0) {
> }
> NULL

### Складові типи

Можна комбінувати найпростіші типи в складові типи. PHP дозволяє
комбінувати типи такими способами:

- Об'єднання найпростіших типів. Починаючи з PHP 8.0.0.
- Перетин типів класів (інтерфейси та імена класів). Починаючи з
PHP 8.1.0.

**Застереження**

Неможливо комбінувати перетин типів з об'єднанням типів.

#### Об'єднання типів

Об'єднання типів дозволяє використовувати кілька типів, а не
виключно один. Для їх оголошення використовується наступний синтаксис:
`T1|T2|...`. Об'єднання типів доступне, починаючи з PHP 8.0.0.

##### Об'єднання типів, що допускає значення null

Тип `null` можна використовувати як частину об'єднання так:
`T1|T2|null`. Існуюча нотація `?T` розглядається як скорочення
для `T|null`.

**Застереження**

null не може використовуватися як окремий тип.

##### Псевдотип false

Псевдотип `false` підтримується як частина поєднання типів. Він
додано з історичних причин, оскільки багато вбудованих функцій
повертають `false` замість `null` у разі виникнення помилки.
Класичний приклад – функція [strpos()](function.strpos.md).

**Застереження**

`false` не можна використовувати як самостійний тип (включаючи обнулюваний)
різновид). Таким чином, всі оголошення такого типу неприпустимі:
`false`, `false|null` та `?false`.

**Застереження**

Зверніть увагу, що псевдотип true не існує.

#### Перетин типів

Оголошення перетину типів набуває значень, які задовольняють
декільком оголошенням типу класу, а чи не одному. Перетин типів
вказуються з використанням синтаксису `T1&T2&...`. Перетин типів
доступні, починаючи з PHP 8.1.0.

#### Типи, що дублюються і повторюються

Для вилову простих помилок у складових оголошеннях, типи, що повторюються,
які можна відстежити без завантаження класу, призведуть до помилки
компіляції. В тому числі:

- Кожен тип, що розпізнається на ім'я, повинен зустрічатися тільки один
разів. Типи виду `int|string|INT` або
`Countable&Traversable&COUNTABLE` призведуть до помилки.
- Використання типу
[mixed](language.types.declarations.md#language.types.declarations.mixed)
призводить до помилки.
- Для об'єднання типів:
- Якщо використовується bool, то додатково використовувати false
не можна.
- Якщо використовується тип object, то додаткове використання
типів класів неприпустимо.
- Якщо використовується [iterable](language.types.iterable.md), то
до нього не можна додати array або
[Traversable](class.traversable.md).
- Для перетину типів:
- Використання типу, що не є типом класу, наводить
до помилки.
- Використання self, parent чи static призводить до помилки.

> **Примітка**: Це не гарантує, що всі об'єднані типи оголошені
> коректно, оскільки така перевірка вимагатиме завантаження всіх
> використовуваних класів.

Наприклад, якщо `A` та `B` є псевдонімами одного і того ж класу,
то `A|B` виглядає як коректний об'єднаний тип, навіть якщо фактично
оголошення може бути скорочено до `A` або `B`. Аналогічно, якщо
`B extends A {}`, то `A|B` теж виглядає коректним типом, незважаючи на
те, що він може бути скорочений до `A`.

` <?phpfunction foo(): int|INT {} // Забороненоfunction foo(): bool|false {} // Забороненоfunction foo(): int&Traversable {}}// Забороненоfunction  B;function foo(): A|B {} // Заборонено ("use" є части дозвіл імен)function foo(): A&B {} // Заборонено ("use" части '' 'Y');function foo(): X|Y {} // Допустимо (повторення буде визначено тільки в час виконання)function foo(): X&Y {} //Допустимо          

### Типи, придатні тільки для значення, що повертається

#### void

Тип `void` означає, що функція нічого не повертає. Відповідно,
він може бути частиною об'єднання. Доступно з PHP 7.1.0.

> **Примітка**:
>
> Повернення за посиланням з функції з типом void застарілим з PHP
> 8.1.0, оскільки така функція суперечлива. Раніше під час виклику
> Видавалася наступна помилка рівня **`E_NOTICE`**:
> `Only variable references should be returned by reference`.
>
> ` <?phpfunction &test(): void {}?> `

#### never

`never` - тип значення, що повертається, що вказує, що функція нічого не
повертає. Це означає, що вона або викликає
[exit()](function.exit.md), або викидає виняток, або
є нескінченним циклом. Отже, вона не може бути
частиною оголошення union-типу. Доступно з PHP 8.1.0.

never, говорячи мовою теорії типів, є нижчим типом. Це означає,
що це підтип будь-якого іншого типу і може замінити будь-який інший тип
значення, що повертається при успадкування.

#### static

Значення має бути
['instanceof`](language.operators.type.md) того ж класу, в якому
був викликаний метод. Доступно із PHP 8.0.0.

### Сувора типізація

За замовчуванням, PHP буде перетворювати значення неправильного типу в
очікувані. Наприклад, якщо в функцію передати параметр типу int
аргумент, оголошений як string, він перетворюється на string.

Можна увімкнути режим строгої типізації на рівні файлу. У цьому режимі,
тип значення повинен суворо відповідати оголошеному, інакше буде
викинутий виняток [TypeError](class.typeerror.md). Єдиним
винятком із цього правила є передача значення типу int туди,
де очікується float.

**Увага**

На виклики з внутрішніх функцій, дія `strict_types` не
поширюється.

Для включення суворої типізації використовується оператор
[`declare`](control-structures.declare.md) з оголошенням
`strict_types`:

> **Примітка**:
>
> Сувора типізація застосовується до викликів функцій, зроблених *зсередини*
> файлу з включеною строгою типізацією, а не до функцій, оголошених у
> цей файл. Якщо з файлу без увімкненої суворої типізації викликається
> функція, яка була визначена у файлі із строгою типізацією, то
> будуть використані його переваги типізації - тобто. правила
> Суворої типізації будуть проігноровані і значень буде
> застосовувати приведення типів.

> **Примітка**:
>
> Сувора типізація визначається лише для оголошень скалярних типів.

**Приклад #8 Сувора типізація для значень аргументів**

`<?phpdeclare(strict_typesu003d1);function sum(int $a, int $b) {   return $a + $b;}var_dump(sum(1, 2));var_dump(sum(1.5, 2.) ?> `

Результат виконання цього прикладу в PHP 8:

int(3)

Error error: Uncaught TypeError: sum(): Argument #1 ($a) повинен бути типом int, float given, названий - line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
thrown in - on line 4

**Приклад #9 Приведення типів для значень аргументів**

` <?phpfunction sum(int $a, int $b) {   return $a + $b;}var_dump(sum(1, 2)); (sum(1.5, 2.5));?> `

Результат виконання цього прикладу:

int(3)
int(3)

**Приклад #10 Сувора типізація для значень, що повертаються**

`<?phpdeclare(strict_typesu003d1);function sum($a, $b): int {    return $a + $b;}var_dump(sum(1, 2));var_dump(sum(1, 2.5)); ?> `

Результат виконання цього прикладу:

int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
thrown in - on line 5

### Приведення для об'єднаних типів

Якщо `strict_types` не дозволено, то оголошення скалярних типів підлягають
обмеженого неявного приведення. Якщо фактичний тип не є
частиною об'єднання, то використовується такий порядок приведення типів:

1. int
2. float
3. string
4. bool

Якщо тип є в об'єднанні, і значення може бути приведено до
ньому, ґрунтуючись на існуючій семантиці приведення типів PHP, то
станеться приведення до нього. Якщо ні, то перевіриться наступний тип
список.

**Застереження**

Єдиним винятком є приведення рядка у разі, якщо у
об'єднанні одночасно присутні і int, і float. В такому випадку
буде обрано найбільш підходящий тип за правилом приведення "числових
рядків". Наприклад, для `"42"` буде обрано тип int, а для `"42.0"` - тип
float.

> **Примітка**:
>
> Типи, що не входять до цього списку, не підходять для цілей неявного
> приведення. Зокрема, для `null` та `false` неявного приведення не
> трапиться.

**Приклад #11 Приклад приведення для об'єднаних типів**

` <?php// int|string42    --> 42          // явный тип"42"  --> "42"        // явный типnew ObjectWithToString --> строка с результатом выполнения __toString()                      // Объекты никогда не будут приведены к целому числу, даже если вернут "числовую строку"42.0  --> 42          // float совместим с int42.1  --> 42          // float совместим с int1e100 --> "1.0E+100"  // float слишком большой для типа int, преобразуется в строкуINF   --> "INF"       // float слишком большой для типа int, преобразуется в строкуtrue  --> 1           // bool совместим с int[]    --> TypeError   // array несовместим ни с int, ни со string// int|float|bool"45"    --> 45        // целочисленная "числовая строка""45.0"  --> 45.0      // "числовая строка" с плавающей точкой"45X"   --> true      // не "числовая строка", приведётся к bool""      --> false     // не "числовая строка", приведётся к bool"X"     --> true      // не "числовая строка", приведётся к bool[]      --> TypeError // array несовм естим ні с int, ні с float, ні с bool?> `

### Додатково

**Приклад #12 Типізовані параметри, передані за посиланням**

Оголошення типів для параметрів, що передаються за посиланням, перевіряється
лише на етапі виклику функції. Немає жодної гарантії, що після виходу
з функції тип змінної залишиться постійним.

` <?phpfunction array_baz(array &$param){    $param u003d 1;}$var u003d [];array_baz($var);var_dump($var);array_baz($var);?> `

Результат виконання цього прикладу в PHP 8:

int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) повинен бути тип array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
thrown in - on line 2

**Приклад #13 Обробка [TypeError](class.typeerror.md)**

`<?phpdeclare(strict_typesu003d1);function sum(int $a, int $b) {   return $a + $b;}try {   var_dump(sum(1, 2)); var_dump(sum(1.5, 2.5));} catch (TypeError $e) {   echo 'Помилка: ', $e->getMessage();}?> `

Результат виконання цього прикладу в PHP 8:

int(3)
Помилка: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 10
