{"pageProps":{"page":{"slug":"language.oop5.properties.md","content":"## Властивості\n\nЗмінні, які є членами класу, називаються *властивості*. Також їх називають, використовуючи інші терміни, такі як *поля*, але в рамках цієї документації, ми будемо називати їх *властивостями*. Вони визначаються з використанням хоча б одного необов'язкового (за винятком `readonly`\\-властивостей) модифікатора (наприклад, [Область видимості](language.oop5.visibility.md) [Ключове слово static](language.oop5.static.md) або, починаючи з PHP 8.1.0, [readonly](language.oop5.properties.md#language.oop5.properties.readonly-properties)), починаючи з PHP 7.4, за яким слідує необов'язкове оголошення типу, за яким слідує звичайне оголошення змінної. Це оголошення може містити ініціалізацію, але ця ініціалізація має бути [постійним значенням](language.constants.md)\n\n> **Зауваження** :\n> \n> Застарілий спосіб оголошення властивостей класу – використання ключового слова `var` замість модифікатора.\n\n> **Зауваження**: Властивість, оголошена без модифікатора [Область видимості](language.oop5.visibility.md) , буде оголошено як `public`\n\nУ межах методів класу доступ до нестатичних властивостей можна отримати за допомогою `->` (об'єктного оператора): $this->property (де `property` - Ім'я якості). Доступ до статичних властивостей здійснюється за допомогою `::` (подвійного двокрапки): self::$property. Додаткову інформацію про відмінність статичних та нестатичних властивостей дивіться у розділі [Ключове слово static](language.oop5.static.md)\n\nПсевдозмінна $this доступна всередині будь-якого методу класу, коли цей метод викликається з контексту об'єкта. $this - значення об'єкта, що викликає.\n\n**Приклад #1 Визначення властивостей**\n\n```php\n<?php\nclass SimpleClass\n{\n   public $var1 = 'hello ' . 'world';\n   public $var2 = <<<EOD\nhello world\nEOD;\n   public $var3 = 1+2;\n   // неправильное определение свойств:\n   public $var4 = self::myStaticMethod();\n   public $var5 = $myVar;\n\n   // правильное определение свойств:\n   public $var6 = myConstant;\n   public $var7 = [true, false];\n\n   public $var8 = <<<'EOD'\nhello world\nEOD;\n\n   // Без модификатора области видимости:\n   static $var9;\n   readonly int $var10;\n\n}\n?>\n```\n\n> **Зауваження** :\n> \n> Існують різні функції для обробки класів та об'єктів. Дивіться довідник з [функцій для класів/об'єктів](ref.classobj.md)\n\n### Оголошення типів\n\nПочинаючи з PHP 7.4.0, визначення властивостей можуть містити [Оголошення типів](language.types.declarations.md), за исключением типа[callable](language.types.callable.md)\n\n**Приклад #2 Приклад використання типизованих властивостей**\n\n```php\n<?php\n\nclass User\n{\n    public int $id;\n    public ?string $name;\n\n    public function __construct(int $id, ?string $name)\n    {\n        $this->id = $id;\n        $this->name = $name;\n    }\n}\n\n$user = new User(1234, null);\n\nvar_dump($user->id);\nvar_dump($user->name);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(1234)\nNULL\n```\n\nПеред зверненням до типізованої властивості у нього має бути задано значення, інакше буде викинуто виняток [Error](class.error.md)\n\n**Приклад #3 Звернення до властивостей**\n\n```php\n<?php\n\nclass Shape\n{\n    public int $numberOfSides;\n    public string $name;\n\n    public function setNumberOfSides(int $numberOfSides): void\n    {\n        $this->numberOfSides = $numberOfSides;\n    }\n\n    public function setName(string $name): void\n    {\n        $this->name = $name;\n    }\n\n    public function getNumberOfSides(): int\n    {\n        return $this->numberOfSides;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n}\n\n$triangle = new Shape();\n$triangle->setName(\"triangle\");\n$triangle->setNumberofSides(3);\nvar_dump($triangle->getName());\nvar_dump($triangle->getNumberOfSides());\n\n$circle = new Shape();\n$circle->setName(\"circle\");\nvar_dump($circle->getName());\nvar_dump($circle->getNumberOfSides());\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(8) \"triangle\"\nint(3)\nstring(6) \"circle\"\n\nFatal error: Uncaught Error: Typed property Shape::$numberOfSides must not be accessed before initialization\n```\n\n### Readonly-властивості\n\nПочинаючи з PHP 8.1.0, властивість можна оголосити за допомогою модифікатора `readonly`що запобігає зміні властивості після ініціалізації.\n\n**Приклад #4 Приклади readonly-властивостей**\n\n```php\n<?php\nclass Test {\n   public readonly string $prop;\n   public function __construct(string $prop) {\n       // Правильная инициализация.\n       $this->prop = $prop;\n   }\n}\n$test = new Test(\"foobar\");\n// Правильное чтение.\nvar_dump($test->prop); // string(6) \"foobar\"\n// Неправильное переопределение. Не имеет значения, что присвоенное значение такое же.\n$test->prop = \"foobar\";\n// Ошибка: невозможно изменить readonly-свойство Test::$prop\n?>\n```\n\n> **Зауваження** :\n> \n> Модифікатор readonly може застосовуватися тільки до [типізованим властивостям](language.oop5.properties.md#language.oop5.properties.typed-properties). Readonly-властивість без обмежень типу можна створити за допомогою типу [Mixed](language.types.mixed.md)\n\n> **Зауваження** :\n> \n> Статичні реально-властивості не підтримуються.\n\nReadonly-властивість можна ініціалізувати лише один раз і тільки з області, в якій вона була оголошена. Будь-яке інше присвоєння чи зміна властивості призведе до виключення [Error](class.error.md)\n\n**Приклад #5 Неправильна ініціалізація readonly-властивостей**\n\n```php\n<?php\nclass Test1 {\n    public readonly string $prop;\n}\n$test1 = new Test1;\n// Неправильная инициализация за пределами закрытой области.\n$test1->prop = \"foobar\";\n// Ошибка: не удаётся инициализировать readonly-свойство Test1::$prop из глобальной области\n?>\n```\n\n> **Зауваження** :\n> \n> Вказівка ​​явного значення за умовчанням для readonly-властивостей не допускається, тому що readonly-властивість зі значенням за замовчуванням, по суті, те саме, що і константа і тому не особливо корисно.\n> \n> ```php\n> <?php\n> class Test {\n>     // Помилка: у readonly-властивості Test::$prop не може бути значення за замовчуванням\n>     public readonly int $prop = 42;\n> }\n> ?>\n> ```\n\n> **Зауваження** :\n> \n> Readonly-властивості не можуть бути знищені за допомогою [unset()](function.unset.md) після їхньої ініціалізації. Однак можна знищити readonly-властивість до ініціалізації з області, в якій було оголошено властивість.\n\nМодифікації не обов'язково є простими присвоєннями, все наведене нижче також призведе до виключення [Error](class.error.md) :\n\n```php\n<?php\nclass Test {\n    public function __construct(\n        public readonly int $i = 0,\n        public readonly array $ary = [],\n    ) {}\n}\n$test = new Test;\n$test->i += 1;\n$test->i++;\n++$test->i;\n$test->ary[] = 1;\n$test->ary[0][] = 1;\n$ref =& $test->i;\n$test->i =& $ref;\nbyRef($test->i);\nforeach ($test as &$prop);\n?>\n```\n\nОднак реально-властивості не виключають внутрішньої мінливості. Об'єкти (або ресурси), що зберігаються в readonly-властивості, як і раніше, можуть бути змінені всередині:\n\n```php\n<?php\nclass Test {\n    public function __construct(public readonly object $obj) {}\n}\n$test = new Test(new stdClass);\n// Правильное внутреннее изменение.\n$test->obj->foo = 1;\n// Неправильное переопределение.\n$test->obj = new stdClass;\n?>\n```\n\n### Динамічні властивості\n\nПри спробі привласнити неіснуючу властивість об'єкту (object), PHP автоматично створить відповідну властивість. Ця динамічно створена властивість буде доступна *тільки* для цього екземпляра класу.\n\n**Увага**\n\nДинамічні властивості застаріли починаючи з PHP 8.2.0. Натомість рекомендується оголошувати властивість. Для роботи з довільними іменами властивостей, клас має реалізувати магічні методи [\\_\\_get()](language.oop5.overloading.md#object.get) і [\\_\\_set()](language.oop5.overloading.md#object.set). У крайньому випадку клас можна позначити атрибутом `#[\\AllowDynamicProperties]`\n","title":"Властивості","contentType":2,"navigation":[{"language.oop5.basic.md":"« Основи"},{"language.oop5.constants.md":"Константи класів »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}