{"pageProps":{"page":{"slug":"function.preg-replace.md","content":"# preg\\_replace\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\npreg\\_replace — Здійснює пошук та заміну за регулярним виразом.\n\n### Опис\n\n```methodsynopsis\npreg_replace(    string|array $pattern,    string|array $replacement,    string|array $subject,    int $limit = -1,    int &$count = null): string|array|null\n```\n\nВиконує пошук збігів у рядку `subject` із шаблоном `pattern` і замінює їх на `replacement`\n\nДля відповідності точному рядку, а не шаблону, замість цієї функції використовуйте функцію [str\\_replace()](function.str-replace.md) або [str\\_ireplace()](function.str-ireplace.md)\n\n### Список параметрів\n\n`pattern`\n\nШуканий шаблон. Можливо як рядком, і масивом рядків.\n\nТакож доступні деякі [модифікатори PCRE](reference.pcre.pattern.modifiers.md)\n\n`replacement`\n\nРядок або масив рядків для заміни. Якщо цей параметр є рядком, а `pattern` є масивом, всі шаблони будуть замінені цим рядком. Якщо і `pattern`и`replacement` є масивами, кожен елемент `pattern` буде замінений відповідним елементом з `replacement`. Якщо масив `replacement` містить менше елементів, ніж масив `pattern`, то всі зайві шаблони з `pattern` будуть замінені порожніми рядками.\n\n`replacement` може містити посилання на вид `\\n`, либо`$n`, причому останній варіант кращий. Кожне таке посилання буде замінено на підрядок, що відповідає n-ой підмасці. n може набувати значень від 0 до 99, причому посилання `\\0`(либо`$0`) відповідає входженню всього шаблону. Підмаски нумеруються зліва направо, починаючи з одиниці. Зверніть увагу, що зворотні сліші у рядку (string) літерали можуть вимагати екранування.\n\nПри заміні за шаблоном з використанням посилань на підмаски може виникнути ситуація, коли безпосередньо за маскою слідує цифра (наприклад, встановлення цифри відразу після маски, що збіглася). У такому разі не можна використовувати знайому нотацію виду `\\1` для посилання на підмаски. Запис, наприклад, `\\11`, збентежить **preg\\_replace()**, так як вона не зможе зрозуміти, чи хочете ви використовувати посилання `\\1`, за якою слідує цифра або ж ви хочете просто використовувати посилання `\\11`, за якою нічого не слідує. Це непорозуміння можна усунути, якщо скористатися конструкцією `${1}1`, що використовує ізольоване посилання `$1`, і наступну за нею цифру\n\nПри использовании устаревшего модификатора`e` ця функція екранує деякі символи (а саме `'` `\"` `\\` та NULL) у рядках, що заміщають зворотні посилання. Це зроблено для засвідчення коректності синтаксису при використанні зворотних посилань усередині одинарних або подвійних лапок (наприклад, `'strlen(\\'$1\\')+strlen(\"$2\")'`). Переконайтеся, що ви володієте [синтаксисом обробки рядків](language.types.string.md) PHP для того, щоб точно усвідомлювати, як виглядатиме інтерпретований рядок.\n\n`subject`\n\nРядок або масив рядків для пошуку та заміни.\n\nЯкщо `subject` є масивом, то пошук із заміною здійснюється для кожного елемента масиву `subject`, а значення, що повертається, також буде масивом.\n\nЯкщо параметр `subject` є асоціативним масивом, ключі будуть збережені у значенні, що повертається.\n\n`limit`\n\nМаксимально можлива кількість замін кожного шаблону для кожного рядка `subject`По умолчанию равно`-1` (без обмежень).\n\n`count`\n\nЯкщо зазначено, то ця змінна буде заповнена кількістю зроблених замін.\n\n### Значення, що повертаються\n\n**preg\\_replace()** повертає масив, якщо параметр `subject` є масивом, інакше повертається рядок.\n\nЯкщо знайдені збіги, повертається нова версія `subject`, иначе`subject` повертається недоторканим, у разі помилки повертається **`null`**\n\n### Помилки\n\nВикористання модифікатора \"\\\\e\" є помилкою; у цьому випадку видається помилка рівня **`E_WARNING`**;.\n\nЯкщо переданий шаблон регулярного виразу не компілюється в допустимий регулярний вираз, видається помилка рівня **`E_WARNING`**\n\n### Приклади\n\n**Приклад #1 Використання підмасок, за якими слідує цифра**\n\n```php\n<?php\n$string = 'April 15, 2003';\n$pattern = '/(\\w+) (\\d+), (\\d+)/i';\n$replacement = '${1}1,$3';\necho preg_replace($pattern, $replacement, $string);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nApril1,2003\n```\n\n**Приклад #2 Використання масивів з числовими індексами як аргументи функції **preg\\_replace()****\n\n```php\n<?php\n$string = 'The quick brown fox jumps over the lazy dog.';\n$patterns = array();\n$patterns[0] = '/quick/';\n$patterns[1] = '/brown/';\n$patterns[2] = '/fox/';\n$replacements = array();\n$replacements[2] = 'bear';\n$replacements[1] = 'black';\n$replacements[0] = 'slow';\necho preg_replace($patterns, $replacements, $string);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nThe bear black slow jumps over the lazy dog.\n```\n\nВідсортувавши за ключами шаблони та заміни, отримуємо бажаний результат:\n\n```php\n<?php\nksort($patterns);\nksort($replacements);\necho preg_replace($patterns, $replacements, $string);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nThe slow black bear jumps over the lazy dog.\n```\n\n**Приклад #3 Заміна на декілька шаблонів**\n\n```php\n<?php\n$patterns = array ('/(19|20)(\\d{2})-(\\d{1,2})-(\\d{1,2})/',\n                   '/^\\s*{(\\w+)}\\s*=/');\n$replace = array ('\\3/\\4/\\1\\2', '$\\1 =');\necho preg_replace($patterns, $replace, '{startDate} = 1999-5-27');\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n$startDate = 5/27/1999\n```\n\n**Приклад #4 Чищення пробілів**\n\nЦей приклад вичищає зайві прогалини у рядку.\n\n```php\n<?php\n$str = 'foo   o';\n$str = preg_replace('/\\s\\s+/', ' ', $str);\n// Это теперь будет 'foo o'\necho $str;\n?>\n```\n\n**Приклад #5 Использование параметра`count`**\n\n```php\n<?php\n$count = 0;\n\necho preg_replace(array('/\\d/', '/\\s/'), '*', 'xp 4 to', -1 , $count);\necho $count; //3\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nxp***to\n3\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> При использовании массивов в`pattern`и`replacement`, ключі обробляються в порядку, в якому вони знаходяться в масиві. Цей порядок *не завжди* збігається з числовим порядком індексів. Якщо ви використовуєте індекси для порівняння один з одним потрібного `pattern`и`replacement`, то вам необхідно прогнати через функцію [ksort()](function.ksort.md)оба массива перед использованием**preg\\_replace()**\n\n> **Зауваження** :\n> \n> Якщо і `pattern`и`replacement` є масивами, правила відповідності діятимуть послідовно. Тобто друга пара `pattern` `replacement` буде працювати з рядком, отриманим у результаті першої пари `pattern` `replacement`, а не з вихідним рядком. Якщо ви хочете імітувати заміну, що діє паралельно, наприклад, поміняти місцями два значення, замініть один шаблон проміжним заповнювачем, а потім у наступній парі замініть цей проміжний заповнювач необхідною заміною.\n> \n> ```php\n> <?php\n> $p = array('/a/', '/b/', '/c/');\n> $r = array('b', 'c', 'd');\n> print_r(preg_replace($p, $r, 'a'));\n> // prints d\n> ?>\n> ```\n\n### Дивіться також\n\n-   [Регулярні вирази PCRE](pcre.pattern.md)\n-   [preg\\_quote()](function.preg-quote.md) \\- Екранує символи у регулярних виразах\n-   [preg\\_filter()](function.preg-filter.md) \\- Здійснює пошук та заміну за регулярним виразом\n-   [preg\\_match()](function.preg-match.md) \\- Виконує перевірку на відповідність регулярному виразу\n-   [preg\\_replace\\_callback()](function.preg-replace-callback.md) \\- Виконує пошук за регулярним виразом та заміною з використанням callback-функції\n-   [preg\\_split()](function.preg-split.md) \\- Розбиває рядок за регулярним виразом\n-   [preg\\_last\\_error()](function.preg-last-error.md) \\- Повертає код помилки виконання останнього регулярного вираження PCRE\n-   [str\\_replace()](function.str-replace.md) \\- Замінює всі входження рядка пошуку на рядок заміни\n","title":"preg\\_replace","contentType":2,"navigation":[{"function.preg-replace-callback.md":"« preg\\_replace\\_callback"},{"function.preg-split.md":"preg\\_split »"},{"index.md":"PHP Manual"},{"ref.pcre.md":"Функції PCRE"}]}},"__N_SSG":true}