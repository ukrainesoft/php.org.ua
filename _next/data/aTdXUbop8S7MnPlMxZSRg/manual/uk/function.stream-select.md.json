{"pageProps":{"page":{"slug":"function.stream-select.md","content":"# stream\\_select\n\n(PHP 4 >= 4.3.0, PHP 5, PHP 7, PHP 8)\n\nstream\\_select — Запускає еквівалент системного виклику select() на заданих масивах потоків з часом очікування, вказаним параметрами seconds та microseconds\n\n### Опис\n\n```methodsynopsis\nstream_select(    ?array &$read,    ?array &$write,    ?array &$except,    ?int $seconds,    ?int $microseconds = null): int|false\n```\n\nФункция**stream\\_select()** отримує масиви потоків і чекає зміни їхнього статусу. Її робота еквівалентна роботі функції [socket\\_select()](function.socket-select.md), За винятком того, що вона працює з потоками.\n\n### Список параметрів\n\n`read`\n\nПотоки, перелічені у масиві `read` будуть відстежуватися на предмет появи символів, доступних для читання (точніше, щоб переконатися, що читання не блокуватиметься - зокрема потоковий ресурс також готовий для читання в кінці файлу, але в цьому випадку функція [fread()](function.fread.md) повертатиме рядок нульової довжини).\n\n`write`\n\nПотоки, перелічені у масиві `write`, будуть відстежуватися щодо того, що запис у них не буде блокуватися.\n\n`except`\n\nПотоки, перелічені у масиві `except`, будуть відстежуватися щодо надходження високопріоритетних виняткових (позасмугових або \"out-of-band\") даних.\n\n> **Зауваження** :\n> \n> Когда**stream\\_select()** повертається, масиви `read` `write`и`except` змінюються для того, щоб вказати, які потокові ресурси насправді змінили статус. Вихідні ключі масивів зберігаються.\n\n`seconds`\n\nПараметри `seconds`и`microseconds`вместе формируют параметр*timeout* `seconds` вказує кількість секунд, а `microseconds`\\- число микросекунд. Параметр`timeout` - це верхня межа часу, яка функція **stream\\_select()** чекатиме до повернення. Якщо параметри `seconds`и`microseconds` обидва встановлені в , то функция**stream\\_select()** не чекатиме даних - натомість вона повернеться негайно, вказуючи поточний статус потоків.\n\nЯкщо параметр `seconds`равен\\*\\*`null`**, то функция**stream\\_select()\\*\\* може виконуватися невизначений час, повертаючись тільки тоді, коли відбувається подія на одному з потоків, що відстежуються (або якщо системний виклик переривається сигналом).\n\n**Увага**\n\nИспользование значения времени ожидания позволяет вам мгновенно опросить статус потоков, однако ПЛОХАЯ идея использовать значение времени ожидания у циклі, оскільки це змусить ваш скрипт споживати занадто багато процесорного часу.\n\nНабагато краще вказати значення часу очікування в кілька секунд, хоча якщо вам потрібно перевіряти та одночасно запускати інший код, використання часу очікування як мінімум `200000` мікросекунд допоможе зменшити використання процесорного часу вашим скриптом.\n\nЗапам'ятайте, що значення часу очікування – це максимальний час, який буде витрачено. Функція **stream\\_select()** повернеться як тільки запитані потоки будуть готові до використання.\n\n`microseconds`\n\nСмотрите описание параметра`seconds`\n\n### Значення, що повертаються\n\nУ разі успішного виконання функція **stream\\_select()** повертає кількість потокових ресурсів, що міститься в змінених масивах, яка може дорівнювати нулю, якщо перевищено час очікування до того, як сталося щось цікаве. У разі виникнення помилки повертається **`false`** і виникає попередження (це може статися, якщо системний виклик переривається вхідним сигналом).\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.1.0 | Параметр`microseconds` тепер припускає значення **`null`** |\n\n### Приклади\n\n**Приклад #1 Приклад використання** stream\\_select()\\*\\*\\*\\*\n\nЦей приклад перевіряє, що отримано дані для читання на потоках `$stream1`или`$stream2`Так как значение времени ожидания равно , функція повернеться негайно:\n\n```php\n<?php\n/* Подготовить массив для чтения */\n$read   = array($stream1, $stream2);\n$write  = NULL;\n$except = NULL;\nif (false === ($num_changed_streams = stream_select($read, $write, $except, 0))) {\n    /* Обработка ошибок */\n} elseif ($num_changed_streams > 0) {\n    /* Как минимум на одном из потоков произошло что-то интересное */\n}\n?>\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Через обмеження в поточному Zend Engine неможливо передати постійну **`null`** безпосередньо як параметр у функцію, яка очікує, що цей параметр буде передано за посиланням. Натомість використовуйте тимчасову змінну або вираз, у якому крайній лівий член буде тимчасовою змінною:\n> \n> ```php\n> <?php\n> $e = NULL;\n> stream_select($r, $w, $e, 0);\n> ?>\n> ```\n\n> **Зауваження** :\n> \n> Переконайтеся, що використовуєте оператор `===`при проверке на ошибку. Так как функция**stream\\_select()** може повертати 0, порівняння з використанням `==` може повертати **`true`** :\n> \n> ```php\n> <?php\n> $ e = NULL;\n> if (false === stream_select($r, $w, $e, 0)) {\n>     echo \"Відбулася помилка під час виклику stream_select()\\n\";\n> }\n> ?>\n> ```\n\n> **Зауваження** :\n> \n> Якщо ви читаєте/пишете в потік, що повертається в масивах, знайте, що вони не обов'язково читають/пишуть повну кількість даних, які ви запросили. Будьте готові до того, щоб мати можливість читати/писати навіть по одному байту.\n\n> **Зауваження** :\n> \n> Деякі потоки (наприклад, `zlib`) не можуть бути обрані цією функцією.\n\n> **Зауваження** **Сумісність із Windows**\n> \n> Использование функции**stream\\_select()** на файлових дескрипторах, повернутих функцією [proc\\_open()](function.proc-open.md) не вдасться і поверне \\*\\*`false`\\*\\*под Windows.\n> \n> **`STDIN`** з консолі змінює статус, як тільки стають доступними *будь-які* вхідні події, але читання потоку все ще може блокуватися.\n\n### Дивіться також\n\n-   [stream\\_set\\_blocking()](function.stream-set-blocking.md) \\- Встановити блокуючий/неблокуючий режим у потоці\n","title":"stream\\_select","contentType":2,"navigation":[{"function.stream-resolve-include-path.md":"« stream\\_resolve\\_include\\_path"},{"function.stream-set-blocking.md":"stream\\_set\\_blocking »"},{"index.md":"PHP Manual"},{"ref.stream.md":"Функції для роботи з потоками"}]}},"__N_SSG":true}