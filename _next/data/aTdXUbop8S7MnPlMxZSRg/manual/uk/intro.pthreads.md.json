{"pageProps":{"page":{"slug":"intro.pthreads.md","content":"# Вступ\n\npthreads надає об'єктно-орієнтований API до роботи з багатопоточністю в PHP. Програми на PHP можуть створювати, читати, записувати, запускати та виконувати синхронізацію з об'єктами Threads, Workers та Threaded.\n\n**Увага**\n\nМодуль вважається непідтримуваним та мертвим.\n\n**Підказка**\n\nСпробуйте замість цього використати [parallel](book.parallel.md)\n\n**Увага**\n\nМодуль доступний лише для програм CLI. Виходячи з цього, багатопоточність PHP в оточенні веб-сервера недоступна.\n\n**Увага**\n\npthreads (v3) може використовуватися тільки з PHP 7.2 і вище, оскільки ZTS-режим нестабільний у 7.0 та 7.1.\n\nКласс[Threaded](class.threaded.md) надає базовий функціонал, необхідний для роботи pthreads. Він надає методи синхронізації та деякі корисні для розробника інтерфейси.\n\nКласс[Thread](class.thread.md) дозволяє створювати потоки. Для створення потоку необхідно створити наслідуючий його клас і в ньому реалізувати метод `run`. Будь-які властивості можуть бути записані та прочитані з будь-якого контексту через посилання на потік. Також із будь-якого контексту можуть бути викликані публічні та захищені методи. Метод run буде запущений в окремому потоці, як тільки буде викликаний метод [Thread::start()](thread.start.md) з контексту, у якому його було створено. Стартувати та приєднати потік можна лише у тому контексті, де він був створений.\n\nКласс[Worker](class.worker.md) має постійний стан і буде доступний із методу [Thread::start()](thread.start.md) (успадкований метод) доти, доки об'єкт не вийде з області видимості, або поки не буде примусово зупинений (за допомогою [Worker::shutdown()](worker.shutdown.md)). Будь-який контекст, що має посилання на цей об'єкт, може додавати завдання на стек Worker (за допомогою [Worker::stack()](worker.stack.md)), які будуть запущені в окремому потоці. Метод `run` об'єкта Worker буде запущений раніше, ніж будь-який об'єкт з його стека завдань, що дає можливість ініціалізувати необхідні для завдання ресурси.\n\nКласс[Pool](class.pool.md) використовується для створення групи виконавців (worker) для розподілу між ними об'єктів [Threaded](class.threaded.md). Це найпростіший і найефективніший варіант використання багатопоточності в PHP.\n\n**Застереження**\n\nКласс[Pool](class.pool.md)не наследует[Threaded](class.threaded.md)таким чином є звичайним об'єктом PHP. Об'єкти цього класу не повинні розділятися за різними контекстами.\n\nКласс[Volatile](class.volatile.md) доданий до pthreads v3. Він використовується для завдання змінюваних [Threaded](class.threaded.md)\\-властивостей класів типу [Threaded](class.threaded.md) (оскільки тепер вони за умовчанням незмінні). Також використовується для зберігання масивів PHP у контексті [Threaded](class.threaded.md)\n\nСинхронізація – важлива частина багатопоточності. Всі об'єкти, створені pthreads, мають вбудовані методи для забезпечення синхронізації (вони здадуться дуже знайомими для розробників Java): [Threaded::wait()](threaded.wait.md) і [Threaded::notify()](threaded.notify.md). Виклик [Threaded::wait()](threaded.wait.md) переведе об'єкт в очікування до того моменту, поки з іншого контексту не буде викликано [Threaded::notify()](threaded.notify.md) для об'єкта, що очікує. Цей механізм дозволяє синхронізувати між об'єктами. [Threaded](class.threaded.md)\n\n**Застереження**\n\nБудь-які об'єкти вашої програми, які передбачається використовувати в багатопотоковому режимі, повинні успадковувати [Threaded](class.threaded.md)\n\nЗберігання даних: Як правило, в об'єкті Threaded можна використовувати будь-які дані, які можуть бути серіалізовані. Вони можуть бути записані та прочитані з будь-якого контексту через посилання на цей об'єкт. Не кожен тип даних зберігається у серіалізованому вигляді. Базові типи зберігаються у їхній справжній формі. Складні типи, масиви та об'єкти, що не є Threaded, зберігаються серіалізованими; вони можуть бути прочитані або записані в Threaded-об'єкт з будь-якого контексту за посиланням. За винятком Threaded-об'єктів, всі посилання, що використовуються для встановлення властивості в Threaded-об'єкті відокремлені від посилань усередині Threaded-об'єкті. Читання тих самих даних можна проводити безпосередньо з будь-якого контексту за посиланням на Threaded-об'єкті.\n\nСтатичні властивості: Коли створюється новий контекст (Thread або Worker), вони просто копіюються, але ресурси та об'єкти обнулюються (з міркувань безпеки). Це дозволяє використовувати їх як локальні для потоку сховища. Наприклад, під час створення контексту, для класу, статичні властивості якого зберігають інформацію про з'єднання до БД і саме з'єднання, буде скопійована тільки інформація необхідна для з'єднання, але не сама з'єднання. Це дозволить створити нове з'єднання в новому контексті і зберегти його в тому самому місці ніяк не торкаючись оригінального контексту.\n\n**Застереження**\n\nКоли запускаються print\\_r, var\\_dump або інші функції налагодження, вони не включають захист від рекурсії.\n\n> **Зауваження** :\n> \n> Ресурси: Модулі та функціональність PHP, що створюють ресурси, зовсім не підготовлені для такого оточення; pthreads надає механізм поділу ресурсів між контекстами, проте для більшості типів ресурсів його слід вважати небезпечним. Розділяючи ресурс між контекстами, необхідно бути вкрай уважним і обережним.\n\n**Застереження**\n\nВ оточенні, де запускається pthreads, необхідні деякі обмеження та заборони для забезпечення стабільності.\n","title":"Вступ","contentType":2,"navigation":[{"book.pthreads.md":"« pthreads"},{"pthreads.setup.md":"Встановлення та налаштування \""},{"index.md":"PHP Manual"},{"book.pthreads.md":"pthreads"}]}},"__N_SSG":true}