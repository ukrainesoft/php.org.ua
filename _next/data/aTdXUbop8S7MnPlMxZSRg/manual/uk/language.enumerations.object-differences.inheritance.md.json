{"pageProps":{"page":{"slug":"language.enumerations.object-differences.inheritance.md","content":"## Чому перерахування не розширюються\n\nДля методів класів оголошено контракти:\n\n```php\n<?php\n\nclass A {}\nclass B extends A {}\n\nfunction foo(A $a) {}\n\nfunction bar(B $b) {\n    foo($b);\n}\n?>\n```\n\nЦей код безпечний для типів, оскільки клас B виконує контракт класу A, і, за рахунок магії коваріантності та контраваріантності, очікування щодо методів будуть виправдані, за винятком винятків.\n\nПереліки мають контракти на їх варіанти, а не методи:\n\n```php\n<?php\n\nenum ErrorCode\n{\n    case SOMETHING_BROKE;\n}\n\nfunction quux(ErrorCode $errorCode)\n{\n    // Кажется, что этот код охватывает все варианты\n    match ($errorCode) {\n        ErrorCode::SOMETHING_BROKE => true,\n    }\n}\n\n?>\n```\n\nПровівши статичний аналіз виразу [match](control-structures.match.md) у функції `quux`легко зрозуміти, що охоплений кожен варіант перерахування ErrorCode.\n\nАле уявіть, що можна було б розширювати перерахування:\n\n```php\n<?php\n\n// Экспериментальный код, в котором перечисления не конечно.\n// Обратите внимание, что это не будет работать в PHP.\nenum MoreErrorCode extends ErrorCode\n{\n    case PEBKAC;\n}\n\nfunction fot(MoreErrorCode $errorCode) {\n    quux($errorCode);\n}\n\nfot(MoreErrorCode::PEBKAC);\n\n?>\n```\n\nДотримуючись стандартних правил успадкування, клас, який розширює інший клас, пройде перевірку типу.\n\nПроблема полягає в тому, що вираз [match](control-structures.match.md) у функції `quux()` вже не покриває всіх випадків. Оскільки воно не знає про варіант `MoreErrorCode::PEBKAC`, вираз [match](control-structures.match.md) викине виняток.\n\nТому перерахування є остаточними і їх не дозволяється розширювати.\n","title":"Чому перерахування не розширюються","contentType":2,"navigation":[{"language.enumerations.serialization.md":"« Серіалізація"},{"language.enumerations.examples.md":"Приклади »"},{"index.md":"PHP Manual"},{"language.enumerations.md":"Перерахування"}]}},"__N_SSG":true}