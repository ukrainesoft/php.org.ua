{"pageProps":{"page":{"slug":"language.oop5.late-static-bindings.md","content":"## Пізніше статичне зв'язування\n\nPHP реалізує функцію, звану пізніше статичне зв'язування, яка може бути використана для того, щоб отримати посилання на клас, що викликається в контексті статичного успадкування.\n\nЯкщо точніше говорити, пізніше статичне зв'язування зберігає ім'я класу вказаного в останньому \"неперенаправленому виклику\". У разі статичних викликів це явно вказаний клас (зазвичай ліворуч від оператора [`::`](language.oop5.paamayim-nekudotayim.md)); у разі нестатичних викликів це клас об'єкта. \"Переспрямований виклик\" - це статичний виклик, що починається з `self::` `parent::` `static::`, або, якщо рухатися вгору по ієрархії класів, [forward\\_static\\_call()](function.forward-static-call.md)Функция[get\\_called\\_class()](function.get-called-class.md) може бути використана для отримання рядка з ім'ям викликаного класу, а `static::` представляє її сферу дії.\n\nСама назва \"пізнє статичне зв'язування\" відображає в собі внутрішню реалізацію цієї особливості. \"Пізнє зв'язування\" відображає той факт, що звернення через `static::` не будуть обчислюватися по відношенню до класу, в якому метод, що викликається, визначений, а будуть обчислюватися на основі інформації в ході виконання. Також ця особливість була названа \"статичне зв'язування\" тому, що вона може бути використана (але не обов'язково) у статичних методах.\n\n### Ограничения`self::`\n\nСтатичні посилання на поточний клас, такі як `self::`или`__CLASS__`, обчислюються використовуючи клас, якого ця функція належить, як у тому місці, де було визначено:\n\n**Приклад #1 Использование`self::`**\n\n```php\n<?php\nclass A {\n    public static function who() {\n        echo __CLASS__;\n    }\n    public static function test() {\n        self::who();\n    }\n}\n\nclass B extends A {\n    public static function who() {\n        echo __CLASS__;\n    }\n}\n\nB::test();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nA\n```\n\n### Використання пізнього статичного зв'язування\n\nПізніше статичне зв'язування намагається усунути це обмеження, надаючи ключове слово, яке посилається клас, викликаний безпосередньо під час виконання. Простіше кажучи, ключове слово, яке дозволить вам посилатися на `B`из`test()` у попередньому прикладі. Вирішили не вводити нове ключове слово, а використовувати `static`, яка вже зарезервована.\n\n**Приклад #2 Простое использование`static::`**\n\n```php\n<?php\nclass A {\n    public static function who() {\n        echo __CLASS__;\n    }\n    public static function test() {\n        static::who(); // Здесь действует позднее статическое связывание\n    }\n}\n\nclass B extends A {\n    public static function who() {\n        echo __CLASS__;\n    }\n}\n\nB::test();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nB\n```\n\n> **Зауваження** :\n> \n> У нестатичному контексті викликаним класом буде той, до якого належить екземпляр об'єкта. Оскільки `$this->` буде намагатися викликати закриті методи з тієї ж області дії, використання `static::` може дати різні результати. Інша відмінність у тому, що `static::` може посилатися лише на статичні поля класу.\n\n**Приклад #3 Использование`static::` у нестатичному контексті**\n\n```php\n<?php\nclass A {\n    private function foo() {\n        echo \"success!\\n\";\n    }\n    public function test() {\n        $this->foo();\n        static::foo();\n    }\n}\n\nclass B extends A {\n   /* foo() будет скопирован в В, следовательно его область действия по прежнему А,\n      и вызов будет успешным */\n}\n\nclass C extends A {\n    private function foo() {\n        /* исходный метод заменён; область действия нового метода - С */\n    }\n}\n\n$b = new B();\n$b->test();\n$c = new C();\n$c->test();   // потерпит ошибку\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nsuccess!\nsuccess!\nsuccess!\n\n\nFatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9\n```\n\n> **Зауваження** :\n> \n> Дозволяюча область пізнього статичного зв'язування буде фіксована статичним викликом, що обчислює її. З іншого боку, статичні виклики з використанням таких директив як `parent::`или`self::` перенаправляють інформацію дзвінка.\n> \n> **Приклад #4 Перенаправлені та неперенаправлені дзвінки**\n> \n> ```php\n> <?php\n> class A {\n>     public static function foo() {\n>         static::who();\n>     }\n> \n>     public static function who() {\n>         echo __CLASS__.\"\\n\";\n>     }\n> }\n> \n> class B extends A {\n>     public static function test() {\n>         A::foo();\n>         parent::foo();\n>         self::foo();\n>     }\n> \n>     public static function who() {\n>         echo __CLASS__.\"\\n\";\n>     }\n> }\n> class C extends B {\n>     public static function who() {\n>         echo __CLASS__.\"\\n\";\n>     }\n> }\n> \n> C::test();\n> ?>\n> ```\n> \n> Результат виконання наведеного прикладу:\n> \n> ```\n> A\n> C\n> C\n> ```\n","title":"Пізніше статичне зв'язування","contentType":2,"navigation":[{"language.oop5.object-comparison.md":"« Порівняння об'єктів"},{"language.oop5.references.md":"Об'єкти та посилання »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}