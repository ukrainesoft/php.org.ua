- [« Рекурсивні шаблони](regexp.reference.recursive.md)
- [Описує можливі модифікатори шаблонів Perl-сумісних
регулярних виразів (PCRE)
»](reference.pcre.pattern.modifiers.md)

- [PHP Manual](index.md)
- [Опис синтаксису Perl-сумісних регулярних
виразів](reference.pcre.pattern.syntax.md)
- продуктивність

## Продуктивність

Деякі елементи, які можуть зустрічатися в шаблонах, є більш
ефективнішими, ніж низка інших. Наприклад, набагато ефективніше використовувати
символьний клас \[aeiou\] замість набору альтернатив (a\|e\|i\|o\|u).
Як правило, більш проста конструкція є більш ефективною. Книга
Джеффрі Фрідла містить багато обговорень питання оптимізації регулярних
виразів.

Якщо шаблон починається з .\* і використовується прапор
[PCRE_DOTALL](reference.pcre.pattern.modifiers.md), шаблон неявно
заякорюється, оскільки він може збігатися лише на початку рядка. Але
якщо [PCRE_DOTALL](reference.pcre.pattern.modifiers.md) не
використовується, PCRE не може виконати відповідну оптимізацію, так
як у такому разі метасимвол '.' не відповідає символу початку рядка
(якщо дані, що обробляються, містять переклади рядків, такий шаблон може
відповідати шаблону не від початку рядка, а від позиції
безпосередньо після переведення рядка). Наприклад, застосовуючи шаблон
`(.*) second` до рядка "first
and second" (де
 позначає символ
(переведення рядка), значення, захоплене першою підмаскою, буде 'and'.
Щоб обробити всі можливі точки відповідності, PCRE намагається
зіставити шаблон після кожного символу перекладу рядка.

У випадку, якщо ви використовуєте подібні шаблони для обробки даних, не
що містять переклади рядків, для кращої продуктивності використовуйте
модифікатор [PCRE_DOTALL](reference.pcre.pattern.modifiers.md), або
починайте шаблон із ^.\* для вказівки явного заякорювання. Це
запобігає PCRE від пошуку символів нових рядків та додаткових
спроб зіставити шаблон із кожною такою знайденою позицією.

Уникайте шаблонів, які містять вкладені необмежені
повторення. Зіставлення їх з рядками, що не містять збігів,
займає тривалий час. Розглянемо приклад шаблону `(a+)*`

Він може відповідати з "aaaa" 33-ма різними способами, і ця
цифра дуже швидко зростає зі збільшенням рядка. (У цьому прикладі,
квантифікатор може збігатися 0, 1, 2, 3 або 4 рази, і для кожного
такого випадку, крім нуля, квантифікатор + також може збігатися
різне число разів.) Якщо залишок шаблону такий, що весь збіг
терпить невдачу, PCRE має спробувати усі можливі варіанти
збігу, що може вимагати величезної кількості часу.

За допомогою оптимізації можна відловити найпростіші випадки, такі як
`(a+)*b` де слідом йде літеральний символ. Перш ніж виробляти
стандартну процедуру пошуку, PCRE перевіряє в наступному підрядку
наявність символу 'b', і, у разі відсутності такого, спроба
зіставлення негайно завершується невдачею. Однак, коли
наступного літералу немає, оптимізація може бути застосована. Ви
можете відчути різницю, порівнявши поведінку `(a+)*\d` з поведінкою
наведеного вище шаблону. Перший визначає неможливість зіставлення
майже відразу ж, у порівнянні з рядком що складається з знаків
'a', тоді як другий витрачає тривалий час на пошук у рядках
довше за 20 символів.
