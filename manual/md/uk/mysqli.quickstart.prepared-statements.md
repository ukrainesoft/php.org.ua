- [«Виконання запитів](mysqli.quickstart.statements.md)
- [Збережені процедури »](mysqli.quickstart.stored-procedures.md)

- [PHP Manual](index.md)
- [Короткий посібник](mysqli.quickstart.md)
- запити, що готуються

## Підготовлювані запити

СУБД MySQL підтримує запити, що готуються. Що готуються (або
параметризовані) запити використовуються для підвищення ефективності,
коли один запит виконується багаторазово і захищає від ін'єкцій SQL.

*Принцип роботи*

Виконання запиту, що готується, проводиться в два етапи: підготовка
та виконання. На етапі підготовки на сервер надсилається шаблон запиту.
Сервер виконує синтаксичну перевірку цього шаблону, будує план
виконання запиту та виділяє під нього ресурси.

MySQL сервер підтримує неіменовані, або позиційні,
псевдозмінні `?`.

За підготовкою слідує виконання. Під час виконання клієнт пов'язує
значення параметрів і надсилає їх на сервер. Сервер виконує запит
із пов'язаними значеннями, використовуючи раніше створені внутрішні ресурси.

**Приклад #1 Підготовлений запит**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");/* Підготовлений запрос, крок1: підготовка */$stmt u003d $mysqli- (id, label) VALUES (?, ?)");/* Підготовлений запит, крок2: зв'язування і виконання */$id u003d 1;$label u003d 'PHP';$stmt->bind_param(" id, $label); // "is"  означає, що $id зв'язується, як ціле число, а $label - як рядок$stmt->execute(); `

*Повторне виконання запиту*

Підготовлений запит можна запускати багаторазово. Перед кожним запуском
значення прив'язаних змінних будуть передаватися на сервер та
підставлятись у текст запиту. Сам текст запиту повторно не
аналізується, так само як і не надсилається повторно шаблон.

**Приклад #2 Вираз INSERT один раз готується, а потім
багаторазово виконується**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");/* Підготовлений запрос, крок1: підготовка */$stmt u003d $mysqli- (id, label) VALUES (?, ?)");/* Підготовлений запит, крок 2: зв'язування і виконання */$stmt->bind_param("is", $id, $label); // "is"  означає, що $id зв'язується, як ціле число, а $label - як рядок$data u003d [   1 u003d> 'PHP',  '              $data as $id u003d> $label) {    $stmt->execute();}$result u003d $mysqli->query('SELECT id, label FROM test');var_dump($result->fetch_all ; `

Результат виконання цього прикладу:

array(3) {
[0]u003d>
array(2) {
["id"]u003d>
string(1) "1"
["label"]u003d>
string(3) "PHP"
}
[1]u003d>
array(2) {
["id"]u003d>
string(1) "2"
["label"]u003d>
string(4) "Java"
}
[2]u003d>
array(2) {
["id"]u003d>
string(1) "3"
["label"]u003d>
string(3) "C++"
}
}

Кожен запит, що готується, використовує ресурси сервера. Якщо запит
більше не потрібен, його необхідно одразу закрити. Якщо не зробити цього
явно запит закриється сам, але тільки коли PHP звільнить його
дескриптор, як правило, це відбувається при виході запиту з області
видимості або після завершення роботи скрипта.

Використання підготовлюваних запитів не завжди призводить до підвищення
ефективності. Якщо параметризований запит запускається лише раз, це
призводить до більшої кількості клієнт-серверних обмінів даними, ніж
під час простого запиту. Саме з цієї причини у прикладі вище
вираз `SELECT` виконувалося як звичайний запит.

Також має сенс розглянути SQL-синтаксис вставки множини значень у
виразі INSERT. У прикладі вище мультивставка (значення для вставки
перераховуються через кому) у реченні INSERT обійшлася б дешевше,
ніж підготовлений запит.

**Приклад #3 Менше обміну даними під час використання мультивставок SQL**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");$mysqli->query("DR| $mysqli->query("CREATE TABLE test(id INT)");$values u003d [1, 2, 3, 4];$stmt u003d $mysqli->prepare("INSERT INTO test(id) VALUES (?) , (?), (?), (?)");$stmt->bind_param('iiii', ...$values);$stmt->execute(); `

*Типи даних значень у результуючій таблиці*

У протоколі клієнт-серверної взаємодії MySQL для звичайних і
підготовлюваних запитів визначено різні протоколи передачі даних
клієнту. Параметризовані запити використовують так званий двійковий
протокол. Сервер MySQL надсилає результуючий набір клієнту "як є"
у двійковому форматі. Дані в таблиці не перетворюються на текст.
Клієнтські бібліотеки отримують двійкові дані та намагаються перетворити
значення відповідних типів даних PHP. Наприклад, стовпець
результатів запиту типу SQL `INT` PHP прийме та перетворює на тип
integer.

**Приклад #4 Вихідні типи даних**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'PHP) );$stmt u003d $mysqli->prepare("SELECT id, label FROM test WHERE id u003d 1");$stmt->execute();$result u003d $stmt->get_result();$row u003d $ >fetch_assoc();printf("id u003d %s (%s)
", $row['id'], gettype($row['id']));printf("label u003d %s (%s)
", $row['label'], gettype($row['label'])); `

Результат виконання цього прикладу:

id u003d 1 (integer)
label u003d PHP (string)

Така поведінка не характерна для звичайних запитів, які за замовчуванням
всі результати повертають як текстових рядків. Ця поведінка по
За замовчуванням можна змінити, настроївши з'єднання відповідно.
Після такого настроювання різниці між даними підготовлюваного та звичайного
запитів не буде.

*Отримання результатів запиту з прив'язкою змінних*

Результати з підготовленого запиту можна отримати або прив'язавши
вихідні змінні, або запитавши об'єкт
[mysqli_result](class.mysqli-result.md).

Вихідні параметри слід прив'язувати після виконання запиту. кожному
стовпцю результуючої таблиці повинна відповідати рівно одна
змінна.

**Приклад #5 Прив'язка змінних до результату запиту**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'PHP) );$stmt u003d $mysqli->prepare("SELECT id, label FROM test WHERE id u003d 1");$stmt->execute();$stmt->bind_result($out_id, $out_label);wh ->fetch()) {    printf("idu003du003d%s|(%s), labelu003du003d%s|(%s)
", $out_id, gettype($out_id), $out_label, gettype($out_label));} `

Результат виконання цього прикладу:

id u003d 1 (integer), label u003d PHP (string)

Об'єкти запитів за замовчуванням повертають
небуферизовані результати набори. Ці таблиці ніяким неявним
не переносяться на клієнта, вони залишаються на сервері, займаючи його
ресурси, поки клієнтський процес самостійно не витягне всі дані.
Якщо клієнт не може отримати дані результуючого набору, або після
закриття об'єкта запиту залишаються невибраними якісь дані, то на
`mysqli` лягає відповідальність неявно підчистити це сміття за
клієнтським процесом.

Також можна буферизувати дані результуючих таблиць підготовленого
запиту за допомогою функції
[mysqli_stmt::store_result()](mysqli-stmt.store-result.md).

*Вилучення результатів запиту за допомогою mysqli_result інтерфейсу*

Замість використання прив'язки змінних до результатів запиту,
результуючі таблиці можна видобувати засобами інтерфейсу
mysqli_result. Функція
[mysqli_stmt::get_result()](mysqli-stmt.get-result.md) повертає
буферизований результуючий набір рядків.

**Приклад #6 Використання mysqli_result для вибірки результатів
запиту**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'PHP) );$stmtu003du003d$mysqli->prepare("SELECT id, label FROM test WHERE id u003d 1");$stmt->execute();$result u003d $stmt->get_result();var_dump($result fetch_all(MYSQLI_ASSOC)); `

Результат виконання цього прикладу:

array(1) {
[0]u003d>
array(2) {
["id"]u003d>
int(1)
["label"]u003d>
string(3) "PHP"
}
}

Використання інтерфейсу [mysqli_result](class.mysqli-result.md) має
додаткова перевага в тому, що буферизація результуючих таблиць
на клієнті пропонує гнучку систему навігації за цими таблицями.

**Приклад #7 Буферизація результуючого набору для зручності читання
даних**

` <?phpmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);$mysqli u003d new mysqli("example.com", "user", "password", "database");/* Непідготовлений TA IF EXISTS test");$mysqli->query("CREATE TABLE test(id INT, label TEXT)");$mysqli->query("INSERT INTO test(id, label) VALUES (1, 'PHP) (2, 'Java'), (3, 'C++')");$stmtu003du003d$mysqli->prepare("SELECT id, label FROM test");$stmt->execute();$result u003d $stmt ->get_result();for ($row_no u003d $result->num_rows - 1; $row_no >u003d 0; $row_no--) {    $result->data_seek($row_no); var_dump($result->fetch_assoc());} `

Результат виконання цього прикладу:

array(2) {
["id"]u003d>
int(3)
["label"]u003d>
string(3) "C++"
}
array(2) {
["id"]u003d>
int(2)
["label"]u003d>
string(4) "Java"
}
array(2) {
["id"]u003d>
int(1)
["label"]u003d>
string(3) "PHP"
}

*Екранування та SQL-ін'єкції*

Прив'язані змінні відправляються на сервер окремо від запиту та
таким чином не можуть впливати на нього. Сервер використовує ці значення
безпосередньо в момент виконання вже після того, як був оброблений
вираз. Прив'язані параметри не потребують екранування,
тому що вони ніколи не підставляються безпосередньо в рядок запиту.
Необхідно відправляти тип прив'язаної змінної на сервер, щоб
визначити відповідне перетворення. Дивіться функцію
[mysqli_stmt::bind_param()](mysqli-stmt.bind-param.md) для отримання
більшої інформації.

Такий поділ часто вважається єдиним способом убезпечитися від
SQL-ін'єкції, але насправді такого ж рівня безпеки можна
добитися і з непідготовленими висловлюваннями, якщо правильно
відформатувати всі значення. Правильне відзначити, що правильне
форматування - не те саме, що і екранування, і включає в себе
більше логіки. Таким чином, підготовлені висловлювання - просто більше
зручний і менш схильний до помилок спосіб для досягнення такої
безпеки бази даних

*Емуляція підготовленого запиту на клієнті*

В API немає можливості емулювати підготовлювані запити на клієнта.

*Швидке порівняння підготовлених та непідготовлених запитів*

У таблиці нижче наведено порівняння звичайного та підготовленого на сервері
запитів.

| | Підготовлений запит Звичайний запит |
|------------------------------------------------- ------------------------|------------------------- -------------------------------------------------- -------------------------------------------------- -------------------------------|------------------ -------------------------------------------------- -------------------------------------------------- --------------------|
| Кількість звернень до сервера, SELECT, одноразове виконання 2 | 1 |
| Кількість рядків із текстом запиту, переданих клієнтом на сервер | 1 | 1 |
| Кількість звернень до сервера, SELECT, n-кратне виконання | 1+n | n |
| Кількість рядків із текстом запиту, переданих клієнтом на сервер | 1 шаблон, n разів параметри, якщо є | n разів і щоразу розбирається |
| Прив'язка вхідних параметрів засобами API Є | Ні, настройки екрануються вручну |
| Прив'язка вихідних параметрів засобами API Є | Ні |
| Підтримує API mysqli_result | Так, використовується [mysqli_stmt::get_result()](mysqli-stmt.get-result.md) | Так |
| Буферизація результуючих наборів Є, можна використовувати функцію [mysqli_stmt::get_result()](mysqli-stmt.get-result.md) або [mysqli_stmt::store_result()](mysqli-stmt.store-result.md) | Є ця поведінка за умовчанням для [mysqli::query()](mysqli.query.md) |
| Робота з небуферизованими результуючими наборами Можливо, використовується прив'язка вихідних параметрів за допомогою API Можливо, використовується функція [mysqli::real_query()](mysqli.real-query.md) спільно з [mysqli::use_result()](mysqli.use-result.md) |
| Спосіб передачі даних протоколу клієнт-серверної взаємодії MySQL Двійковий протокол | Текстовий протокол
| SQL-типи значень результуючого набору Зберігаються під час вилучення | Перетворюються на рядки або зберігаються під час вилучення |
| Підтримує всі SQL-вирази Останні версії MySQL підтримують більшість, але все | Так |

**Порівняння підготовлених та непідготовлених запитів**

*Дивіться також*

- [mysqli::\_\_construct()](mysqli.construct.md)
- [mysqli::query()](mysqli.query.md)
- [mysqli::prepare()](mysqli.prepare.md)
- [mysqli_stmt::prepare()](mysqli-stmt.prepare.md)
- [mysqli_stmt::execute()](mysqli-stmt.execute.md)
- [mysqli_stmt::bind_param()](mysqli-stmt.bind-param.md)
- [mysqli_stmt::bind_result()](mysqli-stmt.bind-result.md)
