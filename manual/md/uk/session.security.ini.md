- [« Базові засади управління
сесіями](features.session.security.management.md)
- [Функції для роботи із сесіями »](ref.session.md)

- [PHP Manual](index.md)
- [Безпека сесій](session.security.md)
- INI-налаштування безпеки сесій

## INI-налаштування безпеки сесій

Надаючи INI-налаштування, пов'язані з сесіями, ви можете покращити
безпека сесій. Деякі важливі параметри безпеки не мають
рекомендованих значень. Ви самі відповідальні за вибір необхідних
значень.

- [session.cookie_lifetime](session.configuration.md#ini.session.cookie-lifetime)u003d0

`0` має особливе значення. Він повідомляє браузеру не зберігати cookie
у постійне сховище. Отже, коли браузер закривається,
сесійні cookie одразу ж віддаляються. Якщо задати значення відмінне
від 0, це може дозволити іншим користувачам використовувати ці
cookie. Найчастіше найкраще використовувати "`0`".

Якщо потрібна функціональність автологіна, реалізовуйте його
самостійно і ніколи не використовуйте для цього довгоживучі
сесії. Докладніше викладено вище у відповідних розділах.

- [session.use_cookies](session.configuration.md#ini.session.use-cookies)u003dOn

[session.use_only_cookies](session.configuration.md#ini.session.use-only-cookies)u003dOn

Незважаючи на те, що HTTP-cookie мають деякі проблеми, все ж вони
найкращі для зберігання ідентифікатора сесії. Коли
це можливо, для управління ідентифікаторами сесій необхідно
використовувати "cookie". Більшість програм повинні використовувати
cookie для сесії ідентифікатора.

Якщо `session.use_only_cookies`u003dOff, модуль сесії буде
використовувати ідентифікатор, встановлений через GET/POST/URL, якщо
"cookie" не було виставлено заздалегідь.

- [session.use_strict_mode](session.configuration.md#ini.session.use-strict-mode)u003dOn

Вкрай рекомендується включати `session.use_strict_mode`. за
замовчуванням не увімкнено.

Це не дозволить сесійному модулю використовувати неініціалізовані
ідентифікатори сесій. Іншими словами, сесійний модуль буде
приймати тільки коректні ідентифікатори, згенеровані ним же
ігноруватиме ідентифікатори створені на стороні користувача.

Через особливості специфікації cookie атакуючий може зробити
cookie з ідентифікатором сесії, що не видаляється за допомогою локальної бази
cookie або JavaScript-ін'єкцією. `session.use_strict_mode` може не
дати атакуючому використати цей ідентифікатор.

> **Примітка**:
>
> Атакуючі можуть ініціалізувати ідентифікатор сесії на своєму
> пристрої та виставити його жертві. Вони повинні будуть підтримувати
> сесію в активному стані для зловживань. Атакуючим
> знадобиться вчинити додаткові дії для проведення атаки
> за цим сценарієм. Тому `session.use_strict_mode` служить як
> запобігання цьому.

- [session.cookie_httponly](session.configuration.md#ini.session.cookie-httponly)u003dOn

Забороняє доступ до сесійної cookie для JavaScript. Ця опція
запобігає крадіжці cookie за допомогою JavaScript-ін'єкції.

Можна використовувати сесійний ID як захисний ключ CSRF, але не
рекомендується. Наприклад, HTML може бути збережений та надісланий
іншому користувачеві. Розробник не повинен записувати сесійний ID
всередині сторінки для підвищення безпеки. Майже всі програми
повинні використовувати атрибут httponly для сесійної cookie.

> **Примітка**:
>
> Захисний ключ CSRF повинен періодично оновлюватися, як і
> ідентифікатор сесії.

- [session.cookie_secure](session.configuration.md#ini.session.cookie-secure)u003dOn

Дозволяє отримувати доступ до cookie ідентифікатора сесії тільки за
використання протоколу HTTPS. Якщо ваш сайт використовує тільки
протоколу HTTPS, вам необхідно включити цю опцію.

Для таких сайтів слід також розглядати використання HSTS.

- [session.cookie_samesite](session.configuration.md#ini.session.cookie-samesite)u003d"Lax"
або
[session.cookie_samesite](session.configuration.md#ini.session.cookie-samesite)u003d"Strict"

Починаючи з PHP 7.3, ви можете встановити cookie-прапор ``SameSite'` для
ідентифікатор cookie сесії. Цей прапор є способом пом'якшення
атак CSRF (міжсайтова підробка запиту).

Різниця між Lax і Strict полягає в доступності cookie в
запити, що виходять з іншого реєстрованого домену з
використанням HTTP-методу GET. Cookie, які використовують Lax, будуть
доступні в GET-запиті, що виходить з іншого домену, що реєструється,
тоді як cookie, які використовують Strict, не будуть.

- [session.gc_maxlifetime](session.configuration.md#ini.session.gc-maxlifetime)u003d\[вибрати
найменший із можливих\]

`session.gc_maxlifetime` налаштування для видалення застарілих
ідентифікаторів сесій. Покладатись на цю опцію категорично *не*
рекомендується. Ви повинні керувати життєвим циклом сесії
самостійно.

Сесійний збирач сміття GC (garbage collection) краще використовувати
за допомогою [session_gc()](function.session-gc.md). Функцію
[session_gc()](function.session-gc.md) найкраще запускати через
планувальник, наприклад, cron на nix-системах.

За замовчуванням GC працює на принципі імовірності. Це налаштування
*не* гарантує видалення старих сесій. Розробнику не слід
покладатися на це налаштування, але все одно, рекомендується виставити
її мінімально можливим значенням. Налаштовуйте
[session.gc_probability](session.configuration.md#ini.session.gc-probability)
і
[session.gc_divisor](session.configuration.md#ini.session.gc-divisor)
так, щоб застарілі сесії віддалялися досить часто. Якщо
потрібна функціональність автологіна, реалізуйте його самостійно
і ніколи не використовуйте для цього довготривалі сесії.

> **Примітка**:
>
> Деякі обробники збереження сесій не використовують механізм
> старіння сесій на основі ймовірностей. Наприклад memcached,
> memcache. Читайте відповідну документацію для повнішої
> інформації.

- [session.use_trans_sid](session.configuration.md#ini.session.use-trans-sid)u003dOff

Використання прозорого керування сесійним ID не рекомендується.
Ви можете використовувати його, якщо потрібно. Однак, вимкнення
прозорого управління підвищує безпеку сесій загалом, прибираючи
можливість ін'єкції сесійного ID та його крадіжки.

> **Примітка**:
>
> Ідентифікатор сесії може витекти через закладку в браузері, URL
> надісланий поштою, збережений вихідний HTML.

- [session.trans_sid_tags](session.configuration.md#ini.session.trans-sid-tags)u003d\[ігноровані
теги\]

(PHP 7.1.0 \>u003d) Ви не повинні перезаписувати непотрібні HTML-теги.
Значення за замовчуванням має бути достатньою для більшості
випадків. Старі версії PHP для цього використовують
[url_rewriter.tags](outcontrol.configuration.md#ini.url-rewriter.tags).

- [session.trans_sid_hosts](session.configuration.md#ini.session.trans-sid-hosts)u003d\[список
хостів\]

(PHP 7.1.0 \>u003d) Ця установка визначає білий список хостів, для
яких дозволено прозоре керування ідентифікаторами сесій.
Ніколи не додавайте недовірені хости. Якщо це налаштування
порожня, то буде дозволено тільки $\_SERVER\['HTTP_HOST'\].

- [session.referer_check](session.configuration.md#ini.session.referer-check)u003d\[ваш
вихідний URL\]

Якщо
[session.use_trans_sid](session.configuration.md#ini.session.use-trans-sid)
увімкнено, то рекомендується використовувати цю опцію, якщо це можливо.
Це зменшує ризик ін'єкції сесійного ID. Якщо ваш сайт
знаходиться за адресою http://example.com/, то встановіть цю опцію
значення http://example.com/. Зверніть увагу, що при
використовуючи HTTPS, браузер не надсилає referrer заголовок. Таким
Таким чином, цей параметр не є достатньо надійним показником
безпеки, але, все ж таки, рекомендується його використовувати.

- [session.cache_limiter](session.configuration.md#ini.session.cache-limiter)u003dnocache

Переконайтеся, що вміст HTTP не кешується для автентифікації
сесії. Допускається кешувати лише неконфіденційний контент.
Інакше вмістом можуть користуватися. Можна використовувати значення
"private", якщо вміст HTTP не містить чутливих до
безпеки дані. Врахуйте, що "private" може залишати
конфіденційні дані у загальному кеші клієнтів. Значення "public"
можна використовувати тільки якщо HTTP-контент взагалі не містить
жодних конфіденційних даних.

- [session.sid_length](session.configuration.md#ini.session.sid-length)u003d"48"

(PHP 7.1.0 \>u003d) Чим довший ідентифікатор сесії, тим він надійніший.
Довжина, що рекомендується, - 32 символи і більше. У будь-якому випадку, не менше
26 символів потрібно для
[session.sid_bits_per_character](session.configuration.md#ini.session.sid-bits-per-character)u003d"5".

- [session.sid_bits_per_character](session.configuration.md#ini.session.sid-bits-per-character)u003d"6"

(PHP 7.1.0 \>u003d) Чим більше біт використовується для символів
ідентифікатор сесії, тим більше надійні ідентифікатори будуть
створено для тієї ж довжини ідентифікатора сесії.

- [session.hash_function](session.configuration.md#ini.session.hash-function)u003d"sha256"

(PHP 7.1.0 \<) Більш складна хеш-функція буде створювати більше
складний сесійний ID. Хоча колізії з хеш майже не відбуваються і з
MD5-хешом, проте розробнику краще використовувати функції
SHA-2 або новіший. Розробники також можуть використати складні
функції sha384 та sha512. Переконайтеся, що ви використовуєте
достатньо
[ентропії](session.configuration.md#ini.session.entropy-length)
для цих функцій.

- [session.save_path](session.configuration.md#ini.session.save-path)u003d\[загальнодоступний
каталог для читання\]

Якщо встановлено у загальнодоступний каталог для читання всім, такий як
`/tmp` (за замовчуванням), інші користувачі на сервері можуть
захопити сеанси, отримавши список файлів у цьому каталозі.
