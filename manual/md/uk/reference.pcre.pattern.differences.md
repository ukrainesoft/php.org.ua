- [« Описує можливі модифікатори шаблонів Perl-сумісних
регулярних виразів (PCRE)] (reference.pcre.pattern.modifiers.md)
- [Функції PCRE»] (ref.pcre.md)

- [PHP Manual](index.md)
- [Регулярні висловлювання PCRE](pcre.pattern.md)
- Відмінність від Perl

# Відмінності від Perl

Наведені тут відмінності відносяться до версії Perl 5.005.

1. За замовчуванням пробельний символ - це будь-який символ, який має функцію
isspace() з бібліотеки C упізнає таким, хоча можливо
скомпілювати PCRE з альтернативними таблицями символів. Функція
isspace() визначає як пробільний наступні символи: пробіл, кінець
сторінки (formfeed), переклад рядка, повернення каретки, горизонтальну
табуляцію та вертикальну табуляцію. Perl 5 не включає
вертикальну табуляцію до списку пробільних символів. Екранування
довгий час присутнє в документації Perl насправді
ніколи не розпізнавалася. Проте, символ як такий, вважався за
пробільний до версії 5.002. У 5.004 та 5.005 він не визначається як
\s.

2. PCRE не дозволяє використовувати квантифікатори повторення в
випереджальних припущеннях. Perl дозволяє, але вони не означають того,
про що ви могли б подумати. Наприклад, (?! a) {3} не перевіряє, що
наступні три символи не є "a". Перевіряється лише те, що наступний
символ не "a" тричі.

3. Захоплюючі підшаблони, що виникають у негативних
випереджальних перевірок вважаються, але їх записи у векторі зсувів
ніколи не встановлюються. Perl встановлює числові змінні
з будь-яких подібних масок, які збіглися до моменту, коли
припущення не підтвердилося під час перевірки чогось, але тільки
якщо випереджаюче припущення містить лише одну гілку.

4. Хоча бінарні нульові символи підтримуються в рядку, що перевіряється,
вони неприпустимі в рядку шаблону, тому що вона передається як
нормальний рядок C, в якому цей символ позначає кінець рядка.
Для його використання в рядку шаблону необхідно скористатися
конструкцією "x00".

5. Наступні екрануючі послідовності Perl не підтримуються:
\l, \u, \L, \U. Фактично вони реалізовані стандартним обробником
рядків Perl і не є частиною модуля обробки регулярних
виразів.

6. Припущення \G із Perl також не підтримується, оскільки не
має відношення до окремо взятої схеми збігів.

7. Досить очевидно, що PCRE не підтримує конструкції (?{code}) та
(?? {code}). Проте є підтримка рекурсивних шаблонів.

8. Є ще дивний момент при Perl 5.005_02, пов'язаний з
встановленням захоплених рядків, коли частина шаблону повторюється. До
Наприклад, перевірка "aba" шаблоном /^(a(b)?)+$/, встановлює $2 в
значення "b", але перевірка "aabbaa" шаблоном /^(aa(bb)?)+$/,
залишає $2 не виставленою. Хоча, якщо шаблон поміняти на
/^(aa(b(b))?)+$/, то $2 (і $3) буде встановлено. У Perl 5.004, $2
встановиться в обох випадках, і це також істинно для PCRE. Якщо в
майбутньому Perl якось зафіксує цю поведінку, PRCE буде йому
дотримуватися.

9. Інша досі невирішена суперечність у тому, що Perl
5.005_02, шаблоном /^(a)?(?(1)a\|b)+$/ розпізнає рядок "a", а PCRE
ні. Хоча і в Perl і PCRE, /^(a)?a/ розпізнає "a" і залишає $1
не виставленої.

10. PCRE надає деякі розширення регулярних виразів Perl:

1. Незважаючи на те, що випереджальні припущення мають
розпізнавати рядки фіксованої довжини, кожне альтернативне
ретроспективне припущення може розпізнавати рядки різного
довжини. Perl 5.005 вимагає, щоб вони були однією довжиною.
2. Якщо встановлено
[PCRE_DOLLAR_ENDONLY](reference.pcre.pattern.modifiers.md) та
не встановлена
[PCRE_MULTILINE](reference.pcre.pattern.modifiers.md),
метасимвол $ розпізнається лише наприкінці рядка.
3. Якщо встановлено
[PCRE_EXTRA](reference.pcre.pattern.modifiers.md), зворотний
сліш з наступною за ним літерою, що не має спеціального
значення, що призводить до помилки.
4. Якщо встановлено
[PCRE_UNGREEDY](reference.pcre.pattern.modifiers.md), жадібність
Квантифікатори повторення інвертовані. Тобто за умовчанням
вони не жадібні, поки їх не буде знак питання.
