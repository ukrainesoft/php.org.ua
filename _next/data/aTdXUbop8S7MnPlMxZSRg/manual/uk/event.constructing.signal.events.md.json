{"pageProps":{"page":{"slug":"event.constructing.signal.events.md","content":"# Створення подій для сигналів\n\nEvent може відстежувати сигнали у стилі POSIX. Для створення обробника сигналу використовуйте конструктор [Event::\\_\\_construct()](event.construct.md) з прапором **`Event::SIGNAL`** або фабричний метод [Event::signal()](event.signal.md)\n\n**Приклад #1 Обработка сигнала`SIGTERM`**\n\n```php\n<?php\n/*\nЗапускайте в окне терминала:\n\n$ php examples/signal.php\n\nВ другом терминальном окне отыщите этот процесс и\nпошлите ему сигнал SIGTERM:\n\n$ ps aux | grep examp\nruslan    3976  0.2  0.0 139896 11256 pts/1    S+   10:25   0:00 php examples/signal.php\nruslan    3978  0.0  0.0   9572   864 pts/2    S+   10:26   0:00 grep --color=auto examp\n$ kill -TERM 3976\n\nВ первом терминале вы увидите следующее:\n\nПойман сигнал 15\n*/\nclass MyEventSignal {\n    private $base, $ev;\n\n    public function __construct($base) {\n        $this->base = $base;\n        $this->ev = Event::signal($base, SIGTERM, array($this, 'eventSighandler'));\n        $this->ev->add();\n    }\n\n    public function eventSighandler($no, $c) {\n        echo \"Пойман сигнал $no\\n\";\n        $this->base->exit();\n    }\n}\n\n$base = new EventBase();\n$c    = new MyEventSignal($base);\n\n$base->loop();\n?>\n```\n\nЗверніть увагу, що функції зворотного дзвінка запускаються всередині подієвого циклу після отримання сигналу, тому для них цілком безпечно викликати функції, які не слід запускати зі звичайних обробників сигналів POSIX.\n\nТакже почитайте[» Fast portable non-blocking network programming with Libevent, Constructing Signal Events](http://www.wangafu.net/~nickm/libevent-book/Ref4_event.md#_constructing_signal_events)\n","title":"Створення подій для сигналів","contentType":2,"navigation":[{"event.callbacks.md":"« Callback-функції"},{"class.event.md":"Event »"},{"index.md":"PHP Manual"},{"book.event.md":"Event"}]}},"__N_SSG":true}