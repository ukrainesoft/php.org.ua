{"pageProps":{"page":{"slug":"mysqlnd.plugin.developing.md","content":"## Розпочинаємо розробку плагіна mysqlnd\n\nВажливо пам'ятати, що плагін `mysqlnd` сам собою є модулем PHP.\n\nНаступний приклад показує базову структуру функції MINIT, що використовується у типовому плагіні `mysqlnd` :\n\n```\n/* my_php_mysqlnd_plugin.c */\n\n static PHP_MINIT_FUNCTION(mysqlnd_plugin) {\n  /* глобальные переменные, ini-настройки, ресурсы, классы */\n\n  /* регистрируем плагин mysqlnd */\n  mysqlnd_plugin_id = mysqlnd_plugin_register();\n\n  conn_m = mysqlnd_get_conn_methods();\n  memcpy(org_conn_m, conn_m,\n    sizeof(struct st_mysqlnd_conn_methods));\n\n  conn_m->query = MYSQLND_METHOD(mysqlnd_plugin_conn, query);\n  conn_m->connect = MYSQLND_METHOD(mysqlnd_plugin_conn, connect);\n}\n```\n\n```\n/* my_mysqlnd_plugin.c */\n\n enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, query)(/* ... */) {\n  /* ... */\n}\nenum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, connect)(/* ... */) {\n  /* ... */\n}\n```\n\n**Аналіз завдання: від C до простору користувача**\n\n```\nclass proxy extends mysqlnd_plugin_connection {\n  public function connect($host, ...) { .. }\n}\nmysqlnd_plugin_set_conn_proxy(new proxy());\n```\n\nПроцес:\n\n1.  PHP: користувач реєструє callback-функцію плагіна\n    \n2.  PHP: користувач викликає PHP MySQL API для з'єднання з MySQL\n    \n3.  C: ext/\\*mysql\\*викликає метод mysqlnd\n    \n4.  C: mysqlnd обривається в ext/mysqlnd\\_plugin\n    \n5.  C: ext/mysqlnd\\_plugin\n    \n    1.  Викликає користувацьку callback-функцію\n        \n    2.  Або оригінальний метод`mysqlnd`якщо вона не задана\n        \n\nВам необхідно виконати такі дії:\n\n1.  Створіть клас клас \" mysqlnd\\_plugin\\_connection\"\n    \n2.  Прийміть та зареєструйте проксі об'єкт за допомогою \"mysqlnd\"\\_plugin\\_set\\_conn\\_proxy()\"\n    \n3.  Викличте проксі методи простору користувача з C (оптимізація - zend\\_interfaces.h)\n    \n\nМетоди об'єкта простору користувача мають бути викликані за допомогою `call_user_function()` або на рівень нижче, за допомогою `zend_call_method()`\n\n**Оптимізація: викликайте методи З за допомогою zend\\_call\\_method**\n\nСледующий кусок кода демонстрирует прототип функции`zend_call_method`взятий з zend\\_interfaces.h.\n\n```\nZEND_API zval* zend_call_method(\n  zval **object_pp, zend_class_entry *obj_ce,\n  zend_function **fn_proxy, char *function_name,\n  int function_name_len, zval **retval_ptr_ptr,\n  int param_count, zval* arg1, zval* arg2 TSRMLS_DC\n);\n```\n\nZend API підтримує лише два аргументи. Вам може знадобитися більше. Наприклад:\n\n```\nenum_func_status (*func_mysqlnd_conn__connect)(\n  MYSQLND *conn, const char *host,\n  const char * user, const char * passwd,\n  unsigned int passwd_len, const char * db,\n  unsigned int db_len, unsigned int port,\n  const char * socket, unsigned int mysql_flags TSRMLS_DC\n);\n```\n\nДля обходу цієї проблеми вам необхідно зробити копію `zend_call_method()` та додати необхідні параметри. Ви можете зробити це створивши набір макросів `MY_ZEND_CALL_METHOD_WRAPPER`\n\n**Звернення до простору користувача PHP**\n\nЦей шматок коду демонструє оптимізований метод виклику функцій простору користувача з:\n\n```\n/* my_mysqlnd_plugin.c */\n\nMYSQLND_METHOD(my_conn_class,connect)(\n  MYSQLND *conn, const char *host /* ... */ TSRMLS_DC) {\n  enum_func_status ret = FAIL;\n  zval * global_user_conn_proxy = fetch_userspace_proxy();\n  if (global_user_conn_proxy) {\n    /* вызов прокси пространства пользователя */\n    ret = MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, host, /*...*/);\n  } else {\n    /* или оригинальный метод mysqlnd = ничего не делать, быть прозрачным */\n    ret = org_methods.connect(conn, host, user, passwd,\n          passwd_len, db, db_len, port,\n          socket, mysql_flags TSRMLS_CC);\n  }\n  return ret;\n}\n```\n\n**Звернення до простору користувача: прості аргументи**\n\n```\n/* my_mysqlnd_plugin.c */\n\n MYSQLND_METHOD(my_conn_class,connect)(\n  /* ... */, const char *host, /* ...*/) {\n  /* ... */\n  if (global_user_conn_proxy) {\n    /* ... */\n    zval* zv_host;\n    MAKE_STD_ZVAL(zv_host);\n    ZVAL_STRING(zv_host, host, 1);\n    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_host /*, ...*/);\n    zval_ptr_dtor(&zv_host);\n    /* ... */\n  }\n  /* ... */\n}\n```\n\n**Звернення до простору користувача: структури як аргументи**\n\n```\n/* my_mysqlnd_plugin.c */\n\nMYSQLND_METHOD(my_conn_class, connect)(\n  MYSQLND *conn, /* ...*/) {\n  /* ... */\n  if (global_user_conn_proxy) {\n    /* ... */\n    zval* zv_conn;\n    ZEND_REGISTER_RESOURCE(zv_conn, (void *)conn, le_mysqlnd_plugin_conn);\n    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_conn, zv_host /*, ...*/);\n    zval_ptr_dtor(&zv_conn);\n    /* ... */\n  }\n  /* ... */\n}\n```\n\nперший аргумент багатьох методів `mysqlnd` - це \"об'єкти\" С. Наприклад, перший аргумент методу connect() є вказівником на `MYSQLND`. Структура MYSQLND є об'єктом з'єднання `mysqlnd`\n\nВказівник на об'єкт з'єднання `mysqlnd` можна порівняти зі стандартним обробником файлового вводу/виводу. Так само як і він, об'єкт з'єднання `mysqlnd` повинен бути пов'язаний із простором користувача з використанням PHP типом \"resource\".\n\n**З C в простір користувача і назад**\n\n```\nclass proxy extends mysqlnd_plugin_connection {\n  public function connect($conn, $host, ...) {\n    /* до внедрения */\n    printf(\"Подключение к = '%s'\\n\", $host);\n    debug_print_backtrace();\n    return parent::connect($conn);\n  }\n\n  public function query($conn, $query) {\n    /* после внедрения */\n    $ret = parent::query($conn, $query);\n    printf(\"Запрос = '%s'\\n\", $query);\n    return $ret;\n  }\n}\nmysqlnd_plugin_set_conn_proxy(new proxy());\n```\n\nКористувачі PHP повинні мати можливість викликати батьківські реалізації перевизначених методів.\n\nВ результаті успадкування можна \"уточнити\" лише вибрані методи і ви можете вибрати, коли виконувати ваш код, до або після батьківського.\n\n**Вбудований клас: mysqlnd\\_plugin\\_connection::connect()**\n\n```\n/*  my_mysqlnd_plugin_classes.c */\n\n PHP_METHOD(\"mysqlnd_plugin_connection\", connect) {\n  /* ... упрощённый! ... */\n  zval* mysqlnd_rsrc;\n  MYSQLND* conn;\n  char* host; int host_len;\n  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\",\n    &mysqlnd_rsrc, &host, &host_len) == FAILURE) {\n    RETURN_NULL();\n  }\n  ZEND_FETCH_RESOURCE(conn, MYSQLND* conn, &mysqlnd_rsrc, -1,\n    \"Mysqlnd Connection\", le_mysqlnd_plugin_conn);\n  if (PASS == org_methods.connect(conn, host, /* simplified! */ TSRMLS_CC))\n    RETVAL_TRUE;\n  else\n    RETVAL_FALSE;\n}\n```\n","title":"Розпочинаємо розробку плагіна mysqlnd","contentType":2,"navigation":[{"mysqlnd.plugin.api.md":"« API плагінів mysqlnd"},{"book.oci8.md":"OCI8 »"},{"index.md":"PHP Manual"},{"mysqlnd.plugin.md":"API для плагінів до вбудованого драйвера MySQL"}]}},"__N_SSG":true}