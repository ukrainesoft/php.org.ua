- [«Зумовлені змінні](language.variables.predefined.md)
- [Змінні змінні »](language.variables.variable.md)

- [PHP Manual](index.md)
- [Змінні](language.variables.md)
- область видимості змінної

## Область видимості змінної

Область видимості змінної – це контекст, у якому ця змінна
визначено. У більшості випадків всі змінні PHP мають лише одну
область видимості. Ця єдина область видимості охоплює також
включаються (include) та необхідні (require) файли. Наприклад:

` <?php$a u003d 1;include 'b.inc';?> `

Тут змінна `$a` буде доступна всередині скрипта `b.inc`.
Проте визначення (тіло) функції користувача задає локальну
область видимості цієї функції. Будь-яка використовується всередині функції
Змінна за замовчуванням обмежена локальною областю видимості функції.
Наприклад:

`<?php$a u003d 1; /* глобальна область видимості */function test(){   echo $a; /* посилання на змінну в локальної області видимості */}test();?> `

Цей скрипт не згенерує жодного висновку, оскільки вираз echo
вказує на локальну версію змінної `$a`, а в межах цієї області
видимості їй був присвоєно значення. Можливо ви помітили, що це
трохи відрізняється від мови C у тому, що глобальні змінні в C
автоматично доступні функціям, якщо вони не були перезаписані
локальним визначенням. Це може викликати деякі проблеми, оскільки
люди можуть ненароком змінити глобальну змінну. У PHP, якщо
глобальна змінна буде використовуватися всередині функції, вона повинна
бути оголошена глобальною всередині визначення функції.

### Ключове слово `global`

Спочатку приклад використання `global`:

**Приклад #1 Використання `global`**

` <?php$a u003d 1;$b u003d 2;function Sum(){    global $a, $b; $b u003d $a + $b;}Sum();echo $b;?> `

Наведений вище скрипт виведе `3`. Після визначення `$a` та `$b` всередині
функції як global всі посилання на будь-яку з цих змінних будуть
вказувати на їхню глобальну версію. Не існує жодних обмежень на
кількість глобальних змінних, які можуть опрацьовуватися функцією.

Другий спосіб доступу до змінних глобальної області видимості -
використання спеціального PHP масиву `$GLOBALS`.
Попередній приклад може бути переписаний так:

**Приклад #2 Використання `$GLOBALS` замість global**

` <?php$a u003d 1;$b u003d 2;function Sum(){    $GLOBALS['b'] u003d $GLOBALS['a'] + $GLOBALS['b'];}Sum();echo $ b;?> `

`$GLOBALS` - це асоціативний масив, ключем якого є ім'я, а
значенням – вміст глобальної змінної. Зверніть увагу, що
`$GLOBALS` існує в будь-якій області видимості, це пояснюється тим,
що `$GLOBALS` є
[суперглобальний](language.variables.superglobals.md). Нижче наведено
приклад, що демонструє можливості суперглобальних змінних:

**Приклад #3 Суперглобальні змінні та область видимості**

` <?phpfunction test_superglobal(){    echo $_POST['name'];}?> `

> **Примітка**:
>
> Використання ключового слова `global` поза функцією не є
> помилкою. Воно може бути використане у файлі, який включається
> усередині функції.

### Використання статичних (`static`) змінних

Іншою важливою особливістю області видимості змінної є
* Статична * змінна. Статична змінна існує тільки в
локальної області видимості функції, але не втрачає свого значення, коли
виконання програми виходить із цієї області видимості. Розглянемо
наступний приклад:

**Приклад #4 Демонстрація необхідності статичних змінних**

` <?phpfunction test(){    $a u003d 0; echo $a; $a++;}?> `

Ця функція досить марна, оскільки при кожному виклику вона
встановлює `$a` в `0` і виводить `0`. Інкремент змінної `$a`++
тут не грає ролі, тому що при виході з функції змінна `$a`
зникає. Щоб написати корисну функцію підрахунку, яка не буде
втрачати поточного значення лічильника, змінна `$a` оголошується як
static:

**Приклад #5 Приклад використання статичних змінних**

`<?phpfunction test(){   static $a u003d 0; echo $a; $a++;}?> `

Тепер `$a` буде проініціалізована лише при першому виклику функції,
а кожен виклик функції `test()` буде виводити значення `$a` та
інкрементувати його.

Статичні змінні також дають змогу працювати з рекурсивними
функціями. Рекурсивною є функція, що викликає саму себе. При
написання рекурсивної функції потрібно бути уважним, оскільки є
можливість зробити рекурсію нескінченною. Ви повинні переконатися, що
Існує адекватний спосіб завершення рекурсії. Наступна проста
функція рекурсивно рахує до 10, використовуючи для визначення моменту
зупинки статичну змінну `$count`:

**Приклад #6 Статичні змінні та рекурсивні функції**

` <?phpfunction test(){   static $count u003d 0; $ count++; echo $count; if ($count < 10) {         test(); }   $count--;}?> `

Статичним змінним можна присвоїти значення, що є результатом
вирази, але не можна використовувати для цього функцію, так це викличе
помилку розбору.

**Приклад #7 Оголошення статичних змінних**

`<?phpfunction foo() {    static $int u003d 0; // вірно    static $int u003d 1+2; // Правильно Static $ int u003d sqrt (121); // невірно (оскільки це функція)    $int++; echo $int;}?> `

Починаючи з PHP 8.1.0, коли метод, який використовує статичні змінні,
успадковується (але не перевизначається), успадкований метод тепер буде
використовувати статичні змінні разом із батьківським методом.
Це означає, що статичні змінні в методах тепер поводяться так
ж як статичні властивості.

**Приклад #8 Використання статичних змінних у успадкованих
методах**

` <?phpclass Foo {    public static function counter() {       static $counter u003d 0; $ counter++; return $counter; }}class Bar extends Foo {}var_dump(Foo::counter()); //int(1)var_dump(Foo::counter()); //int(2)var_dump(Bar::counter()); // int(3), до PHP 8.1.0 int(1)var_dump(Bar::counter()); // int(4), до PHP 8.1.0 int(2)?> `

> **Примітка**:
>
> Статичні оголошення обчислюються під час компіляції скрипту.

### Посилання з глобальними (`global`) та статичними (`static`) змінними

PHP використовує модифікатори змінних
[static](language.variables.scope.md#language.variables.scope.static)
і
[global](language.variables.scope.md#language.variables.scope.global)
як [посилання](language.references.md). Наприклад, реальна глобальна
змінна, впроваджена в область видимості функції вказівкою ключового
слова `global`, насправді створює посилання на глобальне
змінну. Це може призвести до несподіваної поведінки, як це
показано в наступному прикладі:

` <?phpfunction test_global_ref() {    global $obj; $newu003du003dnew stdclass; $obj u003d &$new;}function test_global_noref() {    global $obj; $newu003du003dnew stdclass; $obj u003d $new;}test_global_ref();var_dump($obj);test_global_noref();var_dump($obj);?> `

Результат виконання цього прикладу:

NULL
object(stdClass)#1 (0) {
}

Аналогічно поводиться і вираз `static`. Посилання не зберігаються статично:

` <?phpfunction &get_instance_ref() {    static $obj; echo 'Статичний об'єкт: '; var_dump($obj); if (!isset($obj)) {         $new u003d new stdclass; // Присвоїти посилання статичної змінної        $obj u003d &$new; }   if (!isset($obj->property)) {        $obj->property u003d 1; } else {        $obj->property++; }   return $obj;}function &get_instance_noref() {    static $obj; echo 'Статичний об'єкт: '; var_dump($obj); if (!isset($obj)) {         $new u003d new stdclass; // Присвоїти об'єкт статичної змінної         $obj u003d $new; }   if (!isset($obj->property)) {        $obj->property u003d 1; } else {        $obj->property++; }   return $obj;}$obj1 u003d get_instance_ref();$still_obj1 u003d get_instance_ref();echo "
";$obj2 u003d get_instance_noref();$still_obj2 u003d get_instance_noref();?> `

Результат виконання цього прикладу:

Статичний об'єкт: NULL
Статичний об'єкт: NULL

Статичний об'єкт: NULL
Статичний об'єкт: object(stdClass)#3 (1) {
["property"]u003d>
int(1)
}

Цей приклад демонструє, що при привласненні статичного посилання
змінною вона не запам'ятовується, коли ви викликаєте функцію
`&get_instance_ref()` вдруге.
