- [« Основи перерахувань](language.enumerations.basics.md)
- [Методи перерахувань »](language.enumerations.methods.md)

- [PHP Manual](index.md)
- [Перерахування](language.enumerations.md)
- Типізовані перерахування

## Типізовані перерахування

За замовчуванням варіанти перерахувань не мають скалярного еквівалента. Це
просто одноелементні об'єкти. Однак існує безліч випадків,
коли варіанти перерахувань повинні мати можливість звертатися до бази
даних або аналогічному сховищу даних і назад, тому корисно
мати вбудований скалярний (і, отже, тривіально серіалізується)
еквівалент, визначений внутрішньо.

Щоб визначити скалярний еквівалент для перерахувань, використовуйте
наступний синтаксис:

`<?phpenum Suit: string{   case Hearts u003d 'H'; case Diamonds u003d 'D'; case Clubs u003d 'C'; case Spades u003d 'S';}?> `

Варіант, що має скалярний еквівалент, називається типізованим,
оскільки він "підтримується" простішим значенням. Перелік, у
якого всі варіанти типізовані, називається "типізованим
перерахуванням". Типізоване перерахування може містити тільки
типизовані варіанти. Чисте перерахування може містити лише
чисті варіанти.

Типізований перелік може підтримуватися типами `int` або
`string` і цей перелік підтримує тільки один тип за раз (то
є не допускається об'єднання `int|string`). Якщо перерахування
позначено як таке, що має скалярний еквівалент, тоді всі варіанти повинні
мати певний унікальний скалярний еквівалент. Не існує
скалярних еквівалентів, що автоматично генеруються (наприклад,
послідовних цілих чисел). Типізовані варіанти мають бути
унікальними; два варіанти типізованого перерахування не можуть мати
одного й того ж скалярного еквівалента. Однак константа може
ставитись до варіанту, фактично створюючи псевдонім. Дивіться
[Константи перерахувань](language.enumerations.constants.md).

Еквівалентні значення мають бути рядками або рядковими виразами.
Константи та постійні вирази не підтримуються. Тобто `1+1`
дозволено, а `1+SOME_CONST` - ні.

Типизовані варіанти мають додаткову властивість, доступну
тільки для читання, `value`, яке є значенням, вказаним у
визначенні.

` <?phpprint Suit::Clubs->value;// Виведе "C"?> `

Щоб зробити властивість `value` доступною лише для читання, не можна
призначити змінну як посилання неї. Тобто наступний код
видасть помилку:

` <?php$suit u003d Suit::Clubs;$ref u003d &$suit->value;// Error: Cannot acquire reference to property Suit::$value?> `

Типізовані перерахування реалізують внутрішній інтерфейс
[BackedEnum](class.backedenum.md), який надає два
додаткові методи:

- `from(int|string): self` візьме скаляр і поверне відповідний
варіант перерахування. Якщо варіант не знайдено, метод видасть
[ValueError](class.valueerror.md). Це корисно у тих випадках,
коли вхідний скаляр є довіреним, а відсутність значення
Переліки слід розглядати як помилку зупинення програми.
- `tryFrom(int|string): ?self` візьме скаляр і поверне відповідний
варіант перерахування. Якщо варіант не знайдено, метод поверне `null`.
Це корисно в тих випадках, коли вхідний скаляр не є
довіреним і викликає функція хоче реалізувати свою власну
обробку помилок або логіку значення за промовчанням.

Методи `from()` та `tryFrom()` дотримуються стандартних правил
слабкої/суворої типізації. У режимі слабкої типізації допустима передача
цілого числа або рядка та система відповідним чином перетворює
значення. Передача числа з плаваючою точкою також буде працювати з
примусовим перетворенням. У режимі суворої типізації передача
цілого числа `from()` у перерахунку з рядковою типізацією (або
навпаки) призведе до [TypeError](class.typeerror.md), як і передача
числа з плаваючою точкою за будь-яких обставин. Всі інші типи
параметрів викликають помилку TypeError в обох режимах.

` <?php$record u003d get_stuff_from_database($id);print $record['suit'];$suit u003d  Suit::from($record['suit']);// Недопустимі дані видають помилка Value не є припустимим скалярним значенням для перерахування "Suit"print $suit->value;$suit u003d Suit::tryFrom('A') ?? Suit::Spades;// Неприпустимі дані повертають значення null, замого замість цього використовується Suit::Spades.print $suit->value;?> `

Ручне визначення методу `from()` або `tryFrom()` у типизованих
переліки призведе до фатальної помилки.
