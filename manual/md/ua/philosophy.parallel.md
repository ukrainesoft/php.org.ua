- [« Установка](parallel.setup.md)
- [Функціональний API »](functional.parallel.md)

- [PHP Manual](index.md)
- [parallel](book.parallel.md)
- Філософія

# Філософія

Розділ містить основні принципи, важливі для написання паралельного
коду та деякі подробиці про внутрішню реалізацію parallel.

### Не спілкуйтесь, розділяючи пам'ять; замість цього поділіться пам'яттю за допомогою спілкування.

Ця філософія, якої дотримується parallel, бере свій початок із Go,
однією з найпопулярніших із використовуваних платформ для написання
паралельного коду зараз. Програмісти на Go повинні завзято
трудитися, щоб відповідати цьому ідеалу: PHP та паралельний
інтерфейс роблять всю важку роботу за програміста, причому
замовчуванням.

У традиційних моделях потокової передачі, що зустрічаються в інших
мовами, потоки зазвичай обмінюються даними один з одним тільки
завдяки тому факту, що вони працюють в тому самому адресному
просторі. Програміст повинен використовувати взаємний виняток,
змінні умови та інші низькорівневі примітиви потокової передачі
або синхронізації, щоб забезпечити належну передачу стану та
узгодженість.

Коли стандартна модель інвертована, це означає, що потоки спільно
використовують пам'ять лише в результаті обміну даними (наприклад,
змінна передається каналом).

Коли parallel передає змінну з одного потоку до іншого будь-якому
способом - аргументами завдання, поверненням через Future та каналами - вона
передається за значенням. У всіх випадках, крім небуферизованих каналів,
змінна також буферизується, тому вона не може змінитися (або бути
знищена) до того, як вона буде використана в будь-якому потоці,
який передається змінна. Небуферизоване читання каналом -
єдиний випадок, коли потік безпосередньо читає пам'ять,
виділену іншим потоком, це можна зробити безпечно, тому що
потік, який володіє пам'яттю, очікує завершення читання, перш ніж він
зможе продовжити керувати ним, і потік, якому не належить пам'ять,
читає за значенням. Коли обидва потоки продовжують роботу, вони більше не
розділяють пам'ять.

Це значно спрощує написання паралельного коду та міркування про
ньому порівняно з традиційною моделлю багатопоточності. Це означає,
що програмісту не потрібно враховувати, що потоки можуть одночасно
керувати даними, бо це неможливо.

Це також робить PHP ідеальною платформою для реалізації API
паралельного коду на основі CSP (передача повідомлень каналами),
оскільки сам PHP нічого не поділяє – потоки PHP за замовчуванням працюють
у власному віртуальному адресному просторі і тому можуть
спільно використовувати пам'ять лише шляхом обміну даними.

### У даних повинен бути остаточний єдиний власник

Наближаючись до моделі CSP вперше, програміст розбирається в
традиційної моделі потокової передачі, може виявити, що шукає
паралельні структури даних, тому що це те, що вони теж
використовують: вони передають загальні об'єкти управління.

Коли справа доходить до моделі CSP, немає потреби в тому, щоб
структури даних спільно використовувалися багатьма завданнями та
дійсно це простіше, якщо це не так. Дані повинні належати
одного завдання, зміни (або операції) у цій структурі даних повинні
передаватися каналами та виконуватися власником даних, успішне
виконання, помилка або результат (стан) зміни (або операції)
передається назад.

Знову ж таки, природа PHP нічого не поділяє і природа паралельного
копіювання за значенням допомагають програмісту досягти цієї мети, ніякі
дані не будуть передані випадково лише в результаті обміну даними.
