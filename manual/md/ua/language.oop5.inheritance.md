- [« Область видимості](language.oop5.visibility.md)
- [Оператор роздільної здатності (::)
»](language.oop5.paamayim-nekudotayim.md)

- [PHP Manual](index.md)
- [Класи та об'єкти](language.oop5.md)
- успадкування

## Спадкування

Наслідування — це принцип, що добре себе зарекомендував.
програмування, і PHP використовує цей принцип у своїй об'єктній
моделі. Цей принцип вплине на те, як багато класів та об'єктів пов'язані
один з одним.

Наприклад, при розширенні класу дочірній клас успадковує все
загальнодоступні та захищені методи, властивості та константи батьківського
класу. Доки ці методи не будуть перевизначені, вони будуть
зберігати свою вихідну функціональність.

Це корисно для визначення та абстрагування функціональності та
дозволяє реалізувати додаткову функціональність у схожих об'єктах
без потреби реалізовувати всю загальну функціональність.

Закриті методи батьківського класу недоступні для дочірнього класу. В
результаті дочірні класи можуть повторно реалізувати закритий метод без
обліку традиційних правил успадкування. Однак до PHP 8.0.0 до закритих
методам застосовувалися обмеження `final` та `static`. Починаючи з PHP 8.0.0,
єдине обмеження закритого методу, що застосовується – це
конструктори `private final`, оскільки це звичайний спосіб "відключити"
конструктор під час використання замість нього статичних фабричних методів.

[Видимість](language.oop5.visibility.md) методів, властивостей та констант
можна послабити, наприклад, 'захищений' метод може бути помічений як
загальнодоступний, але не можна обмежити видимість, наприклад, не можна
позначити 'загальнодоступну' властивість як 'закриту'.

> **Примітка**:
>
> Якщо не використовується автозавантаження, класи повинні бути оголошені до
> те, як вони будуть використовуватися. Якщо клас розширює інший, то
> батьківський клас має бути оголошений до наступного класу. Це
> правило застосовується до класів, які успадковують інші класи або
> інтерфейси.

> **Примітка**:
>
> Не дозволяється перевизначати властивість читання-запису за допомогою
> [readonly-властивості](language.oop5.properties.md#language.oop5.properties.readonly-properties)
> чи навпаки.
>
> `<?phpclass A {    public int $prop;}class B extends A {    // Неможна: read-write ->readonly    public readonly int 

**Приклад #1 Приклад успадкування**

` <?phpclass Foo{    public function printItem($string)    {       echo 'Foo: ' . $string. PHP_EOL; }    public function printPHP()    {        echo 'PHP просто супер.' . PHP_EOL; }}class Bar extends Foo{    public function printItem($string)    {        echo 'Bar: ' . $string. PHP_EOL; }}$foo u003d new Foo();$bar u003d new Bar();$foo->printItem('baz'); // Виведе: 'Foo: baz'$foo->printPHP(); // Виведе: 'PHP просто супер'$bar->printItem('baz'); // Виведе: 'Bar: baz'$bar->printPHP(); // Виведе: 'PHP просто супер'?> `

### Сумісність типів значень, що повертаються, з внутрішніми класами

До PHP 8.1.0 більшість внутрішніх класів чи методів не оголошували
свої типи значень, що повертаються, і при їх розширенні допускався будь-який тип
значення, що повертається.

Починаючи з PHP 8.1.0, більшість внутрішніх методів розпочали
"попередньо" оголошувати тип значення, що повертається. В цьому випадку тип
значення методів, що повертаються, повинен бути сумісний з розширюваним
батьком; інакше видається повідомлення про старіння.
Зверніть увагу, що відсутність явного оголошення типу, що повертається
значення також вважається невідповідністю сигнатури і, відповідно,
призводить до повідомлення про старіння.

Якщо тип значення, що повертається, не може бути оголошений для
перевизначуваного методу через проблеми із сумісністю з різними
версіями PHP, може бути доданий атрибут `#[ReturnTypeWillChange]`,
щоб заглушити повідомлення про старіння.

**Приклад #2 Перевизначальний метод не оголошує жодного типу
значення, що повертається**

` <?phpclass MyDateTime extends DateTime{    public function modify(string $modifier) { return false; }}// "Deprecated: Return type of MyDateTime::modify(string$$modifier) should either be compatible with DateTime::modify(string $modifier): DateTime|false, temporarily suppress the notice", починаючи с PHP 8.1.0?> `

**Приклад #3 Перевизначальний метод оголошує невірний тип повертається
значення**

`<?phpclass MyDateTime extends DateTime{    public function modify(string $modifier): ?DateTime { return null; }}// "Deprecated: Return type of MyDateTime::modify(string$$modifier): ?DateTime should either becompatible with DateTime::false|string| be used to temporarily suppress the notice", починаючи з PHP 8.1.0?> `

**Приклад #4 Перевизначальний метод оголошує невірний тип повертається
значення без повідомлення про старіння**

` <?phpclass MyDateTime extends DateTime{    /**     * @return DateTime|false     */    #[ReturnTypeWillChange]          ¦¦ }}// Повідомлення про старіння не виводиться?> `
