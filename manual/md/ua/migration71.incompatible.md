- [« Нові глобальні константи](migration71.constants.md)
- [Функціонал, оголошений застарілим у PHP 7.1.x
»](migration71.deprecated.md)

- [PHP Manual](index.md)
- [Міграція з PHP 7.0.x на PHP 7.1.x](migration71.md)
- Зміни, що ламають зворотну сумісність

## Зміни, що ламають зворотну сумісність

### Виклик виключення при передачі функції недостатньої кількості аргументів

Раніше, якщо функція користувача викликалася з недостатнім
кількістю аргументів видавалося попередження. Тепер же, замість
попередження викликатиметься виняток класу Error. Ця зміна
зачіпає тільки функції користувача і не впливає на
вбудовані. Наприклад:

` <?phpfunction test($param){}test(); `

Результатом виконання цього прикладу буде щось подібне:

Error error: Uncaught ArgumentCountError: Щасливі argumentи до функцій test(), 0 passed in %s on line %d and exactly 1 expected in %s:%d

### Заборона динамічного виклику функцій інтроспекції області видимості

Динамічні виклики певних функцій було заборонено (у вигляді
`$func()` або `array_map('extract', ...)`, і т.д.) Ці функції перевіряють
або модифікують об'єкти іншої області видимості, ніж викликають
неоднозначна та невизначена поведінка. Список таких функцій:

- [assert()](function.assert.md) - з рядком як перший
аргументу
- [compact()](function.compact.md)
- [extract()](function.extract.md)
- [func_get_args()](function.func-get-args.md)
- [func_get_arg()](function.func-get-arg.md)
- [func_num_args()](function.func-num-args.md)
- [get_defined_vars()](function.get-defined-vars.md)
- [mb_parse_str()](function.mb-parse-str.md) - з одним аргументом
- [parse_str()](function.parse-str.md) - з одним аргументом

` <?php(function () {    $func u003d 'func_num_args';    $func();})(); `

Результат виконання цього прикладу:

Warning: Cannot call func_num_args() dynamically в %s on line %d

### Некоректні імена класів, інтерфейсів та трейтів

Наступні імена не можна використовувати як імена класів, інтерфейсів або
трейтів:

- void
- [iterable](language.types.iterable.md)

### Перетворення числових рядків тепер враховує наукову нотацію

Цілочисленні операції та конвертації числових рядків тепер враховують
наукову нотацію, включаючи приведення `(int)` та такі функції:
[intval()](function.intval.md) (з базою 10),
[settype()](function.settype.md), [decbin()](function.decbin.md),
[decoct()](function.decoct.md) та [dechex()](function.dechex.md).

### Виправлення алгоритму [mt_rand()](function.mt-rand.md)

[mt_rand()](function.mt-rand.md) тепер за замовчуванням використовує
зафіксовану версію алгоритму "Вихор Мерсена" Якщо ви покладалися на
детермінований висновок [mt_srand()](function.mt-srand.md), можна
використовувати константу **`MT_RAND_PHP`** як друге,
необов'язкового параметра [mt_srand()](function.mt-srand.md) для
збереження старої (неправильної) реалізації.

### [rand()](function.rand.md) псевдонім для [mt_rand()](function.mt-rand.md) та [srand()](function.srand.md) псевдонім для [mt_srand() ](function.mt-srand.md)

[rand()](function.rand.md) та [srand()](function.srand.md) тепер
є просто синонімами для [mt_rand()](function.mt-rand.md) та
[mt_srand()](function.mt-srand.md). Це означає, що виведення наступних
функцій змінився: [rand()](function.rand.md),
[shuffle()](function.shuffle.md),
[str_shuffle()](function.str-shuffle.md) та
[array_rand()](function.array-rand.md).

### Заборона використовувати символ видалення з таблиці ASCII в ідентифікаторах

Символ видалення ASCII (`0x7F`) більше не можна використовувати в
ідентифікаторах, не обгорнутих у лапки.

### Значення `error_log` змінено на `syslog`

Якщо ini-параметр `error_log` встановлений як `syslog`, то рівні помилок
PHP проектується на рівні помилок "syslog". Це дозволяє більш тонко
логувати події, а не як раніше, коли всі вони записувалися з
рівнем "notice".

### Деструктори не викликаються на незавершених об'єктах

Тепер деструктори ніколи не викликаються, якщо було викликано виключення
конструктор об'єкта. Раніше ця поведінка залежала від того, чи була
посилання на об'єкт поза конструктором (наприклад, у трасуванні виключення).

### [call_user_func()](function.call-user-func.md) обробляє посилання на аргументи

Тепер [call_user_func()](function.call-user-func.md) завжди викликає
попередження, якщо викликається функція, що очікує посилання як
параметрів. Раніше це залежало від того, чи був виклик повністю
певним.

Крім того, [call_user_func()](function.call-user-func.md) та
[call_user_func_array()](function.call-user-func-array.md) більше не
припиняють виконання функції у разі. Попередження "expected
reference" буде викликано, але сама функція продовжить виконання.

### Оператор порожнього індексу більше не застосовується до рядків

Застосування оператора порожнього індексу до рядка (`$str[] u003d $x`) викликає
фатальну помилку замість тихого перетворення змінної масиву.

### Присвоєння через механізм доступу до елемента рядка за індексом стосовно порожнього рядка

Модифікація символу в порожньому рядку тепер працює так само, як і для не
порожній. Тобто. запис по неіснуючому зміщенню призведе до
перетворення не цілого значення зсуву до цілого числа,
доповнення рядка до потрібної довжини символами пропуску та використання
тільки першого символу з рядка, що привласнюється. Раніше, в такій
ситуації, порожній рядок розглядався як порожній масив.

` <?php$a u003d '';$a[10] u003d 'foo';var_dump($a);?> `

Результат виконання цього прикладу в PHP 7.0:

array(1) {
[10] u003d>
string(3) "foo"
}

Результат виконання цього прикладу в PHP 7.1:

string(11) " f"

### Віддалені ini-директиви

Наступні ini-директиви були видалені:

- `session.entropy_file`
- `session.entropy_length`
- `session.hash_function`
- `session.hash_bits_per_character`

### Порядок масиву, коли елементи створені автоматично через присвоєння посилання, було змінено

Порядок розташування елементів масиву, створюваних присвоєнням по
посилання не створених на момент присвоєння елементів, було змінено. До
Наприклад:

` <?php$array u003d [];$array["a"] u003d& $array["b"];$array["b"] u003d 1;var_dump($array);?> `

Результат виконання цього прикладу в PHP 7.0:

array(2) {
["a"]u003d>
&int(1)
["b"]u003d>
&int(1)
}

Результат виконання цього прикладу в PHP 7.1:

array(2) {
["b"]u003d>
&int(1)
["a"]u003d>
&int(1)
}

### Порядок сортування еквівалентних елементів

Внутрішній алгоритм сортування був покращений, що може призвести до відмінності
у порядку розташування еквівалентних елементів після сортування за
порівняно з попередніми версіями PHP.

> **Примітка**:
>
> Не покладайтеся на порядок розташування еквівалентних елементів, так
> як він може будь-якої миті змінитися.

### Повідомлення для помилок E_RECOVERABLE

Повідомлення для помилок E_RECOVERABLE змінено з "Catchable fatal error" на
"Recoverable fatal error".

### Параметр $options функції unserialize()

Тепер елемент `allowed_classes` параметра $options функції
[unserialize()](function.unserialize.md) строго типізований, тобто
якщо передати значення з типом, відмінним від array та bool, то
unserialize() поверне **`false`** та викличе помилку рівня
**`E_WARNING`**.

### Конструктор DateTime використовує мікросекунди

Тепер [DateTime](class.datetime.md) та
[DateTimeImmutable](class.datetimeimmutable.md) використовують
мікросекунди при створенні з поточним часом, або у явному вигляді, або з
рядком відносного часу (наприклад,
``first day of next month``). Це означає, що порівняння двох поспіль
створених екземплярів класу швидше повертатиме **`false`** ніж
**`true`**:

` <?phpnew DateTime() u003du003d new DateTime();?> `

### Виклик винятків [Error](class.error.md) замість фатальних помилок

Для модуля Date при некоректних даних серіалізації класів
[DateTime](class.datetime.md) або [DatePeriod](class.dateperiod.md),
або помилки ініціалізації часового поясу із серіалізованих даних, буде
викидатися виняток [Error](class.error.md) з методів
**\_\_wakeup()** або **\_\_set_state()**, замість виклику фатальної
помилки.

У модулі DBA функції маніпулювання даними (такі як
[dba_insert()](function.dba-insert.md)) тепер будуть викидати
виняток [Error](class.error.md) замість виклику відловлюваного
фатальної помилки якщо ключ не містить двох елементів.

У модулі DOM некоректна перевірка контексту схеми або RelaxNG тепер
викидають виняток [Error](class.error.md) замість виклику
фатальної помилки. Аналогічно, спроби зареєструвати клас
вузла, який не розширює правильний базовий клас, спроби прочитати
некоректна властивість або перезаписати властивість доступна тільки для
Читання будуть викидати виняток [Error](class.error.md).

У модулі IMAP адреса email довша 16385 байт тепер викидатиме
виняток [Error](class.error.md) замість виклику фатальної помилки.

Модуль Intl у разі виникнення помилки виклику батьківського
конструктора в класі, що наслідує [Collator](class.collator.md) до
виклику батьківських методів тепер викидатиме виняток
[Error](class.error.md) замість виклику фатальної помилки. Крім того,
клонування об'єкта [Transliterator](class.transliterator.md) тепер
буде викидати виняток [Error](class.error.md) у разі
виникнення помилки клонування внутрішнього transliterator замість
виклику фатальної помилки.

Модуль LDAP при вказівці невідомого типу модифікації в
**ldap_batch_modify()** тепер викидатиме виняток
[Error](class.error.md) замість виклику фатальної помилки.

У модулі mbstring функції [mb_ereg()](function.mb-ereg.md) та
[mb_eregi()](function.mb-eregi.md) тепер викидатимуть виняток
[ParseError](class.parseerror.md) у разі некоректного регулярного
висловлювання чи разі використання опції 'e'.

У модулі Mcrypt [mcrypt_encrypt()](function.mcrypt-encrypt.md) та
[mcrypt_decrypt()](function.mcrypt-decrypt.md) тепер буде
викидати виняток [Error](class.error.md) замість фатального виклику
помилки, якщо mcrypt не ініціалізовано.

У модулі mysqli спроби прочитати некоректну властивість або перезаписати
властивість доступна тільки для читання викидатиме виняток
[Error](class.error.md) замість виклику фатальної помилки.

У модулі Reflection невдале вилучення відбитого об'єкта або
властивості об'єкта викидають виняток [Error](class.error.md)
замість виклику фатальної помилки.

У модулі сесій користувальницькі обробники сесії, які не
повертають рядок для ідентифікатора сесії, викидатимуть
виняток [Error](class.error.md) замість виклику фатальної помилки,
коли буде викликано функцію для генерації ідентифікатора.

У модулі SimpleXML спроба створення безіменного чи дублюючого
атрибута буде викидати виняток [Error](class.error.md) замість
виклику фатальної помилки.

У модулі SPL спроба клонувати об'єкт **SplDirectory** буде
викидати виняток [Error](class.error.md) замість фатального виклику
помилки. Аналогічно, виклик
[ArrayIterator::append()](arrayiterator.append.md) коли ітерація
об'єкта закінчена буде викидати виняток
[Error](class.error.md).

Функція [assert()](function.assert.md), коли їй передано рядковий
аргумент першим параметром, тепер викидатиме виняток
[ParseError](class.parseerror.md) замість виклику відловлюваного
фатальної помилки, якщо PHP код некоректний. Аналогічно, виклик
[forward_static_call()](function.forward-static-call.md) за межами
простору класу викидатиме виняток
[Error](class.error.md).

У модулі Tidy ручне створення [tidyNode](class.tidynode.md) буде
викидати виняток [Error](class.error.md).

У модулі WDDX циклічні посилання під час серіалізації будуть викидати
виняток [Error](class.error.md) замість виклику фатальної помилки.

У модулі XML-RPC циклічні посилання серіалізації будуть викидати
виняток [Error](class.error.md) замість виклику фатальної помилки.

У модулі Zip метод [ZipArchive::addGlob()](ziparchive.addglob.md)
викидатиме виняток [Error](class.error.md) замість виклику
фатальної помилки, якщо відсутня підтримка glob.

### Лексично пов'язані змінні не можуть перевикористовувати імена

Змінні, прив'язані до [замикання](functions.anonymous.md) через
конструкцію `use`, не можуть використовувати ті ж імена, що і будь-які
[superglobals](language.variables.predefined.md), `$this` або
параметри. Наприклад, всі наведені функції викликають фатальну помилку:

` <?php$f u003d function () use ($_SERVER) {};$f u003d function () use ($this) {};$f u003d function ($param) use ($param) {}; `

### Змінено тип параметра long2ip()

Тепер [long2ip()](function.long2ip.md) очікує параметр типу int, а не
string.

### Кодування та декодування JSON

INI-налаштування `serialize_precision` визначає точність серіалізації при
кодування значень типу float.

Тепер декодування порожнього ключа призводить до появи властивості з
порожнім ім'ям, раніше ім'я властивості наводилося до значення `_empty_`.

`<?phpvar_dump(json_decode(json_encode([''u003d> 1])))); `

Результатом виконання цього прикладу буде щось подібне:

object(stdClass)#1 (1) {
[""]u003d>
int(1)
}

Під час передачі прапора **`JSON_UNESCAPED_UNICODE`** у функцію
[json_encode()](function.json-encode.md) послідовності U+2028 та
U+2029 буде екрановано.

### Зміна в семантиці параметрів [mb_ereg()](function.mb-ereg.md) та [mb_eregi()](function.mb-eregi.md)

Третій параметр функцій [mb_ereg()](function.mb-ereg.md) та
[mb_eregi()](function.mb-eregi.md) (`regs`) тепер встановлюється
рівним порожньому масиву, якщо не було знайдено збігів. Раніше параметр
залишався незмінним.

### Видалена підтримка потоку sslv2

Підтримка потоку sslv2 у OpenSSL видалена.

### Заборонено "return;" для типізованих повернень вже під час компіляції

Оператори повернення без аргументів у функціях, які оголошують тип
значення, що повертається, тепер викликають **`E_COMPILE_ERROR`** (якщо тип
повернення не оголошено як void), навіть якщо оператор ніколи не
буде досягнуто.
