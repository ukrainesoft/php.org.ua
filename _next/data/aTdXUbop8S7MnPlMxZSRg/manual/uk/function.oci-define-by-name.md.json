{"pageProps":{"page":{"slug":"function.oci-define-by-name.md","content":"# oci\\_define\\_by\\_name\n\n(PHP 5, PHP 7, PHP 8, PECL OCI8 >= 1.1.0)\n\noci\\_define\\_by\\_name — Порівняє змінну PHP стовпцю результату запиту\n\n### Опис\n\n```methodsynopsis\noci_define_by_name(    resource $statement,    string $column,    mixed &$var,    int $type = 0): bool\n```\n\nСопоставляет переменную PHP столбцу результата запроса, полученного с помощью[oci\\_fetch()](function.oci-fetch.md)\n\nВиклик \\*\\*oci\\_define\\_by\\_name()\\*\\*должен производиться до запуска[oci\\_execute()](function.oci-execute.md)\n\n### Список параметрів\n\n`statement`\n\nКоректний ідентифікатор виразу OCI8, отриманий з [oci\\_parse()](function.oci-parse.md) та виконаний функцією [oci\\_execute()](function.oci-execute.md), або ідентифікатор виразу `REF CURSOR`\n\n`column`\n\nІм'я стовпця використаного у запиті.\n\nВикористовуйте верхній регістр для стандартних незалежних імен стовпців Oracle. Використовуйте точне написання імені стовпця для реєстрозалежних імен.\n\n`var`\n\nЗмінна PHP, призначена для зберігання поверненого значення.\n\n`type`\n\nТип даних, що повертаються. Зазвичай не потрібно. Майте на увазі, що перетворення Oracle-даних не виконуються. Наприклад, `SQLT_INT` буде проігноровано і повернені дані будуть, як і раніше, у вигляді `SQLT_CHR`\n\nЯкщо вам потрібно призначити змінну абстрактного типу даних (LOB/ROWID/BFILE), її необхідно спочатку створити за допомогою [oci\\_new\\_descriptor()](function.oci-new-descriptor.md)\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** oci\\_define\\_by\\_name()\\*\\*\\*\\*\n\n```php\n<?php\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$sql = 'SELECT location_id, city FROM locations WHERE location_id < 1200';\n$stid = oci_parse($conn, $sql);\n\n// Переменные ДОЛЖНЫ быть определены перед запуском\noci_define_by_name($stid, 'LOCATION_ID', $locid);\noci_define_by_name($stid, 'CITY', $city);\n\noci_execute($stid);\n\n//  Каждый результат запроса помещает в заранее определённую переменную следующую строку данных\nwhile (oci_fetch($stid)) {\n    echo \"ID местоположения $locid - $city<br>\\n\";\n}\n\n// Выведет:\n//   ID местоположения 1000 - Roma\n//   ID местоположения 1100 - Venice\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #2 Приклад використання** oci\\_define\\_by\\_name()\\*\\* з реєстрозалежними іменами стовпців\\*\\*\n\n```php\n<?php\n\n/*\n  До запуска, создаётся таблица со столбцом, имеющим регистрозависимое имя\n    CREATE TABLE mytab (id NUMBER, \"MyDescription\" VARCHAR2(30));\n    INSERT INTO mytab (id, \"MyDescription\") values (1, 'Iced Coffee');\n    COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT * FROM mytab');\n\n// Используется верхний регистр для регистронезависимых имён столбцов\noci_define_by_name($stid, 'ID', $id);\n\n// Используется точное написание для регистрозависимых имён столбцов\noci_define_by_name($stid, 'MyDescription', $mydesc);\n\noci_execute($stid);\n\nwhile (oci_fetch($stid)) {\n    echo \"Идентификатор $id - $mydesc<br>\\n\";\n}\n\n// Выведет:\n//   Идентификатор 1 - Iced Coffee\n\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #3 Приклад використання** oci\\_define\\_by\\_name()\\*\\* зі стовпцями типу LOB\\*\\*\n\n```php\n<?php\n\n/*\n  Перед запуском создаются таблицы:\n    CREATE TABLE mytab (id NUMBER, fruit CLOB);\n    INSERT INTO mytab (id, fruit) values (1, 'apple');\n    INSERT INTO mytab (id, fruit) values (2, 'orange');\n    COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT * FROM mytab');\n\n// Переменные ДОЛЖНЫ быть определены перед запуском\noci_define_by_name($stid, 'ID', $id);\noci_define_by_name($stid, 'FRUIT', $fruit);  // $fruit станет дескриптором LOB\n\noci_execute($stid);\n\nwhile (oci_fetch($stid)) {\n    echo $id . \" - \" . $fruit->load(100) . \"<br>\\n\";\n}\n\n// Выведет:\n//   1 - apple\n//   2 - orange\n\n$fruit->free();\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n**Приклад #4 Приклад використання** oci\\_define\\_by\\_name()\\*\\* з наведеними типами\\*\\*\n\n```php\n<?php\n\n/*\n  Перед запуском создаётся таблица:\n    CREATE TABLE mytab (id NUMBER, fruit CLOB);\n    INSERT INTO mytab (id, fruit) values (1, 'apple');\n    INSERT INTO mytab (id, fruit) values (2, 'orange');\n    COMMIT;\n*/\n\n$conn = oci_connect('hr', 'welcome', 'localhost/XE');\nif (!$conn) {\n    $e = oci_error();\n    trigger_error(htmlentities($e['message'], ENT_QUOTES), E_USER_ERROR);\n}\n\n$stid = oci_parse($conn, 'SELECT * FROM mytab');\n\n// Переменные ДОЛЖНЫ быть определены перед запуском\noci_define_by_name($stid, 'ID', $id);\n\n$fruit = oci_new_descriptor($conn, OCI_D_LOB);\noci_define_by_name($stid, 'FRUIT', $fruit, OCI_D_CLOB);\n\noci_execute($stid);\n\nwhile (oci_fetch($stid)) {\n    echo $id . \" - \" . $fruit->load(100) . \"<br>\\n\";\n}\n\n// Выведет:\n//   1 - apple\n//   2 - orange\n\n$fruit->free();\noci_free_statement($stid);\noci_close($conn);\n\n?>\n```\n\n### Дивіться також\n\n-   [oci\\_fetch()](function.oci-fetch.md) \\- Вибирає наступний рядок із результату в буфер\n-   [oci\\_new\\_descriptor()](function.oci-new-descriptor.md) \\- Ініціалізує новий дескриптор об'єкта LOB чи FILE\n","title":"oci\\_define\\_by\\_name","contentType":2,"navigation":[{"function.oci-connect.md":"« oci\\_connect"},{"function.oci-error.md":"oci\\_error »"},{"index.md":"PHP Manual"},{"ref.oci8.md":"OCI8 Функції"}]}},"__N_SSG":true}