{"pageProps":{"page":{"slug":"regexp.reference.escape.md","content":"## Екрануючі послідовності\n\nЗворотня коса риса («\\\\») має кілька призначень. Насамперед, якщо вона передує не буквенно-цифровому символу, вона знімає з нього спеціальне значення, яке міг мати. Застосування зворотної косої риси як символу, що екранує, припустимо як у символьному класі, так і поза ним.\n\nНаприклад, якщо потрібно задати відповідність символу «\\*», у шаблоні вказують «\\\\\\*». Це запобігатиме трактуванню наступного символу як метасимволу з особливим значенням. У будь-яких випадках безпечно екранувати не буквено-цифрові символи символом зворотної косої риси.\\\\», якщо потрібно переконатися, що вони означають у шаблоні себе. В окремому випадку для порівняння з самим символом зворотної косої межі, використовуйте запис «\\\\\\\\».\n\n> **Зауваження** :\n> \n> [PHP-рядки](language.types.string.md#language.types.string.syntax), Укладені в одинарні і подвійні лапки, по-особливому інтерпретують зворотну косу межу. Таким чином, якщо необхідно порівняти \\\\ з регулярним виразом \\\\\\\\, у PHP-коді потрібно використовувати \"\\\\\\\\\\\\\\\\\"або\"\\\\\\\\\\\\\\\\'.\n\nЯкщо вказано модифікатор [PCRE\\_EXTENDED](reference.pcre.pattern.modifiers.md), пробілові символи шаблону (поза описом символьного класу) ігноруються. Також ігнорується частина рядка, що знаходиться між символом «#» (знову ж таки, що не бере участі в описі символьного класу) і наступним символом перекладу рядка. У цій ситуації зворотний сліш можна застосовувати як екрануючий символ для вказівки входжень пробельних символів або символу # у шаблоні.\n\nДруге застосування зворотного слеша полягає в тому, що він дозволяє використовувати недруковані символи у видимій формі в описі шаблону. При тому, що в PCRE немає обмежень на використання недрукованих символів (за винятком бінарного нуля, який інтерпретується як кінець шаблону), при редагуванні програмного коду в якомусь текстовому редакторі набагато зручніше використовувати такі комбінації, ніж реальні символи, які вони представляють:\n\n*\\\\a*\n\nсимвол оповіщення, сигнал (BEL, шістнадцятковий код 07)\n\n*\\\\cx*\n\n\"control+x\", де x - довільний символ\n\n*\\\\e*\n\nescape (шістнадцятковий код 1B)\n\n*\\\\f*\n\nрозрив сторінки (шістнадцятковий код 0C)\n\n*\\\\n*\n\nпереклад рядка (шістнадцятковий код 0A)\n\n*\\\\p{xx}*\n\nсимвол із властивістю xx, докладніше про це розказано у розділі «[Властивості Unicode-символів](regexp.reference.unicode.md)»\n\n*\\\\P{xx}*\n\nсимвол без властивості xx, докладніше про це розказано у розділі «[Властивості Unicode-символів](regexp.reference.unicode.md)»\n\n*\\\\r*\n\nповернення каретки (шістнадцятковий код 0D)\n\n*\\\\R*\n\nрозрив рядка: збігається з \\\\n,\\\\r и\\\\r\\\\n\n\n*\\\\t*\n\nтабуляція (шістнадцятковий код 09)\n\n*\\\\xhh*\n\nсимвол з шістнадцятковим кодом hh\n\n*\\\\ddd*\n\nсимвол із вісімковим кодом ddd, або посилання на підмаску\n\nЯкщо бути точнішим, комбінація «`\\cx`» інтерпретується так: якщо «`x`» - символ нижнього регістру, він перетворюється на верхній регістр. Після цього шостий біт символу (шістнадцятковий код 40) інвертується. Таким чином, \"`\\cz`» інтерпретується як шістнадцяткове значення 1A, тоді як «`\\c{`» отримує шістнадцяткове значення 3B, а «`\\c;`» — 7B.\n\nПісля «`\\x`» зчитуються ще дві шістнадцяткові цифри (вони можуть бути записані в нижньому або верхньому регістрі). У *режимі UTF-8*, дозволяється використання «`\\x{...}`», де вміст дужок є рядком із шістнадцяткових цифр. Вона інтерпретується як символ UTF-8 character з кодом, що збігається з цим шістнадцятковим числом. Вихідна шістнадцяткова екрануюча послідовність, `\\xhh`, збігається з двобайтним UTF-8 символом, якщо його значення перевищує 127.\n\nПісля «`\\0`» зчитуються дві вісімкові цифри. Якщо в записі менше двох цифр, будуть використані всі цифри, що фактично присутні. Таким чином, послідовність`\\0\\x\\07`» буде інтерпретована як два бінарних нулі, за якими слідує символ оповіщення (дзвінок). Якщо ви використовуєте подання числа у вісімковому коді, переконайтеся, що за початковим нулем йдуть дві цифри.\n\nОбробка зворотного сліша, за яким слідує ненульова цифра, дещо складніше. Поза символьного класу PCRE сприймає зворотний слєш і такі цифри як десяткове число. Якщо отримане значення менше десяти, або якщо шаблон містить щонайменше таку кількість попередніх поточної позиції підмасок, вся конструкція інтерпретується як *посилання на підмаску*. Більш детальний опис буде наведено нижче під час обговорення механізму роботи підмасок.\n\nВсередині символьного класу, або якщо отримане значення більше 9 і відповідна кількість попередніх підмасок відсутня, PCRE зчитує до трьох вісімкових цифр, що йдуть за зворотним слешем, і генерує один байт з останніх 8 значних бітів отриманого значення. Усі наступні цифри позначають себе. Наприклад:\n\n*\\\\040*\n\nще один спосіб запису пробілу\n\n*\\\\40*\n\nте саме, якщо даного запису передує менше сорока підмасок\n\n*\\\\7*\n\nзавжди інтерпретується як посилання на підмаску\n\n*\\\\11*\n\nможе бути як зворотним посиланням, так і альтернативним записом символу табуляції\n\n*\\\\011*\n\nзавжди інтерпретується як символ табуляції\n\n*\\\\0113*\n\nсимвол табуляції, за яким слідує цифра «3»\n\n*\\\\113*\n\nінтерпретується як символ з вісімковим кодом 113 (оскільки посилань на підмаски не може бути більш ніж 99)\n\n*\\\\377*\n\nбайт, що повністю складається з одиничних бітів\n\n*\\\\81*\n\nабо зворотне посилання, або бінарний нуль, за яким йдуть цифри «8» і «1»\n\nСлід пам'ятати, що вісімкові значення, що перевищують 100, слід писати без лідируючого нуля, тому що читається не більше трьох вісімкових цифр.\n\nУсі послідовності, що визначають однобайтне значення, можуть зустрічатися як усередині, так і поза символьними класами. Крім того, всередині символьного класу запис «`\\b`» інтерпретується як символ повернення («backspace», шістнадцятковий код 08). Поза символьним класом вона має інше значення (яке саме, описано нижче).\n\nТретє використання зворотного сліша - вказівка ​​загального типу символів:\n\n*\\\\d*\n\nбудь-яка десяткова цифра\n\n*\\\\D*\n\nбудь-який символ, крім десяткової цифри\n\n*\\\\h*\n\nбудь-який горизонтальний символ пробілу\n\n*\\\\H*\n\nбудь-який символ, що не є горизонтальним символом пробілу\n\n*\\\\s*\n\nбудь-який пробіловий символ\n\n*\\\\S*\n\nбудь-який непробільний символ\n\n*\\\\v*\n\nбудь-який вертикальний символ пробілу\n\n*\\\\V*\n\nбудь-який символ, що не є вертикальним символом пробілу\n\n*\\\\w*\n\nБудь-який символ, що утворює «слово»\n\n*\\\\W*\n\nБудь-який символ, що не утворює «слово»\n\nКожна пара таких спеціальних послідовностей ділить повну множину всіх символів на дві множини, що не перетинаються. Будь-який символ відповідає одній і тільки одній множині з пари.\n\nНаступні символи вважаються «пробільні»: HT (9), LF (10), FF (12), CR (13), і пробіл (32). Тим не менш, якщо йде локале-залежний пошук, і відбудеться збіг з символами в діапазоні 128-255, вони також будуть сприйняті як пробільні, наприклад, NBSP (A0).\n\nСимвол, що утворює «слово» - це довільна цифра, буква або символ підкреслення, простіше кажучи, будь-який символ, який може бути частиною «*слова*» у Perl. Визначення літер та цифр управляється символьними таблицями, з якими було зібрано PCRE. І, як наслідок, ці набори можуть відрізнятися у різних локалізованих дистрибутивах. Наприклад, у локалі «fr» (Франція) ряд символів із кодом вище 128 застосовують для запису ударних символів і тому вони відповідають масці `\\w`\n\nНаведені вище типи символів можуть застосовуватися як усередині, так і поза символьними класами, і відповідають одному символу даного типу. Якщо поточна точка порівняння знаходиться в кінці рядка, жоден з них не зможе збігтися, тому що немає символу, з яким може статися збіг.\n\nЧетверте використання зворотного слеша — визначення деяких формальних тверджень, що описують умови щодо розташування особливих позицій у рядку і зовсім не зачіпають самі символи. Використання підмасок як складніших формальних тверджень описано нижче. Такими керуючими послідовностями є:\n\n*\\\\b*\n\nмежа слова\n\n*\\\\B*\n\nне є межею слова\n\n*\\\\A*\n\nпочаток даних (незалежно від багаторядкового режиму)\n\n*\\\\Z*\n\nкінець даних чи позиція перед останнім перекладом рядка (незалежно від багаторядкового режиму)\n\n*\\\\z*\n\nкінець даних (незалежно від багаторядкового режиму)\n\n*\\\\G*\n\nперша позиція, що збігається в рядку\n\nОписані вище послідовності що неспроможні зустрічатися у символьних класах (виключаючи комбінацію «`\\b`», що всередині класу означає символ повернення «backspace»).\n\nКордоном слова вважається така позиція у рядку, в якому з поточного та попереднього символу лише один відповідає `\\w`или`\\W` (тобто один з них відповідає `\\w`, а другой`\\W`). Початок або кінець рядка також відповідають межі слова Якщо перший або відповідно останній символ збігається з `\\w`\n\nСпеціальні послідовності `\\A` `\\Z`и`\\z` відрізняються від загальновживаних метасимволів початку рядка («^») і кінця рядка («$»), описаних у розділі «[Якоря](regexp.reference.anchors.md)», тим, що вони завжди збігаються або на самому початку або наприкінці рядка. На них ніяк не впливають опції [PCRE\\_MULTILINE](reference.pcre.pattern.modifiers.md) і [PCRE\\_DOLLAR\\_ENDONLY](reference.pcre.pattern.modifiers.md)Разница между`\\Z`и`\\z` у тому, що `\\Z` відповідає позиції перед останнім символом Якщо останній символ — переклад рядка, крім кінця кінця рядка. В той час як `\\z` відповідає виключно кінцю даних.\n\nУтверждение`\\G` є дійсним тільки в тому випадку, якщо поточна позиція знаходиться на початку збігу, вказаного параметром `offset` функції [preg\\_match()](function.preg-match.md)Она отличается от`\\A`при ненулевом значении параметра`offset`\n\n`\\Q`и`\\E` можуть бути використані для ігнорування метасимволів регулярних виразів у шаблоні. Наприклад: `\\w+\\Q.$.\\E$` збігається з одним або більше символів, що становлять «слово», за якими слідують символи `.$.` і якір в кінці рядка. Зауважте, що це не змінює поведінки роздільників; наприклад, шаблон `#\\Q#\\E#$` некоректний, бо другий `#` відзначає кінець шаблону, а `\\E#` інтерпретується як неприпустимі модифікатори.\n\nПослідовність `\\K` може бути використана для скидання початку збігу. Наприклад, шаблон `foo\\Kbar` збігається з \"foobar\", але повідомить про те, що збігся тільки з \"bar\". Використання `\\K`не мешает установке подмасок. НаПриклад, если шаблон`(foo)\\Kbar` збігається з рядком \"foobar\", першою підмаскою все одно буде \"foo\".\n","title":"Екрануючі послідовності","contentType":2,"navigation":[{"regexp.reference.meta.md":"« Метасимволи"},{"regexp.reference.unicode.md":"Властивості Unicode-символів »"},{"index.md":"PHP Manual"},{"reference.pcre.pattern.syntax.md":"Опис синтаксису Perl-сумісних регулярних виразів"}]}},"__N_SSG":true}