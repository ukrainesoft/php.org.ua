{"pageProps":{"page":{"slug":"security.filesystem.md","content":"# Безпека файлової системи\n\n## Зміст\n\n-   [Проблеми безпеки, пов'язані з нульовим байтом](security.filesystem.nullbytes.md)\n\nPHP є одним із важливих моментів у питанні безпеки сервера, оскільки PHP-скрипти можуть маніпулювати файлами та каталогами на диску. У зв'язку з цим існують конфігураційні установки, які вказують, які файли можуть бути доступні і які операції можна виконувати. Необхідно виявляти обережність, оскільки будь-який із файлів, з повними правами читання (\"world readable\") може бути прочитаний кожним, хто має доступ до файлової системи.\n\nОскільки в PHP спочатку передбачався повноправний доступ до файлової системи, можна написати PHP-скрипт, який дозволить читати системні файли, такі як /etc/passwd, керувати мережевими з'єднаннями, надсилати завдання принтеру тощо. Як наслідок, ви завжди повинні бути впевнені в тому, що файли, які ви читаєте або модифікуєте, є тими, які ви мали на увазі.\n\nРозглянемо наступний приклад, у якому користувач створив скрипт, який видаляє файл із його домашньої директорії. Передбачається ситуація, коли веб-інтерфейс, написаний на PHP, регулярно використовується для роботи з файлами і налаштування безпеки дозволяють видаляти файли в домашньому каталозі.\n\n**Приклад #1 Недостатня перевірка зовнішніх даних веде до...**\n\n```php\n<?php\n// Удаление файла из домашней директории пользователя\n$username = $_POST['user_submitted_name'];\n$userfile = $_POST['user_submitted_filename'];\n$homedir  = \"/home/$username\";\n\nunlink(\"$homedir/$userfile\");\n\necho \"Файл был удалён!\";\n?>\n```\n\nОскільки змінні вводяться в формі користувача, існує можливість видалити файли, що належать комусь іншому, ввівши відповідні значення. І тут може знадобитися авторизація. Подивимося, що станеться, якщо буде відправлено значення \"../etc/\" і \"passwd\". Скрипт виконає такі дії:\n\n**Приклад #2 ... атаці на файлову систему**\n\n```php\n<?php\n// Удаление любого файла, доступного из PHP-скрипта.\n// В случае, если PHP работает с правами пользователя root:\n$username = $_POST['user_submitted_name']; // \"../etc\"\n$userfile = $_POST['user_submitted_filename']; // \"passwd\"\n$homedir  = \"/home/$username\"; // \"/home/../etc\"\n\nunlink(\"$homedir/$userfile\"); // \"/home/../etc/passwd\"\n\necho \"Файл был удалён!\";\n?>\n```\n\nІснують два важливі заходи, які можна вжити для запобігання описаній проблемі.\n\n-   Обмежити доступ користувача, з правами якого працює веб-сервер із PHP.\n-   Перевіряйте всі дані, що вводяться користувачем.\n\nОсь покращений варіант коду:\n\n**Приклад #3 Безпечніша перевірка імені файлу**\n\n```php\n<?php\n// Удаление любого файла, к которому имеет доступ пользователь,\n// под которым запущен PHP.\n$username = $_SERVER['REMOTE_USER']; // использование авторизации\n$userfile = basename($_POST['user_submitted_filename']);\n$homedir  = \"/home/$username\";\n\n$filepath = \"$homedir/$userfile\";\n\nif (file_exists($filepath) && unlink($filepath)) {\n    $logstring = \"$filepath удалён\\n\";\n} else {\n    $logstring = \"Не удалось удалить $filepath\\n\";\n}\n$fp = fopen(\"/home/logging/filedelete.log\", \"a\");\nfwrite($fp, $logstring);\nfclose($fp);\n\necho htmlentities($logstring, ENT_QUOTES);\n\n?>\n```\n\nОднак і така перевірка не враховує всіх можливих ситуацій. Якщо система авторизації дозволяє користувачам вибирати довільні логіни, зломщик може створити обліковий запис виду \"../etc/\" і система знову виявиться вразливою. Виходячи з цього, вам може знадобитися суворіша перевірка:\n\n**Приклад #4 Суворіша перевірка імені файлу**\n\n```php\n<?php\n$username     = $_SERVER['REMOTE_USER']; // использование авторизации\n$userfile     = $_POST['user_submitted_filename'];\n$homedir      = \"/home/$username\";\n\n$filepath     = \"$homedir/$userfile\";\n\nif (!ctype_alnum($username) || !preg_match('/^(?:[a-z0-9_-]|\\.(?!\\.))+$/iD', $userfile)) {\n    die(\"Неправильное имя пользователя или файл\");\n}\n\n//etc...\n?>\n```\n\nЗалежно від операційної системи, що ви використовуєте, необхідно передбачати можливість атаки на різноманітні файли, включаючи системні файли пристроїв (/dev/ або COM1), конфігураційні файли (наприклад /etc/ або файли з розширенням .ini), добре відомі області зберігання даних (/home /, My Documents), і так далі. Виходячи з цього, як правило, легше реалізувати таку безпекову політику, в якій заборонено все, виключаючи те, що явно дозволено.\n","title":"Безпека файлової системи","contentType":2,"navigation":[{"security.sessions.md":"« Безпека сесій"},{"security.filesystem.nullbytes.md":"Проблеми безпеки, пов'язані з нульовим байтом."},{"index.md":"PHP Manual"},{"security.md":"Безпека"}]}},"__N_SSG":true}