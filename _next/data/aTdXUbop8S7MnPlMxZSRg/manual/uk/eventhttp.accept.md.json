{"pageProps":{"page":{"slug":"eventhttp.accept.md","content":"# EventHttp::accept\n\n(PECL event >= 1.2.6-beta)\n\nEventHttp::accept — Примушує HTTP-сервер приймати з'єднання із зазначеним потоком сокету або ресурсом\n\n### Опис\n\n```methodsynopsis\npublic\n   EventHttp::accept(\n    mixed\n     $socket\n   ): bool\n```\n\nПримушує HTTP-сервер приймати з'єднання із зазначеним потоком сокету чи ресурсом. Сокет повинен бути готовим до прийому з'єднань.\n\nМоже викликатись кілька разів, щоб приймати з'єднання на різних сокетах.\n\n> **Зауваження** :\n> \n> Щоб зв'язати сокет, `прослухати`и`прийняти` з'єднання на сокеті в одному дзвінку, використовуйте [EventHttp::bind()](eventhttp.bind.md). . **EventHttp::accept()** потрібно лише в тому випадку, якщо один виклик вже має сокет, готовий для прийняття з'єднань.\n\n### Список параметрів\n\n`socket`\n\nРесурс сокету, потоковий або числовий дескриптор файлу, що представляє сокет, готовий приймати з'єднання.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад використання** EventHttp::accept()\\*\\*\\*\\*\n\n```php\n<?php\n$base = new EventBase();\n$http = new EventHttp($base);\n\n$addresses = array (\n     8091 => \"127.0.0.1\",\n     8092 => \"127.0.0.2\",\n);\n$i = 0;\n\n$socket = array();\n\nforeach ($addresses as $port => $ip) {\n    echo $ip, \" \", $port, PHP_EOL;\n    $socket[$i] = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n    if (!socket_bind($socket[$i], $ip, $port)) {\n        exit(\"ошибка socket_bind\\n\");\n    }\n    socket_listen($socket[$i], 0);\n    socket_set_nonblock($socket[$i]);\n\n    if (!$http->accept($socket[$i])) {\n        echo \"Принять не удалось\\n\";\n        exit(1);\n    }\n\n    ++$i;\n}\n\n$http->setCallback(\"/some-page\", function() {\n echo \"(some-page)\\n\";\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n});\n\n$http->setDefaultCallback(function($req) {\n    echo \"URI: \", $req->getUri(), PHP_EOL;\n    $req->sendReply(200, \"OK\");\n    echo \"OK\\n\";\n});\n\n$signal = Event::signal($base, SIGINT, function () use ($base) {\n    echo \"Пойман SIGINT. Останавливаем...\\n\";\n    $base->stop();\n});\n$signal->add();\n\n$base->dispatch();\necho \"конец\\n\";\n// Мы не закрывали сокеты, так как Libevent\n// уже установил флаги CLOSE_ON_FREE и CLOSE_ON_EXEC\n// в дескрипторе файла, связанном с сокетами.\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nClient:\n$ nc 127.0.0.1 8091\nGET /about HTTP/1.0\nConnection: close\n\nHTTP/1.0 200 OK\nContent-Type: text/html; charset=ISO-8859-1\nConnection: close\n\nServer:\n127.0.0.1 8091\n127.0.0.2 8092\nURI: /about\nOK\n```\n\n### Дивіться також\n\n-   [EventHttp::bind()](eventhttp.bind.md) \\- Прив'язує HTTP-сервер до вказаної адреси та порту\n","title":"EventHttp::accept","contentType":2,"navigation":[{"class.eventhttp.md":"« EventHttp"},{"eventhttp.addserveralias.md":"EventHttp::addServerAlias »"},{"index.md":"PHP Manual"},{"class.eventhttp.md":"EventHttp"}]}},"__N_SSG":true}