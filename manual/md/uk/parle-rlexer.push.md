- [« Parle\RLexer::insertMacro](parle-rlexer.insertmacro.md)
- [Parle\RLexer::pushState »](parle-rlexer.pushstate.md)

- [PHP Manual](index.md)
- [Parle\RLexer](class.parle-rlexer.md)
- Додає правило лексера

# Parle\RLexer::push

(PECL parle \>u003d 0.5.1)

Parle\RLexer::push — Додає правило лексера

### Опис

public **Parle\RLexer::push**(string `$regex`, int `$id`): void

public **Parle\RLexer::push**(
string `$state`,
string `$regex`,
int `$id`,
string `$newState`
): void

public **Parle\RLexer::push**(string `$state`, string `$regex`, string
`$newState`): void

Додає шаблон для розпізнавання лексеми.

"Початковий стан" та "стан виходу" можна вказати за допомогою
відповідної сигнатури.

### Список параметрів

`regex`
Регулярне вираз, використовуване зіставлення токенів.

`id`
Ідентифікатор токена. Якщо екземпляр лексера призначений для
автономного використання, це може бути довільне число. Якщо
екземпляр лексера буде переданий синтаксичному аналізатору, це повинен
бути ідентифікатором, що повертається
[Parle\RParser::tokenid()](parle-rparser.tokenid.md).

`state`
Назва стану. Якщо як початковий стан використовується
'\*', то правило застосовується до всіх станів лексера.

`NewState`
Нова назва стану після застосування правила.

Якщо як стан виходу вказано '.', то стан лексера не
змінюється, коли правило збігається. Стан виходу з '\>' перед
іменем означає додавання. Використовуйте сигнатуру без ідентифікатора
або для продовження, або для початку зіставлення, коли потрібно
продовження чи рекурсія.

Якщо як стан виходу вказано '\<', це означає вилучення.
У цьому випадку сигнатура, що містить ідентифікатор, може використовуватись
для ідентифікації збігу. Зверніть увагу, що навіть у тому випадку,
якщо вказано ідентифікатор, правило завершиться першим, коли будуть
виконано всі попередні додавання.

### Значення, що повертаються

Функція не повертає значення після виконання.
