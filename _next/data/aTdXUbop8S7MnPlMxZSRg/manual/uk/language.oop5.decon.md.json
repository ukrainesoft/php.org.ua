{"pageProps":{"page":{"slug":"language.oop5.decon.md","content":"## Конструктори та деструктори\n\n### Конструктор\n\n```methodsynopsis\n__construct(mixed ...$values = \"\"): void\n```\n\nPHP дозволяє розробникам оголошувати для класів методи-конструктори. Метод-конструктор буде викликаний на кожному новоствореному екземплярі класу. Тому оголошення методу-конструктора зручне для ініціалізації того, що може знадобитися об'єкту на початку роботи.\n\n> **Зауваження**: Конструктори, які визначені у класах-батьках, не викликаються автоматично, якщо дочірній клас визначає свій конструктор. Щоб запустити конструктор батьківського класу, необхідно викликати його всередині конструктора дочірнього класу. **parent::\\_\\_construct()**. Якщо в дочірньому класі не визначено конструктора, він буде успадкований від батьківського класу як звичайний метод (якщо батьківський конструктор не був визначений як приватний).\n\n**Приклад #1 Конструктори при наслідуванні**\n\n```php\n<?php\nclass BaseClass {\n   function __construct() {\n       print \"Конструктор класса BaseClass\\n\";\n   }\n}\n\nclass SubClass extends BaseClass {\n   function __construct() {\n       parent::__construct();\n       print \"Конструктор класса SubClass\\n\";\n   }\n}\n\nclass OtherSubClass extends BaseClass {\n    // наследует конструктор класса BaseClass\n}\n\n// Конструктор класса BaseClass\n$obj = new BaseClass();\n\n// Конструктор класса BaseClass\n// Конструктор класса SubClass\n$obj = new SubClass();\n\n// Конструктор класса BaseClass\n$obj = new OtherSubClass();\n?>\n```\n\nВ отличие от других методов, метод[\\_\\_construct()](language.oop5.decon.md#object.construct) звільняється від звичайних [правил сумісності сигнатури](language.oop5.basic.md#language.oop.lsp)при наследовании.\n\nКонструктори - це звичайні методи, що викликаються при інстанціюванні об'єктів, що їх містять, або об'єктів дочірніх класів без конструктора. Тому в них може бути визначена довільна кількість аргументів, які можна оголосити обов'язковими, типізованими, за умовчанням. Аргументи конструктора вказуються у круглих дужках після імені класу.\n\n**Приклад #2 Оголошення аргументів у конструкторах**\n\n```php\n<?php\nclass Point {\n    protected int $x;\n    protected int $y;\n\n    public function __construct(int $x, int $y = 0) {\n        $this->x = $x;\n        $this->y = $y;\n    }\n}\n\n// Передаём оба параметра.\n$p1 = new Point(4, 5);\n// Передаём только обязательные параметры. Для переменной $y установлено значение по умолчанию 0.\n$p2 = new Point(4);\n// Вызываем с именованными параметрами (начиная с PHP 8.0):\n$p3 = new Point(y: 5, x: 4);\n?>\n```\n\nЯкщо клас не має конструктора, або його конструктор не містить обов'язкових параметрів, дужки після імені класу можна не писати.\n\n#### Конструктори у старому стилі\n\nДо PHP 8.0.0 класи у глобальному просторі імен інтерпретуватимуть названий ім'ям класу метод як конструктор старого стилю. Цей синтаксис застарів і викликатиме помилку рівня \\*\\*`E_DEPRECATED`\\*\\*Але все одно ці методи будуть викликатися як конструктор. Якщо в класі є і метод [\\_\\_construct()](language.oop5.decon.md#object.construct), і метод з ім'ям класу, то як конструктор буде викликаний метод [\\_\\_construct()](language.oop5.decon.md#object.construct)\n\nПочинаючи з PHP 8.0.0 для класів усередині простору імен та для всіх класів метод, названий на ім'я класу, буде проігнорований.\n\nВ новом коде всегда используют метод[\\_\\_construct()](language.oop5.decon.md#object.construct)\n\n#### Визначення властивостей об'єкта у конструкторі\n\nПочинаючи з PHP 8.0.0, через параметри конструктора можна встановлювати властивості об'єкта. Це поширена практика — надавати властивостям об'єкта значення лише рахунок переданих конструктор параметрів. Визначення властивостей класу в конструкторі значно скорочує кількість шаблонного коду такого випадку. Приклад вище можна буде переписати як показано нижче:\n\n**Приклад #3 Використання визначення властивостей конструктора**\n\n```php\n<?php\nclass Point {\n    public function __construct(protected int $x, protected int $y = 0) {\n    }\n}\n```\n\nЯкщо декларація аргументу конструктора включає модифікатор, PHP інтерпретує його одночасно як аргумент конструктора, як властивість об'єкта, і автоматично встановить властивості значення, передане конструктор. При цьому, якщо не потрібно додаткової логіки, тіло конструктора можна залишити порожнім. Код конструктора виконається після того, як значення аргументів буде надано параметрам функції або властивостям класу.\n\nНе всі передані в конструктор аргументи повинні бути просунутими (що встановлюють якості об'єкта). Просунуті та звичайні аргументи можна вказувати та зіставляти у будь-якому порядку. Просунуті аргументи не впливають на код, який виконується в конструкторі.\n\n> **Зауваження** :\n> \n> Вказати [модифікатор області видимості](language.oop5.visibility.md) `public` `protected`или`private`) — це найімовірніший спосіб застосувати просунуту установку властивостей, але будь-який інший модифікатор (наприклад, `readonly`) дасть такий самий ефект.\n\n> **Зауваження** :\n> \n> Не можна вказувати властивості об'єкта тип [callable](language.types.callable.md). Це з неоднозначністю, що вони представляють для движка PHP. Тому і аргументів конструктора, які встановлюють класу якості, також не можна вказувати тип [callable](language.types.callable.md). Будь-які інші [декларації типів](language.types.declarations.md) допустимі.\n\n> **Зауваження** :\n> \n> Оскільки при розборі коду PHP трансформує синтаксичний цукор просунутих властивостей у звичайне декларування властивостей конструктора з тими ж модифікаторами видимості та типом даних, які вказані у просунутому аргументі, а також надає значення просунутого аргументу і параметру функції, і властивості класу, все без винятку обмеження на визначення аргументів конструктора буде застосовано як до параметрів функції, і до властивостей класу.\n\n> **Зауваження** :\n> \n> [Атрибути](language.attributes.md) , встановлені аргументу в просунутому конструкторі, будуть репліковані як у аргумент, і на властивість класу. Значення за умовчанням для аргументу в просунутому конструкторі поширюється лише аргумент, а чи не властивість.\n\n#### New в ініціалізації класу\n\nЗ PHP 8.1.0 об'єкти можна надавати як значення параметрів за умовчанням, статичних змінних і глобальних констант, а також в аргументах атрибутів. Об'єкти також можна передавати у функцію [define()](function.define.md)\n\n> **Зауваження** :\n> \n> При цьому динамічні чи нестрокові імена класів чи анонімних класів не дозволені. Використовувати розпакування аргументів заборонено. Непідтримувані вирази як аргументи не дозволені.\n\n**Приклад #4 Приклад використання new в ініціалізації класу**\n\n```php\n<?php\n// Всё допустимо:\nstatic $x = new Foo;\nconst C = new Foo;\n\nfunction test($param = new Foo) {}\n\n#[AnAttribute(new Foo)]\nclass Test {\n    public function __construct(\n        public $prop = new Foo,\n    ) {}\n}\n// Всё недопустимо (ошибка во времени компиляции):\nfunction test(\n    $a = new (CLASS_NAME_CONSTANT)(), // динамическое имя класса\n    $b = new class {}, // анонимный класс\n    $c = new A(...[]), // распаковка аргументов\n    $d = new B($abc), // неподдерживаемое постоянное выражение\n) {}\n?>\n```\n\n#### Статичні методи створення об'єкту\n\nPHP підтримує лише один конструктор для класу. Однак буває так, що потрібно створювати різні об'єкти для вхідних даних. Рекомендований спосіб використовувати статичні методи як обгортки над конструктором.\n\n**Приклад #5 Використання статичних методів створення об'єктів**\n\n```php\n<?php\nclass Product {\n\n    private ?int $id;\n    private ?string $name;\n\n    private function __construct(?int $id = null, ?string $name = null) {\n        $this->id = $id;\n        $this->name = $name;\n    }\n\n    public static function fromBasicData(int $id, string $name): static {\n        $new = new static($id, $name);\n        return $new;\n    }\n\n    public static function fromJson(string $json): static {\n        $data = json_decode($json);\n        return new static($data['id'], $data['name']);\n    }\n\n    public static function fromXml(string $xml): static {\n        // Пользовательская логика.\n        $data = convert_xml_to_array($xml);\n        $new = new static();\n        $new->id = $data['id'];\n        $new->name = $data['name'];\n        return $new;\n    }\n}\n\n$p1 = Product::fromBasicData(5, 'Widget');\n$p2 = Product::fromJson($some_json_string);\n$p3 = Product::fromXml($some_xml_string);\n```\n\nКонструктор можна зробити закритим або захищеним для запобігання прямому виклику. Тоді об'єкт класу можна буде створити лише виклик статичного методу. Оскільки це методи того ж класу, вони мають доступ до всіх його прихованих методів, навіть якщо вони відносяться до різних екземплярів класу. Закритий конструктор опціональний, і може бути оголошений або не мати сенсу в різних ситуаціях.\n\nУ прикладі вище три публічні статичні методи показують різні способи створення екземпляра об'єкта.\n\n-   Метод`fromBasicData()`приймає явні параметри, створює екземпляр класу через конструктор та повертає об'єкт.\n-   Метод`fromJson()`приймає JSON-рядок, здійснює над нею перетворення, витягує необхідні для створення об'єкта дані і, так само як і попередній метод, викликає конструктор і повертає створений об'єкт.\n-   Метод`fromXml()`приймає XML-рядок, витягує необхідні дані і, оскільки в конструкторі немає обов'язкових параметрів, викликає його без них. Після цього, оскільки йому доступні приховані властивості, він надає їм значення безпосередньо. Після цього повертає готовий об'єкт.\n\nУ всіх трьох випадках ключове слово `static` транслюється в ім'я класу, в якому код викликається. У нашому випадку — до класу `Product`\n\n### Деструктори\n\n```methodsynopsis\n__destruct(): void\n```\n\nPHP успадковує концепцію деструктора, аналогічну до інших об'єктно-орієнтованих мов, наприклад, C++. Деструктор буде викликаний у разі звільнення всіх посилань на об'єкт або при завершенні скрипту (порядок виконання деструкторів не гарантується).\n\n**Приклад #6 Приклад використання деструктора**\n\n```php\n<?php\nclass MyDestructableClass\n{\n   function __construct() {\n       print \"Конструктор\\n\";\n   }\n\n   function __destruct() {\n       print \"Уничтожается \" . __CLASS__  . \"\\n\";\n   }\n}\n\n$obj = new MyDestructableClass();\n```\n\nЯк і конструктори, деструктори, оголошені у батьківському класі, не викликатимуться автоматично. Щоб запустити деструктор батьківського класу, необхідно викликати **parent::\\_\\_destruct()** у тілі деструктора дочірнього класу. Аналогічно конструкторам, дочірній клас, у якому не визначено деструктора, успадковує його з батьківського класу.\n\nДеструктор буде викликаний навіть якщо скрипт був зупинений функцією [exit()](function.exit.md). Виклик функції [exit()](function.exit.md) у деструкторі запобігає запуску всіх інших процедур завершення роботи.\n\n> **Зауваження** :\n> \n> Деструктори, що викликаються при завершенні скрипта, викликаються після надсилання заголовків HTTP. На етапі завершення роботи скрипта робоча директорія SAPI (наприклад, Apache) може змінитися.\n\n> **Зауваження** :\n> \n> Спроба викинути виняток із деструктора (викликаного під час завершення роботи скрипта) спричинить фатальну помилку.\n","title":"Конструктори та деструктори","contentType":2,"navigation":[{"language.oop5.autoload.md":"« Автоматичне завантаження класів"},{"language.oop5.visibility.md":"Область видимості \""},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}