- [« Правила дозволу імен](language.namespaces.rules.md)
- [Перерахування »](language.enumerations.md)

- [PHP Manual](index.md)
- [Простори імен](language.namespaces.md)
- Часті питання (FAQ): речі, які вам необхідно знати про
просторах імен

## Часті питання (FAQ): речі, які вам необхідно знати про простори імен

(PHP 5 \>u003d 5.3.0, PHP 7, PHP 8)

Цей перелік питань поділено на дві частини: загальні питання та деякі
особливості реалізації, які корисні більш повного розуміння.

Спершу, спільні питання.

1. [Якщо я не використовую простору імен, чи слід вважати що-небудь
із цього
важливим?](language.namespaces.faq.md#language.namespaces.faq.shouldicare)
2. [Як мені використовувати внутрішні або глобальні класи в
просторі
імен?](language.namespaces.faq.md#language.namespaces.faq.globalclass)
3. [Як мені використовувати функції класів у просторах імен, або
константи у їхньому власному просторі
імен?](language.namespaces.faq.md#language.namespaces.faq.innamespace)
4. [Як таке ім'я як `\my
ame` або `
ame`
перетворюється?](language.namespaces.faq.md#language.namespaces.faq.full)
5. [Як таке ім'я, як my
ame`
перетворюється?](language.namespaces.faq.md#language.namespaces.faq.qualified)
6. [Як неповне ім'я класу таке як `name`
перетворюється?](language.namespaces.faq.md#language.namespaces.faq.shortname1)
7. [Як неповне ім'я функції або неповне ім'я константи таке як
`name`
перетворюється?](language.namespaces.faq.md#language.namespaces.faq.shortname2)

Деякі деталі реалізації просторів імен, які корисно розуміти.

1. [Імпортовані імена не повинні конфліктувати з класами,
певними в тому ж
файлі.](language.namespaces.faq.md#language.namespaces.faq.conflict)
2. [Вкладені простори імен
неприпустимі.](language.namespaces.faq.md#language.namespaces.faq.nested)
3. [Динамічні імена просторів імен (ідентифікатори, взяті в
лапки) повинні екранувати символ зворотного
слєша.](language.namespaces.faq.md#language.namespaces.faq.quote)
4. [Посилатися на невизначені константи, використовуючи зворотний сліш,
не можна. Виводиться фатальна
ошибка](language.namespaces.faq.md#language.namespaces.faq.constants)
5. [Неможливо перевизначити спеціальні константи, такі як NULL,
TRUE, FALSE, ZEND_THREAD_SAFE або
ZEND_DEBUG_BUILD](language.namespaces.faq.md#language.namespaces.faq.builtinconst)

### Якщо я не використовую простору імен, чи слід вважати щось із цього важливим?

Ні. Простір імен не впливає ні на який
існуючий код у жодному вигляді або на будь-який написаний код, який не
містить просторів імен. Ви можете написати такий код, якщо бажаєте:

**Приклад #1 Доступ до глобальних класів поза простором імен**

` <?php$a u003d new \stdClass;?> `

Це функціонально еквівалентно наступному:

**Приклад #2 Доступ до глобальних класів поза простором імен**

` <?php$a u003d new stdClass;?> `

### Як мені використовувати внутрішні чи глобальні класи у просторі імен?

**Приклад #3 Доступ до внутрішніх класів у просторах імен**

`<?phpnamespace foo;$a u003d new \stdClass;function test(\ArrayObject $parameter_type_example u003d null) {}$a u003d \DirectoryIterator::CURRENT_AS_FILEINFO;// розширення        ¦

### Як мені використовувати функції класів у просторах імен або константи у їхньому власному просторі імен?

**Приклад #4 Доступ до внутрішніх класів, функцій або константів у
просторах імен**

` <?phpnamespace foo;class MyClass {}// использование класса из текущего пространства имен в качестве типа параметраfunction test(MyClass $parameter_type_example u003d null) {}// другой способ использовать класс из текущего пространства имен в качестве типа параметраfunction test(oo\ MyClass $parameter_type_example u003d null) {}// розширення класу з поточного простору іменclass Extended extends MyClass {}// доступ к глобальної функції$a u003d \   

### Як таке ім'я як `\my
ame` або `
ame` перетворюється?

Імена, які починаються з `\` завжди перетворюються на те, як вони
виглядають, тобто. `\my
ame` - це насправді `my
ame`, та
`Exception` - це `Exception`.

**Приклад #5 Абсолютні імена**

` <?phpnamespace foo;$a u003d new \my
ame(); // створює примірник класу "my
ame"echo \strlen('hi'); // викликає функцію "strlen"$a u003d \INI_ALL; // змінної $a присвоюється значення константи "INI_ALL"?> `

### Як таке ім'я, як `my
ame` перетворюється?

Імена, які містять зворотний сліш, але не починаються з нього, такі
як `my
ame` можуть бути перетворені двома різними способами.

Якщо є імпортуючий вираз, який створює синонім `my`
іншого імені, то цей синонім застосовується до `my` в `my
ame`.

В іншому випадку, поточне ім'я простору імен стає префіксом
`my
ame`.

**Приклад #6 Повні імена**

`<?phpnamespace foo;use blah lah as foo;$a u003d new my
ame(); // створює примірник класу "foo\my
ame"foo ar::name(); // викликає статичний метод "name" в класі "blah lah ar"my ar(); // викликає функцію "foo\my ar"$a u003d my\ BAR; // присвоює змінної $a значення константи "foo\my\BAR"?> `

### Як неповне ім'я класу таке як `name` перетворюється?

Імена класів, які не містять зворотний сліш, такі як `name` можуть
бути перетворені двома різними способами.

Якщо є імпортуючий вираз, який створює синонім
`name` іншого імені, то застосовується цей синонім.

В іншому випадку, поточне ім'я простору імен стає префіксом
`name`.

**Приклад #7 Неповні імена класів**

`<?phpnamespace foo;use blah lah as foo;$a u003d new name(); // створює примірник класу "foo
ame"foo::name(); // викликає статичний метод "name" в класі "blah lah"?> `

### Як неповне ім'я функції або неповне ім'я константи таке як 'name' перетворюється?

Імена функцій або констант, які не містять зворотного сліша, такі
як `name` можуть бути перетворені двома різними способами.

Спочатку поточне ім'я простору імен стає префіксом до `name`.

Потім, якщо константа або функція `name` не існує у поточному
просторі імен, використовується глобальна константа або функція `name`,
якщо вона існує.

**Приклад #8 Неповні імена функцій або констант**

`<?phpnamespace foo;use blah lah as foo;const FOO u003d 1;function my() {}function foo() {}function sort(&$a){    \sort($a); // викликає глобальну функцію "sort"   $a u003d array_flip($a); return $a;} my (); // викликає "foo\my"$a u003d strlen('hi'); // викликає глобальну функцію "strlen", потому "foo\strlen" не існує$arr u003d array(1,3,2);$b u003d sort($arr); // викликає функцію "foo\sort"$c u003d foo(); // викликає функцію "foo oo" - імпорт не застосовується$a u003d FOO; // привласнює змінною $a значення константи "foo\FOO" - імпорт не застосовується$b u003d INI_ALL; // привласнює змінною $b значення глобальної константи "INI_ALL"?> `

### Імпортовані імена не повинні конфліктувати з класами, визначеними в тому ж файлі.

Наступні комбінації скриптів допустимі:

file1.php

`<?phpnamespace my\stuff;class MyClass {}?> `

another.php

`<?phpnamespace another;class thing {}?> `

file2.php

`<?phpnamespace my\stuff;include 'file1.php';include 'another.php';use another hing as MyClass;$a u003d new MyClass; // створює примірник класу "thing" з простору імен "another"?> `

Конфлікт імен відсутній навіть незважаючи на те, що клас `MyClass`
існує всередині простору імен `my\stuff`, тому що визначення
MyClass знаходиться в окремому файлі. Однак наступний приклад призводить до
фатальної помилки з конфліктом імен, тому що клас MyClass визначений у
тому ж файлі, де знаходиться оператор use.

`<?phpnamespace my\stuff;use another hing as MyClass;class MyClass {} // фатальна помилка: MyClass конфліктує з вираженням імпорту$a u003d new MyClass;

### Вкладені простори імен неприпустимі.

PHP не дозволяє вкладення просторів імен одне в інше

`<?phpnamespace my\stuff {   namespace nested {         class foo {}    }}?> `

Однак, можна зімітувати вкладені простори імен так:

`<?phpnamespace my\stuff
ested {    class foo {}}?> `

### Динамічні імена просторів імен (ідентифікатори, взяті в лапки) повинні екранувати символ зворотного сліша.

Дуже важливо представляти це, тому що зворотний сліш використовується як
екрануючий символ усередині рядків. Він завжди має бути продубльований,
коли використовується всередині рядка, інакше з'являється ризик виникнення
ненавмисних наслідків:

**Приклад #9 Підводне каміння при використанні імені простору імен
усередині рядка з подвійними лапками**

` <?php$a u003d "dangerous
ame"; //
- це перехід на новий рядок внутрі рядки з подвійними лапками!$obj u003d new $a;$a u003d 'not t ll\dangerous'; // а тут немає проблем.$obj u003d new $a;?> `

Усередині рядків, укладених в одинарні лапки, зворотний сліш як
роздільника більш безпечний, але, як і раніше, рекомендована практика
екранування зворотного слеша у всіх рядках є найкращим
варіантом.

### Посилатися на невизначені константи, використовуючи зворотний сліш, не можна. Виводиться фатальна помилка

Будь-яка невизначена константа, що є неповним ім'ям, як `FOO`,
буде приводити до висновку повідомлення про те, що PHP припустив, що `FOO`
було значення константи. Будь-яка константа, з повним чи абсолютним
іменем, що містить символ зворотного сліша буде призводити до
фатальної помилки, якщо не буде знайдено.

**Приклад #10 Невизначені константи**

`<?phpnamespace bar;$a u003d FOO; // виводить попередження: undefined constants "FOO" assumed "FOO";$a u003d \FOO; // фатальна помилка: undefined namespace constant FOO$a u003d Bar\FOO; // фатальна помилка: undefined namespace constant bar\Bar\FOO$a u003d \Bar\FOO; // фатальна помилка: undefined namespace constant Bar\FOO?> `

### Неможливо перевизначити спеціальні константи, такі як NULL, TRUE, FALSE, ZEND_THREAD_SAFE або ZEND_DEBUG_BUILD

Будь-яка спроба визначити константу простору імен, що збігається
з назвами спеціальних вбудованих констант, призведе до фатальної
помилки.

**Приклад #11 Невизначені константи**

`<?phpnamespace bar;const NULL u003d 0; // Фатальна помилка;const true u003d 'stupid'; // також фатальна помилка;// і т.д.?> `
