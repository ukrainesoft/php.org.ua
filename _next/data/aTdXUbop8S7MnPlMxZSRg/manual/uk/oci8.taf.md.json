{"pageProps":{"page":{"slug":"oci8.taf.md","content":"# Підтримка прозорого для програм відновлення після відмови (Transparent Application Failover або TAF) для OCI8\n\nTAF – це механізм бази даних Oracle, що забезпечує високу доступність. Він дозволяє програмам PHP, що використовують OCI8, автоматично перепідключатися до резервної бази даних у разі збою на основний або при мережевих проблемах.\n\nУ конфігурованій системі бази даних Oracle, TAF відбувається коли програма PHP визначає, що екземпляр бази даних недоступний. У цьому випадку відбувається з'єднання з іншим вузлом Oracle [» RAC](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2). Це може бути гарячий резерв або той самий екземпляр бази даних. Докладніше про OCI TAF читайте у [» Oracle Call Interface Programmer's Guide](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F)\n\nФункцію зворотного дзвінка для програми можна зареєструвати за допомогою [oci\\_register\\_taf\\_callback()](function.oci-register-taf-callback.md). У процесі відновлення після відмови виконання програми буде призупинено та буде викликана зареєстрована функція зворотного дзвінка. Ця функція сповіщатиме про програму відновлення. Якщо відновлення завершилося успішно, керування буде повернено програмі. Якщо відновлення завершилося невдало, всі наступні звернення до базі даних будуть завершуватися з помилкою, оскільки відсутня підключення.\n\nКоли з'єднання переходить до іншої бази даних, зворотний виклик може скинути будь-який необхідний стан з'єднання, наприклад, перевиконати будь-яку необхідну команду ALTER SESSION якщо для сервісу бази даних не включено -failover\\_restore.\n\nРеєстрацію функції зворотного дзвінка можна видалити за допомогою [oci\\_unregister\\_taf\\_callback()](function.oci-unregister-taf-callback.md)\n\n## налаштування TAF\n\nTAF можна настроїти на стороні PHP OCI8 або конфігурації бази даних. Якщо налаштовано там і там, то перевага віддається налаштувань за бази даних.\n\nНалаштувати TAF в PHP OCI8 (на стороні клієнта) можна, додавши параметр FAILOVER\\_MODE у частині CONNECT\\_DATA дескриптора з'єднання. Докладніше про налаштування TAF на стороні клієнта читайте у [»  Oracle Database Net Services Administrator's Guide](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-8F532535-C401-4B51-BE0B-04FD74BB0621)\n\nПриклад налаштування TAF в tnsnames.ora для перепідключення до тієї ж БД:\n\n```\nORCL =\n      (DESCRIPTION =\n        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))\n        (CONNECT_DATA =\n          (SERVICE_NAME = orclpdb1)\n          (FAILOVER_MODE =\n            (TYPE = SELECT)\n            (METHOD = BASIC)\n            (RETRIES = 20)\n            (DELAY = 15))))\n```\n\nТакож можна налаштувати TAF на стороні бази даних шляхом модифікації сервісу за допомогою [» srvctl](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-8DC4D5E0-CA9D-47BC-BAD0-8769405AFEC5) (для RAC) або за допомогою пакетної процедури [»  DBMS\\_SERVICE.MODIFY\\_SERVICE](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-C11449DC-EEDE-4BB8-9D2C-0A45198C1928) (Для одиночних екземплярів баз даних).\n\n## Використання функцій зворотного дзвінка TAF у OCI8\n\nФункція зворотного виклику TAF є функцією, зареєстрованою з програми для запуску в процесі відновлення після збою. При відновленні з'єднання вона викликається кілька разів.\n\nПерший раз вона запускається у момент виявлення проблем зі з'єднанням. Це дозволяє програмі коректно підготуватися до затримки виконання на час відновлення після збою. Якщо відновлення завершилося успішно, функція буде викликана відразу після відновлення підключення. Цей запуск програма може використовувати для пересинхронізації налаштувань сесії та оповіщення користувача про те, що відбулося відновлення після збою. Якщо відновлення завершилося невдало, функція запускається ще раз для оповіщення програми про те, що відновлення завершилося з помилкою і з'єднання з базою даних недоступне.\n\nІнтерфейс функції зворотного виклику TAF:\n\n```methodsynopsis\nuserCallbackFn(resource $connection, int $event, int $type): int\n```\n\n`connection`\n\nІдентифікатор з'єднання Oracle, для якого ця функція була зареєстрована за допомогою [oci\\_register\\_taf\\_callback()](function.oci-register-taf-callback.md)Соединение недоступно во время аварийного восстановления.\n\n`event`\n\nПодія відновлення означає поточний статус відновлення.\n\n-   \\*\\*`OCI_FO_BEGIN`\\*\\*означає, що відбулася втрата з'єднання та процес відновлення розпочато.\n    \n-   \\*\\*`OCI_FO_END`\\*\\*означає вдале відновлення з'єднання.\n    \n-   \\*\\*`OCI_FO_ABORT`\\*\\*означає, що відновлення завершилося невдало і спроб відновлення більше не буде.\n    \n-   \\*\\*`OCI_FO_ERROR`\\*\\*також означає, що відновлення завершилося з помилкою, але програма дає можливість обробити помилку і повернути OCI\\_FO\\_RETRY ще для однієї спроби відновлення.\n    \n-   \\*\\*`OCI_FO_REAUTH`\\*\\*означає, що користувач Oracle був повторно автентифікований.\n    \n\n`type`\n\nТип відновлення після відмови. Це дозволяє функціям зрозуміти, який тип відновлення запрошений програмою. Допустимі такі значення:\n\n-   \\*\\*`OCI_FO_SESSION`\\*\\*означає, що користувач запросив лише відновлення сесії. Наприклад, якщо з'єднання зникло, буде створена нова сесія на резервному сервері. Цей тип відновлення не намагатиметься відновити запити типу SELECT.\n    \n-   \\*\\*`OCI_FO_SELECT`\\*\\*означає, що запит запитів SELECT запитано. Це дозволить використовувати відкритий курсор для отримання значень після відновлення.\n    \n\n`return value`\n\n-   означає, що кроки відновлення після відмови мають тривати нормально.\n    \n-   \\*\\*`OCI_FO_RETRY`\\*\\*означає, що потрібно спробувати знову відновитися. У разі виникнення помилки під час переходу на нове з'єднання TAF може повторити перехід на інший ресурс. Зазвичай перед поверненням коду OCI\\_FO\\_RETRY рекомендується деякий час зачекати.\n    \n\nПриклад реєстрації функції зворотного дзвінка TAF\n\n```php\n<?php\n\n// Определяем функцию обратного вызова в пространстве пользователя\nclass MyClass {\n    public static $retry_count;\n    public static function TAFCallback($conn, $event, $type)\n    {\n        switch ($event) {\n            case OCI_FO_BEGIN:\n                printf(\" Failing Over ... Please stand by\\n\");\n                printf(\" Failover type was found to be %s \\n\",\n                       (($type==OCI_FO_SESSION) ? \"SESSION\"\n                        :(($type==OCI_FO_SELECT) ? \"SELECT\" : \"UNKNOWN!\")));\n                self::$retry_count = 0;\n                break;\n            case OCI_FO_ABORT:\n                // Приложение больше не может использовать базу данных\n                printf(\" Восстановление невозможно.\\n\");\n                break;\n            case OCI_FO_END:\n                // Восстановление завершилось успешно. Оповестим пользователей, что была проблема.\n                printf(\" Восстановление завершено ... восстанавливаю работу\\n\");\n                break;\n            case OCI_FO_REAUTH:\n                printf(\" Пользователь переавторизован ... восстанавливаю работу\\n\");\n                // Заново выполняем все необходимые ALTER SESSION\n                // т.е. oci_parse($conn, ‘ALTER SESSION …’) ;\n                break;\n            case OCI_FO_ERROR:\n                // Прекращаем попытки соединения, если их было более 20.\n                if (self::$retry_count >= 20)\n                    return 0;\n                printf(\" Ошибка восстановления. Повторная попытка через 10 секунд...\\n\");\n                sleep(10);\n                self::$retry_count++;\n                return OCI_FO_RETRY; // retry failover\n                break;\n            default:\n                printf(\"Неизвестное событие восстановления: %d.\\n\", $event);\n                break;\n        }\n        return 0;\n    }\n}\n\n$fn_name = 'MyClass::TAFCallback';\n\n$conn = oci_connect('hr', 'welcome', 'orcl');\n$sysconn = oci_connect('system', 'oracle', 'orcl');\n\n// Используйте привилегированное соединение для создания оператора SQL, который будет инициировать отработку отказа\n$sql = <<< 'END'\nselect unique 'alter system disconnect session '''||sid||','||serial#||''''\nfrom v$session_connect_info\nwhere sid = sys_context('USERENV', 'SID')\nEND;\n\n$s = oci_parse($conn, $sql);\noci_execute($s);\n$r = oci_fetch_array($s);\n$disconnectssql = $r[0];\n\noci_register_taf_callback($conn, $fn_name); // Зарегистрируйте TAFCallback для Oracle TAF\n\nprint \"Разбор пользовательского запроса\\n\";\n$sql = \"select systimestamp from dual\";\n$stmt = oci_parse($conn, $sql);\n\n// К Прикладу, если соединение было потеряно на этом шаге, oci_execute()\n// определит это и запустит процедуру восстановления. В процессе восстановления\n// oci_execute() будет вызовать зарегистрированную функцию обратного вызова\n// несколько раз. Если восстановление пройдёт успешно, то будет создано новое соединение\n// и выполнение oci_execute() будет продолжено в нормальном режиме.\n// Настройки сессии могут быть сброшены в функции обратного вызова.\n// Если восстановление завершится неудачно, oci_execute() вернёт ошибку, так как\n// будет отсутствовать соединение.\n\n// Отключите пользователя, который инициирует аварийное переключение\nprint \"Отключение пользователя\\n\";\n$discsql = oci_parse($sysconn, $disconnectssql);\noci_execute($discsql);\n\nprint \"Выполнение пользовательского запроса\\n\";\n$e = oci_execute($stmt);\nif (!$e) {\n    $m = oci_error($stmt);\n    trigger_error('Не удалось выполнить условие:'. $m['message'], E_USER_ERROR);\n}\n$row = oci_fetch_array($stmt);\nprint $row[0] . \"\\n\";\n\n// выполняем другие SQL-запросы на новом подключении\n// $stmt = oci_parse($conn,  . . .);\n\n?>\n```\n\n## Дивіться також\n\n-   [oci\\_register\\_taf\\_callback()](function.oci-register-taf-callback.md)\n-   [oci\\_unregister\\_taf\\_callback()](function.oci-unregister-taf-callback.md)\n","title":"Підтримка прозорого для програм відновлення після відмови (Transparent Application Failover або TAF) для OCI8","contentType":2,"navigation":[{"oci8.fan.md":"« Підтримка OCI8 Fast Application Notification (FAN)"},{"oci8.dtrace.md":"OCI8 та динамічне трасування DTrace »"},{"index.md":"PHP Manual"},{"book.oci8.md":"OCI8"}]}},"__N_SSG":true}