- [« Оператори інкременту та
декременту](language.operators.increment.md)
- [Рядкові оператори »](language.operators.string.md)

- [PHP Manual](index.md)
- [Оператори](language.operators.md)
- Логічні оператори

## Логічні оператори

| приклад | Назва | Результат |
|------------|-----------------|------------------ --------------------------------------|
| $a і $b | І | **`true`**, якщо і `$a`, і `$b` **`true`**. |
| $a або $b | Або | **`true`**, якщо або `$a`, або `$b` **`true`**. |
| $a xor $b | Виключне або | **`true`**, якщо `$a`, або `$b` **`true`**, але не обидва. |
| ! $a | Заперечення | **`true`**, якщо `$a` не **`true`**. |
| $a && $b | І | **`true`**, якщо і `$a`, і `$b` **`true`**. |
| $a \|\| $b | Або | **`true`**, якщо або `$a`, або `$b` **`true`**. |

**Логічні оператори**

Сенс двох різних варіантів для операторів "and" та "or" у тому, що вони
працюють з різними пріоритетами (див. таблицю [Пріоритет
виконання операторів] (language.operators.precedence.md)).

**Приклад #1 Пояснення логічних операторів**

` <?php// --------------------// foo() ніколи не буде викликана, т.к. ці оператори є шунтуючими (short-circuit)$a u003d (false && foo());$b u003d (true  || foo());$c u003d (false and foo());$d  ());// --------------------// "||" має більший пріоритет, чому "or"// Результат вираження (false || true) присвоюється змінною $e// Діє як: ($e u003d (false || true))$ true;// Константа false присвоюється $f, а потім значення true ігнорується// Діє як: (($f u003d false) or true)$f u003d false or $ $   ¦¦ ------------------// "&&" має більший пріоритет, чому "and"// Результат вираження (true && false) присвоюється змінною $g// Діє як: ( $g u003d (true && false))$g u003d true && false;// Константа true привласнюється $h, а потім значення false ігнорується// false і  ;var_dump($g, $h);?> `

Результатом виконання цього прикладу буде щось подібне:

bool(true)
bool(false)
bool(false)
bool(true)
