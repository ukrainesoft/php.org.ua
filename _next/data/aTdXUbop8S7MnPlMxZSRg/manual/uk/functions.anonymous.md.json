{"pageProps":{"page":{"slug":"functions.anonymous.md","content":"## Анонімні функції\n\nАнонімні функції, також відомі як замикання (`closures`), дозволяють створювати функції, що не мають певних імен. Вони найбільш корисні як значення [callable](language.types.callable.md)\\-параметрів, але можуть мати і безліч інших застосувань.\n\nАнонімні функції реалізуються з використанням класу [](class.closure.md)[Closure](class.closure.md)\n\n**Приклад #1 Приклад анонімної функції**\n\n```php\n<?php\necho preg_replace_callback('~-([a-z])~', function ($match) {\n    return strtoupper($match[1]);\n}, 'hello-world');\n// выведет helloWorld\n?>\n```\n\nЗамикання також можуть бути використані як значення змінних; PHP автоматично перетворює такі вирази на екземпляри внутрішнього класу [Closure](class.closure.md). Присвоєння замикання змінної використовує той самий синтаксис, що й для будь-якого іншого присвоєння, включаючи точку з комою:\n\n**Приклад #2 Приклад присвоєння анонімної функції змінної**\n\n```php\n<?php\n$greet = function($name) {\n    printf(\"Привет, %s\\r\\n\", $name);\n};\n\n$greet('Мир');\n$greet('PHP');\n?>\n```\n\nЗамикання можуть успадковувати змінні з батьківської області видимості. Будь-яка подібна змінна має бути оголошена в конструкції `use`. Починаючи з PHP 7.1, ці змінні не повинні включати [superglobals](language.variables.predefined.md), $this і змінні з тими самими іменами, як і параметри функції. Оголошення типу значення функції, що повертається, повинно бути поміщене *після* конструкції `use`\n\n**Приклад #3 Спадкування змінних із батьківської області видимості**\n\n```php\n<?php\n$message = 'привет';\n\n// Без \"use\"\n$example = function () {\n    var_dump($message);\n};\n$example();\n\n// Наследуем $message\n$example = function () use ($message) {\n    var_dump($message);\n};\n$example();\n\n// Значение унаследованной переменной задано там, где функция определена,\n// но не там, где вызвана\n$message = 'мир';\n$example();\n\n// Сбросим message\n$message = 'привет';\n\n// Наследование по ссылке\n$example = function () use (&$message) {\n    var_dump($message);\n};\n$example();\n\n// Изменённое в родительской области видимости значение\n// остаётся тем же внутри вызова функции\n$message = 'мир';\necho $example();\n\n// Замыкания могут принимать обычные аргументы\n$example = function ($arg) use ($message) {\n    var_dump($arg . ', ' . $message);\n};\n$example(\"привет\");\n\n// Объявление типа возвращаемого значения идет после конструкции use\n$example = function () use ($message): string {\n    return \"привет, $message\";\n};\nvar_dump($example());\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nNotice: Undefined variable: message in /example.php on line 6\nNULL\nstring(12) \"привет\"\nstring(12) \"привет\"\nstring(12) \"привет\"\nstring(6) \"мир\"\nstring(20) \"привет, мир\"\nstring(20) \"привет, мир\"\n```\n\nПочинаючи з PHP 8.0.0, список успадкованих змінних може завершуватися комою, яка буде проігнорована.\n\nСпадкування змінних із батьківської області видимості *не* те саме, що використання глобальних змінних. Глобальні змінні існують у глобальній області видимості, яка змінюється, незалежно від цього, яка функція виконується в даний момент. Батьківська область видимості - це функція, в якій було оголошено замикання (не обов'язково та сама, з якої воно було викликане). Дивіться наступний приклад:\n\n**Приклад #4 Замикання та область видимості**\n\n```php\n<?php\n// Базовая корзина покупок, содержащая список добавленных\n// продуктов и количество каждого продукта. Включает метод,\n// вычисляющий общую цену элементов корзины с помощью\n// callback-замыкания.\nclass Cart\n{\n    const PRICE_BUTTER  = 1.00;\n    const PRICE_MILK    = 3.00;\n    const PRICE_EGGS    = 6.95;\n\n    protected $products = array();\n\n    public function add($product, $quantity)\n    {\n        $this->products[$product] = $quantity;\n    }\n\n    public function getQuantity($product)\n    {\n        return isset($this->products[$product]) ? $this->products[$product] :\n               FALSE;\n    }\n\n    public function getTotal($tax)\n    {\n        $total = 0.00;\n\n        $callback =\n            function ($quantity, $product) use ($tax, &$total)\n            {\n                $pricePerItem = constant(__CLASS__ . \"::PRICE_\" .\n                    strtoupper($product));\n                $total += ($pricePerItem * $quantity) * ($tax + 1.0);\n            };\n\n        array_walk($this->products, $callback);\n        return round($total, 2);\n    }\n}\n\n$my_cart = new Cart;\n\n// Добавляем несколько элементов в корзину\n$my_cart->add('butter', 1);\n$my_cart->add('milk', 3);\n$my_cart->add('eggs', 6);\n\n// Выводим общую сумму с 5% налогом на продажу.\nprint $my_cart->getTotal(0.05) . \"\\n\";\n// Результатом будет 54.29\n?>\n```\n\n**Приклад #5 Автоматичне зв'язування `$this`**\n\n```php\n<?php\n\nclass Test\n{\n    public function testing()\n    {\n        return function() {\n            var_dump($this);\n        };\n    }\n}\n\n$object = new Test;\n$function = $object->testing();\n$function();\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nobject(Test)#1 (0) {\n}\n```\n\nПри оголошенні в контексті класу, поточний клас буде автоматично пов'язаний з ним, роблячи `$this` доступним усередині функцій класу. Якщо ви не бажаєте автоматичного зв'язування з поточним класом, використовуйте [статичні анонімні функції](functions.anonymous.md#functions.anonymous-functions.static)\n\n### Статичні анонімні функції\n\nАнонімні функції можуть бути оголошені статично. Це запобігає їх автоматичному зв'язуванню з поточним класом. Об'єкти також не будуть пов'язані з ними під час виконання.\n\n**Приклад #6 Спроба використовувати `$this` у статичній анонімній функції**\n\n```php\n<?php\n\nclass Foo\n{\n    function __construct()\n    {\n        $func = static function() {\n            var_dump($this);\n        };\n        $func();\n    }\n};\nnew Foo();\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNotice: Undefined variable: this in %s on line %d\nNULL\n```\n\n**Приклад #7 Спроба зв'язати об'єкт із статичною анонімною функцією**\n\n```php\n<?php\n\n$func = static function() {\n    // тело функции\n};\n$func = $func->bindTo(new stdClass);\n$func();\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nWarning: Cannot bind an instance to a static closure in %s on line %d\n```\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.1.0 | Анонімні функції не можуть замикатися довкола [superglobals](language.variables.predefined.md), $this або будь-яка змінна з тим же ім'ям, що і параметр. |\n\n### Примітки\n\n> **Зауваження**: Всередині замикань можна використовувати функції [func\\_num\\_args()](function.func-num-args.md) [func\\_get\\_arg()](function.func-get-arg.md) і [func\\_get\\_args()](function.func-get-args.md)\n","title":"Анонімні функції","contentType":2,"navigation":[{"functions.internal.md":"« Вбудовані функції"},{"functions.arrow.md":"Стрілкові функції »"},{"index.md":"PHP Manual"},{"language.functions.md":"Функції"}]}},"__N_SSG":true}