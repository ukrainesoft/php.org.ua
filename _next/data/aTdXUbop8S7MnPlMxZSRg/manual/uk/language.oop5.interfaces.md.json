{"pageProps":{"page":{"slug":"language.oop5.interfaces.md","content":"## Інтерфейси об'єктів\n\nІнтерфейси об'єктів дозволяють створювати код, який вказує, які методи має реалізувати клас, без необхідності визначати, як саме вони мають бути реалізовані. Інтерфейси поділяють простір імен із класами та трейтами, тому вони не можуть називатися однаково.\n\nІнтерфейси оголошуються так само, як і звичайні класи, але з використанням ключового слова `interface` замість `class`. Тіла методів інтерфейсів мають бути порожніми.\n\nУсі методи, визначені в інтерфейсах, мають бути загальнодоступними, що випливає із самої природи інтерфейсу.\n\nНа практиці інтерфейси використовуються у двох взаємодоповнюючих випадках:\n\n-   Щоб дозволити розробникам створювати об'єкти різних класів, які можуть використовуватися взаємозамінно, оскільки вони реалізують той самий інтерфейс або інтерфейси. Типовий приклад – кілька служб доступу до бази даних, кілька платіжних шлюзів або різних стратегій кешування. Різні реалізації можуть бути замінені без будь-яких змін у коді, що їх використовує.\n-   Щоб дозволити функції або методу приймати та оперувати параметром, який відповідає інтерфейсу, не переймаючись тим, що ще може робити об'єкт або як він реалізований. Ці інтерфейси часто називають`Iterable` `Cacheable` `Renderable`і так далі, щоб описати їхню поведінку.\n\nІнтерфейси можуть визначати [магічні методи](language.oop5.magic.md), Вимагаючи від реалізуючих класів реалізації цих методів.\n\n> **Зауваження** :\n> \n> Хотя они поддерживаются, использование[конструкторів](language.oop5.decon.md#language.oop5.decon.constructor) в інтерфейсах не рекомендується. Це значно знижує гнучкість об'єкта, що реалізує інтерфейс. Крім того, до конструкторів не застосовуються правила успадкування, що може призвести до суперечливої ​​та несподіваної поведінки.\n\n### `implements`\n\nДля реализации интерфейса используется оператор`implements`. Клас повинен реалізувати всі методи, описані в інтерфейсі, інакше буде фатальна помилка. За бажанням класи можуть реалізовувати більше одного інтерфейсу, розділяючи кожен інтерфейс комою.\n\n**Увага**\n\nКлас, що реалізує інтерфейс, може використовувати для своїх параметрів ім'я, відмінне від імені інтерфейсу. Однак, починаючи з PHP 8.0, у мові підтримуються [іменовані аргументи](functions.arguments.md#functions.named-arguments), і код, що викликає, може покладатися на ім'я параметра в інтерфейсі. З цієї причини рекомендується, щоб розробники використовували ті ж імена параметрів, що і інтерфейс, що реалізується.\n\n> **Зауваження** :\n> \n> Інтерфейси можуть бути успадковані один від одного, так само, як і класи, за допомогою оператора [extends](language.oop5.inheritance.md)\n\n> **Зауваження** :\n> \n> Клас, що реалізує інтерфейс, повинен оголосити всі методи в інтерфейсі з [сумісною сигнатурою](language.oop5.basic.md#language.oop.lsp). Клас може реалізовувати кілька інтерфейсів, які оголошують метод із однаковим ім'ям. У цьому випадку реалізація має слідувати [правилам сумісності сигнатури](language.oop5.basic.md#language.oop.lsp) для інтерфейсів. Таким чином, можна застосовувати [коваріантність та контраваріантність](language.oop5.variance.md)\n\n### Константи\n\nІнтерфейси можуть містити константи. Константи інтерфейсів працюють так само, як і [константи класів](language.oop5.constants.md). До PHP 8.1.0 вони не могли бути перевизначені класом чи інтерфейсом, що їх успадковує.\n\n### Приклади\n\n**Приклад #1 Приклад інтерфейсу**\n\n```php\n<?php\n\n// Объявим интерфейс 'Template'\ninterface Template\n{\n    public function setVariable($name, $var);\n    public function getHtml($template);\n}\n\n// Реализация интерфейса\n// Это будет работать\nclass WorkingTemplate implements Template\n{\n    private $vars = [];\n\n    public function setVariable($name, $var)\n    {\n        $this->vars[$name] = $var;\n    }\n\n    public function getHtml($template)\n    {\n        foreach($this->vars as $name => $value) {\n            $template = str_replace('{' . $name . '}', $value, $template);\n        }\n\n        return $template;\n    }\n}\n\n// Это не будет работать\n// Fatal error: Class BadTemplate contains 1 abstract methods\n// and must therefore be declared abstract (Template::getHtml)\n// (Фатальная ошибка: Класс BadTemplate содержит 1 абстрактный метод\n// и поэтому должен быть объявлен абстрактным (Template::getHtml))\nclass BadTemplate implements Template\n{\n    private $vars = [];\n\n    public function setVariable($name, $var)\n    {\n        $this->vars[$name] = $var;\n    }\n}\n?>\n```\n\n**Приклад #2 Спадкування інтерфейсів**\n\n```php\n<?php\ninterface A\n{\n    public function foo();\n}\n\ninterface B extends A\n{\n    public function baz(Baz $baz);\n}\n\n// Это сработает\nclass C implements B\n{\n    public function foo()\n    {\n    }\n\n    public function baz(Baz $baz)\n    {\n    }\n}\n\n// Это не сработает и выдаст фатальную ошибку\nclass D implements B\n{\n    public function foo()\n    {\n    }\n\n    public function baz(Foo $foo)\n    {\n    }\n}\n?>\n```\n\n**Приклад #3 Сумісність із кількома інтерфейсами**\n\n```php\n<?php\nclass Foo {}\nclass Bar extends Foo {}\n\ninterface A {\n    public function myfunc(Foo $arg): Foo;\n}\n\ninterface B {\n    public function myfunc(Bar $arg): Bar;\n}\n\nclass MyClass implements A, B\n{\n    public function myfunc(Foo $arg): Bar\n    {\n        return new Bar();\n    }\n}\n?>\n```\n\n**Приклад #4 Множинне наслідування інтерфейсів**\n\n```php\n<?php\ninterface A\n{\n    public function foo();\n}\n\ninterface B\n{\n    public function bar();\n}\n\ninterface C extends A, B\n{\n    public function baz();\n}\n\nclass D implements C\n{\n    public function foo()\n    {\n    }\n\n    public function bar()\n    {\n    }\n\n    public function baz()\n    {\n    }\n}\n?>\n```\n\n**Приклад #5 Інтерфейси з константами**\n\n```php\n<?php\ninterface A\n{\n    const B = 'Константа интерфейса';\n}\n\n// Выведет: Константа интерфейса\necho A::B;\n\n\nclass B implements A\n{\n    const B = 'Константа класса';\n}\n\n// Выведет: Константа класса\n// До PHP 8.1.0 этот код не будет работать,\n// потому что было нельзя переопределять константы.\necho B::B;\n?>\n```\n\n**Приклад #6 Інтерфейси з абстрактними класами**\n\n```php\n<?php\ninterface A\n{\n    public function foo(string $s): string;\n\n    public function bar(int $i): int;\n}\n\n// Абстрактный класс может реализовывать только часть интерфейса.\n// Классы, расширяющие абстрактный класс, должны реализовать все остальные.\nabstract class B implements A\n{\n    public function foo(string $s): string\n    {\n        return $s . PHP_EOL;\n    }\n}\n\nclass C extends B\n{\n    public function bar(int $i): int\n    {\n        return $i * 2;\n    }\n}\n?>\n```\n\n**Приклад #7 Одночасне розширення та впровадження**\n\n```php\n<?php\n\nclass One\n{\n    /* ... */\n}\n\ninterface Usable\n{\n    /* ... */\n}\n\ninterface Updatable\n{\n    /* ... */\n}\n\n// Порядок ключевых слов здесь важен. \"extends\" должно быть первым.\nclass Two extends One implements Usable, Updatable\n{\n    /* ... */\n}\n?>\n```\n\nІнтерфейс, разом із оголошеннями типів, надає відмінний спосіб перевірки те, що певний об'єкт містить певний набір методів. Дивіться також оператор [instanceof](language.operators.type.md) і [оголошення типів](language.types.declarations.md)\n","title":"Інтерфейси об'єктів","contentType":2,"navigation":[{"language.oop5.abstract.md":"« Абстрактні класи"},{"language.oop5.traits.md":"Трейти »"},{"index.md":"PHP Manual"},{"language.oop5.md":"Класи та об'єкти"}]}},"__N_SSG":true}