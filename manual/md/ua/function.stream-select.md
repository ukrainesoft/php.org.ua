- [«
stream_resolve_include_path](function.stream-resolve-include-path.md)
- [stream_set_blocking »](function.stream-set-blocking.md)

- [PHP Manual](index.md)
- [Функції для роботи з потоками](ref.stream.md)
- Запускає еквівалент системного виклику select() на заданих масивах
потоків з часом очікування, вказаним параметрами seconds та
microseconds

#stream_select

(PHP 4 \>u003d 4.3.0, PHP 5, PHP 7, PHP 8)

stream_select — Запускає еквівалент системного виклику select()
заданих масивах потоків з часом очікування, вказаним параметрами
seconds та microseconds

### Опис

**stream_select**(
?array `&$read`,
?array `&$write`,
?array `&$except`,
?int `$seconds`,
?int `$microseconds` u003d **`null`**
): int\|false

Функція **stream_select()** отримує масиви потоків і чекає зміни їх
статусу. Її робота еквівалентна роботі функції
[socket_select()](function.socket-select.md), за винятком того, що
вона працює із потоками.

### Список параметрів

`read`
Потоки, перелічені в масиві `read` будуть відстежуватись на предмет
появи символів, доступних для читання (точніше, щоб переконатися, що
читання не блокуватиметься - зокрема, потоковий ресурс також
готовий для читання в кінці файлу, але в цьому випадку функція
[fread()](function.fread.md) повертатиме рядок нульової довжини).

`write`
Потоки, перелічені в масиві `write`, будуть відстежуватись на предмет
того, що запис у них не блокуватиметься.

`except`
Потоки, перелічені в масиві `except`, будуть відстежуватись на предмет
надходження високопріоритетних виняткових (неполосних або
"out-of-band") даних.

> **Примітка**:
>
> Коли **stream_select()** повертається, масиви `read`, `write` і
> `except` змінюються для того, щоб вказати, які потокові ресурси
> насправді змінили статус. Вихідні ключі масивів (array)
> зберігаються.

`seconds`
Параметри `seconds` та `microseconds` разом формують параметр
*timeout*, `seconds` вказує число секунд, а `microseconds` - число
мікросекунд. Параметр `timeout` - це верхня межа часу, що
функція **stream_select()** чекатиме до повернення. Якщо параметри
`seconds` та `microseconds` обидва встановлені в `0`, то функція
**stream_select()** не буде очікувати даних - натомість вона повернеться
негайно вказуючи поточний статус потоків.

Якщо параметр `seconds` дорівнює **`null`**, то функція **stream_select()**
може виконуватися невизначений час, повертаючись лише тоді, коли
відбувається подія на одному з потоків, що відстежуються (або якщо системний
виклик переривається сигналом).

**Увага**
Використання значення часу очікування `0` дозволяє вам миттєво
опитати статус потоків, однак погана ідея використовувати значення
часу очікування `0` у циклі, тому що це змусить ваш скрипт споживати
надто багато процесорного часу.

Набагато краще вказати значення часу очікування за кілька секунд, хоча
якщо вам потрібно перевіряти та одночасно запускати інший код,
використання часу очікування як мінімум `200000` мікросекунд допоможе
зменшити використання процесорного часу вашим скриптом.

Запам'ятайте, що значення часу очікування – це максимальний час,
яке буде витрачено. Функція **stream_select()** повернеться як тільки
запитані потоки будуть готові до використання.

`microseconds`
Дивіться опис параметра `seconds`.

### Значення, що повертаються

У разі успішного виконання функція **stream_select()** повертає
кількість потокових ресурсів, що міститься в змінених масивах,
яке може дорівнювати нулю, якщо перевищено час очікування до того, як
сталося щось цікаве. У разі виникнення помилки повертається
**`false`** і виникає попередження (це може статися, якщо
системний виклик переривається вхідним сигналом.

### Список змін

| Версія | Опис |
|--------|---------------------------------------- -----------------------|
| 8.1.0 | Параметр `microseconds` тепер допускає значення **`null`**. |

### Приклади

**Приклад #1 Приклад використання **stream_select()****

Цей приклад перевіряє, що отримано дані для читання на потоках
`$stream1` або `$stream2`. Оскільки значення часу очікування дорівнює `0`,
функція повернеться негайно:

` <?php/* Підготувати масив для читання */$read   u003d array($stream1, $stream2);$write  u003d NULL;$except u003d NULL;if (false u003du003du003d $$ write, $except, 0))) {    /* Обробка помилок */} elseif ($num_changed_streams > 0) {    /* Як мінімум на       

### Примітки

> **Примітка**:
>
> Через обмеження в поточному Zend Engine неможливо передати
> постійну **`null`** безпосередньо як параметр у функцію, яка
> очікує, що цей параметр буде надіслано за посиланням. Замість цього
> використовуйте тимчасову змінну або вираз, у якому крайній
> лівий член буде тимчасовою змінною:
>
> ` <?php$e u003d NULL;stream_select($r, $w, $e, 0);?> `

> **Примітка**:
>
> Перевірте, чи використовуєте оператор `u003du003du003d` під час перевірки помилки. Так
> як функція **stream_select()** може повертати 0 порівняння з
> використанням `u003du003d` може повертати **`true`**:
>
> ` <?php$e u003d NULL;if (false u003du003du003d stream_select($r, $w, $e, 0)) {    echo "Сталася помилка при виклику stream_select()
";}?> `

> **Примітка**:
>
> Якщо ви читаєте/пишете в потік, що повертається в масивах, знайте, що
> вони не обов'язково читають/пишуть повну кількість даних, яку ви
> запитали. Будьте готові до того, щоб мати можливість читати/писати
> навіть по одному байту.

> **Примітка**:
>
> Деякі потоки (наприклад, `zlib`) не можуть бути обрані цієї
> функцією.

> **Примітка**: **Сумісність із Windows**
>
> Використання функції **stream_select()** на файлових дескрипторах,
> повернутих функцією [proc_open()](function.proc-open.md) не
> вдасться та поверне **`false`** під Windows.
>
> **`STDIN`** з консолі змінює статус, як тільки стають доступними
> *які* вхідні події, але читання з потоку все ще може
> блокувати.

### Дивіться також

- [stream_set_blocking()](function.stream-set-blocking.md) -
Встановити блокуючий/неблокуючий режим у потоці
