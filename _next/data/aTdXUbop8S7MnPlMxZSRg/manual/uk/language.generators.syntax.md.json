{"pageProps":{"page":{"slug":"language.generators.syntax.md","content":"## Синтаксис генераторів\n\nГенератор в цілому виглядає як звичайна функція, за винятком того, що замість повернення одного значення, генератор перебиратиме стільки значень, скільки необхідно. Будь-яка функція, що містить [yield](language.generators.syntax.md#control-structures.yield)є функцією генератора.\n\nКоли генератор викликається, він повертає об'єкт, який можна ітерувати. Коли ви ітеруєте цей об'єкт (наприклад, у циклі [foreach](control-structures.foreach.md)), PHP викликає методи ітерації об'єкта щоразу, коли вам потрібне нове значення, після чого зберігає стан генератора і при наступному виклику повертає наступне значення.\n\nКоли всі значення генератора закінчилися, генератор просто завершить роботу, нічого не повернувши. Після цього основний код продовжить роботу, як у масиві закінчилися елементи для перебору.\n\n> **Зауваження** :\n> \n> Генератори можуть повертати значення, які можна отримати за допомогою [Generator::getReturn()](generator.getreturn.md)\n\n### Ключевое слово**yield**\n\nВся суть генератора полягає у ключовому слові **yield**. . У найпростішому варіанті оператор \"yield\" можна розглядати як оператор \"return\", за винятком того, що замість припинення роботи функції, \"yield\" тільки зупиняє її виконання та повертає поточне значення, і при наступному виклику функції вона відновить виконання з місця на якому перервалася.\n\n**Приклад #1 Простий приклад видачі значень**\n\n```php\n<?php\nfunction gen_one_to_three() {\n    for ($i = 1; $i <= 3; $i++) {\n        // Обратите внимание, что $i сохраняет своё значение между вызовами.\n        yield $i;\n    }\n}\n\n$generator = gen_one_to_three();\nforeach ($generator as $value) {\n    echo \"$value\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1\n2\n3\n```\n\n> **Зауваження** :\n> \n> Послідовність цілих чисел буде пов'язана з одержуваними від генератора значеннями, начебто перебирається неасоціативний масив.\n\n#### Отримання значень із ключами\n\nPHP підтримує асоціативні масиви, і генератори є винятком. Так само, як можна отримувати прості значення, як показано вище, ви можете отримувати значення з ключами.\n\nСинтаксис отримання ключ/значення дуже схожий на синтаксис асоціативних масивів, як показано нижче.\n\n**Приклад #2 Отримання пар ключ/значення**\n\n```php\n<?php\n/* $input содержит пары ключ/значение разделённые точкой с запятой */\n\n$input = <<<'EOF'\n1;PHP;Любит знаки доллара\n2;Python;Любит пробелы\n3;Ruby;Любит блоки\nEOF;\n\nfunction input_parser($input) {\n    foreach (explode(\"\\n\", $input) as $line) {\n        $fields = explode(';', $line);\n        $id = array_shift($fields);\n\n        yield $id => $fields;\n    }\n}\n\nforeach (input_parser($input) as $id => $fields) {\n    echo \"$id:\\n\";\n    echo \"    $fields[0]\\n\";\n    echo \"    $fields[1]\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1:\n    PHP\n    Любит знаки доллара\n2:\n    Python\n    Любит пробелы\n3:\n    Ruby\n    Любит блоки\n```\n\n#### Отримання NULL\n\nДля получения\\*\\*`null`\\*\\* Треба викликати \"Yield\" без аргументів. Ключ згенерується автоматично.\n\n**Приклад #3 Получение**`null`\\*\\*\\*\\*\n\n```php\n<?php\nfunction gen_three_nulls() {\n    foreach (range(1, 3) as $i) {\n        yield;\n    }\n}\n\nvar_dump(iterator_to_array(gen_three_nulls()));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(3) {\n  [0]=>\n  NULL\n  [1]=>\n  NULL\n  [2]=>\n  NULL\n}\n```\n\n#### Отримання значення за посиланням\n\nГенератори можуть надавати значення за посиланням. Це робиться так само, як [повернення посилань із функцій](functions.returning-values.md): додаванням амперсанда (&) перед ім'ям функції.\n\n**Приклад #4 Отримання значень за посиланням**\n\n```php\n<?php\nfunction &gen_reference() {\n    $value = 3;\n\n    while ($value > 0) {\n        yield $value;\n    }\n}\n\n/* Обратите внимание, что мы можем изменять $number в цикле, и\n * так как генератор возвращает ссылку, $value\n * в gen_reference() также изменится. */\nforeach (gen_reference() as &$number) {\n    echo (--$number).'... ';\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n2... 1... 0...\n```\n\n#### Делегирование генератора с помощью**yield from**\n\nДелегування генератора дозволяє вам отримувати значення з іншого генератора, об'єкта [Traversable](class.traversable.md), або масиву, використовуючи **yield from**. Зовнішній генератор повертатиме значення з внутрішнього генератора, об'єкта або масиву, до того часу, поки вони їх віддають, після чого продовжиться виконання зовнішнього генератора.\n\nЯкщо генератор використовується з **yield from**, то вираз **yield from** також повертатиме значення з внутрішнього генератора.\n\n**Застереження**\n\n# Сохранение в массив (наПриклад, с помощью[iterator\\_to\\_array()](function.iterator-to-array.md)) .\n\n**yield from** не скидає ключі. Ключі, повернуті з об'єкту [Traversable](class.traversable.md) або масиву, збережуться. Таким чином, деякі значення можуть перетинатися по ключах з іншими **yield** або **yield from**, Що, при записі в масив, спричинить перезапис колишніх значень.\n\nЗагальний випадок, коли це має значення, це коли [iterator\\_to\\_array()](function.iterator-to-array.md) повертає масив із ключами за замовчуванням. В цьому випадку можна отримати несподіваний результат . [iterator\\_to\\_array()](function.iterator-to-array.md) має другий параметр `preserve_keys`, який можна встановити в **`false`**, для генерації власних ключів та ігнорування ключів, переданих з об'єкта [Generator](class.generator.md)\n\n**Приклад #5**yield from**с[iterator\\_to\\_array()](function.iterator-to-array.md)**\n\n```php\n<?php\nfunction inner() {\n    yield 1; // ключ 0\n    yield 2; // ключ 1\n    yield 3; // ключ 2\n}\nfunction gen() {\n    yield 0; // ключ 0\n    yield from inner(); // ключи 0-2\n    yield 4; // ключ 1\n}\n// Задайте false вторым параметром для получения массива [0, 1, 2, 3, 4]\nvar_dump(iterator_to_array(gen()));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(3) {\n  [0]=>\n  int(1)\n  [1]=>\n  int(4)\n  [2]=>\n  int(3)\n}\n```\n\n**Приклад #6 Основи використання **yield from****\n\n```php\n<?php\nfunction count_to_ten() {\n    yield 1;\n    yield 2;\n    yield from [3, 4];\n    yield from new ArrayIterator([5, 6]);\n    yield from seven_eight();\n    yield 9;\n    yield 10;\n}\n\nfunction seven_eight() {\n    yield 7;\n    yield from eight();\n}\n\nfunction eight() {\n    yield 8;\n}\n\nforeach (count_to_ten() as $num) {\n    echo \"$num \";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1 2 3 4 5 6 7 8 9 10\n```\n\n**Приклад #7**yield from\\*\\* і значення, що повертаються\\*\\*\n\n```php\n<?php\nfunction count_to_ten() {\n    yield 1;\n    yield 2;\n    yield from [3, 4];\n    yield from new ArrayIterator([5, 6]);\n    yield from seven_eight();\n    return yield from nine_ten();\n}\n\nfunction seven_eight() {\n    yield 7;\n    yield from eight();\n}\n\nfunction eight() {\n    yield 8;\n}\n\nfunction nine_ten() {\n    yield 9;\n    return 10;\n}\n\n$gen = count_to_ten();\nforeach ($gen as $num) {\n    echo \"$num \";\n}\necho $gen->getReturn();\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1 2 3 4 5 6 7 8 9 10\n```\n","title":"Синтаксис генераторів","contentType":2,"navigation":[{"language.generators.overview.md":"«Знайомство з генераторами"},{"language.generators.comparison.md":"Порівняння генераторів з об'єктами класу Iterator »"},{"index.md":"PHP Manual"},{"language.generators.md":"Генератори"}]}},"__N_SSG":true}