- [«Складання сміття](features.gc.md)
- [Збір циклічних посилань »](features.gc.collecting-cycles.md)

- [PHP Manual](index.md)
- [Складання сміття](features.gc.md)
- Основи підрахунку посилань

## Основи підрахунку посилань

Змінна PHP зберігається в контейнері, що називається "zval". Контейнер zval,
крім типу та значення змінної, також містить два додаткові
елемент. Перший називається "is_ref" і представляє булеве значення,
що вказує, є змінна частиною "набору посилань" чи ні.
Завдяки цьому елементу PHP знає як відрізняти звичайні змінні від
посилань. Так як PHP містить посилання користувача, які можна
створити оператором & контейнер zval також містить внутрішній механізм
підрахунку посилань для оптимізації використання пам'яті. Ця друга частина
додаткової інформації, звана "refcount" (лічильник посилань),
містить кількість імен змінних (також званих символами),
які вказують на цей контейнер zval. Усі імена змінних
зберігаються у таблиці імен, окремої кожної області видимості
змінних. Така область видимості існує для головного скрипта, а
також для кожної функції та методу.

Контейнер zval створюється при створенні нової змінної, якою
присвоюється константа, наприклад:

**Приклад #1 Створення нового контейнера zval**

` <?php$a u003d "new string";?> `

У цьому прикладі створюється новий символ `a` у поточній області видимості
і новий контейнер змінної з типом string та значенням "new string".
Біт "is_ref" за замовчуванням задається рівним **`false`**, т.к. не створено
жодного користувача посилання. Значення "refcount" задається рівним
`1`, т.к. лише одне ім'я змінної вказує цей контейнер.
Зверніть увагу, що посилання (тобто "is_ref" одно **`true`**) з
"refcount" рівним `1` обробляються так, якби вони не були
посиланнями (тобто як "is_ref" було б **`false`**). Якщо у вас
встановлений [» Xdebug](http://xdebug.org/), то ви можете вивести цю
інформацію, викликавши функцію **xdebug_debug_zval()**.

**Приклад #2 Виведення інформації про zval**

` <?php$a u003d "new string";xdebug_debug_zval('a');?> `

Результат виконання цього прикладу:

a: (refcountu003d1, is_refu003d0)u003d'new string'

Присвоєння цієї змінної інший збільшує лічильник посилань.

**Приклад #3 Збільшення лічильника посилань zval**

` <?php$a u003d "new string";$b u003d $a;xdebug_debug_zval( 'a' );?> `

Результат виконання цього прикладу:

a: (refcountu003d2, is_refu003d0)u003d'new string'

Лічильник посилань тут дорівнює `2`, т.к. `a` та `b` посилаються на один і той
ж контейнер змінної. PHP досить розумний, щоб не копіювати
контейнер, поки що в цьому немає необхідності. Як тільки "refcount" стане
рівним нулю, контейнер знищується. "refcount" зменшується на одиницю
при відході змінної з області видимості (наприклад, наприкінці функції)
або при видаленні цієї змінної (наприклад при виклику
[unset()](function.unset.md)).

**Приклад #4 Зменшення лічильника посилань zval**

` <?php$a u003d "new string";$c u003d $b u003d $a;xdebug_debug_zval( 'a' );$b u003d 42;xdebug_debug_zval( 'a' );unset( $c ' );?> `

Результат виконання цього прикладу:

a: (refcountu003d3, is_refu003d0)u003d'new string'
a: (refcountu003d2, is_refu003d0)u003d'new string'
a: (refcountu003d1, is_refu003d0)u003d'new string'

Якщо ми зараз викличемо `unset($a);`, то контейнер, включаючи тип і
значення буде видалено з пам'яті.

### Складові типи даних

Усі дещо ускладнюється зі складовими типами даних, такими як масиви
(array) та об'єкти (object). На відміну від скалярних (scalar) значень,
масиви та об'єкти зберігають свої властивості у власних таблицях імен. Це
означає, що наступний приклад створить відразу три zval контейнери:

**Приклад #5 Створення array zval**

` <?php$a u003d array( 'meaning' u003d> 'life', 'number' u003d> 42 );xdebug_debug_zval( 'a' );?> `

Результатом виконання цього прикладу буде щось подібне:

a: (refcountu003d1, is_refu003d0)u003darray (
'meaning' u003d> (refcountu003d1, is_refu003d0)u003d'life',
'number' u003d> (refcountu003d1, is_refu003d0)u003d42
)

Графічно:

![Контейнери для простого
масиву](images/12f37b1c6963c1c5c18f30495416a197-simple-array.png)

Результат - три контейнери: `a`, `meaning` та `number`. Схожі правила
застосовуються і для збільшення та зменшення "refcounts". Нижче ми додаємо
ще один елемент масиву та встановлюємо йому значення вже існуючого
елемента:

**Приклад #6 Додавання вже існуючого елемента до масиву**

` <?php$a u003d array( 'meaning' u003d> 'life', 'number' u003d> 42 );$a['life'] u003d $a['meaning'];xdebug_debug_zval( 'a' );? > `

Результатом виконання цього прикладу буде щось подібне:

a: (refcountu003d1, is_refu003d0)u003darray (
'meaning' u003d> (refcountu003d2, is_refu003d0)u003d'life',
'number' u003d> (refcountu003d1, is_refu003d0)u003d42,
'life' u003d> (refcountu003d2, is_refu003d0)u003d'life'
)

Графічно:

![Контейнери для простого масиву зі
посилання](images/12f37b1c6963c1c5c18f30495416a197-simple-array2.png)

Наведений вище висновок Xdebug показує, що і старий і новий елементи
масиву зараз вказують на контейнер, чий "refcount" дорівнює `2`. Хоча
показано два контейнери зі значенням "life", насправді це один
контейнер. Функція **xdebug_debug_zval()** не виводить інформації про
це, але ви можете перевірити це також відобразивши покажчики пам'яті.

Видалення елемента з масиву відбувається так само, як і видалення
імені змінної в області видимості: зменшується "refcount"
контейнера, який посилається елемент масиву. Знову ж таки, при
досягнувши "refcount" нуля, контейнер видаляється з пам'яті. Приклад:

**Приклад #7 Видалення елемента з масиву**

` <?php$a u003d array( 'meaning' u003d> 'life', 'number' u003d> 42 );$a['life'] u003d $a['meaning'];unset( $a['meaning') ], $a['number'] );xdebug_debug_zval( 'a' );?> `

Результатом виконання цього прикладу буде щось подібне:

a: (refcountu003d1, is_refu003d0)u003darray (
'life' u003d> (refcountu003d1, is_refu003d0)u003d'life'
)

Ситуація стане цікавіше, якщо додати масив новим елементом
самого себе. У наступному прикладі ми також використовуємо оператор
надання за посиланням, щоб PHP не створив копію масиву.

**Приклад #8 Додавання масиву новим елементом до самого себе**

` <?php$a u003d array( 'one' );$a[] u003d& $a;xdebug_debug_zval( 'a' );?> `

Результатом виконання цього прикладу буде щось подібне:

a: (refcountu003d2, is_refu003d1)u003darray (
0 u003d> (refcountu003d1, is_refu003d0)u003d'one',
1 u003d> (refcountu003d2, is_refu003d1)u003d...
)

Графічно:

![Контейнери масиву з циклічними
посилання](images/12f37b1c6963c1c5c18f30495416a197-loop-array.png)

Можна побачити, що змінна з масивом (`a`), як і другий
елемент (`1`) зараз вказують на контейнер із "refcount" рівним `2`.
Символи "..." у висновку означають рекурсію і в нашому випадку вказують на
оригінальний масив.

Як і раніше, видалення змінної зменшує лічильник посилань контейнера на
одиницю. Якщо ми застосуємо unset до змінної `$a` після наведеного вище
Наприклад, лічильник посилань контейнера, на який вказують `$a` і
елемент "1", зміниться з "2" на "1":

**Приклад #9 Видалення `$a`**

(refcountu003d1, is_refu003d1)u003darray (
0 u003d> (refcountu003d1, is_refu003d0)u003d'one',
1 u003d> (refcountu003d1, is_refu003d1)u003d...
)

Графічно:

![Контейнери після видалення масиву з циклічними посиланнями,
демонструють витік
пам'яті](images/12f37b1c6963c1c5c18f30495416a197-leak-array.png)

### Суть проблеми

Хоча у всіх областях видимості більше немає імені змінної, що посилається
на цю структуру, вона може бути очищена, т.к. елемент масиву "1"
як і раніше, посилається на цей масив. Т.к. тепер немає жодної
можливості користувачеві видалити ці дані, ми отримали витік
пам'яті. На щастя, PHP видалить ці дані при завершенні запиту, але до
цього моменту дані займатимуть цінне місце у пам'яті. Така
ситуація часто буває, коли реалізуються алгоритми парсингу чи інші,
де є дочірні елементи, які посилаються на батьківські. Ще частіше така
ситуація трапляється з об'єктами, тому що вони завжди неявно
використовуються за посиланням.

Ця не проблема, якщо таке трапляється раз чи два, але якщо існують
тисячі чи навіть мільйони таких витоків пам'яті, то вони вже стають
проблемою. Особливо у довгопрацюючих скриптах, таких як демони, де
запит ніколи не закінчується, або у великих наборах модульних тестів.
Останній випадок викликав проблеми при запуску модульних тестів
компонента Template із бібліотеки ez Components. В деяких випадках
може знадобитися понад 2 Гб пам'яті, яка не завжди є на
тестовий сервер.
