{"pageProps":{"page":{"slug":"function.token-get-all.md","content":"# token\\_get\\_all\n\n(PHP 4 >= 4.2.0, PHP 5, PHP 7, PHP 8)\n\ntoken\\_get\\_all — Розбиває переданий вихідний код на PHP-лексеми\n\n### Опис\n\n```methodsynopsis\ntoken_get_all(string $code, int $flags = 0): array\n```\n\nФункция**token\\_get\\_all()** розбирає переданий рядок `code` у мовні лексеми PHP, використовуючи лексичний сканер Zend Engine.\n\nСписок лексем смотрите в[Список тегів (tokens) парсера](tokens.md)или используйте[token\\_name()](function.token-name.md) для переведення значення лексеми в рядкову виставу.\n\n### Список параметрів\n\n`code`\n\nВихідний код PHP для аналізу.\n\n`flags`\n\nКоректні прапори:\n\n-   \\*\\*`TOKEN_PARSE`\\*\\*- Визначає можливість використання зарезервованих слів у певних контекстах.\n\n### Значення, що повертаються\n\nМасив ідентифікаторів лексем. Кожен індивідуальний ідентифікатор лексеми це чи одиночний символ (наприклад, `>` `!`, інші...), або триелементний масив, що містить індекс лексеми в нульовому елементі, рядок з оригінальним вмістом лексеми у першому елементі та номером рядка у другому елементі.\n\n### Приклади\n\n**Приклад #1**token\\_get\\_all()**example**\n\n```php\n<?php\n$tokens = token_get_all('<?php echo; ?>');\n\nforeach ($tokens as $token) {\n    if (is_array($token)) {\n        echo \"Строка {$token[2]}: \", token_name($token[0]), \" ('{$token[1]}')\", PHP_EOL;\n    }\n}\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nСтрока 1: T_OPEN_TAG ('<?php ')\nСтрока 1: T_ECHO ('echo')\nСтрока 1: T_WHITESPACE (' ')\nСтрока 1: T_CLOSE_TAG ('?>')\n```\n\n**Приклад #2 Приклад неправильного использования**token\\_get\\_all()\\*\\*\\*\\*\n\n```php\n<?php\n$tokens = token_get_all('/* комментарий */');\n\nforeach ($tokens as $token) {\n    if (is_array($token)) {\n        echo \"Строка {$token[2]}: \", token_name($token[0]), \" ('{$token[1]}')\", PHP_EOL;\n    }\n}\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nСтрока 1: T_INLINE_HTML ('/* комментарий */')\n```\n\nЗверніть увагу, у наведеному прикладі рядок розбирається як **`T_INLINE_HTML`** замість очікуваного **`T_COMMENT`**. Це пов'язано з тим, що не використовується тег, що відкриває в коді. Це було б еквівалентно розміщенню коментарів поза тегами PHP у звичайному файлі.\n\n**Приклад #3 Приклад використання** token\\_get\\_all()\\*\\* з класом, який використовує зарезервовані слова\\*\\*\n\n```php\n<?php\n\n$source = <<<'code'\n<?php\n\nclass A\n{\n    const PUBLIC = 1;\n}\ncode;\n\n$tokens = token_get_all($source, TOKEN_PARSE);\n\nforeach ($tokens as $token) {\n    if (is_array($token)) {\n        echo token_name($token[0]) , PHP_EOL;\n    }\n}\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nT_OPEN_TAG\nT_WHITESPACE\nT_CLASS\nT_WHITESPACE\nT_STRING\nT_CONST\nT_WHITESPACE\nT_STRING\nT_LNUMBER\n```\n\nБез флага\\*\\*`TOKEN_PARSE`**, передостанній токен (**`T_STRING`\\*\\*) був би **`T_PUBLIC`**\n\n### Дивіться також\n\n-   [PhpToken::tokenize()](phptoken.tokenize.md) \\- Розбирає заданий рядок, що містить програму на PHP, на масив об'єктів PhpToken\n-   [token\\_name()](function.token-name.md) \\- Отримати символьне ім'я для переданої PHP-лексеми\n","title":"token\\_get\\_all","contentType":2,"navigation":[{"ref.tokenizer.md":"Функції PHP-лексера (tokenizer)"},{"function.token-name.md":"token\\_name »"},{"index.md":"PHP Manual"},{"ref.tokenizer.md":"Функції PHP-лексера (tokenizer)"}]}},"__N_SSG":true}