{"pageProps":{"page":{"slug":"ev.examples.md","content":"# Приклади\n\n**Приклад #1 Прості таймери**\n\n```php\n<?php\n// Создаём и запускаем таймер на 2 секунды\n$w1 = new EvTimer(2, 0, function () {\n    echo \"2 секунды прошло\\n\";\n});\n\n// Создаём и запускаем таймер, который сработает через 2 секунды, после чего будет срабатывать\n// раз в секунду, пока вы его вручную не остановите\n$w2 = new EvTimer(2, 1, function ($w) {\n    echo \"вызывается раз в секунду, первое срабатывание через 2 секунды\\n\";\n    echo \"итерация = \", Ev::iteration(), PHP_EOL;\n\n    // Останавливаем наблюдателя через 5 итераций\n    Ev::iteration() == 5 and $w->stop();\n    // Остановливаем наблюдателя, если следующий вызов приведёт к десятой (или больше) итерации\n    Ev::iteration() >= 10 and $w->stop();\n});\n\n// Создаём остановленный таймер. Он будет неактивен, пока мы его не запустим\n$w_stopped = EvTimer::createStopped(10, 5, function($w) {\n    echo \"Callback-функция таймера, созданного остановленным\\n\";\n\n    // Останавливаем наблюдателя через 2 итерации\n    Ev::iteration() >= 2 and $w->stop();\n});\n\n// Запускаем событийный цикл, пока работает хотя бы один наблюдатель или пока не вызван Ev::stop()\nEv::run();\n\n// Запускаем и смотрим, как он работает\n$w_stopped->start();\necho \"Запускаем одну итерацию\\n\";\nEv::run(Ev::RUN_ONCE);\n\necho \"Перезапускаем второго наблюдателя и пытаемся отловить те же события, но не блокируем\\n\";\n$w2->again();\nEv::run(Ev::RUN_NOWAIT);\n\n$w = new EvTimer(10, 0, function() {});\necho \"Запускаем блокирующий цикл\\n\";\nEv::run();\necho \"END\\n\";\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\n2 секунды прошло\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 1\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 2\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 3\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 4\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 5\nЗапускаем одну итерацию\nФункция обратного вызова таймера, созданного остановленным\nПерезапускаем второго наблюдателя и пытаемся отловить те же события, но не блокируем\nЗапускаем блокирующий цикл\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 8\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 9\nвызывается раз в секунду, первое срабатывание через 2 секунды\nитерация = 10\nEND\n```\n\n**Приклад #2 Періодичний таймер. Спрацьовує раз на 10.5 секунд**\n\n```php\n<?php\n$w = new EvPeriodic(0., 10.5, NULL, function ($w, $revents) {\n    echo time(), PHP_EOL;\n});\n\nEv::run();\n?>\n```\n\n**Приклад #3 Періодичний таймер. Використання callback-функції для перезавдання інтервалу**\n\n```php\n<?php\n// Срабатывает раз в 10.5 секунд\n\nfunction reschedule_cb ($watcher, $now) {\n    return $now + (10.5. - fmod($now, 10.5));\n}\n\n$w = new EvPeriodic(0., 0., \"reschedule_cb\", function ($w, $revents) {\n    echo time(), PHP_EOL;\n});\n\nEv::run();\n?>\n```\n\n**Приклад #4 Періодичний таймер. Спрацьовує кожні 10.5 секунд, починаючи з поточного моменту**\n\n```php\n<?php\n// Срабатывает раз в 10.5 секунд начиная с текущего момента\n$w = new EvPeriodic(fmod(Ev::now(), 10.5), 10.5, NULL, function ($w, $revents) {\n    echo time(), PHP_EOL;\n});\n\nEv::run();\n?>\n```\n\n**Приклад #5 Чекаємо, доки STDIN не стане читаним**\n\n```php\n<?php\n// Ждём, пока STDIN не станет читаемым\n$w = new EvIo(STDIN, Ev::READ, function ($watcher, $revents) {\n    echo \"STDIN is readable\\n\";\n});\n\nEv::run(Ev::RUN_ONCE);\n?>\n```\n\n**Приклад #6 Використовуємо асинхронне введення/виведення для доступу до сокету**\n\n```php\n<?php\n/* Используем асинхронный ввод/вывод для доступа к сокету */\n\n// Модуль `sockets' продолжит логировать предупреждения\n// для EINPROGRESS, EAGAIN/EWOULDBLOCK etc.\nerror_reporting(E_ERROR);\n\n$e_nonblocking = array (/*EAGAIN или EWOULDBLOCK*/11, /*EINPROGRESS*/115);\n\n// Получаем порт для сервиса WWW\n$service_port = getservbyname('www', 'tcp');\n\n// Получаем IP-адрес целевого хоста\n$address = gethostbyname('google.co.uk');\n\n// Создаём сокет TCP/IP\n$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\nif ($socket === FALSE) {\n    echo \"Ошибка при вызове socket_create(): причина: \"\n        .socket_strerror(socket_last_error()) . \"\\n\";\n}\n\n// Устанавливаем флаг O_NONBLOCK\nsocket_set_nonblock($socket);\n\n// Прерываем по превышению времени ожидания\n$timeout_watcher = new EvTimer(10.0, 0., function () use ($socket) {\n    socket_close($socket);\n    Ev::stop(Ev::BREAK_ALL);\n});\n\n// Посылаем запрос HEAD когда сокет доступен для записи\n$write_watcher = new EvIo($socket, Ev::WRITE, function ($w)\n    use ($socket, $timeout_watcher, $e_nonblocking)\n{\n    // Останавливаем наблюдателя $timeout_watcher\n    $timeout_watcher->stop();\n    // Останавливаем наблюдателя $write_watcher\n    $w->stop();\n\n    $in = \"HEAD / HTTP/1.1\\r\\n\";\n    $in .= \"Host: google.co.uk\\r\\n\";\n    $in .= \"Connection: Close\\r\\n\\r\\n\";\n\n    if (!socket_write($socket, $in, strlen($in))) {\n        trigger_error(\"Ошибка записи $in в сокет\", E_USER_ERROR);\n    }\n\n    $read_watcher = new EvIo($socket, Ev::READ, function ($w, $re)\n        use ($socket, $e_nonblocking)\n    {\n        // Сокет доступен для чтения. Читаем 20 байт в неблокирующем режиме\n        $ret = socket_recv($socket, $out, 20, MSG_DONTWAIT);\n\n        if ($ret) {\n            echo $out;\n        } elseif ($ret === 0) {\n            // Все прочтено\n            $w->stop();\n            socket_close($socket);\n            return;\n        }\n\n        // Ловим EINPROGRESS, EAGAIN или EWOULDBLOCK\n        if (in_array(socket_last_error(), $e_nonblocking)) {\n            return;\n        }\n\n        $w->stop();\n        socket_close($socket);\n    });\n\n    Ev::run();\n});\n\n$result = socket_connect($socket, $address, $service_port);\n\nEv::run();\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nHTTP/1.1 301 Moved Permanently\nLocation: http://www.google.co.uk/\nContent-Type: text/html; charset=UTF-8\nDate: Sun, 23 Dec 2012 16:08:27 GMT\nExpires: Tue, 22 Jan 2013 16:08:27 GMT\nCache-Control: public, max-age=2592000\nServer: gws\nContent-Length: 221\nX-XSS-Protection: 1; mode=block\nX-Frame-Options: SAMEORIGIN\nConnection: close\n```\n\n**Приклад #7 Вбудовуємо один цикл в інший**\n\n```php\n<?php\n/*\n* Пытаемся получить встраиваемый цикл и встроить его в событийный цикл по умолчанию.\n* Если это невозможно - используем цикл по умолчанию. Цикл по умолчанию\n* хранится в $loop_hi, а встраиваемый в $loop_lo (который будет равен $loop_hi в случае\n* если мы не будем использовать встраиваемый цикл).\n*\n* Приклад взят из\n* http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Examples_CONTENT-9\n*/\n$loop_hi = EvLoop::defaultLoop();\n$loop_lo = NULL;\n$embed   = NULL;\n\n/*\n* Смотрим, есть ли возможность получить работающий\n* (Значение 0 означает автоопределение)\n*/\n$loop_lo = Ev::embeddableBackends() & Ev::recommendedBackends()\n    ? new EvLoop(Ev::embeddableBackends() & Ev::recommendedBackends())\n    : 0;\n\nif ($loop_lo) {\n    $embed = new EvEmbed($loop_lo, function () {});\n} else {\n    $loop_lo = $loop_hi;\n}\n?>\n```\n\n**Приклад #8 Вбудовування циклу, створеного за допомогою kqueue у цикл за замовчуванням**\n\n```php\n<?php\n/*\n* Проверяем, что бэкенд kqueue доступен, но не рекомендован, и создаём его для\n* работы с сокетами (которые обычно работают с любой реализацией kqueue).\n* Сохраняем событийный цикл kqueue/socket-only в loop_socket. (Можно опционально\n* использовать флаг EVFLAG_NOENV)\n*\n* Приклад взят из\n* http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Examples_CONTENT-9\n*/\n$loop        = EvLoop::defaultLoop();\n$socket_loop = NULL;\n$embed       = NULL;\n\nif (Ev::supportedBackends() & ~Ev::recommendedBackends() & Ev::BACKEND_KQUEUE) {\n    if (($socket_loop = new EvLoop(Ev::BACKEND_KQUEUE))) {\n        $embed = new EvEmbed($loop);\n    }\n}\n\nif (!$socket_loop) {\n    $socket_loop = $loop;\n}\n\n// теперь используем $socket_loop для всех сокетов, а $loop для всего остального\n?>\n```\n\n**Приклад #9 Перехоплюємо сигнал SIGTERM**\n\n```php\n<?php\n$w = new EvSignal(SIGTERM, function ($watcher) {\n    echo \"Получен сигнал SIGTERM\\n\";\n    $watcher->stop();\n});\n\nEv::run();\n?>\n```\n\n**Приклад #10 Відстежуємо зміну /var/log/messages**\n\n```php\n<?php\n// Используем интервал опроса в 10 секунд\n$w = new EvStat(\"/var/log/messages\", 8, function ($w) {\n    echo \"/var/log/messages изменён\\n\";\n\n    $attr = $w->attr();\n\n    if ($attr['nlink']) {\n        printf(\"Текущий размер: %ld\\n\", $attr['size']);\n        printf(\"Текущее значение atime: %ld\\n\", $attr['atime']);\n        printf(\"Текущее значение mtime: %ld\\n\", $attr['mtime']);\n    } else {\n        fprintf(STDERR, \"файл `messages` отсутствует!\");\n        $w->stop();\n    }\n});\n\nEv::run();\n?>\n```\n\n**Приклад #11 Відслідковуємо зміну /var/log/messages. Уникаємо пропуску оновлень за допомогою затримки за одну секунду**\n\n```php\n<?php\n$timer = EvTimer::createStopped(0., 1.02, function ($w) {\n    $w->stop();\n\n    $stat = $w->data;\n\n    // 1 секунду после последнего изменения файла\n    printf(\"Текущий размер: %ld\\n\", $stat->attr()['size']);\n});\n\n$stat = new EvStat(\"/var/log/messages\", 0., function () use ($timer) {\n    // Сбрасываем наблюдателя $timer\n    $timer->again();\n});\n\n$timer->data = $stat;\n\nEv::run();\n?>\n```\n\n**Приклад #12 Відслідковуємо зміни статусу процесу**\n\n```php\n<?php\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    fprintf(STDERR, \"pcntl_fork failed\\n\");\n} elseif ($pid) {\n    $w = new EvChild($pid, FALSE, function ($w, $revents) {\n        $w->stop();\n\n        printf(\"Процесс %d вышел с кодом %d\\n\", $w->rpid, $w->rstatus);\n    });\n\n    Ev::run();\n\n    // Защита от зомби процессов\n    pcntl_wait($status);\n} else {\n    // Порождённый потомок\n    exit(2);\n}\n?>\n```\n","title":"Приклади","contentType":2,"navigation":[{"ev.global.constants.md":"« Зумовлені константи"},{"ev.watchers.md":"Спостерігачі »"},{"index.md":"PHP Manual"},{"book.ev.md":"Ev"}]}},"__N_SSG":true}