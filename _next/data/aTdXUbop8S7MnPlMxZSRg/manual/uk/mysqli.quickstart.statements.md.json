{"pageProps":{"page":{"slug":"mysqli.quickstart.statements.md","content":"## Виконання запитів\n\nЗа виконання запитів відповідають функції [mysqli::query()](mysqli.query.md) [mysqli::real\\_query()](mysqli.real-query.md) і [mysqli::multi\\_query()](mysqli.multi-query.md). Найчастіше застосовується функція [mysqli::query()](mysqli.query.md)оскільки вона виконує відразу дві задачі: виконує запит і буферизує на клієнті результат цього запиту (якщо він є). Виклик [mysqli::query()](mysqli.query.md) ідентичний послідовному виклику функцій [mysqli::real\\_query()](mysqli.real-query.md) і [mysqli::store\\_result()](mysqli.store-result.md)\n\n**Приклад #1 Виконання запитів**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n```\n\n**Буферизація результатів запиту**\n\nПісля виконання запиту результати можна отримати відразу, або вважати рядок за рядком з сервера. Буферизація набору результатів за клієнта дозволяє серверу якомога раніше звільнити ресурси, пов'язані з результатами запиту. Простіше кажучи, покупці повільно використовують набори результатів. Тому рекомендується використовувати буферизовані набори результатів . [mysqli::query()](mysqli.query.md) поєднує виконання запиту та буферизацію набору результатів.\n\nPHP-програми можуть вільно оперувати даними всередині буферизованих результуючих наборів. Швидка навігація рядками наборів обумовлена ​​тим, що набори повністю розташовуються в пам'яті клієнта. Слід пам'ятати, що найчастіше обробка результатів клієнта простіше, ніж засобами сервера.\n\n**Приклад #2 Навігація рядками буферизованої результуючої таблиці**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n$mysqli->query(\"INSERT INTO test(id) VALUES (1), (2), (3)\");\n\n$result = $mysqli->query(\"SELECT id FROM test ORDER BY id ASC\");\n\necho \"Обратный порядок...\\n\";\nfor ($row_no = $result->num_rows - 1; $row_no >= 0; $row_no--) {\n    $result->data_seek($row_no);\n    $row = $result->fetch_assoc();\n    echo \" id = \" . $row['id'] . \"\\n\";\n}\n\necho \"Исходный порядок строк...\\n\";\nforeach ($result as $row) {\n    echo \" id = \" . $row['id'] . \"\\n\";\n}\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nОбратный порядок...\n id = 3\n id = 2\n id = 1\nИсходный порядок строк...\n id = 1\n id = 2\n id = 3\n```\n\n**Небуферизовані результуючі набори**\n\nЯкщо клієнтські ресурси обмежені, і в той же час не потрібно підтримувати низьке навантаження на сервер, можна використовувати буферизовані результуючі набори. Навігація за такими таблицями неможлива, тому що так чи інакше мають бути оброблені всі рядки набору.\n\n**Приклад #3 Навігація рядками небуферизованої результуючої таблиці**\n\n```php\n<?php\n$mysqli->real_query(\"SELECT id FROM test ORDER BY id ASC\");\n$result = $mysqli->use_result();\n\necho \"Порядок строк в результирующем наборе...\\n\";\nforeach ($result as $row) {\n    echo \" id = \" . $row['id'] . \"\\n\";\n}\n```\n\n**Типи даних значень у результуючій таблиці**\n\nФункції [mysqli::query()](mysqli.query.md) [mysqli::real\\_query()](mysqli.real-query.md) і [mysqli::multi\\_query()](mysqli.multi-query.md) призначені для виконання запитів, що не готуються. На рівні протоколу клієнт-серверної взаємодії MySQL за виконання запитів відповідає команда `COM_QUERY` та текстовий протокол. Коли використовується текстовий протокол, сервер MySQL перед відправкою клієнту перетворює всі дані в результуючому наборі текстових рядків. Це перетворення виконується незалежно від типу даних SQL-стовпця результуючої таблиці. Клієнтські бібліотеки mysql, своєю чергою, отримують усі дані, приймаючи їх за рядки. На клієнті не проводиться жодного зворотного перетворення до вихідних типів, всі дані, отримані програмою залишаються PHP рядками.\n\n**Приклад #4 Текстовий протокол за промовчанням повертає рядки**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label CHAR(1))\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'a')\");\n\n$result = $mysqli->query(\"SELECT id, label FROM test WHERE id = 1\");\n$row = $result->fetch_assoc();\n\nprintf(\"id = %s (%s)\\n\", $row['id'], gettype($row['id']));\nprintf(\"label = %s (%s)\\n\", $row['label'], gettype($row['label']));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid = 1 (string)\nlabel = a (string)\n```\n\nЯкщо використовується бібліотека mysqlnd, можна включити перетворення цілих чисел і чисел з плаваючою точкою зі стовпців таблиці в PHP числа. Робиться це завданням налаштування підключення **`MYSQLI_OPT_INT_AND_FLOAT_NATIVE`**. У такому випадку mysqlnd перевірятиме метадані стовпців і перетворюватиме SQL-числа цих полів на PHP-числа, якщо ці значення не виходять за рамки допустимих діапазонів типів даних PHP. Тобто, наприклад, SQL INT число потрапить у PHP додаток у вигляді цілого (integer).\n\n**Приклад #5 Отримання вихідних типів даних у програмі**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n\n$mysqli = new mysqli();\n$mysqli->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1);\n$mysqli->real_connect(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label CHAR(1))\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'a')\");\n\n$result = $mysqli->query(\"SELECT id, label FROM test WHERE id = 1\");\n$row = $result->fetch_assoc();\n\nprintf(\"id = %s (%s)\\n\", $row['id'], gettype($row['id']));\nprintf(\"label = %s (%s)\\n\", $row['label'], gettype($row['label']));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid = 1 (integer)\nlabel = a (string)\n```\n\n**Дивіться також**\n\n-   [mysqli::\\_\\_construct()](mysqli.construct.md)\n-   [mysqli::options()](mysqli.options.md)\n-   [mysqli::real\\_connect()](mysqli.real-connect.md)\n-   [mysqli::query()](mysqli.query.md)\n-   [mysqli::multi\\_query()](mysqli.multi-query.md)\n-   [mysqli::use\\_result()](mysqli.use-result.md)\n-   [mysqli::store\\_result()](mysqli.store-result.md)\n","title":"Виконання запитів","contentType":2,"navigation":[{"mysqli.quickstart.connections.md":"«"},{"mysqli.quickstart.prepared-statements.md":"Підготовлювані запити »"},{"index.md":"PHP Manual"},{"mysqli.quickstart.md":"Короткий посібник"}]}},"__N_SSG":true}