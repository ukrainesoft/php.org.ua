{"pageProps":{"page":{"slug":"class.ev.md","content":"# Клас Ev\n\n(PECL ev >= 0.2.0)\n\n## Вступ\n\nКлас EV є статичним класом, забезпечуючи доступ до циклу за замовчуванням та деяким поширеним операціям.\n\n## Огляд класів\n\n```classsynopsis\n\n     \n    \n    \n    \n     \n      final\n      class Ev\n     \n     {\n    \n    /* Константы */\n    \n    \n     const\n     int\n      FLAG_AUTO = 0;\n\n    const\n     int\n      FLAG_NOENV = 16777216;\n\n    const\n     int\n      FLAG_FORKCHECK = 33554432;\n\n    const\n     int\n      FLAG_NOINOTIFY = 1048576;\n\n    const\n     int\n      FLAG_SIGNALFD = 2097152;\n\n    const\n     int\n      FLAG_NOSIGMASK = 4194304;\n\n    const\n     int\n      RUN_NOWAIT = 1;\n\n    const\n     int\n      RUN_ONCE = 2;\n\n    const\n     int\n      BREAK_CANCEL = 0;\n\n    const\n     int\n      BREAK_ONE = 1;\n\n    const\n     int\n      BREAK_ALL = 2;\n\n    const\n     int\n      MINPRI = -2;\n\n    const\n     int\n      MAXPRI = 2;\n\n    const\n     int\n      READ = 1;\n\n    const\n     int\n      WRITE = 2;\n\n    const\n     int\n      TIMER = 256;\n\n    const\n     int\n      PERIODIC = 512;\n\n    const\n     int\n      SIGNAL = 1024;\n\n    const\n     int\n      CHILD = 2048;\n\n    const\n     int\n      STAT = 4096;\n\n    const\n     int\n      IDLE = 8192;\n\n    const\n     int\n      PREPARE = 16384;\n\n    const\n     int\n      CHECK = 32768;\n\n    const\n     int\n      EMBED = 65536;\n\n    const\n     int\n      CUSTOM = 16777216;\n\n    const\n     int\n      ERROR = 2147483648;\n\n    const\n     int\n      BACKEND_SELECT = 1;\n\n    const\n     int\n      BACKEND_POLL = 2;\n\n    const\n     int\n      BACKEND_EPOLL = 4;\n\n    const\n     int\n      BACKEND_KQUEUE = 8;\n\n    const\n     int\n      BACKEND_DEVPOLL = 16;\n\n    const\n     int\n      BACKEND_PORT = 32;\n\n    const\n     int\n      BACKEND_ALL = 63;\n\n    const\n     int\n      BACKEND_MASK = 65535;\n\n    \n    /* Методы */\n    \n   final\n   public\n   static\n   backend(): int\nfinal\n   public\n   static\n   depth(): int\nfinal\n   public\n   static\n   embeddableBackends(): int\nfinal\n   public\n   static\n   feedSignal(\n    int\n     $signum\n   ): void\nfinal\n   public\n   static\n   feedSignalEvent(\n    int\n     $signum\n   ): void\nfinal\n   public\n   static\n   iteration(): int\nfinal\n   public\n   static\n   now(): float\nfinal\n   public\n   static\n   nowUpdate(): void\nfinal\n   public\n   static\n   recommendedBackends(): int\nfinal\n   public\n   static\n   resume(): void\nfinal\n   public\n   static\n   run(\n    int\n     $flags\n    = ?): void\nfinal\n   public\n   static\n   sleep(\n    float\n     $seconds\n   ): void\nfinal\n   public\n   static\n   stop(\n    int\n     $how\n    = ?): void\nfinal\n   public\n   static\n   supportedBackends(): int\nfinal\n   public\n   static\n   suspend(): void\nfinal\n   public\n   static\n   time(): float\nfinal\n   public\n   static\n   verify(): void\n\n   }\n```\n\n## Обумовлені константи\n\nПрапори, що передаються під час створення циклу:\n\n**`Ev::FLAG_AUTO`**\n\nЗадає прапори значення за замовчуванням\n\n**`Ev::FLAG_NOENV`**\n\nЯкщо прапор використовується (або програма запускає setuid або setgid), то `libev`не смотрит на переменную окружения LIBEV\\_FLAGS. В іншому випадку (за умовчанням), якщо знайдено LIBEV\\_FLAGS, то він повністю перевизначає прапори. Корисно для тестів продуктивності та пошуку помилок.\n\n**`Ev::FLAG_FORKCHECK`**\n\nПримушує libev перевіряти розгалуження в кожній ітерації замість виклику [EvLoop::fork()](evloop.fork.md) вручну. Це працює шляхом виклику `getpid()` на кожній ітерації циклу, і, таким чином, це може уповільнити роботу циклу подій з великою кількістю циклів ітерацій, але зазвичай не сильно. Цей прапор не може бути перевизначений або вказаний у змінному середовищі LIBEV\\_FLAGS.\n\n**`Ev::FLAG_NOINOTIFY`**\n\nЯкщо цей прапор вказано, то `libev` не намагатиметься використовувати API `inotify` для своїх спостерігачів [» ev\\_stat](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_stat_code_did_the_file_attri) Прапор може бути корисним для збереження файлових дескрипторів inotify, інакше кожен цикл, що використовує спостерігачів `ev_stat`, споживатиме один дескриптор `inotify`\n\n**`Ev::FLAG_SIGNALFD`**\n\nЯкщо прапор вказано, то `libev` намагатиметься використовувати API `signalfd` для своїх спостерігачів [» ev\\_signal](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_signal_code_signal_me_when_a)(и[» ev\\_child](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_child_code_watch_out_for_pro)). API передає сигнали синхронно, що робить його швидшим і, можливо, дозволить отримати дані з черги сигналів, а також дозволяє спростити обробку сигналів за допомогою потоків, оскільки сигнали коректно блокуються в потоках . `Signalfd`не используется по умолчанию.\n\n**`Ev::FLAG_NOSIGMASK`**\n\nЯкщо вказано прапор, то `libev` уникатиме зміни маски сигналу. Зокрема, це застосовується, щоб перед отриманням сигналу переконатися, що його розблоковано.\n\nТака поведінка корисна для обробки сигналів користувача або обробки сигналів тільки певних потоків.\n\nПрапори, що передаються в [Ev::run()](ev.run.md), или[EvLoop::run()](evloop.run.md)\n\n**`Ev::RUN_NOWAIT`**\n\nОзначає, що цикл подій шукатиме і оброблятиме нові події, а також будь-які очікувані виконання події з них, але не чекатиме і блокуватиме процес у разі, якщо не було жодних подій і завершиться після однієї ітерації циклу. Це іноді корисно для опитування та опрацювання нових подій під час виконання тривалих обчислень, зберігаючи при цьому можливість взаємодії з програмою.\n\n**`Ev::RUN_ONCE`**\n\nОзначає, що цикл подій шукатиме нові події (очікуючи, у разі потреби) та обробляти ці та будь-які вже очікуючі події з них. Він блокуватиме процес, доки не надійде принаймні одна нова подія (це може бути внутрішня подія libev, тому немає жодної гарантії, що буде викликана задана callback-функція) і завершиться після однієї ітерації циклу.\n\nПрапори, що передаються в [Ev::stop()](ev.stop.md), или[EvLoop::stop()](evloop.stop.md)\n\n**`Ev::BREAK_CANCEL`**\n\nСкасування операції переривання.\n\n**`Ev::BREAK_ONE`**\n\nПовертає найглибший запит [Ev::run()](ev.run.md)(или[EvLoop::run()](evloop.run.md)\n\n**`Ev::BREAK_ALL`**\n\nЗавершує всі вкладені дзвінки [Ev::run()](ev.run.md)(или[EvLoop::run()](evloop.run.md)\n\nПріоритети спостерігачів:\n\n**`Ev::MINPRI`**\n\nМінімально допустимий пріоритет спостерігача.\n\n**`Ev::MAXPRI`**\n\nНайбільш допустимий пріоритет спостерігача.\n\nПобутові маски (отриманих) подій:\n\n**`Ev::READ`**\n\nДескриптор файлу у спостерігачі [EvIo](class.evio.md)доступен для чтения.\n\n**`Ev::WRITE`**\n\nДескриптор файлу у спостерігачі [EvIo](class.evio.md)доступен для записи.\n\n**`Ev::TIMER`**\n\n[EvTimer](class.evtimer.md) спостерігає за перевищенням ліміту часу.\n\n**`Ev::PERIODIC`**\n\n[EvPeriodic](class.evperiodic.md) спостерігає за перевищенням ліміту часу.\n\n**`Ev::SIGNAL`**\n\nВказаний у [EvSignal::\\_\\_construct()](evsignal.construct.md)сигнал получен.\n\n**`Ev::CHILD`**\n\n`pid` Вказаний у [EvChild::\\_\\_construct()](evchild.construct.md) отримано і статус змінено.\n\n**`Ev::STAT`**\n\nШлях, вказаний у спостерігачі [EvStat](class.evstat.md) змінив свої атрибути.\n\n**`Ev::IDLE`**\n\nСпостерігач [EvIdle](class.evidle.md) працює, коли решта спостерігачів нічого не робить.\n\n**`Ev::PREPARE`**\n\nУсі спостерігачі [EvPrepare](class.evprepare.md) викликані рівно перед стартом [Ev::run()](ev.run.md)таким образом, наблюдатели[EvPrepare](class.evprepare.md) є останніми викликаними спостерігачами перед тим, як цикл подій засне чи опитає нові події.\n\n**`Ev::CHECK`**\n\nУсі спостерігачі [EvCheck](class.evcheck.md) поміщені в чергу відразу після того, як [Ev::run()](ev.run.md) зібрав нові події, але до того, як вони викличуть якусь callback-функцію для отриманих подій. Таким чином, спостерігачі [EvCheck](class.evcheck.md) будуть викликані раніше, ніж будь-які інші спостерігачі з таким самим або нижчим пріоритетом у цій ітерації циклу подій.\n\n**`Ev::EMBED`**\n\nВбудований цикл подій, заданий у спостерігачі [EvEmbed](class.evembed.md)требует к себе внимания.\n\n**`Ev::CUSTOM`**\n\nНіколи не надсилається (або іншим чином використовується) бібліотекою `libev` самостійно, але може вільно використовуватись користувачами `libev` для сигналізуючих спостерігачів (тобто за допомогою [EvWatcher::feed()](evwatcher.feed.md)\n\n**`Ev::ERROR`**\n\nВідбулася невідома помилка і спостерігача буде зупинено. Може статися через некоректний запуск спостерігача, тому що `libev` вичерпав ліміт по пам'яті, через закритий дескриптор файлу або з якоїсь ще причини . `Libev` вважає, що ці помилки програми. Також читайте розділ [» АНАТОМІЯ СПОСТЕРІГАЧІВ](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#ANATOMY_OF_A_WATCHER_CONTENT)\n\nПрапори бекенда:\n\n**`Ev::BACKEND_SELECT`**\n\n`вибір бекенда - select(2)`\n\n**`Ev::BACKEND_POLL`**\n\n`опитування бекенда - poll(2)`\n\n**`Ev::BACKEND_EPOLL`**\n\nСпецифічний для Linux бекенд `epoll(7)` для ядер до та після 2.6.9\n\n**`Ev::BACKEND_KQUEUE`**\n\n`kqueue` - бекенде, що використовується в більшості систем BSD. Спостерігач [EvEmbed](class.evembed.md) може бути використаний для вставки одного циклу (з бекендом kqueue) в інший. Наприклад, можна спробувати створити цикл подій з бекендом `kqueue` та використовувати його тільки для сокетів.\n\n**`Ev::BACKEND_DEVPOLL`**\n\nБекенд Solaris 8. Поки що не реалізований.\n\n**`Ev::BACKEND_PORT`**\n\nМеханізм порту подій із гарним масштабуванням у Solaris 10.\n\n**`Ev::BACKEND_ALL`**\n\nПробувати всі бекенди (крім зіпсованих). Не рекомендується використовувати безпосередньо. Тут потрібно використовувати побітові операції (тобто . **`Ev::BACKEND_ALL`** & ~ **`Ev::BACKEND_KQUEUE`** ). Використати [Ev::recommendedBackends()](ev.recommendedbackends.md) , або не ставити жодного бекенда взагалі.\n\n**`Ev::BACKEND_MASK`**\n\nЧи не бекенд, але маска для вибору всіх біт бекендів зі значення `flags`для виключення будь-яких бекендів. (тобто коли модифікуєте змінну оточення LIBEV\\_FLAGS).\n\n> **Зауваження** :\n> \n> Для циклу за замовчуванням, під час фази ініціалізації модуля `Ev`, реєструється виклик [» ev\\_loop\\_fork](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#FUNCTIONS_CONTROLLING_EVENT_LOOPS_CO) за допомогою `pthread_atfork` (якщо такий є).\n\n> **Зауваження** :\n> \n> Є методи, що дозволяють отримати доступ до *циклу подій за умовчанням*в классе**Ev**(наПриклад,[Ev::iteration()](ev.iteration.md) [Ev::depth()](ev.depth.md)и т.д.). Для*користувальницьких циклів* (створених за допомогою **EvLoop::\\_\\_construct()**) ці значення можуть бути доступні через відповідні властивості та методи класу [EvLoop](class.evloop.md)\n> \n> Примірник циклу подій за умовчанням може бути вилучений за допомогою методу [EvLoop::defaultLoop()](evloop.defaultloop.md)\n\n## Зміст\n\n-   [Ev::backend](ev.backend.md)— Повертає ціле число, що описує бекенд, який використовується libev\n-   [Ev::depth](ev.depth.md)— Здобути глибину рекурсії\n-   [Ev::embeddableBackends](ev.embeddablebackends.md)— Повертає набір бекендів, які можна вбудувати в інші цикли подій\n-   [Ev::feedSignal](ev.feedsignal.md) \\- Передаємо подію сигналу в Ev\n-   [Ev::feedSignalEvent](ev.feedsignalevent.md)— Надіслати подію сигналу в цикл за замовчуванням\n-   [Ev::iteration](ev.iteration.md)— Отримати кількість опитувань циклу за умовчанням щодо нових подій\n-   [Ev::now](ev.now.md)— Отримати час запуску останньої ітерації циклу за умовчанням\n-   [Ev::nowUpdate](ev.nowupdate.md)— Встановлює поточний час шляхом запиту до ядра в процесі оновлюючи час, який повертається Ev::now\n-   [Ev::recommendedBackends](ev.recommendedbackends.md)— Отримати бітову маску рекомендованих бекендів для даної платформи\n-   [Ev::resume](ev.resume.md)— Відновити виконання призупиненого раніше циклу подій за умовчанням\n-   [Ev::run](ev.run.md)— Почати перевірку наявності подій та виклик callback-функцій циклу за умовчанням\n-   [Ev::sleep](ev.sleep.md)— Блокувати процес задану кількість секунд\n-   [Ev::stop](ev.stop.md)— Зупинити цикл події за замовчуванням\n-   [Ev::supportedBackends](ev.supportedbackends.md)— Повертає набір бекендів, які підтримуються поточною конфігурацією libev\n-   [Ev::suspend](ev.suspend.md)— Призупинити цикл подій за умовчанням\n-   [Ev::time](ev.time.md)— Повертає поточний час у секундах, що минув з початку епохи Unix\n-   [Ev::verify](ev.verify.md) \\- Здійснює внутрішню перевірку цілісності (для налагодження)\n","title":"Клас Ev","contentType":2,"navigation":[{"ev.periodic-modes.md":"« Режими роботи періодичних спостерігачів"},{"ev.backend.md":"Ev::backend »"},{"index.md":"PHP Manual"},{"book.ev.md":"Ev"}]}},"__N_SSG":true}