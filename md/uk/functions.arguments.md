- [« Функції, що визначаються користувачем](functions.user-defined.md)
- [Повернення значень »](functions.returning-values.md)

- [PHP Manual](index.md)
- [Функції](language.functions.md)
- аргументи функції

## Аргументи функції

Функція може приймати інформацію як списку аргументів, який
є списком розділених комами виразів. Аргументи обчислюються
ліворуч праворуч перед фактичним викликом функції (*енергійне*
обчислення).

PHP підтримує передачу аргументів за значенням (за умовчанням),
[передачу аргументів по
ссылке](functions.arguments.md#functions.arguments.by-reference), та
[значення по
замовчуванням](functions.arguments.md#functions.arguments.default).
[Списки аргументів змінної
довжини](functions.arguments.md#functions.variable-arg-list) та
[іменовані
аргументи](functions.arguments.md#functions.named-arguments) також
підтримуються.

**Приклад #1 Передача масиву у функцію**

` <?phpfunction takes_array($input){    echo "$input[0] + $input[1] u003d ", $input[0]+$input[1];}?> `

Починаючи з PHP 8.0.0, список аргументів функції може містити
завершальну кому, яка буде проігнорована. Це корисно в
випадку, коли список аргументів дуже довгий, або якщо імена
змінних довжини, що підштовхує до їхнього вертикального розташування.

**Приклад #2 Список аргументів функції із завершальною комою**

` <?phpfunction takes_many_args(    $first_arg,    $second_arg,    $a_very_long_argument_name,    $arg_with_default u003d 5,    $again u003d 'a default string', // Эта завершающая запятая допустима только начиная с  8.0.0.){    // ...} ?> `

### Передача аргументів за посиланням

За умовчанням аргументи у функцію передаються за значенням (це означає,
якщо ви зміните значення аргументу всередині функції, то поза нею
значення все одно залишиться тим самим). Якщо ви хочете дозволити функції
модифікувати свої аргументи, ви повинні передавати їх за посиланням.

Якщо ви хочете, щоб аргумент завжди передавався за посиланням, ви можете
вказати амперсанд (&) перед ім'ям аргументу в описі функції:

**Приклад #3 Передача аргументів за посиланням**

` <?phpfunction add_some_extra(&$string){    $string .u003d 'і щосьщо.';}$str u003d 'Це рядок, ';add_some_extra($str);echo $str; // виведе 'Це рядок, і що-що ще.'?> `

Передача значення як аргумент, який має передаватися по
посилання, є помилкою.

### Значення аргументів за замовчуванням

Функція може визначати значення за промовчанням для аргументів, використовуючи
синтаксис, подібний до присвоєння змінної. Значення за замовчуванням
використовується лише у тому випадку, якщо параметр не вказано; зокрема,
зверніть увагу, що передача **`null`** *не* надає значення по
замовчуванням.

**Приклад #4 Використання значень за промовчанням для визначення функції**

`<?phpfunction makecoffee($type u003d "капучино"){    return "Готуємо чашку $type.
";}echo makecoffee();echo makecoffee(null);echo makecoffee("еспресо");?> `

Результат виконання цього прикладу:

Готуємо чашку капучіно.
Готуємо чашку.
Готуємо чашку еспресо.

Значення параметрів за замовчуванням можуть бути скалярні значення,
масиви (array), спеціальний тип **`null`**, і, починаючи з версії PHP
8.1.0 об'єкти, що використовують синтаксис [new
ClassName()](language.oop5.basic.md#language.oop5.basic.new).

**Приклад #5 Використання нескалярних типів як значень по
замовчуванням**

` <?phpfunction makecoffee($types u003d array("капучино"), $coffeeMaker u003d NULL){    $device u003d is_null($coffeeMaker) ? "вручну": $coffeeMaker; return "Готую чашку ".join(", ", $types)." $device.
";}echo makecoffee();echo makecoffee(array("капучино", "лаватися"), "в чайнику");?> `

**Приклад #6 Використання об'єктів як значень за замовчуванням
(починаючи з PHP 8.1.0) **

` <?phpclass DefaultCoffeeMaker {    public function brew() {       return 'Приготування кави.'; }}class FancyCoffeeMaker {     public function brew() {       return 'Приготування прекрасної кави спеціально для вас.'; }}function makecoffee($coffeeMaker u003d new DefaultCoffeeMaker){    return $coffeeMaker->brew();}echo makecoffee();echo makecoffee(new >

Значення за умовчанням має бути константним виразом, а не (до
приклад) змінної або викликом функції/методу класу.

Зверніть увагу, що будь-які необов'язкові аргументи мають бути
вказані після будь-яких обов'язкових аргументів, інакше вони не можуть бути
опущені під час виклику. Розглянемо наступний приклад:

**Приклад #7 Некоректне використання значень за замовчуванням**

`<?phpfunction makeyogurt($container u003d "миску", $flavour){    return "Робимо $container з $flavour йогуртом.
";}echo makeyogurt("малиновим"); // "малиновим" - це $container, не $flavour?> `

Результат виконання цього прикладу:

Fatal error: Uncaught ArgumentCountError: Too few arguments
to function makeyogurt(), 1 passed in example.php on line 42

Тепер порівняємо його з наступним прикладом:

**Приклад #8 Коректне використання значень за замовчуванням**

`<?phpfunction makeyogurt($flavour, $container u003d "миску"){    return "Робимо $container з $flavour йогуртом.
";}echo makeyogurt("малиновим"); // "малиновим" - це $flavour?> `

Результат виконання цього прикладу:

Робимо миску з малиновим йогуртом.

Починаючи з PHP 8.0.0, [іменовані
аргументи](functions.arguments.md#functions.named-arguments) можна
використовуватиме пропуску кількох необов'язкових параметрів.

**Приклад #9 Правильне використання аргументів за замовчуванням**

`<?phpfunction makeyogurt($container u003d "миску", $flavour u003d "малиновим", $style u003d "грецьким"){   return "Робимо $container с $flavour |
";}echo makeyogurt(style: "натуральним");?> `

Результат виконання цього прикладу:

Робимо миску з малиновим натуральним йогуртом.

Починаючи з PHP 8.0.0, оголошення обов'язкових аргументів після
необов'язкових аргументів є застарілим. Зазвичай це можна вирішити
відмовившись від значення за промовчанням, оскільки воно ніколи не буде
використовуватись. Винятком із цього правила є аргументи виду
`Type $param u003d null`, де **`null`** за умовчанням робить тип неявно
обнулюваним. Таке використання залишається допустимим, хоча рекомендується
використовувати явний [тип
nullable](language.types.declarations.md#language.types.declarations.nullable).

**Приклад #10 Оголошення необов'язкових аргументів після обов'язкових
аргументів**

` <?phpfunction foo($a u003d [], $b) {} // За умовчанням не використовується; застарів, починаючи з версії PHP 8.0.0 function foo ($a, $ b) $a є обов'язковим, але допускає значення nullfunction bar(?A $a, $b) {}        // Рекомендується?> `

> **Примітка**: Починаючи з PHP 7.1.0, опущення параметра, не заданого
> за замовчуванням викидає виняток
> [ArgumentCountError](class.argumentcounterror.md); у попередніх
> версіях це викликало попередження.

> **Примітка**: Значення за промовчанням можна надсилати за посиланням.

### Списки аргументів змінної довжини

PHP підтримує списки аргументів змінної довжини для функцій,
визначаються користувачем за допомогою додавання крапки (`...`).

> **Примітка**: Також можна добитися аргументів змінної довжини,
> використовуючи функції [func_num_args()](function.func-num-args.md),
> [func_get_arg()](function.func-get-arg.md) та
> [func_get_args()](function.func-get-args.md). Цей метод не
> рекомендується, оскільки він використовувався до введення крапки
> (`...`).

Список аргументів може містити багатокрапку (`...`), щоб показати,
що функція приймає змінну кількість аргументів. Аргументи у цьому
у разі будуть передані у вигляді масиву. Наприклад:

**Приклад #11 Використання `...` для доступу до аргументів**

`<?phpfunction sum(...$numbers) {   $acc u003d 0; foreach ($numbers as $n) {        $acc +u003d $n; }   return$acc;}echo sum(1, 2, 3, 4);?> `

Результат виконання цього прикладу:

10

Три крапки (`...`) можна використовувати при виклику функції, щоб
розпакувати масив (array) або [Traversable](class.traversable.md)
змінну до списку аргументів:

**Приклад #12 Використання `...` для передачі аргументів**

` <?phpfunction add($a, $b) {    return $a + $b;}echo add(...[1, 2])."
";$a u003d [1, 2];echo add(...$a);?> `

Результат виконання цього прикладу:

3
3

Можна задати кілька аргументів у звичному вигляді, а потім додати
`...`. У цьому випадку `...` помістить до масиву ті аргументи,
які знайшли відповідності зазначеним у оголошенні функції.

Також можна додати [оголошення типу](language.types.declarations.md)
перед `...`. В цьому випадку, всі аргументи, оброблені трьома крапками
(`...`), повинні відповідати цьому типу параметра.

**Приклад #13 Аргументи з підказкою типу**

` <?phpfunction total_intervals($unit, DateInterval ...$intervals) {   $time u003d 0; foreach ($intervals as $interval) {        $time +u003d $interval->$unit; }   return $time;}$a u003d new DateInterval('P1D');$b u003d new DateInterval('P2D');echo total_intervals('d', $a, $b).' days';// Це не спрацює, т.к. null не є об'єктом DateInterval.echo total_intervals('d', null);?> `

Результат виконання цього прикладу:

3 дні
Catchable fatal error: 2

Зрештою, можна передавати аргументи
ссылке](functions.arguments.md#functions.arguments.by-reference). Для
цього перед `...` потрібно поставити амперсанд (`&`).

#### Попередні версії PHP

Для вказівки того, що функція приймає змінну кількість аргументів,
ніякий спеціальний синтаксис не використовується. Для доступу до аргументів
необхідно використовувати функції
[func_num_args()](function.func-num-args.md),
[func_get_arg()](function.func-get-arg.md) та
[func_get_args()](function.func-get-args.md).

У першому прикладі вище було показано, як поставити список аргументів
змінної довжини для попередніх версій PHP:

**Приклад #14 Доступ до аргументів у попередніх версіях PHP**

` <?phpfunction sum() {    $acc u003d 0; foreach (func_get_args() as $n) {       $acc +u003d $n; }   return$acc;}echo sum(1, 2, 3, 4);?> `

Результат виконання цього прикладу:

10

### Іменовані аргументи

У PHP 8.0.0 як продовження позиційних параметрів з'явилися
іменовані аргументи. З їхньою допомогою аргументи функції можна передавати
на ім'я параметра, а не на його позиції. Таким чином аргумент
стає самодокументованим, незалежним від порядку та зазначеного
значення за замовчуванням.

Іменовані аргументи передаються шляхом додавання через двокрапки імені
параметра перед значенням. Як імена параметрів можна
використовувати зарезервовані ключові слова. Ім'я параметра має бути
ідентифікатор, тобто. він не може бути створений динамічно.

**Приклад #15 Синтаксис іменованого аргументу**

` <?phpmyFunction(paramName: $value);array_foobar(array: $value);// НЕ підтримується.function_name($variableStoringParamName: $value);?> `

**Приклад #16 Позиційні аргументи проти іменованими
аргументами**

`<?php// Використання позиційних аргументів:array_fill(0, 100, 50);// Використання іменованих аргументів:array_fill(start_index: 0, count: 100, value:?>

Порядок, у якому передаються іменовані аргументи, немає значення.

**Приклад #17 Той самий приклад, що й вище, але з іншим порядком
параметрів**

`<?phparray_fill(value: 50, count: 100, start_index: 0);?> `

Іменовані аргументи можна поєднувати з позиційними. В цьому випадку
Іменовані аргументи повинні слідувати після позиційних аргументів.
Також можна передати лише частину необов'язкових аргументів функції,
незалежно від їхнього порядку.

**Приклад #18 Об'єднання іменованих аргументів із позиційними
аргументами**

`<?phphtmlspecialchars($string, double_encode: false);// То самеhtmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);

Передача одного і того ж параметра кілька разів призводить до
викидання виключення Error.

**Приклад #19 Помилка, що виникає при передачі одного і того ж параметра
декілька разів**

`<?phpfunction foo($param) { ... }foo(param: 1, param: 2);// Error: Named parameter $param overwrites previous argumentfoo(1, param: 2); $param overwrites previous argument?> `

Починаючи з PHP 8.1.0, можна використовувати іменовані аргументи після
розпакування аргументів. Іменований аргумент *не повинен* перевизначати
вже розпаковані аргументи.

**Приклад #20 Приклад використання іменованих аргументів після
розпакування**

` <?phpfunction foo($a, $b, $c u003d 3, $d u003d 4) { return $a + $b + $c + $d;}var_dump(foo(...[1, 2], d: 40)); // 46var_dump(foo(...['b' u003d> 2, 'a' u003d> 1], d: 40)); // 46var_dump(foo(...[1, 2], b: 20)); // Фатальна помилка. Іменований аргумент $b перевизначає попередній аргумент?> `
