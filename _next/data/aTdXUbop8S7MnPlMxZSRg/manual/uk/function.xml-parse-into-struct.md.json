{"pageProps":{"page":{"slug":"function.xml-parse-into-struct.md","content":"# xml\\_parse\\_into\\_struct\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nxml\\_parse\\_into\\_struct - Розбір XML-даних та приміщення в масив\n\n### Опис\n\n```methodsynopsis\nxml_parse_into_struct(    XMLParser $parser,    string $data,    array &$values,    array &$index = null): int\n```\n\nЦя функція розбирає XML-рядок і поміщає дані у 2 масиви. Масив `index`содержит указатели на размещение значений в массиве`values`. Аргументи, що задають масиви, повинні передаватися на функцію за посиланням.\n\n### Список параметрів\n\n`parser`\n\nПосилання на використовуваний XML-аналізатор.\n\n`data`\n\nРядок XML-даних.\n\n`values`\n\nМасив значень XML даних.\n\n`index`\n\nМасив покажчиків на відповідні значення масиві $values.\n\n### Значення, що повертаються\n\n**xml\\_parse\\_into\\_struct()** повертає 0 при невдалому розборі рядка та 1 при успішному. Це не те саме, що **`false`** і **`true`**, будьте обережні з такими операторами, як ===.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.0.0 | Параметр`parser` чекає на екземпляр [XMLParser](class.xmlparser.md); раніше очікувався коректний `xml` ресурс (Resource). |\n\n### Приклади\n\nНижче наведено приклад, що демонструє внутрішній пристрій масивів, що генеруються функцією. XML-рядок містить простий тег `note` вкладений у тег `para`. Програма у прикладі розбирає цей рядок і виводить створені масиви:\n\n**Приклад #1 Приклад використання** xml\\_parse\\_into\\_struct()\\*\\*\\*\\*\n\n```php\n<?php\n$simple = \"<para><note>простое примечание</note></para>\";\n$p = xml_parser_create();\nxml_parse_into_struct($p, $simple, $vals, $index);\nxml_parser_free($p);\necho \"Массив index\\n\";\nprint_r($index);\necho \"\\nМассив vals\\n\";\nprint_r($vals);\n?>\n```\n\nПісля обробки програма виведе наступне:\n\n```\nIndex array\nArray\n(\n    [PARA] => Array\n        (\n            [0] => 0\n            [1] => 2\n        )\n\n    [NOTE] => Array\n        (\n            [0] => 1\n        )\n\n)\n\nМассив Vals\nArray\n(\n    [0] => Array\n        (\n            [tag] => PARA\n            [type] => open\n            [level] => 1\n        )\n\n    [1] => Array\n        (\n            [tag] => NOTE\n            [type] => complete\n            [level] => 2\n            [value] => простое примечание\n        )\n\n    [2] => Array\n        (\n            [tag] => PARA\n            [type] => close\n            [level] => 1\n        )\n\n)\n```\n\nРозбір, що керується подіями (заснований на бібліотеці expat) може дати важкооброблюваний результат у разі, якщо розбирається складовий XML-документ. Ця функція не створює DOM-об'єктів, але масиви, що нею створюються, можна перетворити на деревоподібну структуру згодом. Таким чином, можна досить просто створювати об'єкти, що представляють вміст XML-файлу. Припустимо, що наступний XML файл представляє невелику базу даних з інформацією про амінокислоти:\n\n**Приклад #2 moldb.xml – невелика база даних з інформацією про молекули**\n\nAlanine ala `A` hydrophobic Lysine lys `K` charged\n\nКод, який розбирає документ і створює відповідні об'єкти:\n\n**Приклад #3 parsemoldb.php - розбирає moldb.xml і поміщає дані масив молекул**\n\n```php\n<?php\n\nclass AminoAcid {\n    var $name;   // название аминокислоты\n    var $symbol; // трёхбуквенное обозначение\n    var $code;   // однобуквенный код\n    var $type;   // гидрофобная, заряженная, нейтральная\n\n    function __construct ($aa)\n    {\n        foreach ($aa as $k=>$v)\n            $this->$k = $aa[$k];\n    }\n}\n\nfunction readDatabase($filename)\n{\n    // чтение XML-базы данных аминокислот\n    $data = file_get_contents($filename);\n    $parser = xml_parser_create();\n    xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);\n    xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);\n    xml_parse_into_struct($parser, $data, $values, $tags);\n    xml_parser_free($parser);\n\n    // проход через структуры\n    foreach ($tags as $key=>$val) {\n        if ($key == \"molecule\") {\n            $molranges = $val;\n            // каждая смежная пара значений массивов является верхней и\n            // нижней границей определения молекулы\n            for ($i=0; $i < count($molranges); $i+=2) {\n                $offset = $molranges[$i] + 1;\n                $len = $molranges[$i + 1] - $offset;\n                $tdb[] = parseMol(array_slice($values, $offset, $len));\n            }\n        } else {\n            continue;\n        }\n    }\n    return $tdb;\n}\n\nfunction parseMol($mvalues)\n{\n    for ($i=0; $i < count($mvalues); $i++) {\n        $mol[$mvalues[$i][\"tag\"]] = $mvalues[$i][\"value\"];\n    }\n    return new AminoAcid($mol);\n}\n\n$db = readDatabase(\"moldb.xml\");\necho \"** База данных аминокислот:\\n\";\nprint_r($db);\n\n?>\n```\n\nПісля виконання parsemoldb.php змінна $db містить масив об'єктів **AminoAcid**, А висновок відповідно наступний:\n\n```\n** База данных аминокислот:\nArray\n(\n    [0] => aminoacid Object\n        (\n            [name] => Alanine\n            [symbol] => ala\n            [code] => A\n            [type] => hydrophobic\n        )\n\n    [1] => aminoacid Object\n        (\n            [name] => Lysine\n            [symbol] => lys\n            [code] => K\n            [type] => charged\n        )\n\n)\n```\n","title":"xml\\_parse\\_into\\_struct","contentType":2,"navigation":[{"function.xml-get-error-code.md":"« xml\\_get\\_error\\_code"},{"function.xml-parse.md":"xml\\_parse »"},{"index.md":"PHP Manual"},{"ref.xml.md":"Функції парсера XML"}]}},"__N_SSG":true}