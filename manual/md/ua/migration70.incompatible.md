- [« Міграція з PHP 5.6.x на PHP 7.0.x](migration70.md)
- [Нова функціональність »](migration70.new-features.md)

- [PHP Manual](index.md)
- [Міграція з PHP 5.6.x на PHP 7.0.x](migration70.md)
- Зміни, що ламають зворотну сумісність

## Зміни, що ламають зворотну сумісність

### Зміни в обробці помилок та винятків

Багато фатальних і поправних фатальних помилок було перероблено в
винятки в PHP 7. Ці винятки успадковують клас
[Error](class.error.md), який, у свою чергу, реалізує інтерфейс
[Throwable](class.throwable.md) (новий базовий інтерфейс, який
успадковують усі винятки).

Це означає, що користувальницькі обробники помилок можуть не бути викликані,
тому що замість виклику помилки буде викинуто виняток (породжуючи
нові фатальні помилки через неперехоплені винятки класу
[Error](class.error.md)).

Докладніше опис того, як помилки працюють у PHP 7, можна знайти
на сторінці [помилки PHP 7](language.errors.php7.md). Це керівництво
лише перераховує зміни, які можуть призвести до зворотної
несумісності.

#### [set_exception_handler()](function.set-exception-handler.md) більше не гарантує отримання об'єкта класу [Exception](class.exception.md)

Код, що реалізує реєстрацію обробника виключень за допомогою
[set_exception_handler()](function.set-exception-handler.md),
використовуючи декларацію типу [Exception](class.exception.md), викличе
фатальну помилку, якщо буде викинуто виняток
[Error](class.error.md).

Якщо потрібна робота обробника в PHP 5 та 7, ви повинні прибрати
оголошення класу з оброблювача. Якщо код передбачається використовувати
тільки в PHP 7, то можна просто змінити тип з
[Exception](class.exception.md) на [Throwable](class.throwable.md).

`<?php// Тільки PHP 5. У PHP 7 може викликати фатальну помилку.function handler(Exception $e) { ... }set_exception_handler('handler');//   e) { ... }// Тільки PHP 7.function handler(Throwable $e) { ... }?> `

#### Вбудовані конструктори завжди викликають винятки у разі невдачі

Раніше деякі внутрішні класи повертали **`null`** або марний
об'єкт, коли конструктор зазнав невдачі. Всі вбудовані класи тепер
такому разі викидатимуть виняток
[Exception](class.exception.md), як це вже роблять
користувальницькі класи.

#### Помилки аналізу кидають виняток класу [ParseError](class.parseerror.md)

Помилки розбору кидають виняток класу
[ParseError](class.parseerror.md). Обробка помилок
[eval()](function.eval.md) повинна включати блок
[`catch`](language.exceptions.md#language.exceptions.catch), який
ловитиме цю помилку.

#### Зміна суворості повідомлень E_STRICT

Всі повідомлення **`E_STRICT`** перекваліфіковані за іншими рівнями.
Константа **`E_STRICT`** збережена, так що
`error_reporting(E_ALL|E_STRICT)` не викликає помилки.

| Ситуація Новий рівень/поведінка |
|------------------------------------------------- --------|--------------------------------------|
| Індексування ресурсом **`E_NOTICE`** |
| Анотація статичних методів | Повідомлення прибрано, не викликає помилок |
| "Перевизначення" конструктора | Повідомлення прибрано, не викликає помилок |
| Недотримання сигнатури під час успадкування | **`E_WARNING`** |
| Поодинокі (сумісні) властивості у двох різних трейтах Повідомлення прибрано, не викликає помилок |
| Нестатичний доступ до статичної властивості **`E_NOTICE`** |
| Тільки змінні може бути присвоєно за посиланням | **`E_NOTICE`** |
| Тільки змінні може бути передані за посиланням | **`E_NOTICE`** |
| Виклик нестатичного методу статично **`E_DEPRECATED`** |

**Зміна суворості повідомлень **`E_STRICT`****

### Зміни в обробці змінних

PHP 7 використовує абстрактне синтаксичне дерево при розборі файлів з
вихідним кодом. Це дозволило внести безліч покращень у мову, які
раніше були неможливі через обмеження парсера, що використовувався в
попередніх версіях PHP, але призвело до видалення деяких особливих
можливостей з міркувань узгодженості та порушило зворотну
сумісність. Опис цих особливих випадків наведено у цій секції.

#### Зміни в обробці непрямих змінних, властивостей та методів

Непрямий доступ до змінних, властивостей та методів тепер розкривається
суворо зліва-направо, на противагу попередньому поєднанню зі спеціальних
правил. У таблиці представлені зміни у порядку розкриття.

| Вираз | Інтерпретація PHP 5 Інтерпретація PHP 7
|-----------------------|------------------------- |-------------------------|
| `$$foo['bar']['baz']` | `${$foo['bar']['baz']}` | `($$foo)['bar']['baz']` |
| `$foo->$bar['baz']` | `$foo->{$bar['baz']}` | `($foo->$bar)['baz']` |
| `$foo->$bar['baz']()` | `$foo->{$bar['baz']}()` | `($foo->$bar)['baz']()` |
| `Foo::$bar['baz']()` | `Foo::{$bar['baz']}()` | `(Foo::$bar)['baz']()` |

**Стара і нова оцінка непрямих виразів**

Код, що використовує старий порядок розкриття праворуч-ліворуч, має бути
переписаний з використанням фігурних дужок (дивіться середній стовпець у
таблиці вище). Це зробить код робітником як у PHP 5.x, так і в PHP 7.x.

Також це стосується і ключового слова
[`global`](language.variables.scope.md#language.variables.scope.global).
Для емуляції старої поведінки необхідно використовувати фігурні дужки:

` <?phpfunction f() {    // Коректно тільки в PHP 5.   global$$$foo->bar; // Коректно в PHP 5 і 7.   global ${$foo->bar};}?> `

#### Зміна в обробці [list()](function.list.md)

##### [list()](function.list.md) більше не привласнює змінні у зворотному порядку

Тепер [list()](function.list.md) надає змінні в тому
порядку, як вони перераховані, а чи не у протилежному. Загалом це впливає
тільки на випадки, коли [list()](function.list.md) використовується
спільно з оператором масиву `[]`, як показано нижче:

` <?phplist($a[], $a[], $a[]) u003d [1, 2, 3];var_dump($a);?> `

Результат виконання цього прикладу в PHP 5:

array(3) {
[0]u003d>
int(3)
[1]u003d>
int(2)
[2]u003d>
int(1)
}

Результат виконання цього прикладу в PHP 7:

array(3) {
[0]u003d>
int(1)
[1]u003d>
int(2)
[2]u003d>
int(3)
}

Також хочеться відзначити, що покладатись на порядок присвоєння оператором
[list()](function.list.md) - не найрозумніше рішення, оскільки він
знову може змінитися у майбутньому.

##### Порожнє присвоєння [list()](function.list.md) більше не дозволено

Конструкція [list()](function.list.md) не може бути порожньою.
Наступні приклади неприпустимі:

` <?phplist() u003d $a;list(,,) u003d $a;list($x, list(), $y) u003d $a;?> `

##### [list()](function.list.md) не може розкривати рядки

[list()](function.list.md) більше не може розкривати рядки.
Використовуйте [str_split()](function.str-split.md).

#### Змінено порядок масиву при автоматичному створенні через присвоєння за посиланням

Порядок створення елементів у масиві було змінено, коли елемент
створюється шляхом присвоєння значення змінної, яку посилається
цей елемент. Приклад:

` <?php$array u003d [];$array["a"] u003d& $array["b"];$array["b"] u003d 1;var_dump($array);?> `

Результат виконання цього прикладу в PHP 5:

array(2) {
["b"]u003d>
&int(1)
["a"]u003d>
&int(1)
}

Результат виконання цього прикладу в PHP 7:

array(2) {
["a"]u003d>
&int(1)
["b"]u003d>
&int(1)
}

#### Дужки навколо аргументів функції більше ні на що не впливають

У PHP 5 при використанні надлишкових дужок навколо аргументів функції не
виводилося попередження, коли аргумент передавався за посиланням. Тепер
попередження виводиться завжди.

` <?phpfunction getArray() {    return [1, 2, 3];}function squareArray(array &$a) {   foreach ($a as &$v) {    }}// Виведе попередження в PHP 7.squareArray((getArray()));?> `

Результат виконання цього прикладу:

Notice: Лише variables should be passed by reference in /tmp/test.php on line 13

### Зміни [foreach](control-structures.foreach.md)

Невеликі зміни були внесені до поведінки керуючої структури
[foreach] (control-structures.foreach.md). Основна зміна стосується
модифікації ітерованого масиву та обробки його внутрішнього покажчика.

#### [foreach](control-structures.foreach.md) більше не змінює внутрішній покажчик масиву

До PHP 7 в процесі ітерації масиву
[foreach](control-structures.foreach.md), його внутрішній покажчик
змінювався. У прикладі нижче показано, що це поведінка змінено:

` <?php$array u003d [0, 1, 2];foreach ($array as &$val) {    var_dump(current($array));}?> `

Результат виконання цього прикладу в PHP 5:

int(1)
int(2)
bool(false)

Результат виконання цього прикладу в PHP 7:

int(0)
int(0)
int(0)

#### [foreach](control-structures.foreach.md) за значеннями оперує копією масиву

Якщо [foreach](control-structures.foreach.md) використовується для
стандартного перебору за значенням, він оперує копією масиву, а чи не
самим масивом. Це означає, що зміни внесені до масиву всередині
циклу не торкнуться значення, що перебираються.

#### Для [foreach](control-structures.foreach.md) за посиланням покращили поведінку при ітерації

Коли [foreach](control-structures.foreach.md) використовується для
перебору за посиланням, він краще відстежуватиме зміни, що вносяться в
масив у процесі ітерації. Наприклад, додавання елементів до
ітерованого масиву призведе до того, що ці нові елементи потраплять у
перебір:

` <?php$array u003d [0];foreach ($array as &$val) {    var_dump($val); $array[1]u003du003d 1;}?> `

Результат виконання цього прикладу в PHP 5:

int(0)

Результат виконання цього прикладу в PHP 7:

int(0)
int(1)

#### Ітерація об'єктів, що не реалізують [Traversable](class.traversable.md)

Ітерація об'єктів, що не реалізують [Traversable](class.traversable.md)
тепер відбувається так само, як і ітерація масиву за посиланням. Так
виходить внаслідок того, що [покращення поведінки при зміні
масиву під час
ітерації](migration70.incompatible.md#migration70.incompatible.foreach.by-ref)
також впливає при додаванні або видаленні властивостей об'єкта.

### Зміна в обробці значень типу int

#### Некоректна вісімкова нотація

Раніше вісімкові літерали, що містять некоректні числа мовчки
обрізалися (`0128` вважалися за `012`). Зараз у таких випадках буде
видана помилка аналізу.

#### Негативні побітові зсуви

Тепер побитові зсуви на негативну величину кидатимуть
виняток [ArithmeticError](class.arithmeticerror.md):

`<?phpvar_dump(1 >> -1);?> `

Результат виконання цього прикладу в PHP 5:

int(0)

Результат виконання цього прикладу в PHP 7:

Fatal error: Uncaught ArithmeticError: Bit shift by negative number in /tmp/test.php:2
Stack trace:
#0 {main}
thrown in /tmp/test.php on line 2

#### Побітові зсуви з виходом із допустимого діапазону

Побітові усунення (в обох напрямках) за межі ширини типу int
завжди повертатимуть 0. Раніше поведінка залежала від архітектури.

#### Зміна в розподілі на нуль

Раніше використання нуля як дільника в операціях поділу (/) або
розподілу за модулем (%) призводило до помилки рівня E_WARNING та повернення
значення **`false`**. Тепер оператор поділу повертає число з
плаваючою точкою, що дорівнює +INF, -INF або NAN, як визначено в IEEE 754.
Поділ за модулем замість помилки рівня E_WARNING викидатиме
виняток [DivisionByZeroError](class.divisionbyzeroerror.md).

` <?phpvar_dump(3/0);var_dump(0/0);var_dump(0%0);?> `

Результат виконання цього прикладу в PHP 5:

Warning: Division by zero in %s on line %d
bool(false)

Warning: Division by zero in %s on line %d
bool(false)

Warning: Division by zero in %s on line %d
bool(false)

Результат виконання цього прикладу в PHP 7:

Warning: Division by zero in %s on line %d
float(INF)

Warning: Division by zero in %s on line %d
float(NAN)

PHP Fatal error: Uncaught DivisionByZeroError: Modulo by zero in %s line %d

### Зміни в обробці рядків

#### Шістнадцяткові рядки більше не рахуються за числові

Рядки, що містять шістнадцяткові символи більше не вважаються за
числові. Приклад:

` <?phpvar_dump("0x123" u003du003d "291");var_dump(is_numeric("0x123"));var_dump("0xe" + "0x1");var_dump(substr("foo", "0x1")); ?> `

Результат виконання цього прикладу в PHP 5:

bool(true)
bool(true)
int(15)
string(2) "oo"

Результат виконання цього прикладу в PHP 7:

bool(false)
bool(false)
int(0)

Notice: A non well formed numeric value encountered in /tmp/test.php on line 5
string(3) "foo"

Використовуйте функцію [filter_var()](function.filter-var.md) для
перевірки рядка на утримання шістнадцяткового числа та перетворення
цього рядка до значення типу int:

` <?php$str u003d "0xffff";$int u003d filter_var($str, FILTER_VALIDATE_INT, FILTER_FLAG_ALLOW_HEX);if (false u003du003du003d $int) {                  ¦¦¦ int); // int (65535)?

#### `\u{` може викликати помилки

У зв'язку з додаванням нового [синтаксису екранування кодів
Unicode](migration70.new-features.md#migration70.new-features.unicode-codepoint-escape-syntax),
рядки, що містять рядок `\u{`, що передує некоректному
послідовність може призвести до фатальної помилки. Для того щоб
цього уникнути, необхідно екранувати перший зворотний сліш.

### Віддалені функції

#### **call_user_method()** та **call_user_method_array()**

Функції, оголошені застарілими в PHP 4.1.0
[call_user_func()](function.call-user-func.md) та
[call_user_func_array()](function.call-user-func-array.md). можливо
вам також буде цікаво розглянути можливість [звернення до функцій
через змінні](functions.variable-functions.md) та/або оператор
[`...`](functions.arguments.md#functions.variable-arg-list).

#### Всі функції ereg\*

Усі функції `ereg` видалені. Рекомендована альтернатива -
[PCRE](book.pcre.md).

#### Псевдоніми [mcrypt](book.mcrypt.md)

Застаріла функція **mcrypt_generic_end()** була видалена на користь
функції [mcrypt_generic_deinit()](function.mcrypt-generic-deinit.md).

Крім цього, застарілі функції **mcrypt_ecb()**, **mcrypt_cbc()**,
**mcrypt_cfb()** та **mcrypt_ofb()** були видалені на користь використання
[mcrypt_decrypt()](function.mcrypt-decrypt.md) з відповідною
константою **`MCRYPT_MODE_*`**.

#### Всі функції модуля mysql

Усі функції [ext/mysql](book.mysql.md) було видалено. Для вибору
іншого MySQL API дивіться розділ [Вибір MySQL
API] (mysqlinfo.api.choosing.md).

#### Всі функції модуля mssql

Усі функції `ext/mssql` було видалено.

- [PDO_SQLSRV](ref.pdo-sqlsrv.md)
- [PDO_ODBC](ref.pdo-odbc.md)
- [SQLSRV](book.sqlsrv.md)
- [Unified ODBC API](book.uodbc.md)

#### Псевдоніми [intl](book.intl.md)

Застарілі псевдоніми **datefmt_set_timezone_id()** та
**IntlDateFormatter::setTimeZoneID()** були видалені на користь
[datefmt_set_timezone()](intldateformatter.settimezone.md) та
[IntlDateFormatter::setTimeZone()](intldateformatter.settimezone.md)
відповідно.

#### **set_magic_quotes_runtime()**

**set_magic_quotes_runtime()** та її псевдонім **magic_quotes_runtime()**
були вилучені. Вони були оголошені застарілими в PHP 5.3.0 та повністю
втратили свій сенс з відмовою від магічних лапок у PHP 5.4.0.

#### **set_socket_blocking()**

Застарілий псевдонім **set_socket_blocking()** був видалений на користь
[stream_set_blocking()](function.stream-set-blocking.md).

#### [dl()](function.dl.md) в PHP-FPM

Функція [dl()](function.dl.md) більше не може використовуватись у
PHP-FPM. Однак вона збереглася в CLI і вбудованих SAPI.

#### Функції [GD](book.image.md) Type1

Підтримка шрифтів PostScript Type1 видалена із модуля GD. Відповідно
були видалені такі функції:

- **imagepsbbox()**
- **imagepsencodefont()**
- **imagepsextendfont()**
- **imagepsfreefont()**
- **imagepsloadfont()**
- **imagepsslantfont()**
- **imagepstext()**

Замість них рекомендується використовувати шрифти TrueType та пов'язані з ними
функції.

### Видалені директиви INI-файлу

#### Віддалені можливості

Наступні INI-директиви були видалені, оскільки пов'язані з ними функції
також були видалені:

- `always_populate_raw_post_data`
- `asp_tags`

#### `xsl.security_prefs`

Директива `xsl.security_prefs` була вилучена. Замість неї для контролю
налаштувань безпеки повинен викликатися метод
[XsltProcessor::setSecurityPrefs()](xsltprocessor.setsecurityprefs.md)
лише на рівні кожного процесора.

### Інші зміни, що стосуються зворотної сумісності

#### Нові об'єкти не можуть присвоюватися за посиланням

Результат оператора
[`new`](language.oop5.basic.md#language.oop5.basic.new) більше не
може бути присвоєний змінною за посиланням:

` <?phpclass C {}$c u003d& new C;?> `

Результат виконання цього прикладу в PHP 5:

Deprecated: Assigning the return value of new by reference is deprecated in /tmp/test.php on line 3

Результат виконання цього прикладу в PHP 7:

Пірс error: syntax error, unexpected 'new' (T_NEW) in /tmp/test.php on line 3

#### Некоректні імена класів, інтерфейсів та трейтів

Наступні імена не можна використовувати для класів, інтерфейсів та трейтів:

- bool
- int
- float
- string
- **`null`**
- **`true`**
- **`false`**

Більше того, такі імена не повинні використовуватися. Вони не приведуть до
помилки в PHP 7.0, але вони зарезервовані на майбутнє і повинні рахуватися
застарілими.

- resource
- object
- [mixed](language.types.declarations.md#language.types.declarations.mixed)
- numeric

#### Видалені PHP-теги ASP та script

Видалено підтримку використання тегів ASP та script для визначення коду
PHP.

| Відкриваючи тег | Закриває тег |
|---------------------------|-----------------|
| '<%' | `%>` |
| `<%u003d` | `%>` |
| `<script languageu003d"php">` | `</script>` |

**Видалені теги ASP та script**

#### Видалені виклики з невідповідного контексту

[Раніше визнані застарілими у PHP
5.6](migration56.deprecated.md#migration56.deprecated.incompatible-context)
статичні виклики нестатичних методів з невідповідного контексту
тепер призведуть до того, що для методу, що викликається, змінна `$this`
буде не визначено та буде виведено попередження.

`<?phpclass A {    public function test() { var_dump($this); }}// Зверніть вимання: НЕ розширює клас Aclass B {    public function callNonStaticMethodOfA() { A::test(); }}(new B)->callNonStaticMethodOfA();?> `

Результат виконання цього прикладу в PHP 5.6:

Deprecated: Non-static method A::test() не повинен бути названий статічним, оцінюваним $this from incompatible context in /tmp/test.php on line 8
object(B)#1 (0) {
}

Результат виконання цього прикладу в PHP 7:

Deprecated: Non-static method A::test() не повинен бути названий статичне в /tmp/test.php on line 8

Notice: Undefined variable: this in /tmp/test.php on line 3
NULL

#### [yield](language.generators.syntax.md#control-structures.yield) тепер право-асоціативний оператор

Конструкція
[yield](language.generators.syntax.md#control-structures.yield) більше
не вимагає обертання у дужки та є право-асоціативним
оператором з пріоритетом між `print` та `u003d>`. Це може призвести до
зміни поведінки:

`<?phpecho yield -1;// Раніше інтерпретувалося такecho (yield) - 1;// А тепер такecho yield (-1);yield $foo or die;// Р  А тепер так(yield $foo) or die;?> `

Дужки можуть бути використані для усунення неоднозначності в таких
випадках.

#### Функції не можуть мати кілька параметрів з однаковими іменами

Більше не можна визначити кілька параметрів функції з однаковими
іменами. Наприклад, така функція видасть помилку рівня
**`E_COMPILE_ERROR`**:

` <?phpfunction foo($a, $b, $unused, $unused) {    //}?> `

#### Функції, що працюють з аргументами, тепер повертають їх *поточні* значення

**func_get_arg()**, [func_get_args()](function.func-get-args.md),
[debug_backtrace()](function.debug-backtrace.md) та трасування
винятків повертають не вихідні передані значення, а поточні
значення, які можуть бути змінені.

`<?phpfunction foo($x) {    $x++; var_dump(func_get_arg(0));}foo(1);?> `

Результат виконання цього прикладу в PHP 5:

1

Результат виконання цього прикладу в PHP 7:

2

#### Оператор switch більше не може мати кілька блоків default

Більше неможливо встановити більше одного блоку default в операторі switch.
Наприклад, така конструкція видасть помилку **`E_COMPILE_ERROR`**:

`<?phpswitch (1) {    default:    break; default:   break;}?> `

#### Видалена `$HTTP_RAW_POST_DATA`

`$HTTP_RAW_POST_DATA` більше недоступне. Замість нього використовуйте потік
[`php://input`](wrappers.php.md#wrappers.php.input).

#### Заборонені коментарі `#` в INI-файлах

Підтримка префіксу коментаря `#` в INI-файлах видалена. Використовуйте
префікс `;` замість нього. Ця зміна стосується як `php.ini`, так і
файлів, що обробляються функціями
[parse_ini_file()](function.parse-ini-file.md) та
[parse_ini_string()](function.parse-ini-string.md).

#### Модуль JSON замінено на JSOND

Модуль JSON замінено на JSOND, що породжує три невеликі зворотні
несумісності. Перше - числа не повинні закінчуватися на точку (то
є `34.` має бути замінено на `34.0` або `34`). Друге - при
використання наукової нотації, експонента `e` не повинна слідувати відразу
за десятковою точкою (тобто `3.e3` потрібно поміняти на `3.0e3` або
`3e3`). Третє - порожній рядок більше не вважається коректним JSON.

#### Помилки внутрішніх функцій при переповненні

Раніше вбудовані функції могли тихо обрізати числа, отримані за
приведенні типу float до integer, якщо float був більшим, ніж здатний
вмістити integer. Тепер же видаватиметься помилка E_WARNING та
повертатися **`null`**.

#### Виправлення для повертаних значень користувальницького обробника сесії

Будь-які предикатні функції, реалізовані за допомогою користувацьких
обробників сесії та повертаючі **`false`** або `-1`, викличуть
фатальну помилку. Якщо ці функції повернуть будь-яке значення, крім
логічного, `-1` або `0`, вони будуть вважатися завершеними з помилкою та
викликатиме попередження E_WARNING.

#### Порядок сортування однакових елементів

Внутрішній алгоритм сортування був змінений, що може позначитися на
відмінному від попереднього відсортованому порядку елементів, визначених
як однакові.

> **Примітка**:
>
> Не покладайтеся на порядок однакових елементів, оскільки він може в
> Будь-який час змінити.

#### Зміна порядку обробки операторів break та switch

Оператори `break` і `continue` поза циклом або керуючою структурою
`switch` тепер обробляються під час компіляції, а не під час
виконання, як це було раніше, тому видають помилки рівня
**`E_COMPILE_ERROR`**.

#### Mhash більше не є модулем

Модуль Mhash повністю інтегрований модуль [Hash](book.hash.md).
Таким чином, тепер не можна визначити доступність підтримки Mhash з
за допомогою функції [extension_loaded()](function.extension-loaded.md);
замість неї використовуйте
[function_exists()](function.function-exists.md). Крім того, Mhash
більше не виводитиме за допомогою
[get_loaded_extensions()](function.get-loaded-extensions.md) та
подібних функцій.

#### declare(ticks)

Директива
[declare(ticks)](control-structures.declare.md#control-structures.declare.ticks)
більше не проникає у різні модулі компіляції.
