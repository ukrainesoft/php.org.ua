{"pageProps":{"page":{"slug":"eventbufferevent.sslfilter.md","content":"# EventBufferEvent::sslFilter\n\n(PECL event >= 1.2.6-beta)\n\nEventBufferEvent::sslFilter — Створює нову подію буфера SSL для надсилання своїх даних через іншу подію буфера\n\n### Опис\n\n```methodsynopsis\npublic\n   static\n   EventBufferEvent::sslFilter(    \n    EventBase\n     $base\n   ,    \n    EventBufferEvent\n     $underlying\n   ,    \n    EventSslContext\n     $ctx\n   ,    \n    int\n     $state\n   ,    \n    int\n     $options\n     = 0\n   ): EventBufferEvent\n```\n\nСтворює нову подію буфера SSL для надсилання своїх даних через іншу подію буфера\n\n> **Зауваження** :\n> \n> Функція доступна лише в тому випадку, якщо `Event` скомпільований за допомогою OpenSSL.\n\n### Список параметрів\n\n`base`\n\nПов'язана основа подій.\n\n`underlying`\n\nПодія буфера сокету використовувати для цього SSL.\n\n`ctx`\n\nОб'єкт класу [EventSslContext](class.eventsslcontext.md)\n\n`state`\n\nТекущее состояние SSL-соединения:**`EventBufferEvent::SSL_OPEN`** **`EventBufferEvent::SSL_ACCEPTING`** або **`EventBufferEvent::SSL_CONNECTING`**\n\n`options`\n\nОдин чи кілька параметрів буфера.\n\n### Значення, що повертаються\n\nПовертає новий SSL [EventBufferEvent](class.eventbufferevent.md) об'єкт.\n\n### Приклади\n\n**Приклад #1 Простий SMTP-сервер**\n\n```php\n<?php\n /*\n * Автор: Andrew Rose <hello at andrewrose dot co dot uk>\n *\n * Usage:\n * 1) Подготовим файлы сертификата cert.pem и приватного ключа privkey.pem.\n * 2) Запустим скрипт сервера\n * 3) Откроем TLS-соединение, наПриклад:\n *      $ openssl s_client -connect localhost:25 -starttls smtp -crlf\n * 4) Протестируем команды, описанные в метода `cmd`.\n */\n\nclass Handler {\n    public $domainName = FALSE;\n    public $connections = [];\n    public $buffers = [];\n    public $maxRead = 256000;\n\n    public function __construct() {\n        $this->ctx = new EventSslContext(EventSslContext::SSLv3_SERVER_METHOD, [\n            EventSslContext::OPT_LOCAL_CERT  => 'cert.pem',\n            EventSslContext::OPT_LOCAL_PK    => 'privkey.pem',\n            //EventSslContext::OPT_PASSPHRASE  => '',\n            EventSslContext::OPT_VERIFY_PEER => false, // для корректного сертификата укажите true\n            EventSslContext::OPT_ALLOW_SELF_SIGNED => true // для корректного сертификата укажите false\n        ]);\n\n        $this->base = new EventBase();\n        if (!$this->base) {\n            exit(\"Не удалось открыть обработчик событий\\n\");\n        }\n\n        if (!$this->listener = new EventListener($this->base,\n            [$this, 'ev_accept'],\n            $this->ctx,\n            EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE,\n            -1,\n            '0.0.0.0:25'))\n        {\n            exit(\"Невозможно создать слушателя\\n\");\n        }\n\n        $this->listener->setErrorCallback([$this, 'ev_error']);\n        $this->base->dispatch();\n    }\n\n    public function ev_accept($listener, $fd, $address, $ctx) {\n        static $id = 0;\n        $id += 1;\n\n        $this->connections[$id]['clientData'] = '';\n        $this->connections[$id]['cnx'] = new EventBufferEvent($this->base, $fd,\n            EventBufferEvent::OPT_CLOSE_ON_FREE);\n\n        if (!$this->connections[$id]['cnx']) {\n            echo \"Failed creating buffer\\n\";\n            $this->base->exit(NULL);\n            exit(1);\n        }\n\n        $this->connections[$id]['cnx']->setCallbacks([$this, \"ev_read\"], NULL,\n            [$this, 'ev_error'], $id);\n        $this->connections[$id]['cnx']->enable(Event::READ | Event::WRITE);\n\n        $this->ev_write($id, '220 '.$this->domainName.\" wazzzap?\\r\\n\");\n    }\n\n    function ev_error($listener, $ctx) {\n        $errno = EventUtil::getLastSocketErrno();\n\n        fprintf(STDERR, \"Ошибка слушателя: %d (%s). Аварийное завершение работы.\\n\",\n            $errno, EventUtil::getLastSocketError());\n\n        if ($errno != 0) {\n            $this->base->exit(NULL);\n            exit();\n        }\n    }\n\n    public function ev_close($id) {\n        $this->connections[$id]['cnx']->disable(Event::READ | Event::WRITE);\n        unset($this->connections[$id]);\n    }\n\n    protected function ev_write($id, $string) {\n        echo 'S('.$id.'): '.$string;\n        $this->connections[$id]['cnx']->write($string);\n    }\n\n    public function ev_read($buffer, $id) {\n        while($buffer->input->length > 0) {\n            $this->connections[$id]['clientData'] .= $buffer->input->read($this->maxRead);\n            $clientDataLen = strlen($this->connections[$id]['clientData']);\n\n            if($this->connections[$id]['clientData'][$clientDataLen-1] == \"\\n\"\n                && $this->connections[$id]['clientData'][$clientDataLen-2] == \"\\r\")\n            {\n                // удаляем все завершающие \\r\\n\n                $line = substr($this->connections[$id]['clientData'], 0,\n                    strlen($this->connections[$id]['clientData']) - 2);\n\n                $this->connections[$id]['clientData'] = '';\n                $this->cmd($buffer, $id, $line);\n            }\n        }\n    }\n\n    protected function cmd($buffer, $id, $line) {\n        switch ($line) {\n            case strncmp('EHLO ', $line, 4):\n                $this->ev_write($id, \"250-STARTTLS\\r\\n\");\n                $this->ev_write($id, \"250 OK ehlo\\r\\n\");\n                break;\n\n            case strncmp('HELO ', $line, 4):\n                $this->ev_write($id, \"250-STARTTLS\\r\\n\");\n                $this->ev_write($id, \"250 OK helo\\r\\n\");\n                break;\n\n            case strncmp('QUIT', $line, 3):\n                $this->ev_write($id, \"250 OK quit\\r\\n\");\n                $this->ev_close($id);\n                break;\n\n            case strncmp('STARTTLS', $line, 3):\n                $this->ev_write($id, \"220 Ready to start TLS\\r\\n\");\n                $this->connections[$id]['cnx'] = EventBufferEvent::sslFilter($this->base,\n                    $this->connections[$id]['cnx'], $this->ctx,\n                    EventBufferEvent::SSL_ACCEPTING,\n                    EventBufferEvent::OPT_CLOSE_ON_FREE);\n                $this->connections[$id]['cnx']->setCallbacks([$this, \"ev_read\"], NULL, [$this, 'ev_error'], $id);\n                $this->connections[$id]['cnx']->enable(Event::READ | Event::WRITE);\n                break;\n\n            default:\n                echo 'неизвестная команда: '.$line.\"\\n\";\n                break;\n        }\n    }\n}\n\nnew Handler();\n```\n\n### Дивіться також\n\n-   [EventBufferEvent::sslSocket()](eventbufferevent.sslsocket.md) \\- Створює нову буферну подію SSL для надсилання своїх даних через SSL у сокет\n","title":"EventBufferEvent::sslFilter","contentType":2,"navigation":[{"eventbufferevent.sslerror.md":"« EventBufferEvent::sslError"},{"eventbufferevent.sslgetcipherinfo.md":"EventBufferEvent::sslGetCipherInfo »"},{"index.md":"PHP Manual"},{"class.eventbufferevent.md":"EventBufferEvent"}]}},"__N_SSG":true}