{"pageProps":{"page":{"slug":"function.is-callable.md","content":"# is\\_callable\n\n(PHP 4 >= 4.0.6, PHP 5, PHP 7, PHP 8)\n\nis\\_callable — Перевіряє, що значення може бути викликане як функція у поточній області видимості\n\n### Опис\n\n```methodsynopsis\nis_callable(mixed $value, bool $syntax_only = false, string &$callable_name = null): bool\n```\n\nПеревіряє, що значення є [callable](language.types.callable.md)\n\n### Список параметрів\n\n`value`\n\nЗначення для перевірки\n\n`syntax_only`\n\nЯкщо дорівнює **`true`**, функція тільки перевіряє, що `value` може бути функцією чи методом. У цьому випадку відхилятимуться змінні, які не є ні рядком, ні масивом з коректною структурою для використання як callback-функції. Коректна структура масиву передбачає наявність лише двох елементів, перший у тому числі - об'єкт чи рядок, а другий - лише рядок.\n\n`callable_name`\n\nОтримує ім'я, що викликається. У прикладі нижче це \"someClass:: someMethod\". Слід пам'ятати, що хоча запис someClass::SomeMethod() означає статичний метод, що викликається, це не так.\n\n### Значення, що повертаються\n\nПовертає **`true`**, якщо `value` може бути викликана, або **`false`** в іншому випадку.\n\n### Приклади\n\n**Приклад #1 Приклад використання** is\\_callable()\\*\\*\\*\\*\n\n```php\n<?php\n//  Как проверить переменную, чтобы узнать, может ли она быть вызвана\n//  как функция.\n\n//\n//  Простая переменная, содержащая имя функции\n//\n\nfunction someFunction()\n{\n}\n\n$functionVariable = 'someFunction';\n\nvar_dump(is_callable($functionVariable, false, $callable_name));  // bool(true)\n\necho $callable_name, \"\\n\";  // someFunction\n\n//\n//  Массив, содержащий метод класса\n//\n\nclass someClass {\n\n  function someMethod()\n  {\n  }\n\n}\n\n$anObject = new someClass();\n\n$methodVariable = array($anObject, 'someMethod');\n\nvar_dump(is_callable($methodVariable, true, $callable_name));  //  bool(true)\n\necho $callable_name, \"\\n\";  //  someClass::someMethod\n\n?>\n```\n\n**Приклад #2**is\\_callable()\\*\\* та конструктори\\*\\*\n\nФункция**is\\_callable()** не рахує конструктори за callable.\n\n```php\n<?php\n\nclass Foo\n{\n    public function __construct() {}\n    public function foo() {}\n}\n\nvar_dump(\n    is_callable(array('Foo', '__construct')),\n    is_callable(array('Foo', 'foo'))\n);\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nbool(false)\nbool(false)\n```\n\n### Примітки\n\n-   Об'єкт завжди є callable, якщо він реалізує[\\_\\_invoke()](language.oop5.magic.md#object.invoke), і цей метод доступний у поточній області видимості.\n-   Ім'я класу є callable, якщо воно реалізує[\\_\\_callStatic()](language.oop5.overloading.md#object.callstatic)\n-   Якщо об'єкт реалізує[\\_\\_call()](language.oop5.overloading.md#object.call)тоді ця функція поверне\\*\\*`true`\\*\\*для будь-якого методу цього об'єкта, навіть якщо метод не визначено.\n-   Функція може запускати автозавантаження, якщо викликається під назвою класу.\n\n### Дивіться також\n\n-   [function\\_exists()](function.function-exists.md) \\- Повертає true, якщо вказана функція визначена\n-   [method\\_exists()](function.method-exists.md) \\- Перевіряє, чи існує метод у даному класі\n","title":"is\\_callable","contentType":2,"navigation":[{"function.is-bool.md":"« is\\_bool"},{"function.is-countable.md":"is\\_countable »"},{"index.md":"PHP Manual"},{"ref.var.md":"Функції для роботи зі змінними"}]}},"__N_SSG":true}