{"pageProps":{"page":{"slug":"migration70.new-features.md","content":"## Нова функціональність\n\n### Оголошення скалярних типів\n\n[Оголошення скалярних типів](language.types.declarations.md) введена у двох варіантах: примусовий (за умовчанням) та суворий. Наступні типи можуть бути використані для оголошення параметрів (в обох варіантах): рядки (string), цілі (`int`), числа з плаваючою точкою (float) та логічні значення (`bool`). Вони доповнюють аргументи інших типів, введених у PHP 5: імена класів, інтерфейсів, array та [callable](language.types.callable.md)\n\n```php\n<?php\n// Принудительный режим\nfunction sumOfInts(int ...$ints)\n{\n    return array_sum($ints);\n}\n\nvar_dump(sumOfInts(2, '3', 4.1));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(9)\n```\n\nДля установки строгого режима, в самом начале файла необходимо поместить одну директиву[`declare`](control-structures.declare.md). Це означає, що строгість оголошення скалярних типів працює лише на рівні файла і зачіпає весь інший код. Ця директива зачіпає не тільки оголошення параметрів, але й значення функцій, що повертаються (дивіться [оголошення типу, що повертається](language.types.declarations.md)), вбудовані функції PHP та функції завантажених модулів.\n\nДетальну документацію та приклади використання читайте у розділі [декларація типів](language.types.declarations.md)\n\n### Оголошення значень, що повертаються\n\nВ PHP 7 добавлена поддержка[оголошення типу, що повертається](language.types.declarations.md). Аналогічно як і [оголошення типів аргументів](language.types.declarations.md), оголошення типу значення, що повертається вказує, значення якого типу повинна повернути функція. Для оголошення типу значення, що повертається доступні все ті ж [типи](language.types.declarations.md), що й оголошення типів аргументів.\n\n```php\n<?php\n\nfunction arraysSum(array ...$arrays): array\n{\n    return array_map(function(array $array): int {\n        return array_sum($array);\n    }, $arrays);\n}\n\nprint_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nArray\n(\n    [0] => 6\n    [1] => 15\n    [2] => 24\n)\n```\n\nПовну документацію та приклади використання читайте у розділі про [оголошення типу, що повертається](language.types.declarations.md)\n\n### Оператор об'єднання з null\n\nБуло додано оператор об'єднання з null (`??`), що є синтаксичним цукром для досить поширеної дії, коли спільно використовуються тернарний оператор та функція [isset()](function.isset.md). Він повертає перший операнд, якщо він заданий і не дорівнює **`null`**, а у протилежному випадку повертає другий операнд.\n\n```php\n<?php\n// Извлекаем значение $_GET['user'], а если оно не задано,\n// то возвращаем 'nobody'\n$username = $_GET['user'] ?? 'nobody';\n// Это идентично следующему коду:\n$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';\n\n// Данный оператор можно использовать в цепочке.\n// В этом Прикладе мы сперва проверяем, задан ли $_GET['user'], если нет,\n// то проверяем $_POST['user'], и если он тоже не задан, то присваеваем 'nobody'.\n$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';\n?>\n```\n\n### Оператор spaceship (космічний корабель)\n\nЦей оператор призначений для порівняння двох виразів. Він повертає -1, 0 або 1, якщо $a, відповідно, менше, дорівнює або більше ніж $b. Порівняння проводиться відповідно до [правилами порівняння типів](types.comparisons.md)PHP.\n\n```php\n<?php\n// Целые числа\necho 1 <=> 1; // 0\necho 1 <=> 2; // -1\necho 2 <=> 1; // 1\n\n// Числа с плавающей точкой\necho 1.5 <=> 1.5; // 0\necho 1.5 <=> 2.5; // -1\necho 2.5 <=> 1.5; // 1\n\n// Строки\necho \"a\" <=> \"a\"; // 0\necho \"a\" <=> \"b\"; // -1\necho \"b\" <=> \"a\"; // 1\n?>\n```\n\n### Определение констант массивов с помощью[define()](function.define.md)\n\nМожна визначити константу типу array за допомогою функції [define()](function.define.md). У PHP 5.6 такі константи можна було задавати лише за допомогою [`const`](language.constants.syntax.md)\n\n```php\n<?php\ndefine('ANIMALS', [\n    'dog',\n    'cat',\n    'bird'\n]);\n\necho ANIMALS[1]; // выводит \"cat\"\n?>\n```\n\n### Анонімні класи\n\nДодано підтримку анонімних класів за допомогою `new class`. Їх можна використовувати тоді, коли потрібен одноразовий клас і створювати повноцінний клас, а потім його об'єкт не має сенсу:\n\n```php\n<?php\ninterface Logger {\n    public function log(string $msg);\n}\n\nclass Application {\n    private $logger;\n\n    public function getLogger(): Logger {\n         return $this->logger;\n    }\n\n    public function setLogger(Logger $logger) {\n         $this->logger = $logger;\n    }\n}\n\n$app = new Application;\n$app->setLogger(new class implements Logger {\n    public function log(string $msg) {\n        echo $msg;\n    }\n});\n\nvar_dump($app->getLogger());\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nobject(class@anonymous)#2 (0) {\n}\n```\n\nДетальну документацію та приклади використання читайте у розділі про [анонімні класи](language.oop5.anonymous.md)\n\n### Синтаксис кодування Unicode\n\nВін приймає шістнадцятковий код Unicode і записуємо його у форматі UTF-8 у подвійних лапках або форматі heredoc. Будь-який коректний код буде прийнято. Ведучі нулі за бажанням.\n\n```php\necho \"\\u{aa}\";\necho \"\\u{0000aa}\";\necho \"\\u{9999}\";\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nª\nª (То же самое, что и первый вариант, но с ведущими нулями)\n香\n```\n\n### [Closure::call()](closure.call.md)\n\n[Closure::call()](closure.call.md) є більш продуктивним та коротким способом тимчасового зв'язування області дії об'єкта із замиканням та його викликом.\n\n```php\n<?php\nclass A {private $x = 1;}\n\n// До PHP 7\n$getX = function() {return $this->x;};\n$getXCB = $getX->bindTo(new A, 'A'); // промежуточное замыкание\necho $getXCB();\n\n// PHP 7+\n$getX = function() {return $this->x;};\necho $getX->call(new A);\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1\n1\n```\n\n### [unserialize()](function.unserialize.md) з фільтрацією\n\nЦя функціональність забезпечує більш високий рівень безпеки під час десеріалізації об'єктів з неперевіреними даними. Це дозволяє запобігти можливій ін'єкції коду, дозволяючи розробнику використовувати білий список класів для десеріалізації.\n\n```php\n<?php\n\n// Преобразование всех объектов в __PHP_Incomplete_Class\n$data = unserialize($foo, [\"allowed_classes\" => false]);\n\n// Преобразование всех объектов, кроме MyClass и MyClass2 в __PHP_Incomplete_Class\n$data = unserialize($foo, [\"allowed_classes\" => [\"MyClass\", \"MyClass2\"]]);\n\n// Поведение по умолчанию принимает все классы (можно просто не задавать второй аргумент)\n$data = unserialize($foo, [\"allowed_classes\" => true]);\n```\n\n### [IntlChar](class.intlchar.md)\n\nНовий клас [IntlChar](class.intlchar.md) додає нову функціональність ICU. Клас визначає кілька статичних методів та констант для маніпулювання символами Unicode.\n\n```php\n<?php\n\nprintf('%x', IntlChar::CODEPOINT_MAX);\necho IntlChar::charName('@');\nvar_dump(IntlChar::ispunct('!'));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n10ffff\nCOMMERCIAL AT\nbool(true)\n```\n\nДля використання цього класу необхідно встановити модуль [Intl](book.intl.md)\n\n### Очікування\n\nОчікування є покращеною, обернено сумісною версією старої функції [assert()](function.assert.md). Вони дозволяють робити припущення з нульовою вартістю в промисловому коді і надають можливість викидати винятки в разі провалу очікування.\n\nРазом з тим, що старе API підтримується, [assert()](function.assert.md) тепер є мовною конструкцією, що приймає першим аргументом висловлювання, а не лише рядки (string) для оцінки чи логічні значення (bool) для перевірки.\n\n```php\n<?php\nini_set('assert.exception', 1);\n\nclass CustomError extends AssertionError {}\n\nassert(false, new CustomError('Сообщение об ошибке'));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nFatal error: Uncaught CustomError: Сообщение об ошибке\n```\n\nДетальний опис цього функціоналу, а також інструкції для його конфігурування для тестових та промислових середовищ, можна знайти на сторінці посібника, присвяченого функції [assert()](function.assert.md)\n\n### Групові оголошення `use`\n\nКласи, функції та константи імпортовані з одного і того ж [`namespace`](language.namespaces.definition.md), тепер можна групувати в одному операторі [`use`](language.namespaces.importing.md)\n\n```php\n<?php\n// До PHP 7\nuse some\\namespace\\ClassA;\nuse some\\namespace\\ClassB;\nuse some\\namespace\\ClassC as C;\n\nuse function some\\namespace\\fn_a;\nuse function some\\namespace\\fn_b;\nuse function some\\namespace\\fn_c;\n\nuse const some\\namespace\\ConstA;\nuse const some\\namespace\\ConstB;\nuse const some\\namespace\\ConstC;\n\n// PHP 7+\nuse some\\namespace\\{ClassA, ClassB, ClassC as C};\nuse function some\\namespace\\{fn_a, fn_b, fn_c};\nuse const some\\namespace\\{ConstA, ConstB, ConstC};\n?>\n```\n\n### Вираз return у генераторах\n\nЦя функціональність додана до генераторів, введених у PHP 5.5. Вона дозволяє використовувати оператор `return` в генераторах як остаточне значення, що повертається (повернення за посиланням неприпустимо). Це значення можна отримати за допомогою нового методу `Generator::getReturn()`, який можна використовувати тільки після того, як генератор повернув усі згенеровані значення.\n\n```php\n<?php\n\n$gen = (function() {\n    yield 1;\n    yield 2;\n\n    return 3;\n})();\n\nforeach ($gen as $val) {\n    echo $val, PHP_EOL;\n}\n\necho $gen->getReturn(), PHP_EOL;\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1\n2\n3\n```\n\nМожливість явно отримувати остаточне значення генератора є дуже корисною, оскільки дозволяє клієнтському коду, що використовує генератор, отримувати та обробити останнє значення генератора, після якого точно нічого більше не буде. Це дуже простіше, ніж змушувати розробника перевіряти, чи останнє значення повернулося і якось особливо його обробляти.\n\n### Делегація генератора\n\nТепер генератор може автоматично делегувати іншому генератору, об'єкту класу, що реалізує [Traversable](class.traversable.md) або масиву без необхідності писати додаткову обробку отриманих значень. Досягається це за допомогою конструкції [`yield from`](language.generators.syntax.md#control-structures.yield.from)\n\n```php\n<?php\nfunction gen()\n{\n    yield 1;\n    yield 2;\n    yield from gen2();\n}\n\nfunction gen2()\n{\n    yield 3;\n    yield 4;\n}\n\nforeach (gen() as $val)\n{\n    echo $val, PHP_EOL;\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1\n2\n3\n4\n```\n\n### Функція цілісного поділу [intdiv()](function.intdiv.md)\n\nНова функція [intdiv()](function.intdiv.md) виробляє цілий поділ операндів і повертає його результат.\n\n```php\n<?php\nvar_dump(intdiv(10, 3));\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nint(3)\n```\n\n### Опції сесій\n\nТепер [session\\_start()](function.session-start.md) приймає масив опцій, які перевизначать [конфігураційні директиви сесії](session.configuration.md) встановлені у php.ini.\n\nТакож опції були розширені включеною за замовчуванням опцією [session.lazy\\_write](session.configuration.md#ini.session.lazy-write), яка говорить PHP про те, що файл сесії треба перезаписувати тільки якщо змінилися дані сесії, і опцією `read_and_close`, яку можна задати тільки через [session\\_start()](function.session-start.md) для того, щоб PHP закривав сесію відразу ж як прочитає її дані і не вносив до неї будь-яких змін.\n\nК Прикладу, для установки[session.cache\\_limiter](session.configuration.md#ini.session.cache-limiter) рівним `private` та негайного закриття сесії після читання її даних:\n\n```php\n<?php\nsession_start([\n    'cache_limiter' => 'private',\n    'read_and_close' => true,\n]);\n?>\n```\n\n### [preg\\_replace\\_callback\\_array()](function.preg-replace-callback-array.md)\n\nНова функція [preg\\_replace\\_callback\\_array()](function.preg-replace-callback-array.md) дозволяє писати чистіший код, коли потрібно використовувати функцію [preg\\_replace\\_callback()](function.preg-replace-callback.md). До PHP 7 при необхідності обробити різні регулярні вирази різними функціями доводилося для кожної обробки писати окремий виклик функції.\n\nТепер можна використовувати одну функцію, передаючи до неї асоціативний масив, ключами якого є регулярні вирази, а значеннями – функції зворотного виклику.\n\n### Функції CSPRNG\n\nБуло додано дві нові кросплатформні функції для генерації криптографічно безпечних рядків і цілих чисел: [random\\_bytes()](function.random-bytes.md) і [random\\_int()](function.random-int.md)\n\n### Теперь функция[list()](function.list.md) завжди може розпаковувати об'єкти, що реалізують [ArrayAccess](class.arrayaccess.md)\n\nРанее функция[list()](function.list.md) не гарантувала коректну обробку об'єктів, що реалізують [ArrayAccess](class.arrayaccess.md). Тепер це виправлено.\n\n### Інші зміни\n\n-   Додано можливість доступу до методів та властивостей класу при клонуванні, тобто`(clone $foo)->bar()`\n","title":"Нова функціональність","contentType":2,"navigation":[{"migration70.incompatible.md":"« Зміни, що ламають зворотну сумісність"},{"migration70.deprecated.md":"Функціональність, оголошена застарілою в PHP 7.0.x"},{"index.md":"PHP Manual"},{"migration70.md":"Міграція з PHP 5.6.x на PHP 7.0.x"}]}},"__N_SSG":true}