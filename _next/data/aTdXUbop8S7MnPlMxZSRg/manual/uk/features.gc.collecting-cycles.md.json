{"pageProps":{"page":{"slug":"features.gc.collecting-cycles.md","content":"## Збір циклічних посилань\n\nЗазвичай механізми підрахунку посилань у пам'яті, наприклад, які працювали в PHP раніше, не вирішують проблему витоку пам'яті через циклічні посилання. Починаючи з версії 5.3.0 у PHP реалізовано синхронний механізм із дослідження «[» Concurrent Cycle Collection in Reference Counted Systems](https://pages.cs.wisc.edu/~cymen/misc/interests/Bacon01Concurrent.pdf)», у якому розглядається це питання.\n\nПовний опис роботи алгоритму виходить за межі цього розділу, тому наведено лише основи. Спочатку потрібно поставити основні правила. Якщо лічильник посилань збільшується, то контейнер все ще потрібний і не вважатиметься сміттям. Якщо лічильник зменшується до нуля, zval може бути видалений. З такими правилами витоку пам'яті з циклічними посиланнями можуть вийти тільки при зменшенні лічильника посилань до ненульового значення. Потім у виділених контейнерах можна знайти сміття, перевіривши, чи можна зменшити всі лічильники посилань на одиницю, і визначивши ті контейнери, у яких лічильник стане рівним нулю.\n\n![Алгоритм складання сміття](images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png)\n\nЩоб уникнути постійної перевірки на сміття з циклічними посиланнями при кожному зменшенні лічильника посилань, алгоритм додає все можливе коріння (zval контейнери) в «кореневий буфер» (позначаючи їх як «фіолетові»). Це також гарантує попадання будь-якого кореня в буфер лише один раз. Механізм складання сміття стартує лише тоді, коли наповнюється буфер (дивіться крок A на малюнку вище).\n\nНа кроці B алгоритм шукає в глибину по всіх можливих коренях для одноразового зменшення лічильника посилань на одиницю у всіх контейнерів (позначаючи їх як «сірі»). На кроці C алгоритм знову шукає для перевірки лічильників посилань. Якщо він знаходить лічильник з нульовим значенням, контейнер позначається як «білий» (на малюнку відображено синім). Якщо лічильник більший за нуль, то пошук йде в глибину від цього контейнера зі зворотним збільшенням лічильників на одиницю і повторною позначкою як «чорний» на їх контейнерах. На останньому кроці D алгоритм проходить кореневим буфером і видаляє з нього коріння контейнерів, заодно перевіряючи які контейнери позначені як «білі». Ці контейнери буде звільнено з пам'яті.\n\nТепер, коли є уявлення про роботу алгоритму, розглянемо його інтеграцію до PHP. За замовчуванням збирач сміття завжди включений. Для зміни цієї опції використовується параметр [zend.enable\\_gc](info.configuration.md#ini.zend.enable-gc)в php.ini.\n\nЯкщо збирач сміття включений, алгоритм пошуку циклічних посилань виконується щоразу, коли кореневий буфер наповнюється 10 000 корінням (можна змінити це значення, змінивши константу **`GC_THRESHOLD_DEFAULT`** у файлі `Zend/zend_gc.c` у вихідному коді PHP і перебравши PHP). Якщо збирач сміття вимкнено, алгоритм ніколи не буде запущено. Тим не менш, буфер завжди заповнюється корінням.\n\nЯкщо буфер заповнився при вимкненому механізмі складання сміття, то інше коріння не буде в нього записано. Таким чином, якщо вони виявляться сміттям із циклічними посиланнями, то ніколи не будуть очищені та створять витік пам'яті.\n\nПричиною постійного запису коріння в буфер навіть при вимкненому механізмі складання сміття є те, що це набагато швидше, ніж постійно перевіряти, чи увімкнений механізм складання сміття. Проте, саме складання сміття та алгоритм її аналізу можуть займати значний час.\n\nКроме изменения параметра[zend.enable\\_gc](info.configuration.md#ini.zend.enable-gc), механізм складання сміття можна запустити і зупинити, послідовно викликавши функції [gc\\_enable()](function.gc-enable.md) і [gc\\_disable()](function.gc-disable.md). Виклик цих функцій має той самий ефект, що й увімкнення/вимкнення механізму у налаштуваннях конфігурації. Крім того, можна запустити складання сміття, навіть якщо кореневий буфер ще не заповнений. Для цього ви можете викликати функцію [gc\\_collect\\_cycles()](function.gc-collect-cycles.md), яка також повертає кількість циклічних посилань, зібраних алгоритмом.\n\nПричиною включення та вимикання механізму складання, а також його ручного запуску може стати те, що деякі частини вашої програми можуть бути вимогливими до часу. У цих випадках, можливо, не захочеться стороннього втручання збирача сміття. Зрозуміло, вимикаючи збирач сміття в певних місцях програми, є ризик отримати витік пам'яті, тому що потенційно деякі корені можуть не поміститися в обмежений кореневий буфер. Доцільніше буде викликати функцію [gc\\_collect\\_cycles()](function.gc-collect-cycles.md) прямо перед викликом функції [gc\\_disable()](function.gc-disable.md) для звільнення пам'яті та вже записаних коренів у буфері. Це очистить буфер і дасть більше місця для зберігання коріння, доки механізм буде вимкнений.\n","title":"Збір циклічних посилань","contentType":2,"navigation":[{"features.gc.refcounting-basics.md":"« Основи підрахунку посилань"},{"features.gc.performance-considerations.md":"Питання продуктивності »"},{"index.md":"PHP Manual"},{"features.gc.md":"Складання сміття"}]}},"__N_SSG":true}