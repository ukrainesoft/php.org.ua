- [« Оператор присвоєння](language.operators.assignment.md)
- [Оператори порівняння »](language.operators.comparison.md)

- [PHP Manual](index.md)
- [Оператори](language.operators.md)
- Побітові оператори

## Побітові оператори

Побітові оператори дозволяють зчитувати та встановлювати конкретні біти
цілих чисел.

| приклад | Назва | Результат |
|----------------|-----------------|-------------- -------------------------------------------------- -------------------------------------------------- -------|
| **`$a & $b`** | І | Встановлюються тільки ті біти, які встановлені і в $a, і в $b. |
| **`$a | $b`** | Або | Встановлюються ті біти, які встановлені в $a або $b. |
| **`$a^$b`** | Виключне або | Встановлюються тільки ті біти, які встановлені або тільки в $a, або тільки в $b, але не в обох одночасно. |
| **`~ $a`** | Заперечення | Встановлюються ті біти, які не встановлені в $a, і навпаки. |
| **`$a << $b`** | Зсув ліворуч Усі біти змінної `$a` зсуваються на `$b` позицій вліво (кожна позиція має на увазі "множення на 2") |
| **`$a >> $b`** | Зсув праворуч | Усі біти змінної `$a` зсуваються на `$b` позицій вправо (кожна позиція має на увазі "розподіл на 2") |

**Побітові оператори**

Побітове зрушення в PHP - це арифметична операція. Біти, зрушені за
межі числа відкидаються. Зсув вліво доповнює число нулями праворуч,
зрушуючи в той же час знаковий біт числа вліво, що означає що знак
операнда не зберігається. Зсув праворуч зберігає копію зрушеного
знакового біта зліва, що означає, що знак операнда зберігається.

Використовуйте дужки для забезпечення необхідного [пріоритету
операторов](language.operators.precedence.md). Наприклад,
`$a & $b u003du003d true` спочатку перевіряє на рівність, а потім виконує
побітове та; тоді як `($a & $b) u003du003d true` спочатку виконує побітове
і, а потім виконує перевірку на рівність.

Якщо обидва операнди для `&`, `|` і `^` рядка, то операція буде
проводитися з кодами ASCII всіх символів рядка і в результаті поверне
рядок. У всіх інших випадках, обидва операнди будуть [перетворені до
цілому](language.types.integer.md#language.types.integer.casting) та
результатом буде ціле число.

Якщо операнд для рядка, то операція буде проводитися з кодами
ASCII всіх символів рядка і в результаті поверне рядок, в іншому випадку
як операнд, і результат, вважатимуться цілими.

Обидва операнди і результат виконання `<<` та `>>` завжди вважаються за
ціле.

``` literallayout
Опція налаштувань PHP error_reporting використовує побітові значення, забезпечуючи
реальну демонстрацію видалення значень бітів. Щоб показати всі помилки, крім
зауважень, інструкції у файлі php.ini пропонують використовувати:
E_ALL & ~E_NOTICE

````

``` literallayout
Починаємо зі значення E_ALL:
00000000000000000111011111111111
Потім беремо значення E_NOTICE...
00000000000000000000000001000
... та інвертуємо його за допомогою ~:
111111111111111111111111111110111
Нарешті, використовуємо побітове І (&), щоб встановити тільки ті біти,
які встановлені в одиницю в обох значеннях:
00000000000000000111011111110111

````

``` literallayout
Інший спосіб досягти цього - використовувати ВИКЛЮЧНЕ АБО (XOR, ^),
щоб отримати лише ті біти, які встановлені в одиницю
або тільки в одному, або тільки в іншому значенні:
E_ALL ^ E_NOTICE

````

``` literallayout
Опція error_reporting також може бути використана для демонстрації
установки бітів Показати тільки помилки та помилки, що обробляються, можна
наступним чином:
E_ERROR | E_RECOVERABLE_ERROR

````

``` literallayout
Тут ми поєднуємо E_ERROR
000000000000000000000000000001
і
000000000000000000000000000000
за допомогою оператора АБО (|),
щоб отримати біти, встановлені хоча б в одному операнді:
0000000000000000001000000000001

````

**Приклад #1 Побітові операції І, АБО і ВИКЛЮЧНЕ АБО (AND, OR і XOR)
над цілими числами**

` <?php/* * Не звертайте уваги на це верхній розділ коду, * це просто форматування для більш ясного висновку. */$formatu003du003d''(%1$2du003du003d%1$04b)u003du003d(%2$2du003du003d%2$04b)'         . ' %3$s (%4$2d u003d %4$04b)' . "
";echo <<<EOH ----------   ----------- -- ---------- результат      значення      оп тест ------ ----  ----------- -- ----------EOH;/* * От самі приклади. */$values u003d array(0, 1, 2, 4 , 8);$test u003d 1 + 4;echo "
Побітове І (AND)
";foreach ($values as $value) {   $result u003d $value & $test;    printf($format, $result, $value, '&', $test);}echo 
Побітове (включає) АБО (OR)
";foreach ($values as $value) {   $result u003d $value | $test;    printf($format, $result, $value, '|', $test);}echo 
Побітове ВИКЛЮЧАЄ АБО (XOR)
";foreach ($values as $value) {   $result u003d $value ^ $test;    printf($format, $result, $value, '^', $test);}?> `

Результат виконання цього прикладу:

---------- ----------- -- ----------
результат значення оп тест
---------- ----------- -- ----------
Побітове І (AND)
(0 u003d 0000) u003d (0 u003d 0000) & (5 u003d 0101)
(1 u003d 0001) u003d (1 u003d 0001) & (5 u003d 0101)
(0 u003d 0000) u003d (2 u003d 0010) & (5 u003d 0101)
(4 u003d 0100) u003d (4 u003d 0100) & (5 u003d 0101)
(0 u003d 0000) u003d (8 u003d 1000) & (5 u003d 0101)

Побітове (включає) АБО (OR)
(5 u003d 0101) u003d (0 u003d 0000) | (5 u003d 0101)
(5 u003d 0101) u003d (1 u003d 0001) | (5 u003d 0101)
(7 u003d 0111) u003d (2 u003d 0010) | (5 u003d 0101)
(5 u003d 0101) u003d (4 u003d 0100) | (5 u003d 0101)
(13 u003d 1101) u003d (8 u003d 1000) | (5 u003d 0101)

Побітове ВИКЛЮЧНЕ АБО (XOR)
(5 u003d 0101) u003d (0 u003d 0000) ^ (5 u003d 0101)
(4 u003d 0100) u003d (1 u003d 0001) ^ (5 u003d 0101)
( 7 u003d 0111) u003d ( 2 u003d 0010) ^ ( 5 u003d 0101)
(1 u003d 0001) u003d (4 u003d 0100) ^ (5 u003d 0101)
(13 u003d 1101) u003d (8 u003d 1000) ^ (5 u003d 0101)

**Приклад #2 Побітова операція ВИКЛЮЧНЕ АБО (XOR) над рядками**

`<?phpecho 12 ^ 9; // Виводить '5'echo"12"^^"9"; // Виводить символ Backspace (ascii 8)                  // ('1' (ascii 49))| // Виводить ascii-значення #0 #4 #0 #0 #0               /             // Виводить 1               // 2 ^ ((int)"3") u003du003d 1echo "2" ^ 3; // Виводить 1               //((int)"2") ^ 3 u003du003d 1?> `

**Приклад #3 Побітовий зсув над цілими числами**

`<?php/* * Кілька прикладів. */echo "
--- СДВИГ ВПРАВО НАД ПІДСТАВНИМИ Цілими ЧИСЛАМИ ---
$val u003d 4;$places u003d 1;$res u003d $val >> $places;p($res, $val, '>>', $places, 'зліва вставлена копія знакового біта');$val u003d 4;$places u003d 2;$res u003d $val >> $places;p($res, $val, '>>', $places);$val u003d 4;$places u003d 3;$res u003d $val >> $places;p($res, $val, '>>', $places, 'бити висунуті за правий край');$val u003d 4;$places u003d 4;$res u003d $val >> $places ;p($res, $val, '>>', $places, 'те ж, і і вище; не можна зрушити далі 0');echo ""
--- СДВИГ ВПРАВО НАД ЗАГАДНИМИ ЦИЛИМИ ЧИСЛАМИ ---
$val u003d -4;$places u003d 1;$res u003d $val >> $places;p($res, $val, '>>', $places, 'зліва була вставлена копія знакового біта');$$ val u003d -4;$places u003d 2;$res u003d $val >> $places;p($res, $val, '>>', $places, 'бити були висунуті за правий край');$val u003d 4. "
--- СДВИГ ВЛІВО НАД ПІДСТАВНИМИ Цілими ЧИСЛАМИ ---
$val u003d 4;$places u003d 1;$res u003d $val << $places;p($res, $val, '<<', $places, 'правий край був доповнений нулями');$val u003d 4;$places u003d (PHP_INT_SIZE * 8) - 4;$res u003d $val << $places;p($res, $val, '<<', $places);$val u003d 4;$places u003d (PHP_INT * 8) - 3;$res u003d $val << $places;p($res, $val, '<<', $places, 'знакові біти були висунуті');$val u003d 4;$places u003d (PHP_INT * 8) - 2;$res u003d $val << $places;p($res, $val, '<<', $places, 'біти були висунуті за лівий край');echo ""
--- СДВИГ ВЛІВО НАД НЕГАТИВНИМИ Цілими ЧИСЛАМИ ---
$val u003d -4;$places u003d 1;$res u003d $val << $places;p($res, $val, '<<', $places, 'правий край був доповнений нулями');$val u003d -4;$places u003d (PHP_INT_SIZE * 8) - 3;$res u003d $val << $places;p($res, $val, '<<', $places);$val u003d -4;$places u003d (PHP_INT_SIZE * 8) - 2;$res u003d $val << $places;p($res, $val, '<<', $places, 'бити були висунуті за лівий край, в  | * * Не звертайте уваги на цей нижній розділ кода, * це просто форматування для ясного виводу. */function p($res, $val, $op,          ' . (PHP_INT_SIZE * 8) . "b
";    printf("Вираз: %d u003d %d %s %d
", $res, $val, $op, $places);   echo " Десятичний вигляд:
";   printf(" valu003d%d
", $val);   printf("resu003d%d
", $res);    echo " Двійковий вигляд:
";   printf('  valu003d' . $format, $val);    printf('  resu003d' . $format, $res);    if ($note) Я|                
";    }    echo "
";}?> `

Результат виконання цього прикладу на 32-бітних машинах:


--- Сдвиг вправо над позитивними цілими числами ---
Вираз: 2 u003d 4 >> 1
Десятковий вигляд:
valu003d4
resu003d2
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000000010
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: 1 u003d 4 >> 2
Десятковий вигляд:
valu003d4
resu003d1
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000000001

Вираз: 0 u003d 4 >> 3
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000000000
ПРИМІТКА: біти були висунуті за правий край

Вираз: 0 u003d 4 >> 4
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000000000
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі


--- ЗРУХ ВПРАВО НА ЗАГАЛЬНИХ ЦІЛІХ ЧИСЛАХ ---
Вираз: -2 u003d -4 >> 1
Десятковий вигляд:
valu003d-4
resu003d-2
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d111111111111111111111111111111110
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: -1 u003d -4 >> 2
Десятковий вигляд:
valu003d-4
resu003d-1
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d111111111111111111111111111111111
ПРИМІТКА: біти були висунуті за правий край

Вираз: -1 u003d -4 >> 3
Десятковий вигляд:
valu003d-4
resu003d-1
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d111111111111111111111111111111111
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі -1


--- Сдвиг вліво над позитивними цілими числами ---
Вираз: 8 u003d 4 << 1
Десятковий вигляд:
valu003d4
resu003d8
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000001000
ПРИМІТКА: правий край був доповнений нулями

Вираз: 1073741824 u003d 4 << 28
Десятковий вигляд:
valu003d4
resu003d1073741824
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d010000000000000000000000000000

Вираз: -2147483648 u003d 4 << 29
Десятковий вигляд:
valu003d4
resu003d-2147483648
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d100000000000000000000000000000
ПРИМІТКА: знакові біти були висунуті

Вираз: 0 u003d 4 << 30
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d000000000000000000000000000100
resu003d000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край


--- Сдвиг вліво над негативними цілими числами ---
Вираз: -8 u003d -4 << 1
Десятковий вигляд:
valu003d-4
resu003d-8
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d111111111111111111111111111111000
ПРИМІТКА: правий край був доповнений нулями

Вираз: -2147483648 u003d -4 << 29
Десятковий вигляд:
valu003d-4
resu003d-2147483648
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d100000000000000000000000000000

Вираз: 0 u003d -4 << 30
Десятковий вигляд:
valu003d-4
resu003d0
Двійковий вигляд:
valu003d111111111111111111111111111111100
resu003d000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край, включаючи знаковий біт

Результат виконання цього прикладу на 64-бітних машинах:


--- Сдвиг вправо над позитивними цілими числами ---
Вираз: 2 u003d 4 >> 1
Десятковий вигляд:
valu003d4
resu003d2
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d00000000000000000000000000000000000000000000000000000000
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: 1 u003d 4 >> 2
Десятковий вигляд:
valu003d4
resu003d1
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d0000000000000000000000000000000000000000000000000000000000

Вираз: 0 u003d 4 >> 3
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за правий край

Вираз: 0 u003d 4 >> 4
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d000000000000000000000000000000000000000000000000000000000
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі


--- Сдвиг вправо над негативними цілими числами ---
Вираз: -2 u003d -4 >> 1
Десятковий вигляд:
valu003d-4
resu003d-2
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d11111111111111111111111111111111111111111111111111111111111111110
ПРИМІТКА: зліва була вставлена копія знакового біта

Вираз: -1 u003d -4 >> 2
Десятковий вигляд:
valu003d-4
resu003d-1
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d11111111111111111111111111111111111111111111111111111111111111111
ПРИМІТКА: біти були висунуті за правий край

Вираз: -1 u003d -4 >> 3
Десятковий вигляд:
valu003d-4
resu003d-1
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d11111111111111111111111111111111111111111111111111111111111111111
ЗАУВАЖЕННЯ: те саме, що й вище; не можна зрушити далі -1


--- Сдвиг вліво над позитивними цілими числами ---
Вираз: 8 u003d 4 << 1
Десятковий вигляд:
valu003d4
resu003d8
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d00000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: правий край був доповнений нулями

Вираз: 4611686018427387904 u003d 4 << 60
Десятковий вигляд:
valu003d4
resu003d4611686018427387904
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d010000000000000000000000000000000000000000000000000000000

Вираз: -9223372036854775808 u003d 4 << 61
Десятковий вигляд:
valu003d4
resu003d-9223372036854775808
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d100000000000000000000000000000000000000000000000000000000
ПРИМІТКА: знакові біти були висунуті

Вираз: 0 u003d 4 << 62
Десятковий вигляд:
valu003d4
resu003d0
Двійковий вигляд:
valu003d00000000000000000000000000000000000000000000000000000000000000000000
resu003d000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край


--- Сдвиг вліво над негативними цілими числами ---
Вираз: -8 u003d -4 << 1
Десятковий вигляд:
valu003d-4
resu003d-8
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d11111111111111111111111111111111111111111111111111111111111111000
ПРИМІТКА: правий край був доповнений нулями

Вираз: -9223372036854775808 u003d -4 << 61
Десятковий вигляд:
valu003d-4
resu003d-9223372036854775808
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d100000000000000000000000000000000000000000000000000000000

Вираз: 0 u003d -4 << 62
Десятковий вигляд:
valu003d-4
resu003d0
Двійковий вигляд:
valu003d11111111111111111111111111111111111111111111111111111111111111100
resu003d000000000000000000000000000000000000000000000000000000000
ПРИМІТКА: біти були висунуті за лівий край, включаючи знаковий біт

**Увага**

Використовуйте функції з модуля [gmp](book.gmp.md) для побітових
операцій над числами, більшими за `PHP_INT_MAX`.

### Дивіться також

- [pack()](function.pack.md)
- [unpack()](function.unpack.md)
- [gmp_and()](function.gmp-and.md)
- [gmp_or()](function.gmp-or.md)
- [gmp_xor()](function.gmp-xor.md)
- [gmp_testbit()](function.gmp-testbit.md)
- [gmp_clrbit()](function.gmp-clrbit.md)
