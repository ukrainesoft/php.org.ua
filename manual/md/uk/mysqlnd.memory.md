- [«Примітки](mysqlnd.notes.md)
- [API для плагінів до вбудованого драйвера MySQL
»](mysqlnd.plugin.md)

- [PHP Manual](index.md)
- [Mysqlnd](book.mysqlnd.md)
- Управління пам'яттю

# Управління пам'яттю

*Вступ*

Вбудований драйвер MySQL (mysqlnd) управляє пам'яттю по-іншому,
На відміну від клієнтської бібліотеки MySQL (libmysql). Бібліотеки
розрізняються способом виділення та звільнення пам'яті, тим, як пам'ять
виділяється на шматки під час читання результатів з MySQL, існуючими
опціями для налагодження та розробки, і тим, як результати, лічені з
MySQL, пов'язані з змінами користувача PHP.

Наступна інформація призначена як запровадження та узагальнення для
користувачів, зацікавлених у розумінні `mysqlnd` на рівні C-коду.

*Використовувані функції управління пам'яттю*

Всі операції виділення та звільнення пам'яті відбуваються використовуючи
PHP-функції, призначені для керування пам'яттю. Тому,
споживання пам'яті вбудованого драйвера MySQL може бути відстежено за
за допомогою викликів PHP API, таких як
[memory_get_usage()](function.memory-get-usage.md). Через те що
пам'ять виділяється та звільняється за допомогою системи управління пам'яттю
PHP, зміни на рівні операційної системи можуть бути видні не
миттєво. Система управління пам'яттю PHP поводиться як проксі, яка
може викликати затримку у звільненні пам'яті. Зважаючи на це, порівняння
використання пам'яті вбудованого драйвера MySQL та клієнтської бібліотеки
MySQL (libmysql) досить складно. Клієнтська бібліотека MySQL (libmysql)
використовує систему управління пам'яттю операційної системи безпосередньо,
отже, ефект на рівні операційної системи може бути видно
негайно.

Будь-яке обмеження пам'яті, встановлене в PHP, також впливає на
вбудований драйвер MySQL. Це може спричинити помилки переповнення пам'яті.
при вилученні великих масивів даних, які перевищують розмір
решта пам'яті, наданих РНР. Через те, що клієнтська
бібліотека MySQL не використовує функції управління пам'яті PHP, вона не
підпорядковується обмеження пам'яті, встановленому PHP. При використанні
libmysql, залежно від моделі розгортання, обсяг пам'яті,
займаний PHP-процесом, може зрости межі обмежень,
встановлених у PHP. В той же час, PHP-скрипти можуть обробляти
більший обсяг масивів даних, оскільки області пам'яті, виділені для
зберігання даних, що не знаходяться під управлінням РНР.

Функції системи керування пам'яттю PHP викликаються вбудованим драйвером
MySQL через легковагу обгортку. Серед іншого, обгортка робить налагодження
легше.

*Обробка масивів отриманих даних*

Різні MySQL-сервера та різні клієнтські API розрізняють
[буферизовані та
небуферизовані](mysqli.quickstart.statements.md) результати.
Небуферизовані результати передаються рядок за рядком від MySQL до
клієнту та клієнт читає їх по порядку. Буферизовані результати
забираються клієнтської бібліотекою до передачі їх клієнту.

Вбудований драйвер MySQL використовує PHP-потоки для мережного спілкування з
сервером MySQL. Результати, надіслані MySQL-сервером, вибираються з
мережевих буферів PHP-потоків у результуючий буфер mysqlnd.
Результативний буфер складається з zvals. На другому етапі результати
стають доступними до PHP-скрипту. Остання передача із результуючого
буфера в PHP-змінні викликає споживання пам'яті та в більшості
випадків воно помітне під час використання буферизованих результатів.

За замовчуванням вбудований драйвер MySQL намагається уникнути подвійного
зберігання буферного результату у пам'яті. Результати зберігаються лише один
разів у внутрішніх результуючих буферах та їх зvals. Коли результати
забираються в РНР-змінні PHP-скриптом, змінні будуть посилатися на
внутрішні результати буферів Результати запитів до баз даних
копіюються та зберігаються в пам'яті лише один раз. Досить користувачеві
змінити вміст змінної, що містить результати роботи бази
даних, як буде виконано механізм копіювання під час запису
(Copy-On-Write), щоб уникнути зміни посилаючого
внутрішнього буфера результату. Вміст буфера не повинен бути
змінено, тому що користувач може ухвалити рішення прочитати результат
вдруге. Механізм копіювання під час запису реалізується за допомогою
додаткового управління списком посилань та використання стандартних
zval лічильників посилань. Копіювання під час запису також має бути зроблено,
якщо користувач читає дані результату в PHP змінних та
звільняє дані результату, перш ніж змінні будуть знищені.

Загалом цей шаблон працює добре для скриптів, які читають набори
даних один раз і не змінюють змінних, що містять результати. Його
головний недолік у накладних витратах пам'яті, спричинених додатковим
управлінням посиланнями, причина якого насамперед пов'язана з тим,
що користувацькі змінні, що утримують результати, не можуть бути
повністю звільнені до того, як система керування посиланнями mysqlnd
містить посилання на них. Вбудований драйвер MySQL видаляє посилання на
користувацькі змінні коли масив отриманих даних звільняється
або виконується механізм копіювання під час запису. Спостерігач побачить зростання
загального споживання пам'яті поки що масив отриманих даних не звільниться.
Використовуйте [статистику](mysqlnd.stats.md), щоб перевірити, чи скрипт
явно справив звільнення даних результату або драйвер зробив це
неявно і тому пам'ять використовується протягом більш тривалого часу,
чим це потрібно. Статистика також допомагає побачити кількість
операцій копіювання під час запису.

PHP-скрипт, що читає безліч невеликих рядків у буферизованому
масив даних, що використовує код, подібний
`while ($row u003d $res->fetch_assoc()) { ... }`, може оптимізувати
споживання пам'яті, запросивши копії замість посилань. Хоча і запит копій
означає збереження тих же результатів у пам'яті двічі, це дозволяє PHP
знищити копію, що містить в `$row` як ітерований масив.
даних та перед знищенням результат встановлює сам себе. На
завантаженому сервері оптимізація використання пам'яті може допомогти
покращити загальну продуктивність системи, хоча для окремого скрипту
підхід з копією замість посилань може бути повільнішим у зв'язку з
додатковим виділенням пам'яті та додатковими операціями
копіювання у пам'яті.

Режим копіювання може бути примусово включений, встановивши
[mysqlnd.fetch_data_copy](mysqlnd.config.md#ini.mysqlnd.fetch_data_copy)u003d1.

*Контроль та налагодження*

Існує кілька методів відстеження використання пам'яті
вбудований драйвер MySQL "mysqlnd". Якщо ціль - отримати швидкий
високорівневий огляд або перевірити ефективність PHP-скриптів при
роботи з пам'яттю, то перевірте [статистику](mysqlnd.stats.md),
зібрану бібліотекою. Статистика дозволить вам, наприклад, упіймати
SQL-запит, який генерує більше результатів, ніж обробляються
PHP-скрипт.

[Журнал налагодження](mysqlnd.config.md#ini.mysqlnd.debug) може бути
налаштований для запису викликів системи керування пам'яттю. Це
допомагає побачити коли пам'ять виділяється та звільняється. Проте, розмір
запитаних шматків пам'яті може бути у списку.

У деяких останніх версіях вбудованого драйвера MySQL "mysqlnd"
є можливість емуляції випадкових ситуацій нестачі пам'яті.
Ця можливість була задумана для використання лише C-розробниками
бібліотеки чи авторами [плагіна](mysqlnd.plugin.md) mysqlnd.
Будь ласка, використовуйте пошук за вихідним кодом для відповідної
налаштування PHP та для подальшої інформації. Це можливість є
недокументованою та може бути змінена у будь-який час без
додаткового повідомлення.
