{"pageProps":{"page":{"slug":"mysqli.quickstart.prepared-statements.md","content":"## Підготовлювані запити\n\nСУБД MySQL підтримує запити, що готуються. Підготовлювані (або параметризовані) запити використовуються для підвищення ефективності, коли один запит виконується багаторазово та захищає від ін'єкцій SQL.\n\n**Принцип роботи**\n\nВиконання запиту, що готується, проводиться в два етапи: підготовка та виконання. На етапі підготовки на сервер надсилається шаблон запиту. Сервер виконує синтаксичну перевірку цього шаблону, будує план виконання запиту та виділяє під нього ресурси.\n\nMySQL сервер підтримує неіменовані, або позиційні, псевдозмінні `?`\n\nЗа підготовкою слідує виконання. Під час виконання клієнт пов'язує значення параметрів та відправляє їх на сервер. Сервер виконує запит із зв'язаними значеннями, використовуючи раніше створені внутрішні ресурси.\n\n**Приклад #1 Підготовлений запит**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n\n/* Подготовленный запрос, шаг 1: подготовка */\n$stmt = $mysqli->prepare(\"INSERT INTO test(id, label) VALUES (?, ?)\");\n\n/* Подготовленный запрос, шаг 2: связывание и выполнение */\n$id = 1;\n$label = 'PHP';\n$stmt->bind_param(\"is\", $id, $label); // \"is\" означает, что $id связывается, как целое число, а $label — как строка\n\n$stmt->execute();\n```\n\n**Повторне виконання запиту**\n\nПідготовлений запит можна запускати багаторазово. Перед кожним запуском значення прив'язаних змінних передаватимуться на сервер і підставлятимуться в текст запиту. Сам текст запиту повторно не аналізується, так само як і не надсилається повторно шаблон.\n\n**Приклад #2 Вираз INSERT один раз готується, а потім багаторазово виконується**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n\n/* Подготовленный запрос, шаг 1: подготовка */\n$stmt = $mysqli->prepare(\"INSERT INTO test(id, label) VALUES (?, ?)\");\n\n/* Подготовленный запрос, шаг 2: связывание и выполнение */\n$stmt->bind_param(\"is\", $id, $label); // \"is\" означает, что $id связывается, как целое число, а $label — как строка\n\n$data = [\n    1 => 'PHP',\n    2 => 'Java',\n    3 => 'C++'\n];\nforeach ($data as $id => $label) {\n    $stmt->execute();\n}\n\n$result = $mysqli->query('SELECT id, label FROM test');\nvar_dump($result->fetch_all(MYSQLI_ASSOC));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(3) {\n  [0]=>\n  array(2) {\n    [\"id\"]=>\n    string(1) \"1\"\n    [\"label\"]=>\n    string(3) \"PHP\"\n  }\n  [1]=>\n  array(2) {\n    [\"id\"]=>\n    string(1) \"2\"\n    [\"label\"]=>\n    string(4) \"Java\"\n  }\n  [2]=>\n  array(2) {\n    [\"id\"]=>\n    string(1) \"3\"\n    [\"label\"]=>\n    string(3) \"C++\"\n  }\n}\n```\n\nКожен запит, що готується, використовує ресурси сервера. Якщо запит більше не потрібний, його необхідно одразу закрити. Якщо не зробити цього явно, запит закриється сам, але тільки коли PHP звільнить його дескриптор, як правило, це відбувається при виході запиту з області видимості або при завершенні роботи скрипта.\n\nВикористання запитів, що готуються, не завжди призводить до підвищення ефективності. Якщо параметризований запит запускається лише раз, це призводить до більшої кількості клієнт-серверних обмінів даними, ніж під час простого запиту. Саме з цієї причини у прикладі вище вираз `SELECT` виконувалося як звичайний запит.\n\nТакож є сенс розглянути SQL-синтаксис вставки безлічі значень у виразі INSERT. У прикладі вище мультивставка (значення для вставки перераховуються через кому) у пропозиції INSERT обійшлася б дешевше, ніж підготовлений запит.\n\n**Приклад #3 Менше обміну даними під час використання мультивставок SQL**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT)\");\n\n$values = [1, 2, 3, 4];\n\n$stmt = $mysqli->prepare(\"INSERT INTO test(id) VALUES (?), (?), (?), (?)\");\n$stmt->bind_param('iiii', ...$values);\n$stmt->execute();\n```\n\n**Типи даних значень у результуючій таблиці**\n\nУ протоколі клієнт-серверної взаємодії MySQL для звичайних запитів, що готуються, визначені різні протоколи передачі даних клієнту. Параметризовані запити використовують так званий бінарний протокол. Сервер MySQL надсилає результуючий набір клієнту «як є» у двійковому форматі. Дані в таблиці не перетворюються на текст. Клієнтські бібліотеки отримують двійкові дані та намагаються перетворити значення у відповідні типи даних PHP. Наприклад, стовпець результатів запиту SQL `INT` PHP прийме і перетворює на тип integer.\n\n**Приклад #4 Вихідні типи даних**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'PHP')\");\n\n$stmt = $mysqli->prepare(\"SELECT id, label FROM test WHERE id = 1\");\n$stmt->execute();\n$result = $stmt->get_result();\n$row = $result->fetch_assoc();\n\nprintf(\"id = %s (%s)\\n\", $row['id'], gettype($row['id']));\nprintf(\"label = %s (%s)\\n\", $row['label'], gettype($row['label']));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid = 1 (integer)\nlabel = PHP (string)\n```\n\nТака поведінка не є характерною для звичайних запитів, які за умовчанням усі результати повертають у вигляді текстових рядків. Цю поведінку за умовчанням можна змінити, настроївши з'єднання відповідним чином. Після такого настроювання різниці між даними підготовлюваного та звичайного запитів вже не буде.\n\n**Отримання результатів запиту з прив'язкою змінних**\n\nРезультати з підготовленого запиту можна отримати або прив'язавши вихідні змінні або запросивши об'єкт [mysqli\\_result](class.mysqli-result.md)\n\nВихідні параметри слід прив'язувати після виконання запиту. Кожному стовпцю результуючої таблиці має відповідати рівно одна змінна.\n\n**Приклад #5 Прив'язка змінних до результату запиту**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'PHP')\");\n\n$stmt = $mysqli->prepare(\"SELECT id, label FROM test WHERE id = 1\");\n$stmt->execute();\n\n$stmt->bind_result($out_id, $out_label);\n\nwhile ($stmt->fetch()) {\n    printf(\"id = %s (%s), label = %s (%s)\\n\", $out_id, gettype($out_id), $out_label, gettype($out_label));\n}\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nid = 1 (integer), label = PHP (string)\n```\n\nОб'єкти запитів за замовчуванням повертають небуферизовані результуючі набори. Ці таблиці ніяким чином не переносяться на клієнта, вони залишаються на сервері, займаючи його ресурси, поки клієнтський процес самостійно не витягне всі дані. Якщо клієнт не може отримати дані результуючого набору, або після закриття об'єкта запиту залишаються невибраними якісь дані, то на `mysqli` лягає відповідальність неявно підчистити це сміття за клієнтським процесом.\n\nТакож можна буферизувати дані результуючих таблиць підготовленого запиту за допомогою функції [mysqli\\_stmt::store\\_result()](mysqli-stmt.store-result.md)\n\n**Вилучення результатів запиту за допомогою mysqli\\_result інтерфейсу**\n\nЗамість використання прив'язки змінних до результатів запиту, результуючі таблиці можна отримувати засобами інтерфейсу mysqli\\_result. Функция[mysqli\\_stmt::get\\_result()](mysqli-stmt.get-result.md) повертає буферизований результуючий набір рядків.\n\n**Приклад #6 Використання mysqli\\_result для вибірки результатів запиту**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'PHP')\");\n\n$stmt = $mysqli->prepare(\"SELECT id, label FROM test WHERE id = 1\");\n$stmt->execute();\n\n$result = $stmt->get_result();\n\nvar_dump($result->fetch_all(MYSQLI_ASSOC));\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(1) {\n  [0]=>\n  array(2) {\n    [\"id\"]=>\n    int(1)\n    [\"label\"]=>\n    string(3) \"PHP\"\n  }\n}\n```\n\nИспользование интерфейса[mysqli\\_result](class.mysqli-result.md) має додаткову перевагу в тому, що буферизація результуючих таблиць на клієнті пропонує гнучку систему навігації по цих таблицях.\n\n**Приклад #7 Буферизація результуючого набору для зручності читання даних**\n\n```php\n<?php\n\nmysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\n$mysqli = new mysqli(\"example.com\", \"user\", \"password\", \"database\");\n\n/* Неподготовленный запрос */\n$mysqli->query(\"DROP TABLE IF EXISTS test\");\n$mysqli->query(\"CREATE TABLE test(id INT, label TEXT)\");\n$mysqli->query(\"INSERT INTO test(id, label) VALUES (1, 'PHP'), (2, 'Java'), (3, 'C++')\");\n\n$stmt = $mysqli->prepare(\"SELECT id, label FROM test\");\n$stmt->execute();\n\n$result = $stmt->get_result();\n\nfor ($row_no = $result->num_rows - 1; $row_no >= 0; $row_no--) {\n    $result->data_seek($row_no);\n    var_dump($result->fetch_assoc());\n}\n```\n\nРезультат виконання наведеного прикладу:\n\n```\narray(2) {\n  [\"id\"]=>\n  int(3)\n  [\"label\"]=>\n  string(3) \"C++\"\n}\narray(2) {\n  [\"id\"]=>\n  int(2)\n  [\"label\"]=>\n  string(4) \"Java\"\n}\narray(2) {\n  [\"id\"]=>\n  int(1)\n  [\"label\"]=>\n  string(3) \"PHP\"\n}\n```\n\n**Екранування та SQL-ін'єкції**\n\nПрив'язані змінні відправляються на сервер окремо від запиту і таким чином не можуть на нього впливати. Сервер використовує ці значення безпосередньо в момент виконання вже після того, як був оброблений шаблон виразу. Прив'язані параметри не потребують екранування, тому що вони ніколи не підставляються безпосередньо в рядок запиту. Необхідно відправляти тип прив'язаної змінної на сервер, щоб визначити відповідне перетворення. Дивіться функцію [mysqli\\_stmt::bind\\_param()](mysqli-stmt.bind-param.md) для більшої інформації.\n\nТакий поділ часто вважається єдиним способом убезпечитися від SQL-ін'єкції, але насправді такого ж рівня безпеки можна досягти і з непідготовленими виразами, якщо правильно відформатувати всі значення. Важливо, що правильне форматування — не те саме, що і екранування, і включає більше логіки. Таким чином, підготовлені вирази - просто більш зручний і менш схильний до помилок спосіб для досягнення такої безпеки бази даних.\n\n**Емуляція підготовленого запиту на клієнта**\n\nУ API немає можливості емулювати підготовлювані запити на клієнта.\n\n**Дивіться також**\n\n-   [mysqli::\\_\\_construct()](mysqli.construct.md)\n-   [mysqli::query()](mysqli.query.md)\n-   [mysqli::prepare()](mysqli.prepare.md)\n-   [mysqli\\_stmt::prepare()](mysqli-stmt.prepare.md)\n-   [mysqli\\_stmt::execute()](mysqli-stmt.execute.md)\n-   [mysqli\\_stmt::bind\\_param()](mysqli-stmt.bind-param.md)\n-   [mysqli\\_stmt::bind\\_result()](mysqli-stmt.bind-result.md)\n","title":"Підготовлювані запити","contentType":2,"navigation":[{"mysqli.quickstart.statements.md":"« Виконання запитів"},{"mysqli.quickstart.stored-procedures.md":"Збережені процедури »"},{"index.md":"PHP Manual"},{"mysqli.quickstart.md":"Короткий посібник"}]}},"__N_SSG":true}