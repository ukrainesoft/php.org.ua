{"pageProps":{"page":{"slug":"pdo.sqlitecreateaggregate.md","content":"# PDO::sqliteCreateAggregate\n\n(PHP 5 >= 5.1.0, PHP 7, PHP 8, PECL pdo\\_sqlite >= 1.0.0)\n\nPDO::sqlite Create Aggregate — Реєстрація агрегуючої функції користувача для використання в SQL-запитах\n\n### Опис\n\n```methodsynopsis\npublic PDO::sqliteCreateAggregate(    string $function_name,    callable $step_func,    callable $finalize_func,    int $num_args = ?): bool\n```\n\n**Увага**\n\nЦя функція є *ЕКСПЕРИМЕНТАЛЬНОЇ*. Поведінка цієї функції, її ім'я та документація, що до неї належить, можуть змінитися в наступних версіях PHP без повідомлення. Використовуйте цю функцію на свій страх та ризик.\n\nЦей метод аналогічний [PDO::sqliteCreateFunction](pdo.sqlitecreatefunction.md), крім того, що він реєструє функцію, яку можна використовувати для обчислення агрегованого результату по всіх рядках у запиті.\n\nКлючова відмінність цього методу від [PDO::sqliteCreateFunction](pdo.sqlitecreatefunction.md) у тому, що для керування агрегуванням вимагає використання двох функцій.\n\n### Список параметрів\n\n`function_name`\n\nІм'я функції для використання у запитах.\n\n`step_func`\n\nФункція зворотного дзвінка для кожного рядка в результуючому наборі. Ваша PHP-функція повинна акумулювати результат та зберігати його у контексті агрегації.\n\nЦя функція має бути визначена так:\n\n```methodsynopsis\nstep(    mixed $context,    int $rownumber,    mixed $value,    mixed ...$values): mixed\n```\n\n`context`\n\nДля першого рядка має дорівнювати **`null`**; Для всіх наступних рядків його значення має дорівнювати значенням, повернутим на попередньому кроці; Ви повинні використовувати його, щоб зберегти стан агрегації.\n\n`rownumber`\n\nНомер поточного рядка.\n\n`value`\n\nПерший аргумент передано агрегатору.\n\n`values`\n\nПодальші аргументи.\n\nЗначення функції, що повертається, буде використано як параметр `context` при наступному запуску функції, або як значення, що передається фіналізуючої функції.\n\n`finalize_func`\n\nФункція зворотного дзвінка для обчислення підсумкового агрегованого значення. Вона буде викликана як тільки всі рядки результуючого набору будуть оброблені, їй буде переданий контекст, що агрегує, і вона поверне фінальне значення. Ця функція має повернути значення типу зрозумілого SQLite (тобто . [скалярний тип](language.types.intro.md)\n\nЦя функція має бути визначена так:\n\n```methodsynopsis\nfini(mixed $context, int $rowcount): mixed\n```\n\n`context`\n\nМістить значення, повернене останнім викликом агрегуючої функції step\\_func.\n\n`rowcount`\n\nКількість рядків, до яких застосовувалася функція, що агрегує.\n\nЗначення цієї функції, що повертається, буде використано як результат агрегації.\n\n`num_args`\n\nПідказка для парсера SQLite, якщо функція зворотного дзвінка отримує задану кількість аргументів.\n\n### Значення, що повертаються\n\nПовертає **`true`** у разі успішного виконання або \\*\\*`false`\\*\\*в случае возникновения ошибки.\n\n### Приклади\n\n**Приклад #1 Приклад агрегуючої функції max\\_length**\n\n```php\n<?php\n$data = array(\n   'one',\n   'two',\n   'three',\n   'four',\n   'five',\n   'six',\n   'seven',\n   'eight',\n   'nine',\n   'ten',\n   );\n$db = new PDO('sqlite::memory:');\n$db->exec(\"CREATE TABLE strings(a)\");\n$insert = $db->prepare('INSERT INTO strings VALUES (?)');\nforeach ($data as $str) {\n    $insert->execute(array($str));\n}\n$insert = null;\n\nfunction max_len_step($context, $rownumber, $string)\n{\n    if (strlen($string) > $context) {\n        $context = strlen($string);\n    }\n    return $context;\n}\n\nfunction max_len_finalize($context, $rowcount)\n{\n    return $context === null ? 0 : $context;\n}\n\n$db->sqliteCreateAggregate('max_len', 'max_len_step', 'max_len_finalize');\n\nvar_dump($db->query('SELECT max_len(a) from strings')->fetchAll());\n\n?>\n```\n\nУ цьому прикладі ми створили функцію, що агрегує, яка обчислює довжину найбільшого рядка в одному зі стовпців таблиці. Для кожного рядка викликається функція `max_len_step` і їй передається параметр `$context`. Цей параметр, як і будь-яка інша змінна PHP, може містити і масив, і об'єкт. У цьому прикладі вона використовується для зберігання максимальної довжини рядка; Якщо `$string` має довжину більшу, ніж міститься у контексті, ми оновлюємо контекст новим значенням.\n\nПісля обробки всіх рядків SQLite викличе функцію `max_len_finalize` для обчислення результату агрегації. У ній ми робимо обчислення, ґрунтуючись на даних з `$context`. У нашому простому прикладі ми просто повертаємо його значення, оскільки жодних додаткових обчислень не потрібно.\n\n**Підказка**\n\nВкрай не рекомендується зберігати в контексті копії значень для обробки їх у фінальній функції, оскільки це спричинить велику перевитрату пам'яті SQLite для обробки запиту. Просто уявіть, скільки пам'яті вам знадобиться, якщо вам потрібно агрегувати, наприклад, мільйон значень по 32 байти.\n\n**Підказка**\n\nВи можете використовувати [PDO::sqliteCreateFunction](pdo.sqlitecreatefunction.md) і [PDO::sqliteCreateAggregate](pdo.sqlitecreateaggregate.md) для перевизначення стандартних функцій SQLite, що агрегують.\n\n### Дивіться також\n\n-   [PDO::sqliteCreateFunction](pdo.sqlitecreatefunction.md)\n-   **sqlite\\_create\\_function()**\n-   **sqlite\\_create\\_aggregate()**\n","title":"PDO::sqliteCreateAggregate","contentType":2,"navigation":[{"ref.pdo-sqlite.connection.md":"« PDO\\_SQLITE DSN"},{"pdo.sqlitecreatecollation.md":"PDO::sqliteCreateCollation »"},{"index.md":"PHP Manual"},{"ref.pdo-sqlite.md":"SQLite (PDO)"}]}},"__N_SSG":true}