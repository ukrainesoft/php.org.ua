- [«Порівняння об'єктів](language.oop5.object-comparison.md)
- [Об'єкти та посилання »](language.oop5.references.md)

- [PHP Manual](index.md)
- [Класи та об'єкти](language.oop5.md)
- Пізнє статичне зв'язування

## Пізніше статичне зв'язування

PHP реалізує функцію, звану пізніше статичне зв'язування,
яка може бути використана для того, щоб отримати посилання на
викликаний клас у тих статичного успадкування.

Якщо точніше говорити, пізніше статичне зв'язування зберігає ім'я
класу вказаного в останньому "неперенаправленому виклику". В разі
статичних викликів це явно вказаний клас (зазвичай ліворуч від оператора
[`::`](language.oop5.paamayim-nekudotayim.md)); у разі не
Статичний виклик це клас об'єкта. "Переспрямований виклик" - це
статичний виклик, що починається з `self::`, `parent::`, `static::`, або,
якщо рухатися вгору по ієрархії класів,
[forward_static_call()](function.forward-static-call.md). Функція
[get_called_class()](function.get-called-class.md) може бути
використана для отримання рядка з ім'ям викликаного класу, а
`static::` представляє її сферу дії.

Сама назва "пізнє статичне зв'язування" відображає в собі
внутрішню реалізацію цієї особливості. "Пізнє зв'язування" відображає
той факт, що звернення через 'static::' не будуть обчислюватися
відношенню до класу, в якому викликаний метод визначено, а будуть
обчислюватися з урахуванням інформації під час виконання. Також ця
особливість була названа "статичне зв'язування" тому, що вона може
бути використана (але не обов'язково) у статичних методах.

### Обмеження `self::`

Статичні посилання на поточний клас, такі як `self::` або `__CLASS__`,
обчислюються використовуючи клас, до якого ця функція належить, як і в
тому місці, де вона була визначена:

**Приклад #1 Використання `self::`**

`<?phpclass A {    public static function who() {        echo __CLASS__; }    public static function test() {        self::who(); }}class B extends A {    public static function who() {        echo __CLASS__; }}B::test();?> `

Результат виконання цього прикладу:

A

### Використання пізнього статичного зв'язування

Пізніше статичне зв'язування намагається усунути це обмеження,
надаючи ключове слово, яке посилається на клас, викликаний
безпосередньо під час виконання. Просто кажучи, ключове слово,
яке дозволить вам посилатися на `B` з `test()` у попередньому прикладі.
Вирішили не вводити нове ключове слово, а використовувати `static`,
яке вже зарезервоване.

**Приклад #2 Просте використання `static::`**

`<?phpclass A {    public static function who() {        echo __CLASS__; }    public static function test() {        static::who(); // Тут| }}B::test();?> `

Результат виконання цього прикладу:

B

> **Примітка**:
>
> У нестатичному контексті викликаним класом буде той, до якого
> відноситься екземпляр об'єкта. Оскільки `$this->` намагатиметься
> викликати закриті методи з тієї ж області дії, використання
> `static::` може дати різні результати. Інша відмінність у тому, що
> `static::` може посилатися лише на статичні поля класу.

**Приклад #3 Використання `static::` у нестатичному контексті**

` <?phpclass A {   private function foo() {        echo "success!"
";    }    public function test() {        $this->foo();        static::foo();    }}class B extends A {   /* foo() будет скопирован в В, следовательно его область действия по прежнему А,      и вызов будет успешным */}class C extends A {    private function foo() {        /* исходный метод заменён; область действия нового метода - С */    }}$b u003d new B();$b->test();$ c u003d new C();$c->test();  // потерпить помилку?> `

Результат виконання цього прикладу:

success!
success!
success!


Fatal error: Call до private method C::foo() from context 'A' in /tmp/test.php on line 9

> **Примітка**:
>
> Роздільна область пізнього статичного зв'язування буде фіксована
> що обчислює її статичним викликом. З іншого боку, статичні
> виклики з використанням таких директив як `parent::` або `self::`
> перенаправляють інформацію дзвінка.
>
> **Приклад #4 Перенаправлені та неперенаправлені дзвінки**
>
> ` <?phpclass A {    public static function foo() {       static::who(); }    public static function who() {        echo __CLASS__."
";    }}class B extends A {    public static function test() {        A::foo();        parent::foo();        self::foo();    }    public static function who() {        echo __CLASS__."
";    }}class C extends B {    public static function who() {        echo __CLASS__."
";    }}C::test();?> `
>
> Результат виконання цього прикладу:
>
> A
> C
> C
