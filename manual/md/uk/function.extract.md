- [«end](function.end.md)
- [in_array »](function.in-array.md)

- [PHP Manual](index.md)
- [Функції для роботи з масивами](ref.array.md)
- Імпортує змінні з масиву до поточної таблиці символів

# extract

(PHP 4, PHP 5, PHP 7, PHP 8)

extract — Імпортує змінні з масиву до поточної таблиці символів

### Опис

**extract**(array `&$array`, int `$flags` u003d **`EXTR_OVERWRITE`**, string
`$prefix` u003d ""): int

Імпортує змінні з масиву до поточної таблиці символів.

Кожен ключ перевіряється щодо коректного імені змінної. Також
перевіряються збіги з існуючими змінними символьної таблиці.

**Увага**

Не використовуйте **extract()** на неперевірені дані, такі як
введення користувача (наприклад, `$_GET`, `$_FILES`).

### Список параметрів

`array`
Асоціативний масив. Ця функція розглядає ключі масиву як
імен змінних, які значення - як значень цих змінних.
Для кожної пари ключ/значення буде створено змінну у поточній таблиці
символів, відповідно до параметрів `flags` та `prefix`.

Ви повинні використовувати асоціативний масив, використання числових
масивів не призведе до жодних результатів, якщо ви не використовуєте
**`EXTR_PREFIX_ALL`** або **`EXTR_PREFIX_INVALID`**.

`flags`
Параметр `flags` визначає спосіб трактування неправильних/числових
ключів та колізій. Він може приймати такі значення:

**`EXTR_OVERWRITE`**
Якщо змінна з такою назвою існує, вона буде перезаписана.

**`EXTR_SKIP`**
Якщо змінна з таким ім'ям існує, то її поточне значення не буде
перезаписано.

**`EXTR_PREFIX_SAME`**
Якщо змінна з таким ім'ям існує, до її імені буде додано
префікс, визначений параметром prefix.

**`EXTR_PREFIX_ALL`**
Додати префікс `prefix` до всіх змінних імен.

**`EXTR_PREFIX_INVALID`**
Додати префікс `prefix` тільки до некоректних/числових імен
змінних.

**`EXTR_IF_EXISTS`**
Перезаписати тільки змінні, які вже є в поточній таблиці
символів, інакше не робити нічого. Ця можливість
корисна визначення списку прийнятних змінних й у вилучення
тільки тих змінних, які ви вже визначили з масивів типу
`$_REQUEST`, наприклад.

**`EXTR_PREFIX_IF_EXISTS`**
Створити лише префікс-версії змінних, якщо версія цієї змінної
без префікса вже існує у поточній символьній таблиці.

**`EXTR_REFS`**
Витягти змінні як посилання. Це означає, що значення таких
змінних все ще посилатимуться на значення масиву `array`. Ви
можете використати цей прапор окремо або комбінувати його з іншими
значеннями `flags` за допомогою побітового 'або'.

Якщо `flags` не вказано, він трактується як **`EXTR_OVERWRITE`**.

`prefix`
Зверніть увагу, що `prefix` має значення, тільки якщо `flags`
встановлений у **`EXTR_PREFIX_SAME`**, **`EXTR_PREFIX_ALL`**,
**`EXTR_PREFIX_INVALID`** або **`EXTR_PREFIX_IF_EXISTS`**. Якщо в
в результаті додавання префікса, не буде отримано допустиме ім'я для
змінною вона не буде імпортована в поточну символьну таблицю.

### Значення, що повертаються

Повертає кількість змінних, успішно імпортованих до поточної
таблиці символів.

### Приклади

**Приклад #1 Приклад використання **extract()****

Функцію **extract()** також можна використовувати для імпорту до поточної
таблицю символів змінних, що містяться в асоціативному масиві,
повертається функцією
[wddx_deserialize()](function.wddx-deserialize.md).

` <?php/* Предположим, что $var_array - это массив, полученный в результате   wddx_deserialize */$size u003d "large";$var_array u003d array("color" u003d> "blue",                   "size"  u003d> "medium" ,                       "shape" u003d> "sphere");
";?> `

Результат виконання цього прикладу:

blue, large, sphere, medium

Змінна `$size` не була перезаписана, тому що ми визначили
**`EXTR_PREFIX_SAME`**, внаслідок чого було створено змінну
`$wddx_size`. Якщо було б визначено прапор **`EXTR_SKIP`**, тоді
змінна `$wddx_size` не була створена. **`EXTR_OVERWRITE`** була б
причиною того, що змінною `$size` було б надано значення
"medium", і **`EXTR_PREFIX_ALL`** була б причиною того, що були б
також створені нові змінні `$wddx_color`, `$wddx_size` та
`$wddx_shape`.

### Примітки

**Увага**

Не використовуйте функцію **extract()** на неперевірених даних, таких як
введення користувача (`$_GET`, `$_FILES` і т.п.). Якщо ви зробите це,
переконайтеся, що використовуєте один із прапорів `flags`, які не перезаписують
змінні, такий як **`EXTR_SKIP`** та майте на увазі, що ви повинні
вилучати їх у тому порядку, який визначений у директиві
[variables_order](ini.core.md#ini.variables-order) усередині
[`php.ini`](ini.md).

### Дивіться також

- [compact()](function.compact.md) - Створює масив, що містить
назви змінних та їх значення
- [list()](function.list.md) - Надає змінним зі списку
значення подібно до масиву
