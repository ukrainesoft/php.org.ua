{"pageProps":{"page":{"slug":"function.setcookie.md","content":"# setcookie\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nsetcookie — Надсилає cookie\n\n### Опис\n\n```methodsynopsis\nsetcookie(    string $name,    string $value = \"\",    int $expires_or_options = 0,    string $path = \"\",    string $domain = \"\",    bool $secure = false,    bool $httponly = false): bool\n```\n\nАльтернативна сигнатура доступна з PHP 7.3.0 (іменовані параметри не підтримуються):\n\n```methodsynopsis\nsetcookie(string $name, string $value = \"\", array $options = []): bool\n```\n\nФункция**setcookie()** задає значення cookie, яке буде надіслано клієнту разом з іншими заголовками HTTP. Як і інші заголовки файл cookie повинен передаватися *до* того, як буде виведено будь-які інші дані скрипту (це обмеження протоколу). Для цього потрібно викликати функцію до іншого висновку, включаючи виведення тегів `<html>`и`<head>`, а також порожні рядки та символи пробілів.\n\nПосле установки cookie к нему можно будет получить доступ через суперглобальную переменную[$\\_COOKIE](reserved.variables.cookies.md) при наступному завантаженні сторінки. Значення cookie також може містити суперглобальна змінна [$\\_REQUEST](reserved.variables.request.md)\n\n### Список параметрів\n\nСтандарт[» RFC 6265](http://www.faqs.org/rfcs/rfc6265) дає конкретні вказівки у тому, як потрібно інтерпретувати кожен із параметрів **setcookie()**\n\n`name`\n\nНазву cookie.\n\n`value`\n\nЗначення cookie. Це значення буде збережено на клієнтському комп'ютері; не записуйте секретні дані в cookie. Значення, присвоєне cookie з ім'ям `name`, допустим,`'cookiename'`, будет доступно через[$\\_COOKIE\\['cookiename'\\]](reserved.variables.cookies.md)\n\n`expires_or_options`\n\nЧас закінчення терміну дії cookie. Це позначка часу Unix, тобто кількість секунд від початку епохи. Один із способів встановлення значення – додати кількість секунд до закінчення терміну дії cookie до результату виклику функції [time()](function.time.md). Наприклад, вираз `time() + 60 * 60 * 24 * 30` встановить термін дії cookie, який закінчиться за 30 днів. Інший варіант – викликати функцію [mktime()](function.mktime.md). Якщо поставити або пропустити аргумент, термін дії cookie закінчиться із закінченням сесії (при закритті браузера).\n\n> **Зауваження** :\n> \n> Можна помітити, що параметр `expires_or_options`принимает в качестве значения метку времени Unix, а хранит его в формате`Wdy, DD-Mon-YYYY HH:MM:SS GMT`, причина цього те, що PHP робить це перетворення автоматично.\n\n`path`\n\nШлях на сервері, яким будуть доступні значення cookie. Якщо поставити `«/»`, cookie будуть доступні у всьому домені `domain`. Якщо поставити `«/foo/»`, cookie будуть доступні тільки з директорії `/foo/` та її піддиректорій (наприклад, `/foo/bar/`) домена`domain`. Значення за промовчанням - поточна директорія, в якій PHP встановлює cookie.\n\n`domain`\n\nДомен або піддомен, якому доступні cookie. Завдання піддомену (наприклад, `«www.example.com»`) зробить cookie доступними в ньому та у всіх піддоменах (наприклад, w2.[www.example.com](http://www.example.com)). Щоб зробити cookie доступними для всього домену, включаючи піддомени, потрібно просто вказати ім'я домену (тобто `«example.com»`\n\nСтарі браузери, що йдуть застарілому стандарту [» RFC 2109](http://www.faqs.org/rfcs/rfc2109), можуть вимагати перед доменом, щоб умикалися всі піддомени.\n\n`secure`\n\nВказує на те, що значення cookie має передаватися від клієнта із захищеного з'єднання HTTPS. Якщо поставлено **`true`**, cookie від клієнта буде передано на сервер, лише якщо встановлено захищене з'єднання. При передачі cookie від сервера клієнту програміст веб-сервера повинен стежити за тим, щоб cookie цього типу передавалися по захищеному каналу (наприклад, з урахуванням суперглобальної змінної) [$\\_SERVER\\[\"HTTPS\"\\]](reserved.variables.server.md)\n\n`httponly`\n\nЯкщо поставлено **`true`**, cookie будуть доступні лише через протокол HTTP. Тобто cookie не будуть доступні скриптовим мовам на кшталт JavaScript. Було висловлено припущення, що цей параметр може ефективно зменшити крадіжку особистих даних через XSS-атаку (хоча він підтримується не всіма браузерами), але це твердження часто оспорюється. Може приймати значення **`true`** або **`false`**\n\n`options`\n\nАсоціативний масив (array), який може містити будь-який із ключів: `expires` `path` `domain` `secure` `httponly`и`samesite`. Якщо в масиві виявиться інший ключ, буде видано помилку рівня **`E_WARNING`**. Значення мають той самий сенс, який описаний для параметрів з тим самим ім'ям. Значення елемента `samesite` повинно бути або `None`, либо`Lax`или`Strict`. Якщо якась із дозволених опцій не вказана, її значення за умовчанням збігаються зі значеннями за промовчанням явних параметрів. Якщо елемент `samesite`не указан, функция не установит cookie-атрибут SameSite.\n\n> **Зауваження** :\n> \n> To set a cookie that includes attributes that aren't among the keys listed, use [header()](function.header.md)\n\n### Значення, що повертаються\n\nЯкщо перед викликом функції клієнту вже передавався будь-який висновок (теги, порожні рядки, пробіли, текст тощо), **setcookie()** зазнає невдачі і поверне **`false`**. Якщо **setcookie()** успішно відпрацює, то поверне **`true`**. Це, однак, не означає, що клієнтська програма (браузер) правильно прийняла та обробила cookie.\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 8.2.0 | Формат дати надісланих cookie тепер `«D, d M Y H:i:s \\G\\M\\T»`; раніше він був `«D, d-M-Y H:i:s T»` |\n| 7.3.0 | Додано альтернативний підпис, що підтримує масив опцій `options`. . Цей підпис також підтримує налаштування cookie-атрибута SameSite. |\n\n### Приклади\n\nНаступні приклади ілюструють низку способів відправлення cookies.\n\n**Приклад #1 Приклад використання** setcookie()\\*\\*\\*\\*\n\n```php\n<?php\n\n$value = 'что-то откуда-то';\n\nsetcookie(\"TestCookie\", $value);\nsetcookie(\"TestCookie\", $value, time()+3600);  /* срок действия 1 час */\nsetcookie(\"TestCookie\", $value, time()+3600, \"/~rasmus/\", \"example.com\", 1);\n\n?>\n```\n\nВарто зазначити, що значення cookie перед надсиланням клієнту піддається URL-коду. При зворотному отриманні значення cookie декодується і поміщається в змінну, з тим самим ім'ям, що ім'я cookie. Якщо ви не бажаєте, щоб значення кодувалися, використовуйте функцію [setrawcookie()](function.setrawcookie.md). Подивитися вміст наших тестових cookie можна, запустивши один із таких прикладів:\n\n```php\n<?php\n// Вывести одно конкретное значение cookie\necho $_COOKIE[\"TestCookie\"];\n\n// В целях тестирования и отладки может пригодиться вывод всех cookie\nprint_r($_COOKIE);\n?>\n```\n\n**Приклад #2 Приклад удаления cookie посредством**setcookie()\\*\\*\\*\\*\n\nЩоб видалити cookie, достатньо як термін дії вказати якийсь час у минулому. Це запустить механізм браузера, що видаляє cookie, що минув. У нижченаведених прикладах показано, як видалити cookie, задані в попередніх прикладах:\n\n```php\n<?php\n// установка даты истечения срока действия на час назад\nsetcookie(\"TestCookie\", \"\", time() - 3600);\nsetcookie(\"TestCookie\", \"\", time() - 3600, \"/~rasmus/\", \"example.com\", 1);\n?>\n```\n\n**Приклад #3**setcookie()\\*\\* та масиви\\*\\*\n\nЄ можливість розміщувати в cookie масиви. Для цього кожному cookie потрібно дати ім'я відповідно до правил іменування масивів. Така можливість дозволяє помістити стільки значень, скільки є елементів у масиві. При зворотному отриманні всі ці значення будуть поміщені в масив з ім'ям цього cookie:\n\n```php\n<?php\n// отправка cookie\nsetcookie(\"cookie[three]\", \"cookiethree\");\nsetcookie(\"cookie[two]\", \"cookietwo\");\nsetcookie(\"cookie[one]\", \"cookieone\");\n\n// после перезагрузки страницы, выведем cookie\nif (isset($_COOKIE['cookie'])) {\n    foreach ($_COOKIE['cookie'] as $name => $value) {\n        $name = htmlspecialchars($name);\n        $value = htmlspecialchars($value);\n        echo \"$name : $value <br />\\n\";\n    }\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nthree : cookiethree\ntwo : cookietwo\none : cookieone\n```\n\n> **Зауваження**: Вказівка ​​символів-розділювачів на кшталт `[`и`]` у складі імені cookie не відповідає 4-му розділу стандарту RFC 6265, але має підтримуватися агентами користувача, як зазначено у розділі 5 стандарту RFC 6265.\n\n### Примітки\n\n> **Зауваження** :\n> \n> Дозволено буферизувати висновок для надсилання виводу до виклику цієї функції, при цьому виведення в браузер буферизується на сервері доти, доки не буде відправлений. Це роблять викликом у скрипті функцій [ob\\_start()](function.ob-start.md) і [ob\\_end\\_flush()](function.ob-end-flush.md), або включають директиву конфігурації `output_buffering` у файлі php.ini або файлах конфігурації сервера.\n\nЗагальні зауваження:\n\n-   Cookie стануть видимими лише після перезавантаження сторінки, для якої вони мають бути помітні. Для перевірки, чи правильно встановлені cookie, їх перевіряють при наступному завантаженні сторінки до закінчення терміну дії. Термін дії cookie задають у параметрі`expires_or_options`. Хороший спосіб налагодити наявність файлів cookie - просто викликати функцію`print_r($_COOKIE);`\n-   При видаленні cookie повинні бути задані самі параметри, що і при установці. Якщо в якості значення встановити пустий рядок, а інші параметри відповідають попередньому виклику функції setcookie, то cookie з заданим ім'ям буде видалено на віддаленому клієнті. Внутрішньо це виглядає так: cookie буде надано значення`«deleted»`, а термін дії переноситься на рік у минуле.\n-   Оскільки встановлення значення\\*\\*`false`**призведе до видалення cookie, не потрібно задавати cookie логічні значення. Натомість можна вказати для**`false`**и для**`true`\\*\\*\n-   Імена cookie дозволено встановлювати масивом імен, які будуть доступні в PHP-скрипті як масиви, але в системі користувача вони зберігатимуться у вигляді окремих записів. Для завдання cookie з кількома іменами та значеннями рекомендовано викликати функцію[explode()](function.explode.md). Не рекомендовано користуватися для цього функцією[serialize()](function.serialize.md)оскільки це порушує безпеку.\n\nЧисленні виклики функції **setcookie()** виконуються у порядку дзвінка.\n\n### Дивіться також\n\n-   [header()](function.header.md) \\- Надсилає необроблений (сирий) HTTP-заголовок\n-   [setrawcookie()](function.setrawcookie.md) \\- Надсилає cookie без URL-кодування значення\n-   [розділ cookies](features.cookies.md)\n-   [» RFC 6265](http://www.faqs.org/rfcs/rfc6265)\n-   [» RFC 2109](http://www.faqs.org/rfcs/rfc2109)\n","title":"setcookie","contentType":2,"navigation":[{"function.pfsockopen.md":"« pfsockopen"},{"function.setrawcookie.md":"setrawcookie »"},{"index.md":"PHP Manual"},{"ref.network.md":"Мережеві функції"}]}},"__N_SSG":true}