{"pageProps":{"page":{"slug":"language.references.whatdo.md","content":"## Що роблять посилання\n\nЄ три основні операції з використанням посилань: [присвоєння за посиланням](language.references.whatdo.md#language.references.whatdo.assign) [передача за посиланням](language.references.whatdo.md#language.references.whatdo.pass) і [повернення за посиланням](language.references.whatdo.md#language.references.whatdo.return). Цей розділ познайомить вас із цими операціями та надасть посилання для подальшого вивчення.\n\n### Присвоєння за посиланням\n\nПерша з них - посилання PHP дозволяють створити дві змінні, що вказують на те саме значення. Таким чином, коли виконується таке:\n\n```php\n<?php\n$a =& $b;\n?>\n```\n\nто $a вказує на те саме значення як і $b.\n\n> **Зауваження** :\n> \n> $a та $b тут абсолютно еквівалентні, але це не означає, що $a вказує на $b або навпаки. Це означає, що $a і $b вказують на те саме значення.\n\n> **Зауваження** :\n> \n> При присвоєнні, передачі чи поверненні неініціалізованої змінної за посиланням, відбувається її створення.\n> \n> **Приклад #1 Використання посилань з неініціалізованими змінними**\n> \n> ```php\n> <?php\n> function foo(&$var) { }\n> \n> foo($a); // $a створена і дорівнює null\n> \n> $ b = array ();\n> foo($b['b']);\n> var_dump(array_key_exists('b', $b)); // bool (true)\n> \n> $ c = New stdClass;\n> foo($c->d);\n> var_dump(property_exists($c, 'd')); // bool (true)\n> ?>\n> ```\n\nТакий самий синтаксис може використовуватися у функціях, що повертають посилання, та з оператором `new` :\n\n```php\n<?php\n$foo =& find_var($bar);\n?>\n```\n\nВикористання того ж синтаксису з функцією, яка *не* повертає за посиланням, призведе до помилки, як і її використання з результатом оператора [new](language.oop5.basic.md#language.oop5.basic.new). Хоча об'єкти передаються як покажчики, це не те саме, що посилання, як описано в розділі [Об'єкти та посилання](language.oop5.references.md)\n\n**Увага**\n\nЯкщо змінної, оголошеної всередині функції як `global`, буде присвоєно посилання, воно буде видно лише у функції. Щоб уникнути цього, використовуйте масив [$GLOBALS](reserved.variables.globals.md)\n\n**Приклад #2 Надання посилань глобальним змінним всередині функції**\n\n```php\n<?php\n$var1 = \"Приклад переменной\";\n$var2 = \"\";\n\nfunction global_references($use_globals)\n{\n    global $var1, $var2;\n    if (!$use_globals) {\n        $var2 =& $var1; // только локально\n    } else {\n        $GLOBALS[\"var2\"] =& $var1; // глобально\n    }\n}\n\nglobal_references(false);\necho \"значение var2: '$var2'\\n\"; // значение var2: ''\nglobal_references(true);\necho \"значение var2: '$var2'\\n\"; // значение var2: 'Приклад переменной'\n?>\n```\n\nДумайте о`global $var;` як про скорочення від `$var =& $GLOBALS['var'];`Таким образом, присвоение`$var` інший посилання впливає лише локальну змінну.\n\n> **Зауваження** :\n> \n> При використанні змінної-посилання в [foreach](control-structures.foreach.md), Змінюється зміст, на яке вона посилається.\n> \n> **Приклад #3 Посилання та foreach**\n> \n> ```php\n> <?php\n> $ ref = 0;\n> $row =& $ref;\n> foreach (array(1, 2, 3) as $row) {\n>     // зробити щось\n> }\n> echo $ ref; // 3 - останнє значення, що використовується в циклі\n> ?>\n> ```\n\nХоча у виразах, створюваних за допомогою конструкції [`array()`](function.array.md), немає явного присвоєння за посиланням, проте вони можуть поводитися як такі, якщо вказати префікс `&` для елементів масиву Приклад:\n\n```php\n<?php\n$a = 1;\n$b = array(2, 3);\n$arr = array(&$a, &$b[0], &$b[1]);\n$arr[0]++; $arr[1]++; $arr[2]++;\n/* $a == 2, $b == array(3, 4); */\n?>\n```\n\nПроте слід зазначити, що посилання в масивах потенційно небезпечні. При звичайному (не за посиланням) присвоєння масиву посилання всередині цього масиву зберігаються. Це також стосується і викликів функцій, коли масив передається за значенням. Приклад:\n\n```php\n<?php\n/* Присвоение скалярных переменных */\n$a = 1;\n$b =& $a;\n$c = $b;\n$c = 7; //$c не ссылка и не изменяет значений $a и $b\n\n/* Присвоение массивов */\n$arr = array(1);\n$a =& $arr[0]; // $a и $arr[0] ссылаются на одно значение\n$arr2 = $arr; // присвоение не по ссылке!\n$arr2[0]++;\n/* $a == 2, $arr == array(2) */\n/* Содержимое $arr изменилось, хотя было присвоено не по ссылке! */\n?>\n```\n\nІнакше кажучи, поведінка окремих елементів масиву залежить від типу присвоєння цього масиву.\n\n### Передача за посиланням\n\nДруге, що роблять посилання – передача параметрів за посиланням. При цьому локальна змінна в функції і змінна в області видимості, що викликає, посилаються на один і той же вміст. Приклад:\n\n```php\n<?php\nfunction foo(&$var) {\n    $var++;\n}\n\n$a = 5;\nfoo($a);\n?>\n```\n\nЦей код надасть $a значення 6. Це відбувається, тому що у функції foo змінна $var посилається на той же вміст, що й змінна $a. Дивіться також детальне пояснення [передачі за посиланням](language.references.pass.md)\n\n### Повернення за посиланням\n\nТретє, що можуть робити посилання – це [повернення за посиланням](language.references.return.md)\n","title":"Що роблять посилання","contentType":2,"navigation":[{"language.references.whatare.md":"« Що таке посилання"},{"language.references.arent.md":"Чим посилання не є »"},{"index.md":"PHP Manual"},{"language.references.md":"Пояснення посилань"}]}},"__N_SSG":true}