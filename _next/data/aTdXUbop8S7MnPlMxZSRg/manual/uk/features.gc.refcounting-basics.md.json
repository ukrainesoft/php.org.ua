{"pageProps":{"page":{"slug":"features.gc.refcounting-basics.md","content":"## Основи підрахунку посилань\n\nЗмінна PHP зберігається в контейнері, що називається zval. Контейнер zval, крім типу та значення змінної, також містить два додаткові біти інформації. Перший називається is\\_ref і представляє логічне значення, що вказує, включена змінна в \"набір посилань\" чи ні. За рахунок елемента is\\_ref PHP знає, як відрізняти звичайні змінні від посилань. Оскільки PHP дозволяє користувацькі посилання, які можна створити оператором &, контейнер zval також містить внутрішній механізм підрахунку посилань для оптимізації роботи пам'яті. Друга частина додаткової інформації називається refcount (лічильник посилань) і містить кількість імен змінних (або інша назва — символів), які вказують на цей контейнер zval. Усі імена змінних зберігаються у таблиці імен, окремої кожної області видимості змінних. Така область видимості існує для головного скрипта, кожної функції та методу.\n\nКонтейнер zval створюється при оголошенні нової змінної, якій надається константне значення, наприклад:\n\n**Приклад #1 Створення нового контейнера zval**\n\n```php\n<?php\n$a = \"new string\";\n?>\n```\n\nУ цьому прикладі створюється новий символ `a` у поточній області видимості та новий контейнер змінної з типом string та значенням `new string`Бит is\\_ref за замовчуванням задається рівним **`false`**, т. до. не створено жодного користувача посилання. Значення refcount задається рівним тільки одне ім'я змінної вказує на цей контейнер. Зверніть увагу, що посилання (тобто is\\_ref одно **`true`**) з refcount рівним обробляються так, якби вони не були посиланнями (тобто як is\\_ref було б **`false`**). Если установлен[» Xdebug](http://xdebug.org/), можете вивести цю інформацію, викликавши функцію **xdebug\\_debug\\_zval()**\n\n**Приклад #2 Виведення інформації про zval**\n\n```php\n<?php\n$a = \"new string\";\nxdebug_debug_zval('a');\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\na: (refcount=1, is_ref=0)='new string'\n```\n\nПрисвоєння цієї змінної інший збільшує лічильник посилань.\n\n**Приклад #3 Збільшення лічильника посилань zval**\n\n```php\n<?php\n$a = \"new string\";\n$b = $a;\nxdebug_debug_zval( 'a' );\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\na: (refcount=2, is_ref=0)='new string'\n```\n\nЛічильник посилань тут дорівнює , Так як a і b посилаються на один і той же контейнер змінної. PHP досить розумний, щоб не копіювати контейнер, поки в цьому немає потреби. Як тільки refcount стане рівним нулю, контейнер знищується. refcount зменшується на одиницю при відході змінної з області видимості (наприклад, наприкінці функції) або при видаленні цієї змінної (наприклад при виклику) [unset()](function.unset.md)\n\n**Приклад #4 Зменшення лічильника посилань zval**\n\n```php\n<?php\n$a = \"new string\";\n$c = $b = $a;\nxdebug_debug_zval( 'a' );\n$b = 42;\nxdebug_debug_zval( 'a' );\nunset( $c );\nxdebug_debug_zval( 'a' );\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\na: (refcount=3, is_ref=0)='new string'\na: (refcount=2, is_ref=0)='new string'\na: (refcount=1, is_ref=0)='new string'\n```\n\nЯкщо ми зараз викличемо `unset($a);`, то контейнер, включаючи тип і значення, буде видалено з пам'яті.\n\n### Складові типи даних\n\nВсе дещо ускладнюється зі складовими типами даних, наприклад з масивами (array) та об'єктами (object). На відміну від скалярних (scalar) значень, масиви та об'єкти зберігають властивості у своїх таблицях імен. Тобто наступний приклад створить відразу три zval-контейнери:\n\n**Приклад #5 Створення array zval**\n\n```php\n<?php\n$a = array( 'meaning' => 'life', 'number' => 42 );\nxdebug_debug_zval( 'a' );\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\na: (refcount=1, is_ref=0)=array (\n   'meaning' => (refcount=1, is_ref=0)='life',\n   'number' => (refcount=1, is_ref=0)=42\n)\n```\n\nГрафічно:\n\n![Контейнери для простого масиву](images/12f37b1c6963c1c5c18f30495416a197-simple-array.png)\n\nРезультат – три контейнери: a, meaning та number. Подібні правила застосовуються і для збільшення та зменшення refcounts. Нижче ми додаємо ще один елемент масиву та встановлюємо йому значення вже існуючого елемента:\n\n**Приклад #6 Додавання вже існуючого елемента масив**\n\n```php\n<?php\n$a = array( 'meaning' => 'life', 'number' => 42 );\n$a['life'] = $a['meaning'];\nxdebug_debug_zval( 'a' );\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\na: (refcount=1, is_ref=0)=array (\n   'meaning' => (refcount=2, is_ref=0)='life',\n   'number' => (refcount=1, is_ref=0)=42,\n   'life' => (refcount=2, is_ref=0)='life'\n)\n```\n\nГрафічно:\n\n![Контейнери для простого масиву з посиланнями](images/12f37b1c6963c1c5c18f30495416a197-simple-array2.png)\n\nЗ висновку Xdebug видно, що і старий і новий елементи масиву зараз вказують на контейнер, чий refcount дорівнює Хотя показано два контейнера со значением`'life'`але це один контейнер. Функція **xdebug\\_debug\\_zval()** не виводить інформацію про це, але ви можете перевірити це також відобразивши покажчики пам'яті.\n\nЕлемент видаляється з масиву аналогічно видаленню імені змінної з області видимості: зменшується refcount-контейнер, на який посилається елемент масиву. При досягненні нуля в біті refcount, контейнер видаляється з пам'яті. Приклад:\n\n**Приклад #7 Видалення елемента з масиву**\n\n```php\n<?php\n$a = array( 'meaning' => 'life', 'number' => 42 );\n$a['life'] = $a['meaning'];\nunset( $a['meaning'], $a['number'] );\nxdebug_debug_zval( 'a' );\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\na: (refcount=1, is_ref=0)=array (\n   'life' => (refcount=1, is_ref=0)='life'\n)\n```\n\nСитуація стане цікавішою, якщо додати масив новим елементом у самого себе. У наступному прикладі використано оператора присвоювання за посиланням, щоб PHP не створив копію масиву.\n\n**Приклад #8 Додавання масиву новим елементом до самого себе**\n\n```php\n<?php\n$a = array( 'one' );\n$a[] =& $a;\nxdebug_debug_zval( 'a' );\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\na: (refcount=2, is_ref=1)=array (\n   0 => (refcount=1, is_ref=0)='one',\n   1 => (refcount=2, is_ref=1)=...\n)\n```\n\nГрафічно:\n\n![Контейнери масиву з циклічними посиланнями](images/12f37b1c6963c1c5c18f30495416a197-loop-array.png)\n\nМожна побачити, що змінна з масивом (a), як і другий елемент (1) зараз вказують на контейнер з refcount рівним . Символи «...» у висновку означають рекурсію і, у разі, вказують на оригінальний масив.\n\nЯк і раніше, видалення змінної зменшує лічильник посилань контейнера на одиницю. Якщо застосувати конструкцію unset до змінної $a після цього прикладу, лічильник посилань контейнера, який вказують змінна $a і елемент 1, зміниться з 2 на 1:\n\n**Приклад #9 Видалення $a**\n\n```\n(refcount=1, is_ref=1)=array (\n   0 => (refcount=1, is_ref=0)='one',\n   1 => (refcount=1, is_ref=1)=...\n)\n```\n\nГрафічно:\n\n![Контейнери після видалення масиву з циклічними посиланнями демонструють витік пам'яті](images/12f37b1c6963c1c5c18f30495416a197-leak-array.png)\n\n### Суть проблеми\n\nХоча у всіх областях видимості більше немає імені змінної, що посилається на цю структуру, вона не може бути очищена, тому що елемент масиву з ключем 1, як і раніше, посилається на цей масив. Оскільки тепер немає ніякої можливості користувачеві видалити ці дані, станеться витік пам'яті. На щастя, PHP видалить ці дані після завершення запиту, але до цього моменту дані займатимуть цінне місце в пам'яті. Така ситуація часто буває, коли реалізуються алгоритми парсингу чи інші, де є дочірні елементи, що посилаються на батьківські. Ще частіше така ситуація трапляється з об'єктами, тому що вони завжди неявно використовуються на засланні.\n\nНе проблема, якщо таке трапляється раз чи два, але якщо є тисячі або навіть мільйони таких витоків пам'яті, то вони вже стануть проблемою. Особливо в довгопрацюючих скриптах, наприклад демонах, де запит не закінчується, або у великих наборах модульних тестів. Останній випадок викликав проблеми під час запуску модульних тестів для компонента Template із бібліотеки ez Components. Іноді може знадобитися більше 2 ГБ пам'яті, яка не завжди є на тестовому сервері.\n","title":"Основи підрахунку посилань","contentType":2,"navigation":[{"features.gc.md":"« Складання сміття"},{"features.gc.collecting-cycles.md":"Збір циклічних посилань »"},{"index.md":"PHP Manual"},{"features.gc.md":"Складання сміття"}]}},"__N_SSG":true}