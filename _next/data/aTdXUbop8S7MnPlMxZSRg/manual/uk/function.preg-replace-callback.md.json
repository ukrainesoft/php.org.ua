{"pageProps":{"page":{"slug":"function.preg-replace-callback.md","content":"# preg\\_replace\\_callback\n\n(PHP 4 >= 4.0.5, PHP 5, PHP 7, PHP 8)\n\npreg\\_replace\\_callback — Виконує пошук за регулярним виразом та заміною з використанням callback-функції\n\n### Опис\n\n```methodsynopsis\npreg_replace_callback(    string|array $pattern,    callable $callback,    string|array $subject,    int $limit = -1,    int &$count = null,    int $flags = 0): string|array|null\n```\n\nПоведінка цієї функції багато в чому нагадує [preg\\_replace()](function.preg-replace.md), за винятком того, що замість параметра `replacement` необхідно вказувати `callback`\\-функцію.\n\n### Список параметрів\n\n`pattern`\n\nШуканий шаблон. Можливо як рядком, і масивом рядків.\n\n`callback`\n\nCallback-функція, що викликається, якій буде переданий масив збіглих елементів з рядка `subject`. Callback-функція повинна повернути рядок із заміною. Callback-функція має бути описана так:\n\n```methodsynopsis\nhandler(array $matches): string\n```\n\nДостаточно часто`callback` функція, окрім як у виклику \\*\\*preg\\_replace\\_callback()\\*\\*ні в чому більше не бере участі. Виходячи з цих міркувань, можна використовувати [анонімні функції](functions.anonymous.md) для створення callback-функції безпосередньо у виклику **preg\\_replace\\_callback()**. Якщо ви використовуєте такий підхід, вся інформація, пов'язана із заміною за регулярним виразом, буде зібрана в одному місці, і простір імен функцій не буде захаращуватися записами, що не використовуються.\n\n**Приклад #1**preg\\_replace\\_callback()\\*\\* та анонімна функція\\*\\*\n\n```php\n<?php\n/* фильтр, подобный тому, что используется в системах Unix\n * для преобразования заглавных букв в начале параграфа в строчные */\n$fp = fopen(\"php://stdin\", \"r\") or die(\"не удалось прочесть stdin\");\nwhile (!feof($fp)) {\n    $line = fgets($fp);\n    $line = preg_replace_callback(\n        '|<p>\\s*\\w|',\n        function ($matches) {\n            return strtolower($matches[0]);\n        },\n        $line\n    );\n    echo $line;\n}\nfclose($fp);\n?>\n```\n\n`subject`\n\nРядок або масив рядків для пошуку та заміни.\n\n`limit`\n\nМаксимально можлива кількість замін для кожного шаблону в кожному рядку `subject`По умолчанию равно`-1` (без обмежень).\n\n`count`\n\nЯкщо зазначено, то ця змінна буде заповнена кількістю зроблених замін.\n\n`flags`\n\n`flags` може бути комбінацією прапорів \\*\\*`PREG_OFFSET_CAPTURE`** і **`PREG_UNMATCHED_AS_NULL`\\*\\*які впливають на формат масиву збігів. Дивіться опис у [preg\\_match()](function.preg-match.md) для більш детальної інформації.\n\n### Значення, що повертаються\n\n**preg\\_replace\\_callback()** повертає масив, якщо параметр `subject` є масивом, інакше повертається рядок. У разі помилок повертається **`null`**\n\nЯкщо знайдено збіги, буде повернуто результуючий рядок, інакше `subject` повернеться незміненим.\n\n### Помилки\n\nЯкщо переданий шаблон регулярного виразу не компілюється в допустимий регулярний вираз, видається помилка рівня **`E_WARNING`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.4.0 | Добавлен параметр`flags` |\n\n### Приклади\n\n**Приклад #2 Приклад використання** preg\\_replace\\_callback()\\*\\*\\*\\*\n\n```php\n<?php\n// Этот текст был использован в 2002 году\n// мы хотим обновить даты к 2003 году\n$text = \"День смеха был 01/04/2002\\n\";\n$text.= \"Последнее Рождество было 24/12/2001\\n\";\n// callback-функция\nfunction next_year($matches)\n{\n  // как обычно: $matches[0] -  полное вхождение шаблона\n  // $matches[1] - вхождение первой подмаски,\n  // заключённой в круглые скобки и так далее...\n  return $matches[1].($matches[2]+1);\n}\necho preg_replace_callback(\n            \"|(\\d{2}/\\d{2}/)(\\d{4})|\",\n            \"next_year\",\n            $text);\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nДень смеха был 01/04/2003\nПоследнее Рождество было 24/12/2002\n```\n\n**Приклад #3 Рекурсивна обробка BB-кодів за допомогою **preg\\_replace\\_callback()****\n\n```php\n<?php\n$input = \"верх [indent] глубже [indent] ещё глубже [/indent] глубже [/indent] верх\";\n\nfunction parseTagsRecursive($input)\n{\n\n    $regex = '#\\[indent]((?:[^[]|\\[(?!/?indent])|(?R))+)\\[/indent]#';\n\n    if (is_array($input)) {\n        $input = '<div style=\"margin-left: 10px\">'.$input[1].'</div>';\n    }\n\n    return preg_replace_callback($regex, 'parseTagsRecursive', $input);\n}\n\n$output = parseTagsRecursive($input);\n\necho $output;\n?>\n```\n\n### Дивіться також\n\n-   [Регулярні вирази PCRE](pcre.pattern.md)\n-   [preg\\_replace\\_callback\\_array()](function.preg-replace-callback-array.md) \\- Здійснює пошук та заміну за регулярним виразом з використанням функцій зворотного виклику\n-   [preg\\_quote()](function.preg-quote.md) \\- Екранує символи у регулярних виразах\n-   [preg\\_replace()](function.preg-replace.md) \\- Виконує пошук та заміну за регулярним виразом\n-   [preg\\_last\\_error()](function.preg-last-error.md) \\- Повертає код помилки виконання останнього регулярного вираження PCRE\n-   [Анонімні функції](functions.anonymous.md)\n","title":"preg\\_replace\\_callback","contentType":2,"navigation":[{"function.preg-replace-callback-array.md":"« preg\\_replace\\_callback\\_array"},{"function.preg-replace.md":"preg\\_replace »"},{"index.md":"PHP Manual"},{"ref.pcre.md":"Функції PCRE"}]}},"__N_SSG":true}