{"pageProps":{"page":{"slug":"control-structures.foreach.md","content":"## foreach\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\nМовна конструкція `foreach` пропонує найпростіший спосіб перебору масивів. Конструкція `foreach` працює тільки з масивами та об'єктами, і буде видавати помилку при спробі використовувати її зі змінними інших типів даних або неініціалізованими змінними. Розробнику доступні два види синтаксису:\n\n```\nforeach (iterable_expression as $value)\n    statement\nforeach (iterable_expression as $key => $value)\n    statement\n```\n\nПерша форма обходить доступні для перебору дані, задані виразом `iterable_expression`. На кожній ітерації значення поточного елемента надається змінною `$value`\n\nДруга форма додатково присвоюватиме ключ поточного елемента змінної `$key` на кожній ітерації.\n\nОбратите внимание, что конструкция`foreach` не змінює внутрішній покажчик масиву, з яким, наприклад, працюють функції [current()](function.current.md) і [key()](function.key.md)\n\nРазработчику доступна[налаштування ітерації об'єктів](language.oop5.iterations.md)\n\nЩоб безпосередньо змінювати елементи масиву всередині циклу, перед змінною `$value` вказують знак &. Тоді значення буде надано [за посиланням](language.references.md)\n\n```php\n<?php\n\n$arr = array(1, 2, 3, 4);\nforeach ($arr as &$value) {\n    $value = $value * 2;\n}\n// массив $arr теперь выглядит так: array(2, 4, 6, 8)\nunset($value); // разорвать ссылку на последний элемент\n?>\n```\n\n**Увага**\n\nПосилання змінної `$value` на останній елемент масиву залишиться навіть після закінчення циклу `foreach`. Рекомендовано знищувати її мовною конструкцією [unset()](function.unset.md). В іншому випадку розробник зіткнеться з такою поведінкою:\n\n```php\n<?php\n\n$arr = array(1, 2, 3, 4);\nforeach ($arr as &$value) {\n    $value = $value * 2;\n}\n// $arr = array(2, 4, 6, 8)\n\n// Без вызова конструкции unset($value), перменная $value всё ещё ссылается на последний элемент: $arr[3]\n\nforeach ($arr as $key => $value) {\n    // Значение элемента $arr[3] будет обновляться значениями массива $arr при каждой итерации цикла...\n    echo \"{$key} => {$value} \";\n    print_r($arr);\n}\n// ...до тех пор, пока предпоследнее значение не будет скопировано в последнее значение\n\n// вывод:\n// 0 => 2 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 2 )\n// 1 => 4 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 4 )\n// 2 => 6 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 6 )\n// 3 => 6 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 6 )\n?>\n```\n\nДозволено перебирати значення константного масиву за посиланням:\n\n```php\n<?php\n\nforeach (array(1, 2, 3, 4) as &$value) {\n    $value = $value * 2;\n}\n?>\n```\n\n> **Зауваження** :\n> \n> Мовна конструкція `foreach` не підтримує придушення повідомлень про помилки через оператора `@`\n\nЩе приклади, що показують роботу конструкції:\n\n```php\n<?php\n\n/* Приклад 1: только значение */\n\n$a = array(1, 2, 3, 17);\n\nforeach ($a as $v) {\n    echo \"Текущее значение переменной \\$a: $v.\\n\";\n}\n\n/* Приклад 2: значение (для иллюстрации массив выводится в виде значения с ключом) */\n\n$a = array(1, 2, 3, 17);\n\n$i = 0; /* только для пояснения */\n\nforeach ($a as $v) {\n    echo \"\\$a[$i] => $v.\\n\";\n    $i++;\n}\n\n/* Приклад 3: ключ и значение */\n\n$a = array(\n    \"one\" => 1,\n    \"two\" => 2,\n    \"three\" => 3,\n    \"seventeen\" => 17\n);\n\nforeach ($a as $k => $v) {\n    echo \"\\$a[$k] => $v.\\n\";\n}\n\n/* Приклад 4: многомерные массивы */\n$a = array();\n$a[0][0] = \"a\";\n$a[0][1] = \"b\";\n$a[1][0] = \"y\";\n$a[1][1] = \"z\";\n\nforeach ($a as $v1) {\n    foreach ($v1 as $v2) {\n        echo \"$v2\\n\";\n    }\n}\n\n/* Приклад 5: динамические массивы */\n\nforeach (array(1, 2, 3, 4, 5) as $v) {\n    echo \"$v\\n\";\n}\n?>\n```\n\n### Розпакування вкладених масивів мовною конструкцією list()\n\n(PHP 5 >= 5.5.0, PHP 7, PHP 8)\n\nДоступний перебір масиву масивів та розпакування вкладеного масиву в змінні циклу шляхом передачі конструкції [list()](function.list.md)в качестве значения.\n\nНаПриклад:\n\n```php\n<?php\n\n$array = [\n    [1, 2],\n    [3, 4],\n];\n\nforeach ($array as list($a, $b)) {\n    // Переменная $a содержит первый элемент вложенного массива,\n    // а переменная $b — второй.\n    echo \"A: $a; B: $b\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nA: 1; B: 2\nA: 3; B: 4\n```\n\nУ конструкцію [list()](function.list.md) дозволено передавати меншу кількість елементів, ніж міститься у вкладеному масиві, тоді значення масиву, що залишилися, будуть проігноровані:\n\n```php\n<?php\n\n$array = [\n    [1, 2],\n    [3, 4],\n];\n\nforeach ($array as list($a)) {\n    // Обратите внимание, переменной $b здесь нет.\n    echo \"$a\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n1\n3\n```\n\nЯкщо масив містить недостатньо елементів для заповнення змінних у конструкції [list()](function.list.md), то буде згенеровано повідомлення про помилку:\n\n```php\n<?php\n\n$array = [\n    [1, 2],\n    [3, 4],\n];\n\nforeach ($array as list($a, $b, $c)) {\n    echo \"A: $a; B: $b; C: $c\\n\";\n}\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nNotice: Undefined offset: 2 in example.php on line 7\nA: 1; B: 2; C:\n\nNotice: Undefined offset: 2 in example.php on line 7\nA: 3; B: 4; C:\n```\n","title":"foreach","contentType":2,"navigation":[{"control-structures.for.md":"« for"},{"control-structures.break.md":"break »"},{"index.md":"PHP Manual"},{"language.control-structures.md":"Керуючі конструкції"}]}},"__N_SSG":true}