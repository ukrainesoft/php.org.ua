{"pageProps":{"page":{"slug":"language.types.string.md","content":"## Рядки\n\nРядок (string) – це набір символів, у якому символ – це те саме, що й байт. Тобто PHP підтримує набір лише 256 символів і тому не пропонує вбудовану підтримку кодування Unicode. Докладніше про це розказано у розділі «[Детальна інформація про рядковий тип](language.types.string.md#language.types.string.details)».\n\n> **Зауваження**: У 32-бітових збірках розмір рядка (string) обмежений 2 ГБ (2 147 483 647 байт максимум).\n\n### Синтаксис\n\nРядковий літерал визначають чотирма способами:\n\n-   [одинарними лапками](language.types.string.md#language.types.string.syntax.single)\n-   [подвійними лапками](language.types.string.md#language.types.string.syntax.double)\n-   [heredoc-синтаксисом](language.types.string.md#language.types.string.syntax.heredoc)\n-   [nowdoc-синтаксисом](language.types.string.md#language.types.string.syntax.nowdoc)\n\n#### Одинарні лапки\n\nНайпростіший спосіб визначити рядок - це укласти його в одинарні лапки (символ `'`\n\nЩоб записати всередині рядка буквальну одинарну лапку, її екранують зворотним слішем (`\\`). Щоб записати сам зворотний сліш, його дублюють (`\\`). В інших випадках зворотний сліш буде оброблений як буквальний зворотний сліш: тобто послідовності на кшталт `\\r`или`\\n` не розглядатимуться як управляючі, а будуть виведені як записані.\n\n> **Зауваження** [Змінні](language.variables.md) і керуючі послідовності службових символів, укладені в одинарні лапки, - *не* обробляються, на відміну синтаксису [подвійних лапок](language.types.string.md#language.types.string.syntax.double) і [heredoc](language.types.string.md#language.types.string.syntax.heredoc)\n\n```php\n<?php\n\necho 'Это — простая строка';\n\necho 'В строки также разрешено вставлять\nсимвол новой строки, способом, которым записан этот текст, —\nтак делать нормально';\n\n// Выводит: Однажды Арнольд сказал: \"I'll be back\"\necho 'Однажды Арнольд сказал: \"I\\'ll be back\"';\n\n// Выводит: Вы удалили C:\\*.*?\necho 'Вы удалили C:\\\\*.*?';\n\n// Выводит: Вы удалили C:\\*.*?\necho 'Вы удалили C:\\*.*?';\n\n// Выводит: Это не будет развёрнуто: \\n в новую строку\necho 'Это не будет развёрнуто: \\n в новую строку';\n\n// Выводит: Переменные $expand и $either также не разворачиваются\necho 'Переменные $expand и $either также не разворачиваются';\n\n?>\n```\n\n#### Подвійні лапки\n\nЯкщо рядок укладено в подвійні лапки (\"), PHP розпізнає наступні керуючі послідовності службових символів:\n\n**Керуючі послідовності**\n\n| Последовательность | Значение |\n| --- | --- |\n| `\\n` | новий рядок (LF або 0x0A (10) в ASCII) |\n| `\\r` | повернення каретки (CR або 0x0D (13) до ASCII) |\n| `\\t` | горизонтальна табуляція (HT або 0x09 (9) ASCII) |\n| `\\v` | вертикальна табуляція (VT або 0x0B (11) ASCII) |\n| `\\e` | escape-знак (ESC або 0x1B (27) ASCII) |\n| `\\f` | подання сторінки (FF або 0x0C (12) до ASCII) |\n| `\\` | зворотна коса риса |\n| `\\$` | знак долара |\n| `\\\"` | подвійна лапка |\n| `\\[0-7]{1,3}` | Восьмеричний запис: символ, код якого записаний у вісімковій нотації (тобто. . `\"\\101\" === \"A\"`), тобто у вигляді послідовності символів, що відповідає регулярному виразу `[0-7]{1,3}`. . У ситуації цілого чисельного переповнення (якщо символ не поміститься в один байт), старші біти будуть без попередження відкинуті (тобто. . `\"\\400\" === \"\\000\"`) . |\n| `\\x[0-9A-Fa-f]{1,2}` | Шістнадцяткова система числення: символ, код якого записаний у шістнадцятковій нотації (тобто. . `\"\\x41\" === \"A\"`), тобто у вигляді послідовності символів, що відповідає регулярному виразу `[0-9A-Fa-f]{1,2}` |\n| `\\u{[0-9A-Fa-f]+}` | Стандарт Unicode: символ, код якого записаний у нотації кодових точок Unicode, тобто у вигляді послідовності символів, що відповідає регулярному виразу `[0-9A-Fa-f]+`, які будуть відображені як рядок кодування UTF-8. Послідовність необхідно укладати у фігурні дужки. Наприклад: `\"\\u{41}\" === \"A\"` |\n\nЯк і в рядках в одинарних лапках, екранування іншого символу виведе також символ зворотного сліша.\n\nНайбільш важлива властивість рядків у подвійних лапках полягає в тому, що імена змінних у них будуть розгорнуті та оброблені. Докладніше про це розказано у розділі «[Синтаксичний аналіз змінних](language.types.string.md#language.types.string.parsing)».\n\n#### Heredoc\n\nТретій спосіб визначення рядків – це heredoc-синтаксис: `<<<`. Після цього оператором вказують ідентифікатор, та був переклад рядка. Потім йде сам рядок, за яким знову йде той самий ідентифікатор, щоб закрити вставку.\n\nІдентифікатор, що закриває, дозволено відбивати пробілами або символами табуляції, і тоді відступ буде видалено з кожного рядка в блоці документа. До PHP 7.3.0 ідентифікатор, що закриває, вказували *на самому початку* нового рядка.\n\nКрім того, ідентифікатор, що закриває, підпорядковується тим же правилам іменування, що і інші мітки в PHP: містить тільки буквено-цифрові символи і підкреслення, і не починається з цифрового символу або символу підкреслення.\n\n**Приклад #1 Базовий приклад використання Heredoc-синтаксису у PHP 7.3.0**\n\n```php\n<?php\n\n// без отступов\necho <<<END\n      a\n     b\n    c\n\\n\nEND;\n\n// 4 отступа\necho <<<END\n      a\n     b\n    c\n    END;\n```\n\nРезультат виконання наведеного прикладу в PHP 7.3:\n\n```\na\n     b\n    c\n\n  a\n b\nc\n```\n\nЯкщо ідентифікатор, що закриває, зміщений далі хоча б одного рядка тіла, буде викинуто виняток [ParseError](class.parseerror.md) :\n\n**Приклад #2 Відступу ідентифікатора, що закриває, не можна відступати більше, ніж іншим рядкам тіла**\n\n```php\n<?php\n\necho <<<END\n  a\n b\nc\n   END;\n```\n\nРезультат виконання наведеного прикладу в PHP 7.3:\n\n```\nPHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4\n```\n\nЯкщо ідентифікатор, що закриває, відбитий відступом, то в тілі теж дозволено вказувати табуляції. Проте табуляціям та пробілам *не дозволено* змішуватися щодо відступу закриває ідентифікатора і тіла (аж до ідентифікатора, що закриває). У кожному з цих випадків буде викинуто виняток [ParseError](class.parseerror.md). Ці обмеження на пробільні відступи додали, тому що змішування табуляцій та пробілів для відступів шкідливе для розбору.\n\n**Приклад #3 Інший відступ для тіла, що закриває ідентифікатора (пробілів)**\n\n```php\n<?php\n\n// Весь следующий код не работает.\n\n// Другой отступ для закрывающего идентификатора (табуляций) тела (пробелов)\n{\n    echo <<<END\n     a\n        END;\n}\n\n// Смешивание пробелов и табуляции в теле\n{\n    echo <<<END\n        a\n     END;\n}\n\n// Смешивание пробелов и табуляции в закрывающем идентификаторе\n{\n    echo <<<END\n          a\n         END;\n}\n```\n\nРезультат виконання наведеного прикладу в PHP 7.3:\n\n```\nPHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8\n```\n\nЗа ідентифікатором основного рядка, що закриває, не обов'язково ставити крапку з комою або новий рядок. Наприклад, починаючи з PHP 7.3.0 дозволено наступний код:\n\n**Приклад #4 Продовження виразу після ідентифікатора, що закриває**\n\n```php\n<?php\n\n$values = [<<<END\na\n  b\n    c\nEND, 'd e f'];\nvar_dump($values);\n```\n\nРезультат виконання наведеного прикладу в PHP 7.3:\n\n```\narray(2) {\n  [0] =>\n  string(11) \"a\n  b\n    c\"\n  [1] =>\n  string(5) \"d e f\"\n}\n```\n\n**Увага**\n\nЯкщо ідентифікатор, що закриває, знайдено на початку рядка, навіть якщо це частина слова, парсер прийме його за закриваючий ідентифікатор і викине виняток [ParseError](class.parseerror.md)\n\n**Приклад #5 Ідентифікатор, що закриває, в тілі тексту провокує виключення ParseError**\n\n```php\n<?php\n\n$values = [<<<END\na\nb\nEND ING\nEND, 'd e f'];\n```\n\nРезультат виконання наведеного прикладу в PHP 7.3:\n\n```\nPHP Parse error:  syntax error, unexpected identifier \"ING\", expecting \"]\" in example.php on line 6\n```\n\nЩоб не виникало таких проблем, слідують нескладному, але надійному правилу: *не вибирати ідентифікатор, що закриває, який зустрічається в тілі тексту*\n\n**Увага**\n\nДо PHP 7.3.0 рядку з ідентифікатором, що закриває, не можна було містити символів, крім точки з комою ( ). Тобто ідентифікатор *заборонено вводити з відступом*, а пробіли або знаки табуляції не можна вводити до або після крапки з комою. Враховують також, що першим символом перед ідентифікатором, що закриває, йде символ нового рядка, який визначений в операційній системі. Наприклад, у Unix-системах, включаючи macOS, це символ `\\n`. Після ідентифікатора, що закриває, повинен відразу починатися новий рядок.\n\nЯкщо це правило порушено і ідентифікатор, що закриває, не «чистий», він не буде вважатися закриваючим, і PHP продовжить його пошук далі. Якщо правильний ідентифікатор, що закриває, так і не буде знайдений до кінця поточного файлу, то на останньому рядку виникне помилка синтаксичного аналізу.\n\n**Приклад #6 Приклад неправильного синтаксису до PHP 7.3.0**\n\n```php\n<?php\n\nclass foo {\n    public $bar = <<<EOT\nbar\n    EOT;\n// Отступ перед закрывающим идентификатором недопустим\n}\n\n?>\n```\n\n**Приклад #7 Приклад правильного синтаксису, навіть до PHP 7.3.0**\n\n```php\n<?php\nclass foo {\n    public $bar = <<<EOT\nbar\nEOT;\n}\n?>\n```\n\nУ цьомудокументі зі змінними не можна використовувати для ініціалізації властивостей класу.\n\nHeredoc-текст хоч і не укладений у подвійні лапки, поводиться як рядок у подвійних лапках. Тобто в ньому лапки не екранують, але перелічені керуючі коди, як і раніше, дозволено вказувати. Змінні розгортаються, але у висловлюваннях зі складними змінними всередині неї працюють так само уважно, як і при роботі з рядками.\n\n**Приклад #8 Приклад визначення heredoc-рядка**\n\n```php\n<?php\n\n$str = <<<EOD\nПриклад строки,\nохватывающей несколько строк,\nс использованием heredoc-синтаксиса.\nEOD;\n\n/* Более сложный Приклад с переменными. */\nclass foo\n{\n    var $foo;\n    var $bar;\n\n    function __construct()\n    {\n        $this->foo = 'Foo';\n        $this->bar = array('Bar1', 'Bar2', 'Bar3');\n    }\n}\n\n$foo = new foo();\n$name = 'Имярек';\n\necho <<<EOT\nМеня зовут \"$name\". Я печатаю $foo->foo.\nТеперь я вывожу {$foo->bar[1]}.\nЭто должно вывести заглавную букву 'A': \\x41\nEOT;\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nМеня зовут \"Имярек\". Я печатаю Foo.\nТеперь, я вывожу Bar2.\nЭто должно вывести заглавную букву 'A': A\n```\n\nHeredoc-синтаксис дозволено також для передачі даних через аргументи функції:\n\n**Приклад #9 Приклад heredoc-синтаксису з аргументами**\n\n```php\n<?php\n\nvar_dump(array(<<<EOD\nfoobar!\nEOD\n));\n?>\n```\n\nДозволено ініціалізувати статичні змінні та властивості або константи класу в heredoc-синтаксисі:\n\n**Приклад #10 Ініціалізація статичних змінних heredoc-синтаксисом**\n\n```php\n<?php\n\n// Статические переменные\nfunction foo()\n{\n    static $bar = <<<LABEL\nЗдесь ничего нет...\nLABEL;\n}\n\n// Константы/свойства класса\nclass foo\n{\n    const BAR = <<<FOOBAR\nПриклад использования константы\nFOOBAR;\n\n    public $baz = <<<FOOBAR\nПриклад использования поля\nFOOBAR;\n}\n?>\n```\n\nДозволено також оточувати йогоdoc-ідентифікатор подвійними лапками:\n\n**Приклад #11 Подвійні лапки в heredoc**\n\n```php\n<?php\n\necho <<<\"FOOBAR\"\nПривет, мир!\nFOOBAR;\n\n?>\n```\n\n#### Nowdoc\n\nNowdoc - це те ж для рядків у одинарних лапках, що й heredoc для рядків у подвійних лапках. Nowdoc схожий на heredoc, але всередині нього *не виконуються підстановки*. Конструкція легко вбудовує PHP-код або інші великі текстові блоки без попереднього екранування. У цьому він частково схожий на SGML-конструкцію `<![CDATA[ ]]>`в тому, що він оголошує блок тексту, який не вимагає обробки.\n\nNowdoc задають таку ж послідовність символів `<<<`, що і в heredoc, але наступний за нею ідентифікатор беруть в одинарні лапки, наприклад, `<<<'EOT'`. Умови, які поширюються на ідентифікатори heredoc-синтаксису, дійсні також і для синтаксису nowdoc, а більше інших ті, що відносяться до ідентифікатора, що закриває.\n\n**Приклад #12 Приклад nowdoc-синтаксису**\n\n```php\n<?php\n\necho <<<'EOD'\nПриклад текста,\nзанимающего несколько строк,\nнаписанного синтаксисом nowdoc. Обратные слеши выводятся без обработки,\nнаПриклад, \\\\ и \\'.\nEOD;\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nПриклад текста,\nзанимающего несколько строк,\nнаписанного синтаксисом nowdoc. Обратные слеши выводятся без обработки,\nнаПриклад, \\\\ и \\'.\n```\n\n**Приклад #13 Nowdoc зі змінними рядками з подвійними лапками**\n\n```php\n<?php\n\n/* Усложнённый Приклад с переменными. */\nclass foo\n{\n    public $foo;\n    public $bar;\n\n    function __construct()\n    {\n        $this->foo = 'Foo';\n        $this->bar = array('Bar1', 'Bar2', 'Bar3');\n    }\n}\n\n$foo = new foo();\n$name = 'Имярек';\n\necho <<<'EOT'\nМеня зовут \"$name\". Я печатаю $foo->foo.\nТеперь я печатаю {$foo->bar[1]}.\nЭто не должно вывести заглавную 'A': \\x41\nEOT;\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nМеня зовут \"$name\". Я печатаю $foo->foo.\nТеперь я печатаю {$foo->bar[1]}.\nЭто не должно вывести заглавную 'A': \\x41\n```\n\n**Приклад #14 Приклад зі статичними даними**\n\n```php\n<?php\n\nclass foo {\n    public $bar = <<<'EOT'\nbar\nEOT;\n}\n?>\n```\n\n#### Синтаксичний аналіз змінних\n\nЯкщо рядок вказується у подвійних лапках, або синтаксисом heredoc, [змінні](language.variables.md) усередині неї обробляються.\n\nУ PHP передбачили два види синтаксису для вказівки змінних у рядках: [простий](language.types.string.md#language.types.string.parsing.simple) і [складний](language.types.string.md#language.types.string.parsing.complex). Простим синтаксисом користуються частіше, з ним легко вбудовувати змінну значення масиву (array) або властивість об'єкта (object) з мінімумом зусиль.\n\nСкладний синтаксис легко визначити за фігурними дужками, що оточують вираз.\n\n##### Простий синтаксис\n\nЯкщо інтерпретатор зустрічає знак долара (`$`), він захоплює якнайбільше символів, щоб сформувати правильне ім'я змінної. Якщо потрібно точно визначити кінець імені, ім'я змінної беруть у фігурні дужки.\n\n```php\n<?php\n\n$juice = \"apple\";\n\necho \"He drank some $juice juice.\" . PHP_EOL;\n\n// Непредусмотрительно. Символ «s» — корректный символ для имени переменной, поэтому в этом Прикладе он относится к переменной $juces, но не $juice.\necho \"He drank some juice made of $juices.\" . PHP_EOL;\n\n// Укажем границы переменной, взяв её в фигурные скобки.\necho \"He drank some juice made of {$juice}s.\";\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHe drank some apple juice.\nHe drank some juice made of .\nHe drank some juice made of apples.\n```\n\nАналогічно буде проаналізовано індекс масиву (array) чи властивість об'єкта (object). В індексах масиву квадратна дужка, що закриває (`]`) означає кінець визначення індексу. На властивості об'єкта поширюються самі правила, як і прості змінні.\n\n**Приклад #15 Приклад простого синтаксису**\n\n```php\n<?php\n\n$juices = array(\"apple\", \"orange\", \"koolaid1\" => \"purple\");\n\necho \"He drank some $juices[0] juice.\".PHP_EOL;\necho \"He drank some $juices[1] juice.\".PHP_EOL;\necho \"He drank some $juices[koolaid1] juice.\".PHP_EOL;\n\nclass people {\n    public $john = \"John Smith\";\n    public $jane = \"Jane Smith\";\n    public $robert = \"Robert Paulsen\";\n\n    public $smith = \"Smith\";\n}\n\n$people = new people();\n\necho \"$people->john drank some $juices[0] juice.\".PHP_EOL;\necho \"$people->john then said hello to $people->jane.\".PHP_EOL;\necho \"$people->john's wife greeted $people->robert.\".PHP_EOL;\necho \"$people->robert greeted the two $people->smiths.\"; // Не сработает\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nHe drank some apple juice.\nHe drank some orange juice.\nHe drank some purple juice.\nJohn Smith drank some apple juice.\nJohn Smith then said hello to Jane Smith.\nJohn Smith's wife greeted Robert Paulsen.\nRobert Paulsen greeted the two .\n```\n\nВ PHP 7.1.0 добавлена поддержка*негативних* числових індексів\n\n**Приклад #16 Негативні числові індекси**\n\n```php\n<?php\n\n$string = 'string';\necho \"Символ с индексом -2 равен $string[-2].\", PHP_EOL;\n$string[-3] = 'o';\necho \"Изменение символа на позиции -3 на «o» даёт следующую строку: $string.\", PHP_EOL;\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nСимвол с индексом -2 равен n.\nИзменение символа на позиции -3 на «o» даёт следующую строку: strong\n```\n\nДля виразів, які складніші за ці, краще користуватися складним синтаксисом.\n\n##### Складний (фігурний) синтаксис\n\nВін називається складним не через складність синтаксису, лише тому, що дозволяє писати складні висловлювання.\n\nСкалярна змінна, елемент масиву або властивість об'єкта, що відображається в рядок, дозволено вказувати в рядку цим синтаксисом. Вираз записується як і поза рядком, а потім береться у фігурні дужки: `{`и`}`. Оскільки знак `{` неможливо екранувати, цей синтаксис розпізнаватиметься лише тоді, коли знак `$` йде безпосередньо за знаком `{`. Щоб отримати літерал `{$`знак долара екранують `{\\$`. Приклади, що пояснюють:\n\n```php\n<?php\n\n// Показываем все ошибки\nerror_reporting(E_ALL);\n\n$great = 'здорово';\n\n// Не работает, выводит: Это { здорово}\necho \"Это { $great}\";\n\n// Работает, выводит: Это здорово\necho \"Это {$great}\";\n\n// Работает\necho \"Этот квадрат шириной {$square->width}00 сантиметров.\";\n\n// Работает, ключи, взятые в кавычки, работают только с синтаксисом фигурных скобок\necho \"Это работает: {$arr['key']}\";\n\n// Работает\necho \"Это работает: {$arr[4][3]}\";\n\n// Это неверно по той же причине, что и $foo[bar] вне\n// строки. Говоря по-другому, это по-прежнему работает,\n// но поскольку PHP сначала ищет константу foo, это вызовет\n// ошибку уровня E_NOTICE (неопределённая константа).\necho \"Это неправильно: {$arr[foo][3]}\";\n\n// Работает. При обращении к многомерным массивам внутри\n// строк указывают фигурные скобки\necho \"Это работает: {$arr['foo'][3]}\";\n\n// Работает.\necho \"Это работает: \" . $arr['foo'][3];\n\necho \"Это тоже работает: {$obj->values[3]->name}\";\n\necho \"Это значение переменной с именем $name: {${$name}}\";\n\necho \"Это значение переменной с именем, которое возвращает функция getName(): {${getName()}}\";\n\necho \"Это значение переменной с именем, которое возвращает \\$object->getName(): {${$object->getName()}}\";\n\n// Не работает, выводит: Это то, что возвращает функция getName(): {getName()}\necho \"Это то, что возвращает функция getName(): {getName()}\";\n\n// Не работает, выводит: C:\\folder\\{fantastic}.txt\necho \"C:\\folder\\{$great}.txt\"\n\n// Работает, выводит: C:\\folder\\fantastic.txt\necho \"C:\\\\folder\\\\{$great}.txt\"\n\n?>\n```\n\nДозволено отримувати доступ до властивостей класу, вказуючи змінні всередині рядків, записаних цим синтаксисом.\n\n```php\n<?php\n\nclass foo {\n    var $bar = 'I am bar.';\n}\n\n$foo = new foo();\n$bar = 'bar';\n$baz = array('foo', 'bar', 'baz', 'quux');\necho \"{$foo->$bar}\\n\";\necho \"{$foo->{$baz[1]}}\\n\";\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nI am bar.\nI am bar.\n```\n\n> **Зауваження** :\n> \n> Значение внутри литерала`{$}`, До якого отримують доступ із функцій, викликів методів, статичних змінних класу та констант класу, інтерпретується як ім'я змінної в області, в якій визначено рядок. Синтаксис одинарних фігурних дужок (`{}`) не працюватиме для доступу до значень функцій, методів, констант класів або статичних змінних класу.\n\n```php\n<?php\n\n// Показываем все ошибки\nerror_reporting(E_ALL);\n\nclass beers {\n    const softdrink = 'rootbeer';\n    public static $ale = 'ipa';\n}\n\n$rootbeer = 'A & W';\n$ipa = 'Alexander Keith\\'s';\n\n// Это работает, выводит: Я бы хотел A & W\necho \"Я бы хотел {${beers::softdrink}}\\n\";\n\n// Это тоже работает, выводит: Я бы хотел Alexander Keith's\necho \"Я бы хотел {${beers::$ale}}\\n\";\n\n?>\n```\n\n#### Доступ та зміна символу в рядку\n\nЩоб отримати доступ і змінити символ у рядку, потрібно у квадратних дужках після змінної визначити зміщення шуканого символу щодо початку рядка починаючи з нуля, наприклад $str\\[42\\]. Для цього про рядок думають як про масив символів. Щоб отримати або замінити більше одного символу, викликають функції [substr()](function.substr.md) і [substr\\_replace()](function.substr-replace.md)\n\n> **Зауваження**: Починаючи з PHP 7.1.0, підтримуються негативні значення зсуву. Вони задають усунення з кінця рядка. Раніше негативні усунення викликали помилку рівня **`E_NOTICE`** під час читання (повертаючи порожній рядок) або \\*\\*`E_WARNING`\\*\\*при записи (оставляя строку без изменений).\n\n> **Зауваження**: До PHP 8.0.0 доступ до символів у рядках (string) отримували, вказуючи фігурні дужки, наприклад $str{42}. Синтаксис фігурних дужок застарів із PHP 7.4.0 і не підтримується з PHP 8.0.0.\n\n**Увага**\n\nСпроба запису у зміщення за межами рядка доповнить рядок пробілами до зміщення. Нецілочисленні типи перетворюються на цілочисленні. Невірний тип усунення видасть помилку рівня **`E_WARNING`**. При додаванні до зміщення рядка нових символів надається тільки перший символ (байт). Починаючи з PHP 7.1.0, присвоєння порожнього рядка викликає фатальну помилку. Раніше присвоювався нульовий байт (NULL).\n\n**Увага**\n\nВнутрішній рядок PHP представлений масивами байтів. Тому доступ або зміна рядка зі зміщення небезпечні для багатобайтових даних і виконуються лише з рядками в однобайтних кодуваннях, наприклад, ISO-8859-1.\n\n> **Зауваження**: Починаючи з PHP 7.1.0, спроба вказати оператор порожнього індексу на порожньому рядку видасть фатальну помилку. Раніше порожній рядок перетворювався на масив без попередження.\n\n**Приклад #17 Приклади рядків**\n\n```php\n<?php\n\n// Получим первый символ строки\n$str = 'This is a test.';\n$first = $str[0];\n\n// Получим третий символ строки\n$third = $str[2];\n\n// Получим последний символ строки\n$str = 'This is still a test.';\n$last = $str[strlen($str)-1];\n\n// Изменим последний символ строки\n$str = 'Look at the sea';\n$str[strlen($str)-1] = 'e';\n\n?>\n```\n\nЗміщення у рядку задають або цілим числом, або цілим рядком, інакше буде видано попередження.\n\n**Приклад #18 Приклад неприпустимого усунення рядка**\n\n```php\n<?php\n\n$str = 'abc';\n\nvar_dump($str['1']);\nvar_dump(isset($str['1']));\n\nvar_dump($str['1.0']);\nvar_dump(isset($str['1.0']));\n\nvar_dump($str['x']);\nvar_dump(isset($str['x']));\n\nvar_dump($str['1x']);\nvar_dump(isset($str['1x']));\n\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\nstring(1) \"b\"\nbool(true)\n\nWarning: Illegal string offset '1.0' in /tmp/t.php on line 7\nstring(1) \"b\"\nbool(false)\n\nWarning: Illegal string offset 'x' in /tmp/t.php on line 9\nstring(1) \"a\"\nbool(false)\nstring(1) \"b\"\nbool(false)\n```\n\n> **Зауваження** :\n> \n> Спроба доступу до змінних інших типів (за винятком масивів або об'єктів, що реалізують інтерфейси) через оператори `[]`или`{}` без попередження повертає **`null`**\n\n> **Зауваження** :\n> \n> Доступ до символів у рядкових літералах отримують через оператори `[]`или`{}`\n\n> **Зауваження** :\n> \n> Доступ до символів у рядкових літералах через оператор `{}` оголошений застарілим у PHP 7.4 та видалений у PHP 8.0.\n\n### Корисні функції та оператори\n\nРядки дозволено об'єднувати оператором «.» (крапка). Зверніть увагу, оператор додавання «+» тут *не працює*. Докладніше про це розказано у розділі « [Рядкові оператори](language.operators.string.md) ».\n\nУ мові передбачено низку корисних функцій для маніпулювання рядками.\n\nЗагальні функції описані у розділі «[Функції для роботи з рядками](ref.strings.md)», а для розширеного пошуку та заміни - «[Функції Perl-сумісних регулярних виразів](ref.pcre.md)».\n\nПередбачені також [функції для роботи з URL](ref.url.md) та функції шифрування або дешифрування рядків ([Sodium](ref.sodium.md) і [Hash](ref.hash.md)\n\nНаконец, смотрите также[функції символьних типів](ref.ctype.md)\n\n### Перетворення на рядок\n\nЗначення перетворюють на рядок приведенням через оператор `(string)` або функцією [strval()](function.strval.md). У виразах, у яких потрібен рядок, перетворення виконується автоматично. Це виконується під час виведення через мовні конструкції [echo](function.echo.md) або [print](function.print.md)або коли значення змінної порівнюється з рядком. Розділи керівництва « [Типи](language.types.md) » та «[Маніпуляції з типами](language.types.type-juggling.md)», прояснят сказанное ниже. Смотрите также описание функции[settype()](function.settype.md)\n\nЗначение bool\\*\\*`true`\\*\\* перетворюється на рядок `«1»`, а логічне значення **`false`** перетворюється на `«»` (Порожній рядок). Така поведінка допускає перетворення значення в обидві сторони - з логічного типу в рядковий і навпаки.\n\nЦіле число (int) або число з плаваючою точкою (float) перетворюється на рядок, який представлятиме число в текстовому вигляді (включаючи експоненційну частину для чисел з плаваючою точкою). Великі числа з плаваючою точкою перетворюються на експоненційний запис (`4.1E+6`\n\n> **Зауваження** :\n> \n> Починаючи з PHP 8.0.0 як роздільник дробової частини в числах з плаваючою точкою можна використовувати тільки точку (« »). До PHP 8.0.0 символ десяткової точки визначався у налаштуваннях мовного стандарту скрипта (категорія LC\\_NUMERIC). Смотрите функцию[setlocale()](function.setlocale.md)\n\nМасиви перетворюються на рядок `«Array»`. Тому конструкції [echo](function.echo.md) або [print](function.print.md) не можуть самостійно відображати вміст масиву (array). Щоб переглянути окремий елемент, користуються синтаксисом `echo $arr['foo']`. Нижче буде розказано про те, як відобразити або переглянути весь вміст.\n\nДля перетворення об'єкта (`object`) у рядок (string) визначають магічний метод [\\_\\_function toString() { \\[native code\\] }](language.oop5.magic.md)\n\nРесурс (resource) перетворюється на рядок (string) виду `«Resource id #1»`, где — це номер ресурсу, який PHP призначає ресурсу під час виконання коду. І хоча вона унікальна для поточного запуску скрипта (тобто веб-запиту або CLI-процесу) і не буде використана повторно для цього ресурсу, не варто покладатися на цей рядок, тому що його можуть змінити в майбутньому. Тип ресурсу можна отримати викликом функції [get\\_resource\\_type()](function.get-resource-type.md)\n\nЗначение\\*\\*`null`\\*\\* завжди перетворюється на порожній рядок.\n\nЯк зазначено вище, пряме перетворення на рядок масивів, об'єктів чи ресурсів не дає корисної інформації про значення, крім типу. Більш ефективні інструменти виведення значень для налагодження цих типів – це функції [print\\_r()](function.print-r.md) і [var\\_dump()](function.var-dump.md)\n\nБільшість значень PHP перетворюється на рядок для постійного зберігання. Цей спосіб перетворення називається серіалізацією. Серіалізують значення функцією [serialize()](function.serialize.md)\n\n### Детальна інформація про рядковий тип\n\nРядковий тип (string) в PHP реалізований у вигляді масиву байтів і цілого значення, що містить довжину буфера. У цій структурі немає інформації про те, як перетворювати байти на символи, це завдання вирішує програміст. Немає обмежень на значення, з яких складається рядок, наприклад, байт зі значенням (NUL-байт) дозволено будь-де в рядку (проте рекомендовано враховувати, що ряд функцій, які в цьому посібнику названі «бінарно-небезпечними», передають рядки бібліотекам, які ігнорують дані після NUL-байта).\n\nТака природа рядкового типу пояснює, чому PHP немає окремого типу «byte» — рядки виконують цю роль. Функції, які не повертають текстових даних, наприклад довільний потік даних, що зчитується з мережевого сокету, як і раніше, повертають рядки.\n\nЗ урахуванням того, що PHP не диктує конкретне кодування для рядків, може виникнути питання: Як кодуються строкові літерали? Наприклад, рядок `«á»` еквівалентна `«\\xE1»`(ISO-8859-1),`«\\xC3\\xA1»`(UTF-8, форма нормализации C),`«\\x61\\xCC\\x81»` (UTF-8, форма нормалізації D) чи іншого можливого подання? Відповідь така: рядок буде закодований способом, яким він закодований у файлі скрипта. Тому, якщо скрипт записаний у кодуванні ISO-8859-1, то й рядок буде закодовано в ISO-8859-1 і т. д. Однак це правило не виконується при включеному режимі Zend Multibyte: скрипт записують у довільному кодуванні, оголошуючи його або покладаючись на автовизначення, а потім конвертують у конкретне внутрішнє кодування, яке буде використано для рядкових літералів. Врахуйте, що на кодування скрипта (або на внутрішнє кодування, якщо включений режим Zend Multibyte) накладається ряд обмежень: майже в кожному випадку це кодування має бути надмножиною кодування ASCII, наприклад, UTF-8 або ISO-8859-1. Врахуйте також, що кодування, залежні від стану, де одні й самі значення байтів допустимі у початковому і початковому стані зсуву, створюють ризик проблем.\n\nРядкові функції, щоб бути корисними, намагаються припустити кодування рядка. Єдність у цьому питанні не завадила б, але PHP-функції працюють із текстом по-різному:\n\n-   Одні — припускають, що рядок закодований в якомусь однобайтовому кодуванні, але для коректної роботи їм не потрібно інтерпретувати байти як конкретні символи. Сюди потрапляють функції на кшталт[substr()](function.substr.md) [strpos()](function.strpos.md) [strlen()](function.strlen.md) і [strcmp()](function.strcmp.md). Інший спосіб мислення про ці функції - уявляти, що вони оперують буферами пам'яті, тобто працюють безпосередньо з байтами та їх зміщеннями.\n-   Іншим — передається кодування рядка або вони набирають значення за умовчанням, якщо кодування не передали. Це стосується функції[htmlentities()](function.mdentities.md)та більшу частину функцій модуля[mbstring](book.mbstring.md)\n-   Треті — працюють із поточними налаштуваннями локалі (дивіться[setlocale()](function.setlocale.md)), але оперують побайтово.\n-   Нарешті, четверті — припускають, що рядок використовує конкретне кодування, зазвичай UTF-8. Сюди потрапляє більша частина функцій із модулів[intl](book.intl.md) і [PCRE](book.pcre.md)(для останнього - тільки при вказівці модифікатора`u`\n\nВ кінцевому рахунку, програма буде працювати з кодуванням Unicode правильно, якщо старанно уникати функцій, які не будуть працювати з Unicode-рядками або пошкодять дані, і викликати замість них ті, які поводяться коректно, зазвичай це функції з модулів [intl](book.intl.md) і [mbstring](book.mbstring.md). Однак робота з функціями, які вміють обробляти Unicode, це лише початок. Незалежно від того, які функції пропонує мова, рекомендовано знати специфікацію Unicode. Наприклад, програма, яка передбачає існування лише великих і малих літер, робить неправильне припущення.\n","title":"Рядки","contentType":2,"navigation":[{"language.types.float.md":"Числа з плаваючою точкою"},{"language.types.numeric-strings.md":"Числові рядки »"},{"index.md":"PHP Manual"},{"language.types.md":"Типи"}]}},"__N_SSG":true}