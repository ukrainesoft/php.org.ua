{"pageProps":{"page":{"slug":"function.proc-open.md","content":"# proc\\_open\n\n(PHP 4 >= 4.3.0, PHP 5, PHP 7, PHP 8)\n\nproc\\_open — Виконати команду та відкрити покажчик на файл для введення/виводу\n\n### Опис\n\n```methodsynopsis\nproc_open(    array|string $command,    array $descriptor_spec,    array &$pipes,    ?string $cwd = null,    ?array $env_vars = null,    ?array $options = null): resource|false\n```\n\n\\*\\*proc\\_open()\\*\\*аналогична[popen()](function.popen.md), але надає набагато більше контролю за виконанням програми.\n\n### Список параметрів\n\n`command`\n\nКомандна до виконання, зазначена як рядок (string). Спеціальні символи повинні бути належним чином екрановані, і застосовувати правильні лапки.\n\n> **Зауваження**: В*Windows*, якщо для `bypass_shell`не установлено значение\\*\\*`true`**в`options` `command` передається в **cmd.exe** (точніше, `%ComSpec%`) з прапором `/c` у вигляді рядка *без лапок* (тобто точно так, як було задано в **proc\\_open()**). Це може призвести до того, що **cmd.exe**удалит заключающие из`command`(подробности смотрите в документации**cmd.exe\\*\\*), приводячи до несподіваної та потенційно навіть небезпечної поведінки, тому що повідомлення про помилки **cmd.exe** можуть містити (частково) переданий параметр `command`(смотрите Приклад ниже).\n\nПочинаючи з PHP 7.4.0, `command` може передаватися як масив параметрів команди. У цьому випадку процес буде відкритий безпосередньо (не проходячи через оболонку) і PHP подбає про екранування будь-якого необхідного аргументу.\n\n> **Зауваження** :\n> \n> У Windows екранування аргументу масиву (array) елементів передбачає, що синтаксичний аналіз виконаної команди сумісний із синтаксичним аналізом аргументів командного рядка, що виконуються середовищем виконання VC.\n\n`descriptor_spec`\n\nМасив, ключі якого є номер дескриптора, а значення визначає, як PHP повинен передати цей дескриптор дочірньому процесу. 0 - stdin, 1 - stdout і 2 - stderr.\n\nКожен елемент може бути:\n\n-   Масивом, що описує канал (pipe) передачі процесу. Перший елемент – це дескриптор типу, другий – налаштування для обраного типу. Можливі типи:`pipe`(другий елемент або`r`для передачі процесу сторони каналу для читання, або`w`для передачі сторони запису) та`file`(Другий елемент – ім'я файлу). Зверніть увагу, що все, крім`w`, обробляється як`r`\n-   Ресурс потоку, що представляє дескриптор файлу (наприклад, відкритий файл, сокет,**`STDIN`**\n\nНомери дескрипторів не обмежені лише 0, 1 та 2 - ви можете призначити будь-який дійсний номер дескриптора і він буде переданий дочірньому процесу. Це дозволяє скрипту взаємодіяти з іншими скриптами, що працюють як паралельні процеси. Зокрема, таким чином можна передавати дані, що потребують захисту, у програми на зразок PGP, GPG та openssl безпечніше. Також це може виявитися корисним для читання статусної інформації, яку надають ці програми на допоміжних файлових дескрипторах.\n\n`pipes`\n\nБуде заданий масивом покажчиків на файли, що відповідають створеним каналам передачі PHP.\n\n`cwd`\n\nРобоча директорія команди. Це має бути **абсолютний** шлях до директорії або **`null`**, якщо потрібно використовувати директорію за замовчуванням (Робоча директорія поточного процесу PHP).\n\n`env_vars`\n\nМасив змінних оточення для команди, що запускається, або **`null`**, якщо потрібно використовувати те саме оточення, що й у поточного PHP-процесу.\n\n`options`\n\nДозволяє встановити додаткові параметри. На даний момент підтримуються такі налаштування:\n\n-   `suppress_errors`(лише для Windows): під час встановлення в\\*\\*`true`\\*\\*не будуть показуватися помилки, що виникають під час роботи функції\n-   `bypass_shell`(лише для Windows): під час встановлення в\\*\\*`true`\\*\\*процес буде запущений в обхід оболонки`cmd.exe`\n-   `blocking_pipes`(лише для Windows): примусово блокувати потік під час значення\\*\\*`true`\\*\\*\n-   `create_process_group`(тільки для Windows): дозволити дочірньому процесу обробляти`CTRL`події, якщо встановлено значення\\*\\*`true`\\*\\*\n-   `create_new_console`(лише для Windows): новий процес використовує нову консоль, а не успадковує консоль свого батька\n\n### Значення, що повертаються\n\nПовертає ресурс, який представляє процес. Цей ресурс необхідно звільняти функцією [proc\\_close()](function.proc-close.md) після завершення роботи з ним. У разі виникнення помилки повертає **`false`**\n\n### список змін\n\n| Версия | Опис |\n| --- | --- |\n| 7.4.4 | Добавлена опция`create_new_console`в параметр`options` |\n| 7.4.0 | **proc\\_open()** тепер також приймає масив (array) у `command` |\n| 7.4.0 | Добавлена опция`create_process_group`в параметр`options` |\n\n### Приклади\n\n**Приклад #1 Приклад використання** proc\\_open()\\*\\*\\*\\*\n\n```php\n<?php\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  // stdin - канал, из которого дочерний процесс будет читать\n   1 => array(\"pipe\", \"w\"),  // stdout - канал, в который дочерний процесс будет записывать\n   2 => array(\"file\", \"/tmp/error-output.txt\", \"a\") // stderr - файл для записи\n);\n\n$cwd = '/tmp';\n$env = array('some_option' => 'aeiou');\n\n$process = proc_open('php', $descriptorspec, $pipes, $cwd, $env);\n\nif (is_resource($process)) {\n    // $pipes теперь выглядит так:\n    // 0 => записывающий обработчик, подключённый к дочернему stdin\n    // 1 => читающий обработчик, подключённый к дочернему stdout\n    // Вывод сообщений об ошибках будет добавляться в /tmp/error-output.txt\n\n    fwrite($pipes[0], '<?php print_r($_ENV); ?>');\n    fclose($pipes[0]);\n\n    echo stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    // Важно закрывать все каналы перед вызовом\n    // proc_close во избежание мёртвой блокировки\n    $return_value = proc_close($process);\n\n    echo \"команда вернула $return_value\\n\";\n}\n?>\n```\n\nВисновок наведеного прикладу буде схожим на:\n\n```\nArray\n(\n    [some_option] => aeiou\n    [PWD] => /tmp\n    [SHLVL] => 1\n    [_] => /usr/local/bin/php\n)\nкоманда вернула 0\n```\n\n**Приклад #2**proc\\_open()**причуда в Windows**\n\nХоча можна очікувати, що наступна програма шукатиме у файлі filename.txt текст `search` і виводити результати, вона поводиться трохи інакше.\n\n```php\n<?php\n$descriptorspec = [STDIN, STDOUT, STDOUT];\n$cmd = '\"findstr\" \"search\" \"filename.txt\"';\n$proc = proc_open($cmd, $descriptorspec, $pipes);\nproc_close($proc);\n?>\n```\n\nРезультат виконання наведеного прикладу:\n\n```\n'findstr\" \"search\" \"filename.txt' не распознается как внутренняя или внешняя команда,\nработающая программа или пакетный файл.\n```\n\nЩоб оминути цю поведінку, зазвичай достатньо передати `command` у додаткових лапках:\n\n```php\n$cmd = '\"\"findstr\" \"search\" \"filename.txt\"\"';\n```\n\n### Примітки\n\n> **Зауваження** :\n> \n> Сумісність з Windows: Дескриптори далі 2 (stderr) успадковуються дочірніми процесами, однак відколи Windows не асоціює номери файлових дескрипторів з низькорівневими обробниками, дочірні процеси не мають (поки що) до них доступу. Це не стосується stdin, stdout і stderr.\n\n> **Зауваження** :\n> \n> Якщо потрібний односпрямований канал процесу, використовуйте функцію [popen()](function.popen.md), оскільки вона значно простіша у використанні.\n\n### Дивіться також\n\n-   [popen()](function.popen.md) \\- Відкриває файловий покажчик процесу\n-   [exec()](function.exec.md) \\- Виконати зовнішню програму\n-   [system()](function.system.md) \\- Виконати зовнішню програму та відобразити висновок\n-   [passthru()](function.passthru.md) \\- Виконати зовнішню програму та відобразити необроблений висновок\n-   [stream\\_select()](function.stream-select.md) \\- Запускає еквівалент системного виклику select() на заданих масивах потоків з часом очікування, вказаним параметрами seconds та microseconds\n-   [Оператор зворотний апостроф](language.operators.execution.md)\n","title":"proc\\_open","contentType":2,"navigation":[{"function.proc-nice.md":"« proc\\_nice"},{"function.proc-terminate.md":"proc\\_terminate »"},{"index.md":"PHP Manual"},{"ref.exec.md":"Функції запуску програм"}]}},"__N_SSG":true}